<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>函数式程序设计 / 程序演算入门 Part 1 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">函数式程序设计 / 程序演算入门 Part 1</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2022年12月18日星期日晚上11点17分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2022年12月18日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 5,511 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> 当前文章</div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式编程（Functional-Programming）"><span class="toc-number">1.</span> <span class="toc-text">函数式编程（Functional Programming）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高阶函数（High-Order-Function）"><span class="toc-number">2.</span> <span class="toc-text">高阶函数（High Order Function）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#序列变换函数"><span class="toc-number">3.</span> <span class="toc-text">序列变换函数</span></a></li></ol></div><hr></div><div class="post-content"><p>本文是对胡振江老师所教授的计算概论课实验班内容的期末复习笔记，但因为这部分内容很有意思，所以我会尽量写得通俗易懂，能够让大家也“云课堂”。考虑到大家都是 OIer，所以我也不会写得很啰嗦，保证大家的阅读体验。</p><p>首先简述一下这门课大致的学习路线：Haskell -&gt; Agda -&gt; Bird Meerteen Formalism。下面我们一个一个来说。</p><h2><a id="函数式编程（Functional-Programming）" href="#函数式编程（Functional-Programming）" class="headerlink" title="函数式编程（Functional Programming）"></a>函数式编程（Functional Programming）</h2><p>在这门课中首先你将会学习函数式编程的基本思想。函数式编程简单来说就是：只有常量，没有变量。各位对面向对象、面向过程这一类编程范式想必已经精通，但函数式编程和算法竞赛中学习的内容相去甚远。</p><p>C++ 对函数式编程的支持近乎为零。虽然官方在很努力地抄 Haskell 了，但是它自身的历史包袱以及应用场景就决定了没人用它写函数式编程。例如它难以<strong>方便地</strong>对函数进行变换。我们还是可以勉强用 C++ 来写一些函数式编程：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token function">fact</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这算是遵循 FP 思想写出来的最简单的函数式编程了，它的作用想必大家都了解，等价的 Haskell 代码如下：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token hvariable">fact</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-></span> <span class="token constant">Int</span> <span class="token comment">-- 其实这行可以省略</span>
<span class="token hvariable">fact</span> <span class="token hvariable">n</span> <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token hvariable">n</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">then</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token hvariable">n</span> <span class="token operator">*</span> <span class="token hvariable">fact</span> <span class="token punctuation">(</span><span class="token hvariable">n</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>想必大家还在疑惑函数式编程有什么用。客观来说它有很多用处，但是要说现阶段最能说服诸位且又能短时间理解的用处，我们会在后面提到。下面我们来说一个简单的用处：描述一个计算（Specification）。</p><p>课程中的例子是最大子段和。如果你要向计算机描述最大子段和的问题怎么做？我们可以定义一个函数，这个函数接受一个序列返回一个最大子段和。这样计算机就知道了最大子段和的计算要求。当然，聪明的各位肯定是会写最大子段和的线性算法的，但我们要探讨的不是这个算法，而是得到这个算法的过程。</p><p>我们能够“推理”出最大子段和的线性算法吗？</p><p>这个问题还是太模糊了，我们还缺很多前置知识，但是在这些前置知识里最先要确定的是问题的描述（Specification）。最大子段和最本质的含义是：一个序列所有子区间分别求和，再计算所得到的数中的最大值。我们需要把这个最本质的定义做出形式化地描述，再搞一些基本的推理规则（公理，就和大家写数学几何证明题一样），这样我们才能推导出最大子段和的线性算法。</p><p>也就是说，算法不都是凭空想出来的，一个算法是可以被推理出来的，听起来还不错？</p><p>要描述最大字段和问题当然得用我们的函数式语言描述，为什么 C++ 不行等会儿说。以 Haskell 为例：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token hvariable">mss</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token constant">Int</span>
<span class="token hvariable">mss</span> <span class="token operator">=</span> <span class="token builtin">maximum</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token builtin">sum</span> <span class="token operator">.</span> <span class="token builtin">concat</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token hvariable">tails</span> <span class="token operator">.</span> <span class="token hvariable">inits</span>
<span class="token comment">-- 等价写法 （haskell 里一个函数多个参数是不需要加逗号的）</span>
<span class="token hvariable">mss2</span> <span class="token hvariable">as</span> <span class="token operator">=</span> <span class="token builtin">maximum</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">concat</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token hvariable">tails</span> <span class="token punctuation">(</span><span class="token hvariable">inits</span> <span class="token hvariable">as</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用了一堆函数的复合（composition）来描述最大子段和问题。下面来一一解释一下上面的函数（按从右往左的顺序）：</p><ul><li>inits 会求出一个序列的所有前缀：<pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token hvariable">inits</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">t</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">t</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">inits</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token comment">-- (a : as) 是非空序列的表示，a 的类型为 t（表示第一个元素），as 类型为 [t] 表示之后的其他元素</span>
<span class="token comment">-- 在 Haskell 中列表拆第一个元素比拆最后一个元素快（语言特性）</span>
<span class="token comment">-- 冒号 : 在这里是运算符</span>
<span class="token hvariable">inits</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">:</span> <span class="token hvariable">as</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">:</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">inits</span> <span class="token hvariable">as</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>tails 会求出一个序列的所有后缀：<pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token hvariable">tails</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">t</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">t</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">tails</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">tails</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">:</span> <span class="token hvariable">as</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">:</span> <span class="token hvariable">as</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token hvariable">tails</span> <span class="token hvariable">as</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>map f 会将一个序列里的元素<script type="math/tex">a_i</script>全部变成<script type="math/tex">f(a_i)</script>：<pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token comment">-- (t -> p) 表示接受一个类型为 t 的值，返回一个类型为 p 的值的函数</span>
<span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">t</span> <span class="token operator">-></span> <span class="token hvariable">p</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">t</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">p</span><span class="token punctuation">]</span> 
<span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">:</span> <span class="token hvariable">as</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token hvariable">as</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>concat 表示把一个 <code class="inline-code">[[t]]</code> 类型的列表“拍扁”拼成一个 <code class="inline-code">[t]</code> 类型的列表：<pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token builtin">concat</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">t</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">t</span><span class="token punctuation">]</span>
<span class="token builtin">concat</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment">-- ++ 是运算符表示列表的拼接</span>
<span class="token builtin">concat</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">:</span> <span class="token hvariable">as</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token builtin">concat</span> <span class="token hvariable">as</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>sum 是对一个列表中所有元素求和<pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token comment">-- 之前的 t、p 都是任意类型（类似 C++ 的模板），而这里的 Int 是具体的类型</span>
<span class="token builtin">sum</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token constant">Int</span> 
<span class="token builtin">sum</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">:</span> <span class="token hvariable">as</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token builtin">sum</span> <span class="token hvariable">as</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>maximum 表示对一个列表中所有元素求最大值：<pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token builtin">maximum</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token constant">Int</span> 
<span class="token builtin">maximum</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token builtin">maximum</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">:</span> <span class="token hvariable">as</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">max</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token builtin">maximum</span> <span class="token hvariable">as</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>不熟悉 Haskell 的同学可能有点看不下去了，所以我们给出与之等价的 C++ 实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//by Yao</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;climits></span></span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>ostream<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>function<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">L</span> <span class="token expression">vector</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">F</span> <span class="token expression">function</span></span>

<span class="token comment">// 调试用</span>
ostream <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span> out<span class="token punctuation">,</span> <span class="token keyword">const</span> L<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  out <span class="token operator">&lt;&lt;</span> <span class="token string">"[ "</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">:</span> vs<span class="token punctuation">)</span> out <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
  out <span class="token operator">&lt;&lt;</span> <span class="token string">"]\n"</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> out<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 模拟 : 运算符</span>
<span class="token comment">// 这是一个高阶函数，也就是说返回值为函数的函数</span>
<span class="token comment">//  L&lt;int> as = &#123;1, 2, 3&#125;;</span>
<span class="token comment">//  cout &lt;&lt; cons(5)(as);</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">t</span><span class="token operator">></span> 
F<span class="token operator">&lt;</span> <span class="token generic-function"><span class="token function">L</span><span class="token generic class-name"><span class="token operator">&lt;</span>t<span class="token operator">></span></span></span><span class="token punctuation">(</span>L<span class="token operator">&lt;</span>t<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token function">cons</span><span class="token punctuation">(</span><span class="token keyword">const</span> t a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> L<span class="token operator">&lt;</span>t<span class="token operator">></span> as<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    L<span class="token operator">&lt;</span>t<span class="token operator">></span> res <span class="token operator">=</span> as<span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//  F&lt;int(int)> square = [](int x) &#123; return x * x; &#125;;</span>
<span class="token comment">//  cout &lt;&lt; map(square)(L&lt;int>&#123;1,2,3,4,5&#125;);</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">t</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">p</span><span class="token operator">></span>
F<span class="token operator">&lt;</span> <span class="token generic-function"><span class="token function">L</span><span class="token generic class-name"><span class="token operator">&lt;</span>p<span class="token operator">></span></span></span><span class="token punctuation">(</span>L<span class="token operator">&lt;</span>t<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">const</span> F<span class="token operator">&lt;</span><span class="token function">p</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token operator">></span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> L<span class="token operator">&lt;</span>t<span class="token operator">></span> vs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> L<span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> t a <span class="token operator">=</span> vs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> L<span class="token operator">&lt;</span>t<span class="token operator">></span> as <span class="token operator">=</span> <span class="token generic-function"><span class="token function">L</span><span class="token generic class-name"><span class="token operator">&lt;</span>t<span class="token operator">></span></span></span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vs<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">cons</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//  for(auto xs : inits(L&lt;int>&#123;1,2,3,4,5&#125;)) &#123;</span>
<span class="token comment">//    cout &lt;&lt; xs;</span>
<span class="token comment">//  &#125;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">t</span><span class="token operator">></span>
L<span class="token operator">&lt;</span>L<span class="token operator">&lt;</span>t<span class="token operator">>></span> <span class="token function">inits</span><span class="token punctuation">(</span><span class="token keyword">const</span> L<span class="token operator">&lt;</span>t<span class="token operator">></span> vs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> t a <span class="token operator">=</span> vs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> L<span class="token operator">&lt;</span>t<span class="token operator">></span> as <span class="token operator">=</span> <span class="token generic-function"><span class="token function">L</span><span class="token generic class-name"><span class="token operator">&lt;</span>t<span class="token operator">></span></span></span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vs<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">cons</span><span class="token punctuation">(</span>L<span class="token operator">&lt;</span>t<span class="token operator">></span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">cons</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">inits</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//  for(auto xs : tails(L&lt;int>&#123;1,2,3,4,5&#125;)) &#123;</span>
<span class="token comment">//    cout &lt;&lt; xs;</span>
<span class="token comment">//  &#125;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">t</span><span class="token operator">></span>
L<span class="token operator">&lt;</span>L<span class="token operator">&lt;</span>t<span class="token operator">>></span> <span class="token function">tails</span><span class="token punctuation">(</span><span class="token keyword">const</span> L<span class="token operator">&lt;</span>t<span class="token operator">></span> vs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> t a <span class="token operator">=</span> vs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> L<span class="token operator">&lt;</span>t<span class="token operator">></span> as <span class="token operator">=</span> <span class="token generic-function"><span class="token function">L</span><span class="token generic class-name"><span class="token operator">&lt;</span>t<span class="token operator">></span></span></span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vs<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">cons</span><span class="token punctuation">(</span><span class="token function">cons</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">tails</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//  cout &lt;&lt; cat(L&lt;int>&#123;1,2,3,4,5&#125;)(&#123;3,4,5,6,7&#125;);</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">t</span><span class="token operator">></span>
F<span class="token operator">&lt;</span> <span class="token generic-function"><span class="token function">L</span><span class="token generic class-name"><span class="token operator">&lt;</span>t<span class="token operator">></span></span></span><span class="token punctuation">(</span>L<span class="token operator">&lt;</span>t<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token function">cat</span><span class="token punctuation">(</span><span class="token keyword">const</span> L<span class="token operator">&lt;</span>t<span class="token operator">></span> as<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> L<span class="token operator">&lt;</span>t<span class="token operator">></span> bs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>as<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> bs<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">auto</span> a <span class="token operator">=</span> as<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">auto</span> ass <span class="token operator">=</span> <span class="token generic-function"><span class="token function">L</span><span class="token generic class-name"><span class="token operator">&lt;</span>t<span class="token operator">></span></span></span><span class="token punctuation">(</span>as<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> as<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">cons</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">cat</span><span class="token punctuation">(</span>ass<span class="token punctuation">)</span><span class="token punctuation">(</span>bs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//  cout &lt;&lt; concat(L&lt;L&lt;int>>&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5, 6, 7&#125;&#125;);</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">t</span><span class="token operator">></span>
L<span class="token operator">&lt;</span>t<span class="token operator">></span> <span class="token function">concat</span><span class="token punctuation">(</span><span class="token keyword">const</span> L<span class="token operator">&lt;</span>L<span class="token operator">&lt;</span>t<span class="token operator">>></span> vs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> L<span class="token operator">&lt;</span>t<span class="token operator">></span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">auto</span> a <span class="token operator">=</span> vs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">auto</span> as <span class="token operator">=</span> <span class="token generic-function"><span class="token function">L</span><span class="token generic class-name"><span class="token operator">&lt;</span>L<span class="token operator">&lt;</span>t<span class="token operator">>></span></span></span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vs<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">cat</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">concat</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//  cout &lt;&lt; sum(&#123;1,2,3,4,5&#125;);</span>
<span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">const</span> L<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">auto</span> a <span class="token operator">=</span> vs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">auto</span> as <span class="token operator">=</span> <span class="token generic-function"><span class="token function">L</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vs<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> <span class="token function">sum</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//  cout &lt;&lt; maximum(&#123;1,2,3,4,5&#125;);</span>
<span class="token keyword">int</span> <span class="token function">maximum</span><span class="token punctuation">(</span><span class="token keyword">const</span> L<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> INT_MIN<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">auto</span> a <span class="token operator">=</span> vs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">auto</span> as <span class="token operator">=</span> <span class="token generic-function"><span class="token function">L</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> vs<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token function">maximum</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">mss</span><span class="token punctuation">(</span>L<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 尖括号里的类型无法省略不然会 CE</span>
  <span class="token keyword">return</span> <span class="token function">maximum</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">map</span><span class="token generic class-name"><span class="token operator">&lt;</span>L<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">concat</span><span class="token punctuation">(</span>map<span class="token operator">&lt;</span>L<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> L<span class="token operator">&lt;</span>L<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">(</span>tails<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">inits</span><span class="token punctuation">(</span>vs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token function">mss</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相信各位已经明白了 C++ 为什么不行，毕竟它不是专为函数式编程设计的语言，写起来太麻烦还很别扭。在函数式编程领域，Haskell 是王者之一。</p><p>你可能会说上面的 C++ 代码写法有很多复杂度较大而且很别扭的地方。这个是强行用 C++ 模拟函数式编程的结果。如果要以指令式编程来写，那当然又是另一种写法。</p><p>为什么我们非要用函数式编程来描述 Specification 呢？</p><ul><li>为什么函数式可以：下面会讲。</li><li>为什么指令式不可以：胡老师并没有详细讲。所谓的不可以，其实是指没人这么干，我的理解是指令式编程如果要用数学语言描述，会涉及到状态变换，而这个过程目前还不太好做形式化地处理（太复杂了）。</li></ul><p>回到最大子段和的 Specification：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token hvariable">mss</span> <span class="token operator">=</span> <span class="token builtin">maximum</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token builtin">sum</span> <span class="token operator">.</span> <span class="token builtin">concat</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token hvariable">tails</span> <span class="token operator">.</span> <span class="token hvariable">inits</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你习惯了 Haskell，你其实是可以把它从右往左“读出来”的：</p><ol><li>先求出原序列的所有前缀</li><li>再把每个前缀变成它自己的后缀，这样我们就得到了原序列的所有子区间</li><li>但是目前我们拿到的是个三维列表（数组），所以需要做一下顶层拼接转化为二维列表</li><li>然后把每个子区间变成它的数字和（这样二维列表也就变成了一维列表）</li><li>然后再把所有的数求出最大值</li></ol><p>可以发现，函数式编程利用了基本函数的复合与变换，将原问题的语义清晰地表达出来。这也符合我们平时的语言习惯，函数就像是一个动作，一个指示。当然，这个方法并非万能，有些算法使用指令式语言来描述会更简洁。</p><h2><a id="高阶函数（High-Order-Function）" href="#高阶函数（High-Order-Function）" class="headerlink" title="高阶函数（High Order Function）"></a>高阶函数（High Order Function）</h2><p>各位如果有仔细阅读上文的代码就会发现，Haskell 中大量使用了高阶函数。C++ 代码之所以如此丑陋就是因为我强行使用高阶函数写法来与 Haskell 代码形成准确对应。而在函数式编程里，高阶函数极其常见。把一个多参数函数变成高阶函数的方法不唯一（看用途），不过一个常见的方法叫做柯里化（curry）。以最大值函数为例，<code class="inline-code">max(a, b)</code> 是一个接收两个参数返回一个最大值的函数，我们可以将它改成 <code class="inline-code">max(a)(b)</code>，其中 <code class="inline-code">max(a)</code> 的返回值是一个函数，这个函数接收一个参数并将其与 <code class="inline-code">a</code> 比较，返回最大的那个。C++ 的写法见上文。多参数同理，<code class="inline-code">f(a, b, c)</code> 会被转化为 <code class="inline-code">f(a)(b)(c)</code>。</p><p>Haskell 的确有元组的概念，使用 <code class="inline-code">(a, b)</code> 的方式可以表示二元组（多元组也可），但是你几乎见不到使用元组来表示参数类型的函数，Haskell 的库函数几乎全部柯里化。在 Haskell 中，<code class="inline-code">max a</code> 会返回一个函数（作用同理），而 <code class="inline-code">max a b</code> 等价于 <code class="inline-code">(max a) b</code>。</p><p>柯里化的好处在于，我们可以更简洁地描述计算过程。比如说我们要把一个序列 as 中的数对 x 取最大值，那么使用 Haskell 来写就是 <code class="inline-code">map (max a) as</code>。而在 C++ 中你可能会需要用到 for 循环。</p><p>不妨对照上文 Haskell 代码中的类型声明。以 map 为例：<code class="inline-code">map :: (t -&gt; p) -&gt; [t] -&gt; [p]</code> 等价于 <code class="inline-code">map :: (t -&gt; p) -&gt; ([t] -&gt; [p])</code> （箭头符号默认右结合）。第一个参数的类型是一个从 t 类型到 p 类型的函数，第二个参数的类型是 <code class="inline-code">[t]</code>（类型为 t 的列表），返回值类型是 <code class="inline-code">[p]</code>。</p><h2><a id="序列变换函数" href="#序列变换函数" class="headerlink" title="序列变换函数"></a>序列变换函数</h2><p>学习英语的基础是单词，单词背够了才能有效学习更多的内容。函数式编程同理，对于没有接触过函数式编程的同学来说，你们目前的词汇量都几乎为零，你们平时所编写的函数大多是为了降低耦合或者做模块化处理，归属于面向对象的范式。为了方便大家理解后续内容，我们列出一些基本的函数来打打基础。节约时间，这里只会列出有关列表的函数。</p><p>当然，为了让大家快捷地理解 Haskell 代码，我们先讲讲 Haskell 代码中的列表的定义，以及它的用途。</p><p>在 Haskell 中构造列表有两种方式：<code class="inline-code">[]</code> 代码任意类型的空列表（具体类型由上下文决定），而 <code class="inline-code">(a : as)</code> 表示将元素 a 插入到列表 as 的开头形成的列表（不会改变 as 的值）。顺带一提，Haskell 的类型检查是吊打 C++ 的，所以你在有的代码中没有看到类型声明是正常的事情，因为编译器会推断。</p><p><code class="inline-code">[]</code> 和 <code class="inline-code">:</code> 均可以理解为函数。<code class="inline-code">[]</code> 是不接受参数的函数（参数列表为空），而 <code class="inline-code">:</code> 是接受两个参数的函数。</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token comment">-- 列表的映射函数，用法见上文</span>
<span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">t</span> <span class="token operator">-></span> <span class="token hvariable">p</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">t</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">p</span><span class="token punctuation">]</span> 
<span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">:</span> <span class="token hvariable">as</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token hvariable">as</span>

<span class="token comment">-- 列表的拼接。</span>
<span class="token comment">-- 打括号的意思是 ++ 是一个二元运算符。Haskell 可以定义各种千奇百怪的自定义运算符</span>
<span class="token comment">-- ++ 的用法很多。a ++ b 是正常用法，等价于 (++) a b（当成函数用）</span>
<span class="token comment">-- 同理 (++) a 的返回值是一个函数，这个函数接受一个参数 b，返回在 b 前面拼接 a 的结果</span>
<span class="token comment">-- 针对二元运算符 Haskell 有一些巧妙的语法糖，(++) a 等价于 (a ++)，上文的 (a :) 同理。</span>
<span class="token comment">-- 类似，(++ b) a = (a ++) b = a ++ b = (++) a b = ((++) a) b，所有二元运算符都可以这么用。</span>
<span class="token comment">-- 这里相当于做了一个 switch。如果第一个是空列表就返回第二个。否则就递归把 as 和 b 拼起来再在开头插入 a</span>
<span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">t</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">t</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">t</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token hvariable">b</span>
<span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">:</span> <span class="token hvariable">as</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token hvariable">a</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token hvariable">as</span> <span class="token operator">++</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>

<span class="token comment">-- 右结合的运算</span>
<span class="token comment">-- 例如 foldr (+) 0 [1,2,3,4,5] 返回值为 1 + (2 + (3 + (4 + (5 + 0))))</span>
<span class="token comment">-- 同理 foldr f 0 [1,2,3] = f 1 (f 2 (f 3 0))</span>
<span class="token builtin">foldr</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">b</span> <span class="token operator">-></span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token hvariable">b</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token hvariable">b</span>
<span class="token builtin">foldr</span> <span class="token hvariable">f</span> <span class="token hvariable">e</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token hvariable">z</span>
<span class="token builtin">foldr</span> <span class="token hvariable">f</span> <span class="token hvariable">e</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">:</span> <span class="token hvariable">as</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token builtin">foldr</span> <span class="token hvariable">f</span> <span class="token hvariable">e</span> <span class="token hvariable">as</span><span class="token punctuation">)</span>

<span class="token comment">-- 左结合的运算</span>
<span class="token comment">-- 例如 foldl (+) 0 [1,2,3,4,5] 返回值为 ((((0 + 1) + 2) + 3) + 4) + 5</span>
<span class="token comment">-- 同理 foldl f 0 [1,2,3] = f (f (f 0 1) 2) 3</span>
<span class="token builtin">foldl</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">-></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token hvariable">b</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token hvariable">b</span>
<span class="token builtin">foldl</span> <span class="token hvariable">f</span> <span class="token hvariable">e</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token hvariable">z</span>
<span class="token builtin">foldl</span> <span class="token hvariable">f</span> <span class="token hvariable">e</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">:</span> <span class="token hvariable">as</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">e</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token hvariable">as</span>

<span class="token comment">-- 与 foldr 差不多，唯一的区别是它会把中间计算结果全部返回</span>
<span class="token comment">-- scanr max 0 [1, 2, 3, 2, 1] = [3, 3, 3, 2, 1, 0]</span>
<span class="token builtin">scanr</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">b</span> <span class="token operator">-></span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token hvariable">b</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>
<span class="token builtin">scanr</span> <span class="token hvariable">f</span> <span class="token hvariable">e</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">e</span><span class="token punctuation">]</span>
<span class="token builtin">scanr</span> <span class="token hvariable">f</span> <span class="token hvariable">e</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">:</span> <span class="token hvariable">as</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span> <span class="token operator">:</span> <span class="token hvariable">xss</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">scanr</span> <span class="token hvariable">f</span> <span class="token hvariable">e</span> <span class="token hvariable">as</span> <span class="token keyword">in</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token hvariable">xs</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span> <span class="token operator">:</span> <span class="token hvariable">xss</span><span class="token punctuation">)</span>

<span class="token comment">-- 与 foldl 差不多，唯一的区别是它会把中间计算结果全部返回</span>
<span class="token comment">-- scanl max 0 [1, 2, 3, 2, 1] = [0, 1, 2, 3, 3, 3]</span>
<span class="token builtin">scanl</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">-></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token hvariable">b</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>
<span class="token builtin">scanl</span> <span class="token hvariable">f</span> <span class="token hvariable">e</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">e</span><span class="token punctuation">]</span>
<span class="token builtin">scanl</span> <span class="token hvariable">f</span> <span class="token hvariable">e</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">:</span> <span class="token hvariable">as</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">e</span> <span class="token operator">:</span> <span class="token builtin">scanl</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">e</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token hvariable">as</span>

<span class="token comment">-- 把一个元素转化为一个单元素列表</span>
<span class="token hvariable">singleton</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">singleton</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>

<span class="token comment">-- 返回自身的函数</span>
<span class="token builtin">id</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">a</span>
<span class="token builtin">id</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了这些基础，我们已经可以做一些基本的程序演算了，大家不妨尝试证明以下定理（=== 表示等价于，不是赋值符号）：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token builtin">concat</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token hvariable">singleton</span> <span class="token operator">===</span> <span class="token builtin">id</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里 === 表示两个函数等价，也就是说无论接受什么参数等式两边都返回相同结果（这个参数必须同时满足左右两边的类型要求）</p><p>其实观察 concat 可以发现，它的递归写法等价于 <code class="inline-code">foldr (++) []</code>，因此大家可以再尝试证明</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这些证明都非常简单，目的是让大家理解这样的函数式语言的思维表达方式。</p></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2022年12月18日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/BMF-FFT/">使用 Bird-Meertens Formalism 推导 FFT</a></div><div class="prev-post"><a href="/Intro-to-Calculational-Programming-2/">函数式程序设计 / 程序演算入门 Part 2 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>