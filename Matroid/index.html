<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>拟阵学习笔记 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">拟阵学习笔记</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2021年2月10日星期三上午9点22分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2021年2月10日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 3,987 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> 当前文章</div><div class="post-tags"><span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Notes/">Notes</a></span></div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#拟阵第一定义"><span class="toc-number">1.</span> <span class="toc-text">拟阵第一定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#图拟阵"><span class="toc-number">1.1.</span> <span class="toc-text">图拟阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线性空间拟阵"><span class="toc-number">1.2.</span> <span class="toc-text">线性空间拟阵</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拟阵第二定义"><span class="toc-number">2.</span> <span class="toc-text">拟阵第二定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基与交换定理"><span class="toc-number">3.</span> <span class="toc-text">基与交换定理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拟阵上的最优化问题"><span class="toc-number">4.</span> <span class="toc-text">拟阵上的最优化问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拟阵的基础操作"><span class="toc-number">5.</span> <span class="toc-text">拟阵的基础操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对偶"><span class="toc-number">5.1.</span> <span class="toc-text">对偶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除"><span class="toc-number">5.2.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收缩"><span class="toc-number">5.3.</span> <span class="toc-text">收缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拟阵的交"><span class="toc-number">6.</span> <span class="toc-text">拟阵的交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例题"><span class="toc-number">7.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Rainbow-Graph"><span class="toc-number">7.1.</span> <span class="toc-text">Rainbow Graph</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文献"><span class="toc-number">8.</span> <span class="toc-text">参考文献</span></a></li></ol></div><hr></div><div class="post-content"><p>做一道联合省选题的时候遇到了这个，之前高爸也屡次♂邀请♂我学它，于是就有了本文。</p><p>本文旨在介绍拟阵的概念和应用，其中部分定理不会作出证明，详细的证明请阅读集训队论文。</p><h2><a id="拟阵第一定义" href="#拟阵第一定义" class="headerlink" title="拟阵第一定义"></a>拟阵第一定义</h2><p><strong>拟阵</strong>（Matroid）是指一个集合<script type="math/tex">S</script>与其幂集的子集（family of subset）<script type="math/tex">\mathcal{I}</script>（<script type="math/tex">\mathcal{I}\subseteq 2^S</script>）构成的二元组<script type="math/tex">(S,\mathcal{I})</script>使得<script type="math/tex">\mathcal{I}</script>满足：</p><ol><li>遗传性：若<script type="math/tex">I\in \mathcal{I}</script>，那么<script type="math/tex">\forall A\subseteq I</script>，有<script type="math/tex">A\in \mathcal{I}</script>。</li><li>扩张性（也称交换性）：对于<script type="math/tex">A,B\in \mathcal{I}</script>且<script type="math/tex">|A| &lt; |B|</script>，一定存在<script type="math/tex">e\in B\setminus A</script>使得<script type="math/tex">A+\{e\} \in \mathcal{I}</script>。</li></ol><p>其中<script type="math/tex">S</script>被称为<strong>基础集</strong>，<script type="math/tex">I\in \mathcal{I}</script>被称为<strong>独立集</strong>，<script type="math/tex">\mathcal{I}</script>则是独立集的集合。</p><p>上述两个条件也被称作拟阵公理，它们是拟阵最基本的特征。基于拟阵公理，我们可以容易地理解以下模型的拟阵性。</p><h3><a id="图拟阵" href="#图拟阵" class="headerlink" title="图拟阵"></a>图拟阵</h3><p>图拟阵描述的是对于无向图<script type="math/tex">G=(V,E)</script>，以边集<script type="math/tex">E</script>做为基础集的拟阵<script type="math/tex">(E, \mathcal{I})</script>，其中<script type="math/tex">I\in \mathcal{I}</script>当且仅当<script type="math/tex">I</script>无环。</p><p>从拟阵公理的角度：</p><ol><li>图拟阵的遗传性是显然的。</li><li>扩张性：对于<script type="math/tex">A,B\in \mathcal{I}</script>，若<script type="math/tex">|A| &lt; |B|</script>，那么图<script type="math/tex">(V,A)</script>的连通块数一定多余<script type="math/tex">(V,B)</script>的连通块数，那么一定存在<script type="math/tex">B</script>的一个连通块，它在<script type="math/tex">A</script>里是不连通的，这时我们就可以找到一条边<script type="math/tex">e \in B\setminus A</script>使得<script type="math/tex">A+ \{e\}</script>无环，即<script type="math/tex">A\cup \{e\}</script>是独立集。则扩张性成立。</li></ol><h3><a id="线性空间拟阵" href="#线性空间拟阵" class="headerlink" title="线性空间拟阵"></a>线性空间拟阵</h3><p>这名字我起的，不够严谨。</p><p>线性空间拟阵描述的是以线性空间<script type="math/tex">S</script>做为基础集的拟阵<script type="math/tex">(S,\mathcal{I})</script>，其中<script type="math/tex">I \in \mathcal{I}</script>当且仅当向量组<script type="math/tex">I</script>线性无关。</p><p>同样地，从拟阵公理的角度：</p><ol><li>遗传性显然。</li><li>扩张性：对于<script type="math/tex">A,B\in \mathcal{I}</script>，若<script type="math/tex">|A| &lt; |B|</script>，则<script type="math/tex">B</script>中一定存在一个向量<script type="math/tex">e</script>不能被<script type="math/tex">A</script>中的向量线性表出（如果不存在，那么<script type="math/tex">B</script>就能被<script type="math/tex">A</script>表出，则<script type="math/tex">B</script>中的向量不可能互相线性无关）。</li></ol><h2><a id="拟阵第二定义" href="#拟阵第二定义" class="headerlink" title="拟阵第二定义"></a>拟阵第二定义</h2><p>拟阵的第二定义是从秩函数的角度出发。对于基础集<script type="math/tex">S</script>和其幂集的子集<script type="math/tex">\mathcal{I}</script>（<script type="math/tex">\mathcal{I}\subseteq 2^S</script>），定义<strong>秩函数</strong>（rank function）<script type="math/tex">r(U)</script>：</p><script type="math/tex;mode=display">r(U) = \max_{I\subseteq U, I\in \mathcal{I}} |I|</script><p>即<script type="math/tex">U</script>的极大独立子集。</p><p>那么如果<script type="math/tex">r</script>满足如下三个性质，我们就称<script type="math/tex">(S,\mathcal{I})</script>是拟阵：</p><ol><li>有界性：<script type="math/tex">r(U)\le |U|</script>；</li><li>单调性：<script type="math/tex">\forall A\subseteq B\subseteq S</script>，有<script type="math/tex">r(A) \le r(B)</script>；</li><li>次模性：<script type="math/tex">\forall A,B\subseteq S</script>，<script type="math/tex">r(A\cup B) + r(A\cap B) \le r(A) + r(B)</script>。</li></ol><details><summary>如何理解次模性</summary><p>次模性可以理解为边际效益递减，其有一个更直观的等价的表达式：</p><p><script type="math/tex">\forall A\subseteq B\subseteq S</script>且<script type="math/tex">\forall e\notin B, e\in S</script>，有<script type="math/tex">r(A+\{e\}) - r(A)\ge r(B+\{e\}) - r(B)</script>。</p><p>也就是说我往<script type="math/tex">A</script>里加一个元素的秩的增量<strong>大于等于</strong>往<script type="math/tex">B</script>里加一个元素的秩的增量。</p><p><script type="math/tex">B</script>是<script type="math/tex">A</script>已经吸纳了<script type="math/tex">B\setminus A</script>这部分元素得到的，于是<script type="math/tex">B</script>再吸纳<script type="math/tex">e</script>带来的收益就比不上<script type="math/tex">A</script>直接吸纳<script type="math/tex">e</script>带来的收益。</p><p>如果放在全序集合上，这其实就是凸性的体现。</p></details><p>拟阵第一定义和第二定义是可以互推的。</p><p>我们同样用两个例子来补充叙述这一定义。</p><p>图拟阵：对于图拟阵<script type="math/tex">(E, \mathcal{I})</script>，其秩函数<script type="math/tex">r(U)</script>实质上是<script type="math/tex">G[U]</script>的生成森林的边数。其单调性和有界性都很容易证明，而次模性可以使用其第二种表达式来证明。</p><p>线性空间拟阵：对于线性空间拟阵<script type="math/tex">(S,\mathcal{I})</script>，其秩函数<script type="math/tex">r(U)</script>描述的是<script type="math/tex">U</script>中的最大线性无关组（或者说线性基）的大小。证明不做详细阐述。</p><p>接下来我们用拟阵的两种定义来介绍更多关于拟阵的概念，以丰富它的工具性。</p><h2><a id="基与交换定理" href="#基与交换定理" class="headerlink" title="基与交换定理"></a>基与交换定理</h2><p>对于拟阵<script type="math/tex">M = (S, \mathcal{I})</script>中的一个独立集<script type="math/tex">I</script>，若往<script type="math/tex">I</script>中加入任意一个元素都会让它变成非独立集，那么称<script type="math/tex">I</script>是拟阵<script type="math/tex">M</script>的一个<strong>基</strong>，也称<strong>极大独立集</strong>。</p><p>容易证明，拟阵的基大小相同。</p><p>基有另一个等价的定义形式：满足<script type="math/tex">|I| = r(S)</script>的独立集<script type="math/tex">I</script>是拟阵<script type="math/tex">M</script>的基。</p><p>关于基有两个定理，分别是（弱）基交换定理和强基交换定理。</p><p>弱基交换定理：对于任意拟阵<script type="math/tex">M</script>，若存在两个不同的基<script type="math/tex">A,B</script>，则<script type="math/tex">\forall x\in A\setminus B</script>，<script type="math/tex">\exists y\in B\setminus A</script>使得<script type="math/tex">A-\{x\} + \{y\}</script>是基。</p><p>强基交换定理：对于任意拟阵<script type="math/tex">M</script>，若存在两个不同的基<script type="math/tex">A,B</script>，则<script type="math/tex">\forall x\in A\setminus B</script>，<script type="math/tex">\exists y\in B\setminus A</script>使得<script type="math/tex">A-\{x\} + \{y\}</script>和<script type="math/tex">B-\{y\} + \{x\}</script>都是基。</p><p>具体的证明参见论文。</p><h2><a id="拟阵上的最优化问题" href="#拟阵上的最优化问题" class="headerlink" title="拟阵上的最优化问题"></a>拟阵上的最优化问题</h2><p>拟阵上的最优化问题定义为：给出拟阵<script type="math/tex">M=(S,\mathcal{I})</script>，给出价值函数<script type="math/tex">w:S\to\mathbf{R}</script>。对于<script type="math/tex">A\subseteq S</script>定义<script type="math/tex">W(A) = \sum_{e\in A}w(e)</script>。求<script type="math/tex">\max_{I\in \mathcal{I}}W(I)</script>。</p><p>拟阵上的最优化问题可以使用贪心算法，即将<script type="math/tex">e\in S</script>按照<script type="math/tex">w(e)</script>不升的顺序排列，令<script type="math/tex">I</script>初始为空集，然后从大到小在保证<script type="math/tex">I</script>独立的前提下将<script type="math/tex">e</script>加到<script type="math/tex">I</script>中，最后得到的就是最优解。</p><p>详细的证明不展开叙述。</p><p>最小生成树问题（MST）和和寻找线性基的问题都可以规约为拟阵上的最优化问题。有关的贪心算法的正确性因此得到了保证。</p><h2><a id="拟阵的基础操作" href="#拟阵的基础操作" class="headerlink" title="拟阵的基础操作"></a>拟阵的基础操作</h2><p>接下来介绍三种关于拟阵的操作，这可以帮助我们更深刻地理解拟阵模型的变换。</p><h3><a id="对偶" href="#对偶" class="headerlink" title="对偶"></a>对偶</h3><p>对于拟阵<script type="math/tex">M = (S,\mathcal{I})</script>，定义其对偶拟阵为<script type="math/tex">M^\ast = (S,\mathcal{I}^\ast)</script>，其中<script type="math/tex">\mathcal I^\ast = \{I : \exists B\in\mathcal I, |B|=r(S), B\subseteq S\setminus I\}</script>，即存在一个<script type="math/tex">M</script>中的基<script type="math/tex">B</script>使得<script type="math/tex">B\subseteq S\setminus I</script>。</p><p>这里我们断言拟阵的对偶仍是拟阵，这一点不论是用拟阵第一定义还是第二定义都可以证明。</p><p>对偶运算具有自反性，这从它的定义就可以得知。</p><p>举一个对偶拟阵的例子：图拟阵<script type="math/tex">(E, \mathcal I)</script>的对偶拟阵为<script type="math/tex">(E, \mathcal I^\ast)</script>，其中<script type="math/tex">I\in \mathcal I^\ast</script>当且仅当<script type="math/tex">E-I</script>存在基，即存在生成树，即连通。</p><p>换言之，<script type="math/tex">I\in \mathcal I^\ast</script>当且仅当删掉<script type="math/tex">I</script>中的边后，图仍然连通。</p><h3><a id="删除" href="#删除" class="headerlink" title="删除"></a>删除</h3><p>对于拟阵<script type="math/tex">M = (S,\mathcal I)</script>和<script type="math/tex">Z\subseteq S</script>，定义<script type="math/tex">M</script>删除<script type="math/tex">Z</script>的拟阵是<script type="math/tex">M\setminus Z = (S - Z, \mathcal I')</script>，其中<script type="math/tex">\mathcal I' = \{I : I\subseteq S-Z, I\in \mathcal I\}</script>。</p><p>换言之，就是删掉<script type="math/tex">Z</script>中的部分得到的拟阵。</p><p>同样以图拟阵为例，<script type="math/tex">(E, \mathcal I)</script>删除<script type="math/tex">Z</script>（<script type="math/tex">Z\subseteq E</script>）的拟阵就是<script type="math/tex">G=(V, E-Z)</script>对应的图拟阵。</p><h3><a id="收缩" href="#收缩" class="headerlink" title="收缩"></a>收缩</h3><p>对于拟阵<script type="math/tex">M = (S,\mathcal I)</script>和<script type="math/tex">Z\subseteq S</script>，定义<script type="math/tex">M</script>收缩<script type="math/tex">Z</script>的拟阵是<script type="math/tex">M/Z = (M^\ast\setminus Z)^\ast</script>。</p><p>这东西看着不太直观，经过一番推导我们得到它的秩函数<script type="math/tex">r_{M/Z}(U) = r_M(Z\cup U) - r_M(Z)</script>。</p><p>通过这个秩函数，我们将收缩理解为强制选取了<script type="math/tex">Z</script>中的一组基。</p><p>仍然以图拟阵为例，对应<script type="math/tex">M_G = (E,\mathcal I)</script>：</p><ul><li><script type="math/tex">M_G^\ast</script>的独立集<script type="math/tex">I</script>：删掉<script type="math/tex">I</script>中的边后图仍然连通。</li><li><script type="math/tex">M_G^\ast \setminus Z</script>的独立集<script type="math/tex">I</script>：强制<script type="math/tex">Z</script>中的边不能被删（即强制<script type="math/tex">I\cap Z = \varnothing</script>），删掉<script type="math/tex">I</script>中的边后图仍然连通。</li><li><script type="math/tex">(M_G^\ast \setminus Z)^\ast</script>的独立集<script type="math/tex">I</script>：强制<script type="math/tex">I</script>满足<script type="math/tex">I\cap Z</script>是<script type="math/tex">Z</script>的生成森林（基）。</li></ul><p>因此图拟阵收缩<script type="math/tex">Z</script>可以理解为缩边操作。</p><h2><a id="拟阵的交" href="#拟阵的交" class="headerlink" title="拟阵的交"></a>拟阵的交</h2><p>提示：这部分内容与拟阵的基础操作不太相关。</p><p>对于两个相同基础集<script type="math/tex">S</script>上的拟阵<script type="math/tex">M_1= (S, \mathcal I_1)</script>和<script type="math/tex">M_2 = (S, \mathcal I_2)</script>，定义它们的交<script type="math/tex">(S, \mathcal I_1\cap \mathcal I_2)</script>。</p><p><strong>拟阵的交，不一定是拟阵</strong>。</p><p>（带权）拟阵交问题定义为：给出价值函数<script type="math/tex">w:S\to\mathbf{R}</script>。对于<script type="math/tex">A\subseteq S</script>定义<script type="math/tex">W(A) = \sum_{e\in A}w(e)</script>。则求<script type="math/tex">\max_{I\in \mathcal I_1 \cap \mathcal I _2} W(I)</script>。</p><p>为了描述求拟阵交的算法，我们先定义关于两个拟阵<script type="math/tex">M_1, M_2</script>的<strong>交换图</strong><script type="math/tex">D_{M_1, M_2}(I)</script>：</p><ul><li>其为二分图，左部和右部的点集分别为<script type="math/tex">I</script>和<script type="math/tex">S\setminus I</script>。</li><li>一条从<script type="math/tex">I</script>到<script type="math/tex">S\setminus I</script>的边<script type="math/tex">(u,v)</script>存在，当且仅当<script type="math/tex">I-\{u\} +\{v\}\in \mathcal I_1</script>。</li><li>一条从<script type="math/tex">S\setminus I</script>到<script type="math/tex">I</script>的边<script type="math/tex">(v,u)</script>存在，当且仅当<script type="math/tex">I-\{u\} +\{v\}\in \mathcal I_2</script>。</li></ul><p>也就是说这个二分图里从左到右的边都是满足<script type="math/tex">\mathcal I_1</script>的，从右到左的边都是满足<script type="math/tex">\mathcal I_2</script>的。</p><p>我们还需要定义关于<script type="math/tex">I</script>的两个集合<script type="math/tex">X_1, X_2</script>：</p><ul><li><script type="math/tex">X_1 = \{x \in S\setminus I: I+\{x\}\in \mathcal I_1\}</script>。</li><li><script type="math/tex">X_2 = \{x \in S\setminus I: I+\{x\}\in \mathcal I_2\}</script>。</li></ul><p>以及一个关于<script type="math/tex">I</script>的点权函数：</p><script type="math/tex;mode=display">f(u) = \begin{cases}
w(u) & u\in S\setminus I\\
-w(u) & u\in I
\end{cases}</script><p>接下来我们就可以描述求拟阵交问题的算法——称之为增广路算法足够恰当。</p><p>考虑逐步扩张<script type="math/tex">I</script>。初始<script type="math/tex">I=\varnothing</script>。每次我们找一条从<script type="math/tex">X_1</script>中的点出发，交替经过<script type="math/tex">I</script>和<script type="math/tex">S\setminus I</script>中的点，最后到达<script type="math/tex">X_2</script>中的点的<strong>点权和最小</strong>的简单路径<script type="math/tex">P</script>，然后令<script type="math/tex">I\gets I\Delta P</script>，即<script type="math/tex">I</script>和<script type="math/tex">P</script>的对称差。直到找不到<script type="math/tex">P</script>。最后得到的就是拟阵交的最大权独立集。</p><p>注意，若<script type="math/tex">X_1\cap X_2</script>非空，算法可能会直接扩张一个属于交集的元素。</p><p>算法的正确性证明见论文。</p><p>从算法应用的角度，我们关注的是如何快速求出二分图的边集，或者说在找增广路的过程中如何快速找到后继。若只考虑增广的复杂度，我们最多增广<script type="math/tex">r = \max(r_1(S), r_2(S))</script>次，则总复杂度<script type="math/tex">O(r^2n)</script>。</p><h2><a id="例题" href="#例题" class="headerlink" title="例题"></a>例题</h2><p>时间有点晚，写一道吧，有时间再补补。</p><h3><a id="Rainbow-Graph" href="#Rainbow-Graph" class="headerlink" title="Rainbow Graph"></a>Rainbow Graph</h3><blockquote><p>给定一张带权无向图<script type="math/tex">G = (V, E)</script>，每条边是三种颜色红绿蓝之一。要求对于从<script type="math/tex">1</script>到<script type="math/tex">|E|</script>的每个<script type="math/tex">k</script>，都求出来：选出<script type="math/tex">k</script>条边并使得不含红色边的图和不含蓝色边的图都连通的最小权值，如果不存在则输出<script type="math/tex">-1</script>。</p><p><script type="math/tex">|V|, |E| \le 100</script>。</p></blockquote><p>将问题转化为：删除<script type="math/tex">k</script>条边使得不含红色边的图和不含蓝色边的图都连通。因此构造：</p><ul><li><script type="math/tex">M_1 = (E,\mathcal I_1)</script>，<script type="math/tex">I\in \mathcal I_1</script>描述的是删掉<script type="math/tex">I</script>中的边后不含红色边的图连通。</li><li><script type="math/tex">M_2 = (E,\mathcal I_2)</script>，<script type="math/tex">I\in \mathcal I_2</script>描述的是删掉<script type="math/tex">I</script>中的边后不含蓝色边的图连通。</li></ul><p>通过拟阵第一定义可以证明这两个都是拟阵。求拟阵交即可。由于拟阵交的增广路算法是从空集逐步拓展的，因此可以得到每个<script type="math/tex">k</script>的答案。</p><h2><a id="参考文献" href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>杨乾澜 ，《浅谈拟阵的一些拓展及其应用》，IOI2018 中国国家集训队论文。</p></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2021年2月10日 第2次修订</li><li class="post-history-item">2021年2月1日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/Math/Linear-Algbra/Matrix-Tree/">矩阵树定理学习笔记</a></div><div class="prev-post"><a href="/Isotonic-Regression/">保序回归学习笔记 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>