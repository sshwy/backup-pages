<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>Codeforces 题目选讲 2 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">Codeforces 题目选讲 2</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2020年4月9日星期四下午12点45分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2020年4月9日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 6,681 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> <a class="directory" href="/directory/Codeforces/">Codeforces </a><span class="icon smallarrow"></span> 当前文章</div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Present"><span class="toc-number">1.</span> <span class="toc-text">Present</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Instant-Noodles"><span class="toc-number">2.</span> <span class="toc-text">Instant Noodles</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reality-Show"><span class="toc-number">3.</span> <span class="toc-text">Reality Show</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AND-Segments"><span class="toc-number">4.</span> <span class="toc-text">AND Segments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bombs"><span class="toc-number">5.</span> <span class="toc-text">Bombs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wise-Men"><span class="toc-number">6.</span> <span class="toc-text">Wise Men</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sum-of-Prefix-Sums"><span class="toc-number">7.</span> <span class="toc-text">Sum of Prefix Sums</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#No-Monotone-Triples"><span class="toc-number">8.</span> <span class="toc-text">No Monotone Triples</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dreamoon-Likes-Strings"><span class="toc-number">9.</span> <span class="toc-text">Dreamoon Likes Strings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#On-the-Bench"><span class="toc-number">10.</span> <span class="toc-text">On the Bench</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kate-and-imperfection"><span class="toc-number">11.</span> <span class="toc-text">Kate and imperfection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Road-to-1600"><span class="toc-number">12.</span> <span class="toc-text">Road to 1600</span></a></li></ol></div><hr></div><div class="post-content"><h2><a id="Present" href="#Present" class="headerlink" title="Present"></a><a target="_blank" rel="noopener" href="http://codeforces.com/contest/1322/problem/B">Present</a></h2><blockquote><p>给出长度为<script type="math/tex">n</script>的序列<script type="math/tex">a</script>，求</p><script type="math/tex;mode=display">\begin{aligned}
\bigoplus_{1\le i&lt;j\le n}(a_i+a_j)
=&(a_1 + a_2) \oplus (a_1 + a_3) \oplus \ldots \oplus (a_1 + a_n) \\
&\oplus (a_2 + a_3) \oplus \cdots \oplus (a_2 + a_n) \\
&\cdots \\
&\oplus (a_{n-1} + a_n) \\
\end{aligned}</script><p><script type="math/tex">n\le 4\times 10^5,1\le a_i\le 10^7</script>。</p></blockquote><p><strong>摘要：逐位计算。</strong></p><p>考虑按位计算答案。考虑计算答案的二进制第<script type="math/tex">k</script>位是否为<script type="math/tex">1</script>（<script type="math/tex">k</script>从<script type="math/tex">0</script>计数）。由于高于<script type="math/tex">k</script>的位不影响第<script type="math/tex">k</script>位的数，不妨设<script type="math/tex">a_i&lt;2^{k+1}</script>。因此<script type="math/tex">a_i+a_j&lt;2^{k+2}</script>。那么我们要计算的就是</p><script type="math/tex;mode=display">\sum_{1\le i&lt;j\le n}[2^k\le a_i+a_j&lt;2^{k+1}]\text{ or }[2^{k+1}+2^k\le a_i+a_j&lt;2^{k+2}]</script><p>的奇偶性。</p><p>不妨将<script type="math/tex">a</script>排序。枚举<script type="math/tex">j</script>，在序列上二分查找即可。</p><p>时间复杂度<script type="math/tex">O(n\log_2^2n)</script>。</p><p>可以使用双指针 + 归并排序优化到<script type="math/tex">O(n\log_2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/1322/b.cpp">代码</a></p><h2><a id="Instant-Noodles" href="#Instant-Noodles" class="headerlink" title="Instant Noodles"></a><a target="_blank" rel="noopener" href="http://codeforces.com/contest/1322/problem/C">Instant Noodles</a></h2><blockquote><p>给你一个<script type="math/tex">2n</script>个点的二分图，左部右部各<script type="math/tex">n</script>个点。有<script type="math/tex">m</script>条边。右部的点点权为<script type="math/tex">c_i</script>。</p><p>定义<script type="math/tex">f(S)</script>表示左部点集<script type="math/tex">S</script>的邻居集合（显然都是右部的点）定义<script type="math/tex">g(S)</script>表示<script type="math/tex">f(S)</script>中的点的点权和。</p><p>求<script type="math/tex">\gcd_{S\subseteq[n]}\{g(S)\}</script>。</p><p><script type="math/tex">n,m\le 5\times 10^5,c_i\le 10^{12}</script>。</p></blockquote><p><strong>摘要：哈希判邻居集合是否相等。</strong></p><p>由于是和的 GCD，因此我们关系的是：对于两个右部点<script type="math/tex">u,v</script>，他们是否<strong>同步出现</strong>（要么同时出现，要么同时不出现）。</p><p>如果两个点同步出现，那么我们就只用考虑它们的和。</p><p>推广之。若右部点集合<script type="math/tex">S</script>中的点均同步出现，则我们只用考虑<script type="math/tex">S</script>的点权和。</p><p>因此答案就是所有同步点集合的点权和的 GCD。</p><p>要判断右部点两个点是否同步出现，只需要判断它们的邻居集合是否相同即可。</p><p>若两个点的邻居集合不同，那么一定存在一个左部点集合使得这两个点没有同步出现。</p><p>使用哈希，时间复杂度<script type="math/tex">O(n+m)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/1322/c.cpp">代码</a></p><h2><a id="Reality-Show" href="#Reality-Show" class="headerlink" title="Reality Show"></a><a target="_blank" rel="noopener" href="http://codeforces.com/contest/1322/problem/D">Reality Show</a></h2><blockquote><p>给出长度为<script type="math/tex">n</script>的序列<script type="math/tex">s</script>和<script type="math/tex">l</script>，给出一个长度为<script type="math/tex">n+m</script>的序列<script type="math/tex">c</script>。</p><p>你可以构造一个长度为<script type="math/tex">k(k\le n)</script>的序列<script type="math/tex">p</script>满足：</p><ol><li><script type="math/tex">1\le p_i&lt;p_{i+1}\le n</script>（单增）；</li><li><script type="math/tex">l_{p_i}\ge l_{p_{i+1}}</script>（非严格单减）。</li></ol><p>然后你需要对<script type="math/tex">p</script>和一个集合<script type="math/tex">S</script>做这样的操作：以<script type="math/tex">i=1,2,\cdots,k</script>的顺序考虑<script type="math/tex">x=l_{p_i}</script>：</p><ol><li>你会获得<script type="math/tex">c_x</script>的奖励；</li><li>若<script type="math/tex">x\notin S</script>，把<script type="math/tex">x</script>加入<script type="math/tex">S</script>并结束这次操作；否则把<script type="math/tex">x</script>从<script type="math/tex">S</script>中删除，并令<script type="math/tex">x\gets x+1</script>。</li></ol><p>你的得分是奖励之和减去<script type="math/tex">\sum_{i=1}^k s_{p_i}</script>。</p><p>请构造满足条件的<script type="math/tex">p</script>并最大化得分。输出得分。</p><p><script type="math/tex">1\le n,m\le 2000,1\le l_i\le m,0\le s_i\le 5000,|c_i|\le 5000</script>。</p></blockquote><p><strong>摘要：倒序 DP。</strong></p><p>首先注意到在第二步操作的时候，你以任意顺序操作<script type="math/tex">l_{p_i}</script>，得分不变。</p><p>而我们操作的过程实际上可以看做是二进制的进位过程。</p><p>那么我们考虑倒着构造<script type="math/tex">p</script>。那么我们每次构造的就是当前序列中<script type="math/tex">l_{p_i}</script>最大的元素。</p><p>考虑 DP。设<script type="math/tex">f(i,j)</script>表示<script type="math/tex">l_{p_x}</script>最大值为<script type="math/tex">i</script>，且<script type="math/tex">l_{p_x}=i</script>的人有<script type="math/tex">j</script>个时的最大得分。</p><p>若我们在<script type="math/tex">p</script>的开头插入<script type="math/tex">i</script>（即新的<script type="math/tex">p_1=i</script>），那么就可以对<script type="math/tex">f(l_i,j)</script>做一次背包：</p><script type="math/tex;mode=display">f(l_i,j)\gets f(l_i,j-1)-s_i+c_{l_i}</script><p>另一方面，<script type="math/tex">f(x,j)</script>在<script type="math/tex">j&gt;1</script>的时候可以进位到<script type="math/tex">f(x+1,\lfloor\frac{j}{2}\rfloor)</script>。但是不是所有<script type="math/tex">f(x,j)</script>都需要进位。因为我们只改变了<script type="math/tex">f(l_i,j)</script>，因此只需要对<script type="math/tex">x\ge l_i</script>的部分进位即可。另一个事情是，<script type="math/tex">f(l_i,j)</script>会贡献到<script type="math/tex">f(l_i+1,\lfloor\frac{j}{2}\rfloor)</script>，则<script type="math/tex">j</script>的范围每次除以 2。因此 DP 转移的复杂度是<script type="math/tex">O(n+m)</script>的。</p><p>总复杂度<script type="math/tex">O(n(n+m))</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/1322/d.cpp">代码</a></p><h2><a id="AND-Segments" href="#AND-Segments" class="headerlink" title="AND Segments"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1327/problem/F">AND Segments</a></h2><blockquote><p>给出<script type="math/tex">n,k,m</script>和<script type="math/tex">m</script>个限制<script type="math/tex">(l_i,r_i,x_i)</script>。问有多少长度为<script type="math/tex">n</script>的序列<script type="math/tex">a</script>满足</p><ol><li><script type="math/tex">0\le a_i&lt;2^k</script>；</li><li><script type="math/tex">\forall1\le i\le m, a_{l_i}\operatorname{bitand} a_{l_i+1}\operatorname{bitand}\cdots\operatorname{bitand}a_{r_i}=x_i</script>；</li></ol><p><script type="math/tex">1\le n\le 5\times 10^5,1\le k\le 30,0\le m\le 5\times 10^5</script>。</p></blockquote><p>按位考虑。限制转化为，一段区间全 1，一段区间至少有一个 0。设<script type="math/tex">f(i)</script>表示前<script type="math/tex">i</script>个数且满足与前<script type="math/tex">i</script>个位置相交的限制的方案数。转移时枚举上一个<script type="math/tex">0</script>的位置即可。可以前缀和优化。复杂度<script type="math/tex">O(nk)</script>。</p><p>然而要注意的是，有关区间包含的去重问题一定要三思。千万记住：不要只比相邻的！不要 ban 掉前面的，应该是 ban 掉你当前的这个区间。注意枚举顺序。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/1327/f.cpp">代码</a></p><h2><a id="Bombs" href="#Bombs" class="headerlink" title="Bombs"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1326/problem/E">Bombs</a></h2><blockquote><p>你有一个排列<script type="math/tex">p_i</script>。你有一个 01 序列<script type="math/tex">v_i</script>。对<script type="math/tex">(p,v)</script>进行一次操作为：考虑<script type="math/tex">i=1,2,\cdots,n</script>：</p><ol><li>把<script type="math/tex">p_i</script>插入到集合中；</li><li>如果<script type="math/tex">v_i=1</script>，就把集合中最大的数删除。</li></ol><p>最后集合中剩下的数就是操作结果（如果有）。</p><p>现在给出排列<script type="math/tex">p</script>和<script type="math/tex">q</script>。设序列<script type="math/tex">v_i</script>初始为<script type="math/tex">0</script>，要求你对<script type="math/tex">i=1,2,\cdots,n</script>：</p><ol><li>求出<script type="math/tex">(p,v)</script>操作的结果并输出；</li><li>令<script type="math/tex">v_{q_{i}}\gets 1</script>（増加一个 bomb）。</li></ol><p><script type="math/tex">n\le 3\times 10^5,1\le p_i,q_i\le n</script>。</p></blockquote><p>随着 bomb 的增加，答案是不会增加的（不可能有数字复活）。</p><p>考虑排列中一个数<script type="math/tex">x</script>，假设<script type="math/tex">p_u=x</script>。那么在什么条件下答案<script type="math/tex">&lt;x</script>？</p><p>所有大于等于<script type="math/tex">x</script>的数都被删。也就说，<script type="math/tex">p</script>中最靠右的<script type="math/tex">\ge x</script>的数的右边至少有一个 bomb，第二靠右的<script type="math/tex">\ge x</script>的数右边至少有 2 个 bomb，以此类推。</p><p>可以把<script type="math/tex">\ge x</script>的数的位置 +1，bomb 出现的位置 -1。那么条件就转化为，所有的后缀和都小于等于<script type="math/tex">0</script>。</p><p>如果答案<script type="math/tex">&lt;x</script>，那么我们就把<script type="math/tex">x</script>减 1 并继续检查答案是否小于<script type="math/tex">x</script>。</p><p>线段树维护后缀和即可。</p><p>时间复杂度<script type="math/tex">O(n\log_2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/1326/e.cpp">代码</a></p><h2><a id="Wise-Men" href="#Wise-Men" class="headerlink" title="Wise Men"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1326/problem/F2">Wise Men</a></h2><blockquote><p>给一个<script type="math/tex">n</script>个点简单无向图<script type="math/tex">G=(V,E)</script>。</p><p>对于长度为<script type="math/tex">n</script>的排列<script type="math/tex">p</script>，我们可以构造一个长度为<script type="math/tex">n-1</script>的 01 串<script type="math/tex">s(p)</script>：<script type="math/tex">\forall 1\le i&lt;n,s_i=[(p_i,p_{i+1})\in E]</script>。</p><p>现在对于所有<script type="math/tex">2^{n-1}</script>个长度为<script type="math/tex">n-1</script>的 01 串<script type="math/tex">S</script>，求<script type="math/tex">s(p)=S</script>的排列<script type="math/tex">p</script>的个数。</p><p><script type="math/tex">2\le n\le 18</script>。</p></blockquote><p>考虑容斥。容斥 01 串中的 0，用无限制减去强制为 1 的情况。也就是说，<script type="math/tex">f(S)</script>表示答案，则<script type="math/tex">g(S)=\sum_{S\subseteq T}f(T)</script>。我们考虑求<script type="math/tex">g(S)</script>。</p><p><script type="math/tex">g(S)</script>可以理解为是，用若干条路径覆盖<script type="math/tex">n</script>个点的方案数。其中每条路径的长度的给定的。比如<script type="math/tex">g(11001011)</script>表示用长度分别为<script type="math/tex">1,2,3,3</script>的路径覆盖<script type="math/tex">n</script>个点的方案数（换一种说法，就是<script type="math/tex">g(11001011)=g(11010011)</script>，因为他们对应的路径长度集合都是<script type="math/tex">\{1,2,3,3\}</script>）。</p><p>因此<script type="math/tex">g(S)=G(A)</script>，其中<script type="math/tex">A</script>表示路径长度集合。我们可以考虑求<script type="math/tex">G(A)</script>。<script type="math/tex">A</script>的个数是拆分数，而<script type="math/tex">P(18)=385</script>，复杂度可以接受。</p><p>不妨先求出<script type="math/tex">f(x,S)</script>，表示用长度为<script type="math/tex">x</script>的路径<strong>精确覆盖</strong>点集<script type="math/tex">S</script>的方案数（哈密尔顿路径）。这个可以 DP 求出。那么<script type="math/tex">G(A)</script>可以理解为是<script type="math/tex">\prod f(x,S_i)</script>，其中<script type="math/tex">x\in A</script>，且<script type="math/tex">S_i(1\le i\le |A|)</script>精确覆盖全集<script type="math/tex">[n]</script>。由于的精确覆盖，因此本能地想到是不相交的或卷积。然而注意到我们只需要知道<script type="math/tex">2^n-1</script>处的点值，因此普通的或卷积也是足够的（如果集合出现交集，则这种方案无法对<script type="math/tex">2^n-1</script>的点值做贡献）。</p><p>因此<script type="math/tex">G(A)</script>就是<script type="math/tex">f(x)(x\in A)</script>的或卷积的<script type="math/tex">2^n-1</script>处的点值。这样我们对于每个路径长度集合<script type="math/tex">A</script>都可以计算出答案。</p><p>然后我们再枚举 01 串，求出它的路径集合即可。</p><p>最后容斥（FMT）回去。</p><p>时间复杂度<script type="math/tex">O((?\times P(n)+n^2)2^n)</script>。<script type="math/tex">?</script>表示拆分出的部分的个数。能过。当然，也是可以优化的。优化就是在 DFS 枚举集合的时候顺便 FMT。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/1326/f.cpp">代码</a></p><h2><a id="Sum-of-Prefix-Sums" href="#Sum-of-Prefix-Sums" class="headerlink" title="Sum of Prefix Sums"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1303/problem/G">Sum of Prefix Sums</a></h2><blockquote><p>给你一棵带点权无根树<script type="math/tex">T=(G,E)</script>。点权为<script type="math/tex">a_i</script>。定义一条路径<script type="math/tex">P(u,v)=\{i_1=u,i_2,\cdots,i_k=v\}</script>的权值为<script type="math/tex">\sum_{j=1}^k a_{i_j}j</script>。求权值最大的路径的权值。</p><p><script type="math/tex">2\le n\le 150000,1\le a_i\le 10^6</script>。</p></blockquote><p><strong>摘要：点分治，李超树。</strong></p><p>考虑点分治。</p><p>容易想到把路径<script type="math/tex">i_1,\cdots,i_k</script>分成前后两部分：<script type="math/tex">i_1,\cdots,i_m</script>和<script type="math/tex">i_{m+1},\cdots,i_k</script>。那么两部分的权值分别为<script type="math/tex">\sum_{j=1}^ma_{i_j}j</script>和<script type="math/tex">m\cdot \sum_{j=1}^{k-m}a_{i_{m+j}}+\sum_{j=1}^{k-m}a_{i_{m+j}}j</script>。前者可以用<script type="math/tex">(x_1=\sum_{j=1}^ma_{i_j}j,y_1=m)</script>表示，后者可以用<script type="math/tex">(x_2=\sum_{j=1}^{k-m}a_{i_{m+j}},y_2=\sum_{j=1}^{k-m}a_{i_{m+j}}j)</script>表示。因此整条路径的权值为<script type="math/tex">x_1+y_1x_2+y_2</script>。</p><p>对于每个结点我们都可以计算出它到分治中心的路径对应的<script type="math/tex">(x_1,y_1)</script>和<script type="math/tex">(x_2,y_2)</script>。因此我们要选择两个不同子树的<script type="math/tex">(x_1,y_1)</script>和<script type="math/tex">(x_2,y_2)</script>来更新答案。</p><p>考虑用数据结构维护<script type="math/tex">(x_2,y_2)</script>的集合。然后用<script type="math/tex">y_1</script>查询。那么这就是维护若干个一次函数，查询单点最大值的问题。可以使用李超树。可以标记永久化。</p><p>同时我们要求是不同子树。因此对于一个子树，先查再插入即可。然后再倒着做一遍处理反向的情况。</p><p>时间复杂度<script type="math/tex">O(n\log_2^2n)</script>。</p><p>李超树的复杂度：在一个<strong>线段树区间</strong>上插入一条直线的复杂度是<script type="math/tex">O(\log_2n)</script>的。但是我们每次都是在根结点的区间上插入。因此总复杂度是<script type="math/tex">O(n\log_2^2n)</script>的。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/1303/g.cpp">代码</a></p><h2><a id="No-Monotone-Triples" href="#No-Monotone-Triples" class="headerlink" title="No Monotone Triples"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1332/problem/G">No Monotone Triples</a></h2><blockquote><p>对于一个序列<script type="math/tex">a</script>，如果<script type="math/tex">\forall 1\le i&lt;|a|, a_i\le a_{i+1}</script>或者<script type="math/tex">\forall 1\le i&lt;|a|, a_i\ge a_{i+1}</script>，那么称<script type="math/tex">a</script>是单调序列。</p><p>若序列<script type="math/tex">a</script>不含长度大于等于<script type="math/tex">3</script>的单调子序列，则称<script type="math/tex">a</script>是 no-triple 序列。</p><p>给出长度为<script type="math/tex">n</script>的序列<script type="math/tex">a</script>。<script type="math/tex">q</script>次询问<script type="math/tex">(L,R)</script>，询问区间<script type="math/tex">[L,R]</script>的最长 no-triple 子序列。</p><p><script type="math/tex">n\le 2\times 10^5,q\le 2\times 10^5</script>。</p></blockquote><p>手玩一下可以发现，no-triple 的长度最大为 4。</p><p>考虑对于每个<script type="math/tex">i</script>（<script type="math/tex">1\le i\le n</script>），求出最小的<script type="math/tex">j</script>使得<script type="math/tex">[i,j]</script>里有长度为 4 的 no-triple（长度为 3 的 no-triple 是类似的）。</p><p>那么条件可以转化为，求出最小的<script type="math/tex">j</script>使得<script type="math/tex">[i,j]</script>中存在<script type="math/tex">i&lt;x,y&lt;j,x\ne y</script>使得<script type="math/tex">a_x&gt;\max(a_i,a_j)</script>，<script type="math/tex">a_y&lt;\min(a_i,a_j)</script>。</p><p>首先我们找到<script type="math/tex">a_i</script>右边第一个比<script type="math/tex">i</script>大的数。记为<script type="math/tex">a_p</script>。</p><p>并且找到<script type="math/tex">a_i</script>右边第一个比<script type="math/tex">i</script>小的数。记为<script type="math/tex">a_q</script>。</p><p>那么显然，<script type="math/tex">j&gt;\max(p,q)</script>。</p><p>另一方面，我们维护<script type="math/tex">i</script>的两个非严格单调栈。设<script type="math/tex">P_i</script>表示<script type="math/tex">a_i</script>右边第一个大于等于<script type="math/tex">a_i</script>的位置（即<script type="math/tex">P_i = \min \{j\mid a_j\ge a_i,j\ge i\}</script>）。<script type="math/tex">Q_i</script>表示第一个小于等于。那么第一个栈中存储的就是<script type="math/tex">\{i,P_i,P_{P_i},\cdots,P^{\circ k}_i  \}</script>，第二个栈中存的就是<script type="math/tex">\{i,Q_i,Q_{Q_i},\cdots,Q^{\circ k}_i  \}</script>。</p><p>显然<script type="math/tex">j</script>不能在任何一个栈中。不然就找不到比<script type="math/tex">a_j</script>大的（或者找不到比<script type="math/tex">a_j</script>小的）数了。</p><p>上面的这两个条件，是否是<script type="math/tex">j</script>的充分条件？是的。</p><p>也就是说只要满足这两个条件，就一定能在<script type="math/tex">[i,j]</script>中找到<script type="math/tex">x,y</script>满足 no-triple 的条件。</p><p>因此我们只需要找到满足这两个条件的最小的<script type="math/tex">j</script>即可。</p><p>构造方案：容易发现，一定存在方案使得<script type="math/tex">x,y</script>分别在两个栈中。因此在栈上二分即可。</p><p>长度的 3 的 no-triple 是类似的。</p><p>然后我们离线，后缀<script type="math/tex">\min</script>即可。</p><p>时间复杂度<script type="math/tex">O(n\log_2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/1332/g.cpp">代码</a></p><h2><a id="Dreamoon-Likes-Strings" href="#Dreamoon-Likes-Strings" class="headerlink" title="Dreamoon Likes Strings"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1329/problem/D">Dreamoon Likes Strings</a></h2><blockquote><p>你有一个字符串<script type="math/tex">s</script>。每次你可以删除<script type="math/tex">s</script>的一个子串<script type="math/tex">t</script>，满足<script type="math/tex">t</script>中不存在相邻相同字符。删完后两边自动拼在一起。问最少多少次可以把<script type="math/tex">s</script>删完。并输出方案。</p><p><script type="math/tex">|s|\le 2\times 10^5</script>。</p></blockquote><p>考虑把<script type="math/tex">s</script>中相邻相同字符都写下来。比如<code class="inline-code">abbccddacdbbb</code>可以写出<code class="inline-code">bcdbb</code>，记为<script type="math/tex">s'</script>。那么你删一个子串肯定是删一个极长的子串。于是可以发现，你的删除操作等价于：</p><ol><li>在<script type="math/tex">s'</script>中删除开头或者末位一个字符；</li><li>在<script type="math/tex">s'</script>中删除两个相邻但不同的字符；</li><li>在<script type="math/tex">s'</script>中删除一个字符，且这个字符旁边存在与它相同的字符。</li></ol><p>如果<script type="math/tex">s'=\varnothing</script>，那么我们就可以再删一次把<script type="math/tex">s</script>删光。</p><p>那么我们肯定会先尽量使用 2 操作，多删几个字符。然后使用 1 操作。这就转化为一个经典问题：每次匹配两个不同类型的元素。问最多匹配多少个。设总数为<script type="math/tex">x</script>，同类的最大数量为<script type="math/tex">y</script>。则答案显然为<script type="math/tex">\max(\lfloor\frac{x}{2}\rfloor,y)</script>。而现在的问题是我们还需要构造出方案。</p><ol><li>如果<script type="math/tex">2y\ge x</script>，那么很容易构造方案。我们把其他的都往<script type="math/tex">y</script>上“贴”就行。</li><li>如果<script type="math/tex">2y&lt;x</script>。那么我们可以先随便搞。即遍历一遍，遇到相邻不同字符就双双删除。直到<script type="math/tex">2y=x</script>或者<script type="math/tex">2y=x-1</script>的时候就 break。这时就转化为了情况 1 了，于是再构造一下剩余的方案即可（当然在删除过程中，可能有别的类会变成<script type="math/tex">y</script>）。</li></ol><p>要注意细节的处理。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/1329/d.cpp">代码</a></p><h2><a id="On-the-Bench" href="#On-the-Bench" class="headerlink" title="On the Bench"></a><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/840/C">On the Bench</a></h2><blockquote><p>给你一个长度为<script type="math/tex">n</script>的序列<script type="math/tex">a</script>。问有多少个长度为<script type="math/tex">n</script>的排列<script type="math/tex">p</script>满足<script type="math/tex">\forall 1\le i&lt;n</script>，<script type="math/tex">a_{p_i}a_{p_{i+1}}</script>不是完全平方数。</p><p><script type="math/tex">n\le 300,a_i\le 10^9</script>。</p></blockquote><p>首先注意到，若<script type="math/tex">ab</script>和<script type="math/tex">bc</script>都是完全平方数，则<script type="math/tex">ac</script>也是完全平方数（传递性）。</p><p>因此问题转化为：有<script type="math/tex">n</script>个带标号的球，每个球有一个颜色。你要把他们排成一排且相邻的球颜色不同。求方案数。</p><p>考虑容斥。同色不相邻 = 无限制 - 同色相邻。而同色相邻，可以理解为是把两个球捆在一起。</p><p>考虑 DP。设<script type="math/tex">f(i,j)</script>表示前<script type="math/tex">i</script>种球，有<script type="math/tex">j</script>个同色相邻的方案数。答案就是<script type="math/tex">\sum f(m,i)(-1)^i</script>（假设一共<script type="math/tex">m</script>种颜色）。</p><p>设第<script type="math/tex">i</script>种球有<script type="math/tex">x</script>个。那么我们可以枚举颜色<script type="math/tex">i</script>的相邻的个数，假设是<script type="math/tex">k</script>。那么这样的方案数是<script type="math/tex">\binom{x-1}{k}x!</script>。然后考虑背包的合并，相当于把<script type="math/tex">x</script>个球插板。</p><p>时间复杂度<script type="math/tex">O(n^2)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/840c.cpp">代码</a></p><h2><a id="Kate-and-imperfection" href="#Kate-and-imperfection" class="headerlink" title="Kate and imperfection"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1333/problem/F">Kate and imperfection</a></h2><blockquote><p>设<script type="math/tex">S=\{1,2,\cdots,n\}</script>。</p><p>对于<script type="math/tex">S</script>的子集<script type="math/tex">T</script>，设<script type="math/tex">f(T)=\max \{\gcd(x,y)\mid x,y\in T,x\ne y\}</script>。</p><p>对于<script type="math/tex">i</script>（<script type="math/tex">1&lt;i\le n</script>），求出<script type="math/tex">S</script>的所有大小为<script type="math/tex">i</script>的子集<script type="math/tex">T</script>中，<script type="math/tex">f(T)</script>的最大值。</p><p><script type="math/tex">n\le 5\times 10^5</script>。</p></blockquote><p>考虑<script type="math/tex">f(T)\ne x</script>的条件是什么？必要条件：<script type="math/tex">x,2x,\cdots,\lfloor\frac{n}{x}\rfloor x</script>中至多有一个数在<script type="math/tex">T</script>中。如果要选一个数，显然我们会贪心地保留<script type="math/tex">x</script>，删掉<script type="math/tex">x</script>的倍数。</p><p>因此如果我们想删掉尽量少的数使得<script type="math/tex">f(T)\ne x</script>，则<script type="math/tex">x</script>的倍数必须全部被删。</p><p>因此如果要求<script type="math/tex">f(T)&lt;x</script>，则<script type="math/tex">x,x+1,\cdots,n</script>的倍数都要被删。不妨计算出<script type="math/tex">b_i</script>表示要让<script type="math/tex">f(T)&lt;i</script>，至少要删掉多少个数。即，要让<script type="math/tex">f(T)&lt;i</script>，最多存在多少个数。</p><p>充分性：另一方面，如果存在<script type="math/tex">x</script>和<script type="math/tex">x</script>的倍数，那么<script type="math/tex">f(T)</script>至少是<script type="math/tex">x</script>。</p><p>然后就简单遍历一遍统计答案即可。</p><p>时间复杂度<script type="math/tex">O(n\log n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/1333/f.cpp">代码</a></p><h2><a id="Road-to-1600" href="#Road-to-1600" class="headerlink" title="Road to 1600"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1333/problem/E">Road to 1600</a></h2><blockquote><p>把<script type="math/tex">1,2,\cdots,n^2</script>依次填入<script type="math/tex">n\times n</script>的方格中。然后你需要访问每个格子恰好一次。有两种访问方式。</p><p>Rook 式：</p><ol><li>从<script type="math/tex">1</script>所在方格开始；</li><li>如果与它同行 / 同列中存在未被访问过的格子，选择一数字最小的格子走过去；</li><li>否则，从未访问过的方格中选择一个数字最小的方格并走过去。花费<script type="math/tex">1</script>个代价。</li></ol><p>Queen 式：</p><ol><li>从<script type="math/tex">1</script>所在方格开始；</li><li>如果与它同行 / 同列 / 同对角线（两个方向）中存在未被访问过的格子，选择一数字最小的格子走过去；</li><li>否则，从未访问过的方格中选择一个数字最小的方格并走过去。花费<script type="math/tex">1</script>个代价。</li></ol><p>现在要求你构造一种填数方案，使得 Rook 式的代价严格小于 Queen 式的代价。</p><p><script type="math/tex">n\le 500</script>。</p></blockquote><p>考虑暴搜出小方格的情况。然后其他地方你构造成 Queen 和 Rook 走一样的路线。最后引导到这个小方格即可。</p><p>暴搜就随机一个<script type="math/tex">n^2</script>的排列然后 check。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/1333/e_vio.cpp">暴搜代码</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/1333/e.cpp">代码</a></p></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2020年4月9日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/Math/Rolling-Hash-and-Hack/">滚动哈希和卡哈希的数学原理</a></div><div class="prev-post"><a href="/Math/Minkowski/">闵可夫斯基和入门 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>