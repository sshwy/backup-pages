<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>后缀自动机与后缀树 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">后缀自动机与后缀树</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2020年7月23日星期四晚上6点53分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2020年7月23日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 3,770 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> <a class="directory" href="/directory/String/">字符串 </a><span class="icon smallarrow"></span> 当前文章</div><div class="post-tags"><span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Notes/">Notes</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Automaton/">Automaton</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/SAM/">SAM</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Suffix-Tree/">Suffix-Tree</a></span></div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#后缀自动机"><span class="toc-number">1.</span> <span class="toc-text">后缀自动机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性质"><span class="toc-number">2.</span> <span class="toc-text">性质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#等价类"><span class="toc-number">2.1.</span> <span class="toc-text">等价类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包含类"><span class="toc-number">2.2.</span> <span class="toc-text">包含类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fail-树"><span class="toc-number">2.3.</span> <span class="toc-text">Fail 树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板"><span class="toc-number">3.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后缀树"><span class="toc-number">4.</span> <span class="toc-text">后缀树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#理解增量构造法"><span class="toc-number">5.</span> <span class="toc-text">理解增量构造法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#后缀树与后缀自动机"><span class="toc-number">5.1.</span> <span class="toc-text">后缀树与后缀自动机</span></a></li></ol></li></ol></div><hr></div><div class="post-content"><details open><summary>摘要</summary><p>粗略地，对字符串<script type="math/tex">s</script>定义 SAM<script type="math/tex">(Q,\Sigma,\delta, q_0,F)</script>：</p><ul><li><script type="math/tex">Q</script>是状态集合：<script type="math/tex">s</script>的<strong>等价类</strong>的集合。</li><li><script type="math/tex">\Sigma</script>是字符集：<script type="math/tex">s</script>的字符集；</li><li><script type="math/tex">\delta:Q\times \Sigma \to Q</script>是转移函数：对于<script type="math/tex">q\in Q,c\in \Sigma</script>，<script type="math/tex">\delta(q,c)</script>表示在状态<script type="math/tex">q</script>的末尾添加字符<script type="math/tex">c</script>到达的状态。</li><li><script type="math/tex">q_0</script>（<script type="math/tex">q_0\in Q</script>）是初始状态：<script type="math/tex">\varnothing</script>。</li><li><script type="math/tex">F</script>（<script type="math/tex">F\subseteq Q</script>）是终止状态：<script type="math/tex">s</script>的后缀所在等价类的集合。</li></ul><p>在常见的代码实现过程中，会记录额外的信息：</p><ul><li><script type="math/tex">\theta: Q\to Q</script>，对于<script type="math/tex">q\in Q</script>，<script type="math/tex">\theta(q)</script>表示<script type="math/tex">q</script>的<strong>最近父类</strong>对应的状态。</li></ul><p>等价类代表一个<script type="math/tex">s</script>的子串集合<script type="math/tex">T</script>，使得<script type="math/tex">\forall x,y\in T</script>且<script type="math/tex">x\ne y</script>：</p><ul><li>要么<script type="math/tex">x</script>是<script type="math/tex">y</script>的后缀，要么<script type="math/tex">y</script>是<script type="math/tex">x</script>的后缀。</li><li><script type="math/tex">x</script>在<script type="math/tex">s</script>中的出现次数与<script type="math/tex">y</script>在<script type="math/tex">s</script>中的出现次数相等。</li></ul><p>设<script type="math/tex">c(T)</script>表示<script type="math/tex">x</script>（<script type="math/tex">x\in T</script>）在<script type="math/tex">s</script>中出现的次数。那么我们称<script type="math/tex">S</script>是<script type="math/tex">T</script>的父类（<script type="math/tex">T</script>包含<script type="math/tex">S</script>）当：</p><ul><li><script type="math/tex">\forall x\in S, y\in T</script>，<script type="math/tex">x</script>是<script type="math/tex">y</script>的后缀。</li><li><script type="math/tex">c(S)&gt;c(T)</script>。</li></ul><p>也就是说等价类都包含它的父类，可以类比面向对象中的类继承。</p><p>等价类<script type="math/tex">T</script>的<strong>最近父类</strong>是指它的父类<script type="math/tex">S</script>中<script type="math/tex">c(S)</script><strong>最小</strong>的那个。</p></details><h2><a id="后缀自动机" href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h2><p>后缀自动机（Suffix Automaton，SAM）是一种有限状态自动机。对于一个 SAM，其转移函数是以字符集<script type="math/tex">\Sigma</script>为转移条件，将当前状态<script type="math/tex">q</script>转移到另一状态<script type="math/tex">p</script>的函数<script type="math/tex">\delta(q,x)=p,(p,q\in Q,x\in \Sigma)</script>。</p><p>这个状态分两种：合法与不合法。说白了就是存在和不存在。如果一个字符串不被 SAM 接受，那么<script type="math/tex">\delta</script>就会转移到空指针。初始状态是根结点，也就是字符串开头。</p><h2><a id="性质" href="#性质" class="headerlink" title="性质"></a>性质</h2><p>SAM 的空间复杂度与建立的时间复杂度是<script type="math/tex">O(n)</script>的。</p><p>对<script type="math/tex">S</script>建立的后缀自动机包含<script type="math/tex">S</script>的所有子串。因为<script type="math/tex">S</script>的子串一定是其某一后缀的前缀。</p><p>不同于 AC 自动机，后缀自动机是一个 DAG。</p><p>后缀自动机中的每<strong>一个</strong>状态对应了<strong>一类</strong>子串，这一类子串长度个不相同，并且按长度排序后前一个是后一个的后缀。</p><h3><a id="等价类" href="#等价类" class="headerlink" title="等价类"></a>等价类</h3><p>我们假设这一类子串中最长的子串是<script type="math/tex">\omega</script>，那么这一类子串满足这样的关系：<script type="math/tex">\omega</script>的后缀在 S 中的出现的位置是相同的。这类字符串被称为等价类。</p><h3><a id="包含类" href="#包含类" class="headerlink" title="包含类"></a>包含类</h3><p>还有一种情况，就是 S 的某一子串<script type="math/tex">s</script>的后缀<script type="math/tex">s'</script>在 S 中出现的位置比<script type="math/tex">s</script>多，那么称<script type="math/tex">s'</script>是<script type="math/tex">s</script>的包含类。为什么包含？因为<script type="math/tex">s</script>出现的位置<script type="math/tex">s'</script>一定出现，而<script type="math/tex">s'</script>出现的位置<script type="math/tex">s</script>不一定出现。</p><h3><a id="Fail-树" href="#Fail-树" class="headerlink" title="Fail 树"></a>Fail 树</h3><p>SAM 除了构建自动机还会构建一个 fail 树，fail 树中，当前状态的父结点总是它的包含类，即它的某个后缀形成的等价类。结合等价类和包含类，使得 SAM 的空间复杂度降到了线性级别。</p><p>也可以说，fail 指针指向它的最长的出现次数比它多的后缀。</p><h2><a id="模板" href="#模板" class="headerlink" title="模板"></a>模板</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> SZ<span class="token operator">=</span><span class="token number">2e6</span><span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">,</span>ALP<span class="token operator">=</span><span class="token number">26</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">SAM</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> tot<span class="token punctuation">,</span>last<span class="token punctuation">;</span>
    <span class="token keyword">int</span> tr<span class="token punctuation">[</span>SZ<span class="token punctuation">]</span><span class="token punctuation">[</span>ALP<span class="token punctuation">]</span><span class="token punctuation">,</span>len<span class="token punctuation">[</span>SZ<span class="token punctuation">]</span><span class="token punctuation">,</span>fail<span class="token punctuation">[</span>SZ<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">SAM</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>tot<span class="token operator">=</span>last<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 初始化</span>
    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> u<span class="token operator">=</span><span class="token operator">++</span>tot<span class="token punctuation">,</span>p<span class="token operator">=</span>last<span class="token punctuation">;</span><span class="token comment">// 新建结点，p 是在 fail 上跳指针用的</span>
        len<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span>len<span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>last<span class="token operator">=</span>u<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span>tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>u<span class="token punctuation">,</span>p<span class="token operator">=</span>fail<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 更新 last 在 fail 树上的祖先的转移函数</span>
        <span class="token comment">// 接下来，我们求新建结点 u 的 fail 指针，同时会更新 fail 树</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>fail<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 跳到根结点的 fail</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> q<span class="token operator">=</span>tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token operator">==</span>len<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>fail<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span>q<span class="token punctuation">;</span>
            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
                <span class="token comment">// 如果不是 0，说明结点 p 在之前就存在字符 x 的转移函数</span>
                <span class="token comment">// 那么就考虑这个转移到达的状态是否是等价类</span>
                <span class="token comment">// 如果是等价类，那么 fail 就指向 q；</span>
                <span class="token comment">// 否则就要从中分离出一个包含类，然后指向这个结点</span>
                <span class="token keyword">int</span> cq<span class="token operator">=</span><span class="token operator">++</span>tot<span class="token punctuation">;</span>
                len<span class="token punctuation">[</span>cq<span class="token punctuation">]</span><span class="token operator">=</span>len<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>fail<span class="token punctuation">[</span>cq<span class="token punctuation">]</span><span class="token operator">=</span>fail<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token function">memcpy</span><span class="token punctuation">(</span>tr<span class="token punctuation">[</span>cq<span class="token punctuation">]</span><span class="token punctuation">,</span>tr<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>tr<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                fail<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span>fail<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token operator">=</span>cq<span class="token punctuation">;</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span>tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span>q<span class="token punctuation">)</span>tr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>cq<span class="token punctuation">,</span>p<span class="token operator">=</span>fail<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><a id="后缀树" href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h2><p>首先我们了解一下后缀树的概念。最基本的后缀树就是把一个串<script type="math/tex">S</script>的所有后缀建一个 Trie。以 <code class="inline-code">ababb</code> 为例：</p><p><img src="../../images/suffix_tree6.png"></p><p>绿色的点表示接受状态的结点（即后缀的末尾）。我们将除了二度点以外的标记为关键点（因为这些点可以刻画这棵树的大致结构），如<strong>图 2</strong>。</p><p>灰色结点为关键点，并且我们认为接受状态的结点是关键点（尽管它有可能是二度点）。这个后缀树的简化后缀树相当于关键点构成的树，如<strong>图 3</strong>。</p><p>蓝色边构成的树即为简化后缀树。</p><h2><a id="理解增量构造法" href="#理解增量构造法" class="headerlink" title="理解增量构造法"></a>理解增量构造法</h2><h3><a id="后缀树与后缀自动机" href="#后缀树与后缀自动机" class="headerlink" title="后缀树与后缀自动机"></a>后缀树与后缀自动机</h3><p>一个串的 SAM 的 Fail 树是其反串的简化后缀树，反串简化后缀树的结点与 SAM 的结点一一对应。</p><p>反串后缀树上结点的深度就对应 SAM 上该状态（结点）的长度。</p><p>例如我们对 <code class="inline-code">bbaba</code> 建立后缀自动机：</p><p><img src="../../images/sam.png" alt="sam"></p><p>可以发现，红树和上文的蓝树是一样的！</p><p>那么为什么是这样的呢？我们感性理解一下。前文所述的 SAM 可以理解为最简状态的 SAM，它将重复的状态合并。而我们把反串的后缀树取一个最简后缀树，其实就是在做类似的事情。</p><p>事实上，反串后缀树上的一条从根挂下来的路径对应原串的一个后缀，它到达的状态就是这个路径往下走遇到的第一个关键点！</p><p>比如在后缀树的图中的 <code class="inline-code">aba</code>，<code class="inline-code">abab</code>，<code class="inline-code">ababb</code>，对应原串的 <code class="inline-code">aba</code>，<code class="inline-code">baba</code>，<code class="inline-code">bbaba</code>，把他们在 SAM 上跑一遍，都会跑到<script type="math/tex">6</script>结点去。即结点<script type="math/tex">6</script>在 SAM 上接受的状态是 <code class="inline-code">aba</code>，<code class="inline-code">baba</code>，<code class="inline-code">bbaba</code>。</p><p>这样，对 SAM 的操作就可以与对后缀树的操作形成对应。</p><p>类似地，可以将 SAM 的转移边对应到简化后缀树上。转移边相当于在后面添加一个字符，则在反串简化后缀树上就是在开头加一个字符，然后转移到对应状态的结点。</p><p>SAM 的构造方法是一个增量构造法。我们可以通过反串简化后缀树来理解它。</p><p>例如在 <code class="inline-code">bbaba</code> 的后面添加一个字符 <code class="inline-code">b</code>。则相当于在反串开头添加一个 <code class="inline-code">b</code>，那么我们相当于把 <code class="inline-code">bababb</code> 插入到简化后缀树上，完成的效果是这样的：</p><p><img src="../../images/suffix_tree5.png" alt="suffix_tree4"></p><p>但是你无法像 Trie 一样直接插入，因为你维护 SAM 的时候是没有这么多信息的，你只知道简化后缀树的信息，即关键点。因此我们尝试用 SAM 的操作来完成这个过程。</p><p>要在增量构造 SAM 的同时增量构造反串的简化后缀树，首先考虑增加一个字符带来的影响。</p><p>设<script type="math/tex">q_s</script>表示 SAM 中<script type="math/tex">s</script>所在的等价类，即所有等价类的子类。在末尾添加一个字符<script type="math/tex">c</script>，相当于新建一个状态<script type="math/tex">q_1</script>，并给<script type="math/tex">q_s</script>增加<script type="math/tex">\delta(q_1,c)=q_1</script>的转移。同时，可能有<script type="math/tex">q_s</script>的一些父类<script type="math/tex">q'</script>也能转移到<script type="math/tex">q_1</script>，因此也一并加上。</p><p>接下来我们就要确认<script type="math/tex">q_1</script>的最近父类，设其为<script type="math/tex">q_1'</script>。</p><ul><li>首先，如果<script type="math/tex">q_s</script>的父类中不存在通过<script type="math/tex">c</script>转移得到的状态，说明这个<script type="math/tex">c</script>是一个新的字符。那么<script type="math/tex">q_1</script>的父类就是<script type="math/tex">q_0</script>（<script type="math/tex">\varnothing</script>）。</li><li>否则，可以判断，<script type="math/tex">q_1'</script>一定是由<script type="math/tex">q_s</script>的某个父类<script type="math/tex">q'</script>“分裂”之后，再在其中的每个字符串末位加上<script type="math/tex">c</script>得到的。<script type="math/tex">q'</script>分裂的原因是，在末尾加入了<script type="math/tex">c</script>之后，<script type="math/tex">q'</script>中的某些字符串的出现次数发生了变化，而某些又保存不变。</li></ul><p>还有一件事情。在第一步的过程中我们把<script type="math/tex">q_s</script>以及<script type="math/tex">q_s</script>的父类对字符<script type="math/tex">c</script>建立了向<script type="math/tex">q_1</script>的转移。而如果遇到<script type="math/tex">\delta(q',c)</script>本身存在的情况，意味着我们找到了用于构造<script type="math/tex">q_1</script>父类的等价类。这时我们会直接进行第二步的过程。第二步的过程会给<script type="math/tex">\delta(q',c)</script>中途插入一个分裂出的父类<script type="math/tex">q_x</script>。因此所有的，关于字符<script type="math/tex">c</script>的，原本指向<script type="math/tex">\delta(q',c)</script>的转移，都得改为指向<script type="math/tex">q_x</script>。因此我们要把<script type="math/tex">q'</script>的父类都做更新。</p><p>这样就完成了增量的过程。</p><details><summary>一个具体示例</summary><p><strong>第一部分</strong></p><p>首先，SAM 的<script type="math/tex">last</script>指针指向结点<script type="math/tex">6</script>。反串后缀树上结点<script type="math/tex">6</script>对应路径表示的就是它接收的最长的那个状态（SAM 上的结点<script type="math/tex">6</script>接受<code class="inline-code">aba</code>，<code class="inline-code">baba</code>，<code class="inline-code">bbaba</code>三个状态，而<code class="inline-code">bbaba</code>是最长的，对于反串后缀树上的路径是 <code class="inline-code">ababb</code>）。</p><p>而你在这个状态开头添加一个 <code class="inline-code">b</code>，相当于在 SAM 上通过转移边（<script type="math/tex">tr(u, b)</script>）跳转到对应状态。而<script type="math/tex">tr(6,b)</script>是没有的，因此我们要跳到<script type="math/tex">6</script>在简化后缀树上的父节点。因为这个父节点的状态是<script type="math/tex">6</script>的状态的后缀（别忘了是反串），而跳父节点就相当于是 SAM 上跳<script type="math/tex">fail</script>指针。</p><p>于是我们这样不断跳<script type="math/tex">fail</script>指针直到有一个结点的<script type="math/tex">tr(u,b)</script>存在，在这个例子中，3 结点存在。则我们转移到<script type="math/tex">tr(3,b)=13</script>，在简化后缀树中 13 包含了<script type="math/tex">12</script>的状态（12 的状态即为<code class="inline-code">bab</code>，指反串）。</p><p>现在相当于，我们要把<script type="math/tex">12</script>插入到简化后缀树中，然后从<script type="math/tex">12</script>分叉，连出去一条链把剩下的状态补齐（即<code class="inline-code">bababb</code>-<code class="inline-code">bab</code>=<code class="inline-code">abb</code>）。</p><p>把<script type="math/tex">12</script>加入到简化后缀树，则需要更新<script type="math/tex">13,12</script>的简化后缀树上的父节点指针（对应 SAM 的 fail 指针）。</p><p>然后从<script type="math/tex">12</script>连出去一条链，在简化后缀树上就是一条边（可以理解边权为 <code class="inline-code">abb</code>），然后连出这个新的结点也要更新它的简化后缀树上的父节点指针（SAM 上 fail 指针）。</p><p><strong>第二部分</strong></p><p>最后有一件简化后缀树考虑不完全的事情，就是对转移函数的更新（<script type="math/tex">tr(u,c)</script>）。因为转移函数并不能直观地在反串简化后缀树上表现。但我们仍可以这么理解。</p><p>重新回到一开始。在我们不断跳 fail 寻找<script type="math/tex">tr(u,b)</script>是否存在的时候，如果这个结点不存在<script type="math/tex">tr(u,b)</script>，可以将它事先指向我们新建的代表<script type="math/tex">bababb</script>（原串状态为<code class="inline-code">bbabab</code>）的结点。事实上你也应该这么做，这样才能保证转移函数的完整性。</p><p><strong>第三部分</strong></p><p>由于<script type="math/tex">3</script>结点本来转移到<script type="math/tex">13</script>（<script type="math/tex">tr(3,b)=13</script>），现在我们加了一个结点<script type="math/tex">12</script>，那么自然<script type="math/tex">tr(3,b)=12</script>（其实<script type="math/tex">3</script>结点本来就转移到<script type="math/tex">12</script>，但是在之前的 SAM 中<script type="math/tex">12</script>状态是被归在<script type="math/tex">13</script>结点上的。现在相当于我们把<script type="math/tex">12</script>这个状态分离出来）。既然<script type="math/tex">tr(3,b)</script>是存在的，而<script type="math/tex">3</script>在简化后缀树上的祖先结点状态又是它的后缀状态，因此也存在字符 <code class="inline-code">b</code> 的转移边，那么显然要一并改成<script type="math/tex">12</script>。于是我们就需要在<script type="math/tex">3</script>的基础上不断跳<script type="math/tex">fail</script>并更新字符<code class="inline-code">b</code>的转移函数。</p></details></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2020年7月23日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/WQS-Binary-Search/">WQS 二分学习笔记</a></div><div class="prev-post"><a href="/Codeforces/Polygon-advice-chinese-ver/">Polygon Advices (Chinese version) </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>