<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>Banknote Collection 命题报告 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">Banknote Collection 命题报告</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2021年2月4日星期四上午9点57分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2021年2月4日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 3,923 字 </span><span class="icon infosep"></span><span class="post-info-item post-recommend"> <span class="info-icon iconfont icon-favorite"></span>推荐文章</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> 当前文章</div><div class="post-tags"><span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Original/">Original</a></span></div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目大意"><span class="toc-number">1.</span> <span class="toc-text">题目大意</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从左到右"><span class="toc-number">2.</span> <span class="toc-text">从左到右</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三折"><span class="toc-number">3.</span> <span class="toc-text">三折</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Easy-Version"><span class="toc-number">4.</span> <span class="toc-text">Easy Version</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一部分"><span class="toc-number">4.1.</span> <span class="toc-text">第一部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二部分"><span class="toc-number">4.2.</span> <span class="toc-text">第二部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法描述"><span class="toc-number">4.3.</span> <span class="toc-text">算法描述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hard-Version"><span class="toc-number">5.</span> <span class="toc-text">Hard Version</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一部分-1"><span class="toc-number">5.1.</span> <span class="toc-text">第一部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二部分-1"><span class="toc-number">5.2.</span> <span class="toc-text">第二部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法描述-1"><span class="toc-number">5.3.</span> <span class="toc-text">算法描述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据"><span class="toc-number">6.</span> <span class="toc-text">数据</span></a></li></ol></div><hr></div><div class="post-content"><p>本来是没有打算写命题报告的。不过在讨论的过程中发现，这题似乎的确有一定的难度。于是就有了本文。</p><h2><a id="题目大意" href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1394/problem/E">题目链接</a></p><p>给出一个长度为<script type="math/tex">n</script>的正整数序列<script type="math/tex">a</script>。我们可以<strong>折叠</strong>序列<script type="math/tex">a</script>。例如<script type="math/tex">[3,4,4,3,2,2,3,4,1,3,1,1]</script>可以折叠为</p><pre class="line-numbers language-none"><code class="language-none">   3-4╮
╭2-3-4╯
╰2-3-4-1-3-1╮
           1╯<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>它可以被折叠<script type="math/tex">3</script>次。再举一个例子，<script type="math/tex">[1,1,1,1,1,1]</script>可以被折叠<script type="math/tex">5</script>次：</p><pre class="line-numbers language-none"><code class="language-none"> 1╮
╭1╯
╰1╮
╭1╯
╰1╮
 1╯<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>形式化地，我们定义<script type="math/tex">a</script>的一个<strong>折叠序列</strong>是长度为<script type="math/tex">n</script>的整数序列<script type="math/tex">b</script>满足：</p><ol><li><script type="math/tex">b</script>仅由<script type="math/tex">1</script>和<script type="math/tex">-1</script>构成，且<script type="math/tex">b_1=1</script>；</li><li>设<script type="math/tex">p(i)=[b_i=1]+\sum_{j=1}^{i-1}b_j</script>。则对于任意<script type="math/tex">1\le i&lt;j\le n</script>且<script type="math/tex">p(i)=p(j)</script>，必满足<script type="math/tex">a_i=a_j</script>。</li></ol><p>显然，可能有多个不同的<script type="math/tex">b</script>都满足<script type="math/tex">a</script>的折叠序列条件。</p><p>定义折叠序列<script type="math/tex">b</script>的折叠次数为<script type="math/tex">f(b)=\sum_{i=1}^{n-1}[b_i\ne b_{i+1}]</script>。那么<script type="math/tex">a</script>的<strong>最大折叠次数</strong>定义为所有合法的折叠序列<script type="math/tex">b</script>中<script type="math/tex">f(b)</script>的最大值。</p><p>现在 Boboniu 正操纵着一个序列<script type="math/tex">a</script>。初始时<script type="math/tex">a</script>长度为<script type="math/tex">0</script>。他会执行<script type="math/tex">n</script>次操作，每次他会在<script type="math/tex">a</script>末尾加入一个元素。他想知道每次插入元素后，<script type="math/tex">a</script>的最大折叠次数。</p><p><script type="math/tex">1\le n\le 10^5,1\le a_i\le n</script>。</p><h2><a id="从左到右" href="#从左到右" class="headerlink" title="从左到右"></a>从左到右</h2><p>在讨论算法的过程中，我们把序列理解为一个字符集较大的字符串。这样解释起来方便一些。</p><p>另外，本文中所有的<strong>回文</strong>，一般情况都指<strong>偶回文</strong>。</p><p>在开始讨论关于此题的算法之前，我想讲述关于<strong>折叠</strong>操作的一些直观理解。大家可以想象，你拿着一张纸条做各种各样的折叠。比如对折再对折：</p><p><img src="../images/banknote-proposition-report-1.png" alt=""></p><p>但是其实这种折叠方式（在本题中），等价于你做一个 Z 字型（或者说 M 字型）的折叠：</p><p><img src="../images/banknote-proposition-report-2.png" alt=""></p><p>因为在本题中的折叠次数，实际上指的是<strong>折痕的数量</strong>。而两种折叠方式的折痕数量是一样的。</p><p>考虑一个更具体的例子：<script type="math/tex">a=[1,2,2,2,2,1,1,2,2]</script>。我们分别按照以下两种方式折叠：</p><p><img src="../images/banknote-proposition-report-3.png" alt=""></p><p>（红色表示折叠的位置）</p><p>实际上，两种折叠方式折出来是等价的。你把第二种折叠方式的外面那个圈收到里面来，就变成了第一种折叠方式：</p><p><img src="../images/banknote-proposition-report-4.png" alt=""></p><p>观察第一种折叠方式，它始终呈 Z 型折叠，并且它是按照<strong>从左到右</strong>的顺序依次折过来的。也就是说我们得到了两个关键信息：</p><p><strong>Key point 1</strong>：任意一种折叠方案，都可以通过改变圈的位置，变成 Z 型折叠。</p><p><strong>Key point 2</strong>：任意一种折叠方案，只要折到了不能继续折下去的程度，那么得到的折痕数量是始终相等的。</p><p>也就是说我们把原本的任意折叠，归约成了从左到右依次折叠。</p><p>从左到右依次折叠还有一个好处：每次都只折了一层纸。如果随意折叠，就可能会出现折多层纸的情况，这时的折叠次数就要多次计算。比如在上述例子中，第二种折叠方式的第二次折叠就一次折了 3 层纸，因此折痕数量加 3。也就是说，如果我们从左到右折叠，那么只用考虑折叠的次数，不用考虑每次折叠的层数。</p><p>这部分希望大家自己动手折叠一下，先理解直观的感受。</p><p>接下来，我们就按照<strong>从左到右</strong>的顺序讨论关于本题的算法。</p><h2><a id="三折" href="#三折" class="headerlink" title="三折"></a>三折</h2><p>考虑<script type="math/tex">[\cdots,1,2,2,2,3,\dots]</script>中的三个<script type="math/tex">2</script>。我们一定会把他们折成一个<script type="math/tex">2</script>（<script type="math/tex">2</script>次折叠，Z 型）。假设你不折，那么最终的方案里一定含有<script type="math/tex">[2,2,2]</script>的子串。于是你就可以再折<script type="math/tex">2</script>次来获得更多折痕。</p><p>推广之，考虑三个连续的字符串<script type="math/tex">XYX</script>，其中<script type="math/tex">Y</script>是<script type="math/tex">X</script>的反串。那么我们可以贪心地把它们折成一个<script type="math/tex">X</script>：</p><p><img src="../images/banknote-proposition-report-5.png" alt="p1"></p><p>我们称形如<script type="math/tex">XYX</script>（其中<script type="math/tex">Y</script>是<script type="math/tex">X</script>的反串）的字符串为三折。</p><p>另外，我们定义<strong>最简三折</strong>为一个形如<script type="math/tex">XYX</script>的字符串，满足它不存在三折<strong>真</strong>子串。</p><p>根据 <strong>Key point 2</strong>，我们有一个大致的思路：先把所有能折的三折给折了，剩下一个没有三折的串，再来折这个串。具体地，我们分为两个部分：</p><ol><li>考虑字符串<script type="math/tex">b</script>，初始时为空串。我们执行<script type="math/tex">n</script>次操作，每次在<script type="math/tex">b</script>末尾插入<script type="math/tex">a_i</script>，然后检查<script type="math/tex">b</script>是否产生了新的三折，有就折，没有就不折。</li><li>对于一个没有三折的串<script type="math/tex">b</script>，我们要求出它还能被折多少次。</li></ol><p>那么我们只需要在每次做第一步后做第二步，就可以求出每次操作完之后的答案了。</p><h2><a id="Easy-Version" href="#Easy-Version" class="headerlink" title="Easy Version"></a>Easy Version</h2><h3><a id="第一部分" href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p>设<script type="math/tex">b</script>末位插入<script type="math/tex">a_i</script>后变成了<script type="math/tex">b'</script>。</p><p>首先我们证明一个引理，这在之后的复杂度证明中都会发挥作用。</p><p><strong>Lemma 1</strong>：对于一个串<script type="math/tex">S</script>的两个<strong>偶回文</strong>子串<script type="math/tex">S[l_1,r_1]</script>，<script type="math/tex">S[l_2,r_2]</script>，如果<script type="math/tex">[l_1,r_1]</script>包含<script type="math/tex">S[l_2,r_2]</script>的中心且<script type="math/tex">[l_2,r_2]</script>包含<script type="math/tex">S[l_1,r_1]</script>的中心，那么<script type="math/tex">S</script>一定包含三折子串。</p><details><summary>证明</summary><p>不妨设<script type="math/tex">l_1&lt;l_2</script>，<script type="math/tex">|r_1-l_1|\ge |r_2-l_2|</script>。那么通过简单的构造可以发现：</p><p><img src="../images/banknote-proposition-report-7.png" alt="p1"></p><p>这样就产生了三折。证毕。</p></details><p><strong>Key point 3</strong>：<script type="math/tex">b'</script>至多有一个三折。</p><details><summary>证明</summary><p>证明：考虑反证法。</p><p>首先，<script type="math/tex">b'</script>的三折一定是它的后缀，因为<script type="math/tex">b</script>没有三折。</p><p>那么如果<script type="math/tex">b'</script>产生了多个三折后缀，有三种情况：</p><p><img src="../images/banknote-proposition-report-6.png" alt="p1"></p><p>黑和红：这种情况很容易反证。在第一个<script type="math/tex">X</script>里也会出现一个三折，那么<script type="math/tex">b</script>中就含有三折了，矛盾。</p><p>黑和蓝、黑和绿：可以发现，蓝色的<script type="math/tex">XY</script>和黑色的<script type="math/tex">YX</script>形成了 <strong>Lemma 1</strong> 的情况，绿色的<script type="math/tex">XY</script>和黑色的<script type="math/tex">XY</script>也形成了 <strong>Lemma 1</strong> 的情况。因此<script type="math/tex">b</script>中含有三折，矛盾。</p><p>证毕。</p></details><p>由 <strong>Key point 3</strong> 我们还可以发现，这个三折一定是最简三折。</p><p>因此我们使用一些算法找到这个三折后，把它折叠。折叠的过程就是删掉<script type="math/tex">b'</script>的一个偶回文后缀。如果找不到三折，就不变。</p><h3><a id="第二部分" href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p>对于一个没有三折的串<script type="math/tex">b</script>，我们要求出它还能被折多少次。</p><p>没有三折，我们就只能对折——也就是把一个偶回文前缀或者偶回文后缀折叠。</p><p>考虑贪心，以偶回文后缀为例，我们每次折叠最短的偶回文后缀。那么每次折叠的后缀长度一定是<strong>严格递增</strong>的：</p><p><img src="../images/banknote-proposition-report-8.png" alt="p1"></p><p>因为如果不递增，那么就会出现 <strong>Lemma 1</strong> 的情况，导致出现三折，矛盾。</p><p>因此<script type="math/tex">b</script>折叠出来的应该大致是这个样子：</p><p><img src="../images/banknote-proposition-report-9.png" alt="p1"></p><p><strong>Key point 4</strong>：对于没有三折的串<script type="math/tex">b</script>，最多被折叠<script type="math/tex">O(\sqrt{b})</script>次。</p><ul><li>对于偶回文后缀的折叠 ：设<script type="math/tex">p_i</script>表示<script type="math/tex">b[1,i]</script>的最短偶回文后缀。</li><li>对于偶回文前缀的折叠：设<script type="math/tex">q_i</script>表示，在<script type="math/tex">b[1,i]</script>串上从开头开始折叠，每次折叠最短偶回文前缀，最多能折叠到什么位置。设<script type="math/tex">c_i</script>表示前缀的折叠次数。</li></ul><h3><a id="算法描述" href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>我们使用 hash 来处理两个部分。</p><p>找三折：对于每个后缀判断是否是偶回文后缀，如果是，就判断是否构成三折。时间复杂度<script type="math/tex">O(n)</script>的。</p><p>当<script type="math/tex">b</script>变成<script type="math/tex">b'</script>时：</p><ul><li>如果没有出现三折，那么我们就<script type="math/tex">O(n)</script>求出<script type="math/tex">p_{|b'|}</script>，然后<script type="math/tex">O(1)</script>地求出<script type="math/tex">q_{|b'|},c_{|b'|}</script>（基于<script type="math/tex">q_{|b|},c_{|b|}</script>）。然后我们可以<script type="math/tex">O(1)</script>更新字符串的 hash。</li><li>否则我们要删除<script type="math/tex">b'</script>的后缀，那么我们直接舍弃那部分的后缀对应的<script type="math/tex">p,q,c</script>和 hash 值即可，时间复杂度<script type="math/tex">O(1)</script>。</li></ul><p>回答询问：我们可以<script type="math/tex">O(1)</script>查询<script type="math/tex">c_i</script>，<script type="math/tex">O(\sqrt{n})</script>查询<script type="math/tex">p_i</script>来回答询问。</p><p>总时间复杂度<script type="math/tex">O(n^2)</script>。</p><h2><a id="Hard-Version" href="#Hard-Version" class="headerlink" title="Hard Version"></a>Hard Version</h2><p>为了让获得更快的算法，我们需要挖掘更多有关三折的性质。</p><h3><a id="第一部分-1" href="#第一部分-1" class="headerlink" title="第一部分"></a>第一部分</h3><p>我们需要优化找三折的复杂度。</p><p><strong>Key point 5</strong>：最简三折只有<strong>一个</strong>偶回文后缀（就是<script type="math/tex">XYX</script>的<script type="math/tex">YX</script>）。</p><p>这个同样可以反证，并结合 <strong>Lemma 1</strong> 导出矛盾。</p><p>根据 <strong>Key point 3</strong>，我们发现，<script type="math/tex">b'</script>的三折一定由它的最短偶回文后缀产生。因此我们只需要快速找到<script type="math/tex">b'</script>的最短偶回文后缀，然后看它是否构成三折即可。</p><p><strong>Key point 6</strong>：<script type="math/tex">b'</script>的偶回文后缀数量是<script type="math/tex">O(\log_2n)</script>的。</p><p>因为<script type="math/tex">b'</script>的偶回文后缀不能出现 <strong>引理 1</strong> 的情况，所以必须是一个包含另一个，且不跨过中心。那么偶回文后缀的长度每次至少倍增：</p><p><img src="../images/banknote-proposition-report-10.png" alt="p1"></p><p>设<script type="math/tex">v_i</script>表示<script type="math/tex">b[1,i]</script>的偶回文后缀的集合。由于<script type="math/tex">v_i</script>的大小是<script type="math/tex">O(\log_2n)</script>的，因此可以使用 vector 维护。于是</p><ul><li>找最短回文后缀的复杂度就是<script type="math/tex">O(\log_2n)</script>的。</li><li>判断一个串是否是三折，可以转化为判断一个子串是否是回文串，同样可以<script type="math/tex">O(\log_2n)</script>判断。</li><li>在<script type="math/tex">b</script>末尾插入<script type="math/tex">a_i</script>的时候，可以枚举<script type="math/tex">v_{|b|}</script>的偶回文后缀，求出<script type="math/tex">v_{|b'|}</script>，时间复杂度<script type="math/tex">O(\log_2n)</script>。</li></ul><p>如果找到了一个三折，就删掉<script type="math/tex">b'</script>的一个偶回文后缀。</p><p>这样，找三折以及更新<script type="math/tex">b</script>的复杂度就优化为了<script type="math/tex">O(n\log_2n)</script>。</p><h3><a id="第二部分-1" href="#第二部分-1" class="headerlink" title="第二部分"></a>第二部分</h3><p>沿用 easy version 的算法，单次询问的复杂度仍是<script type="math/tex">O(\sqrt{n})</script>，可以通过本题。</p><h3><a id="算法描述-1" href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>找三折：在<script type="math/tex">v_i</script>中查询最小值，时间复杂度<script type="math/tex">O(\log_2n)</script>。</p><p>当<script type="math/tex">b</script>变成<script type="math/tex">b'</script>时：</p><ul><li>如果没有出现三折，那么我们就<script type="math/tex">O(\log_2n)</script>求出<script type="math/tex">p_{|b'|}</script>，然后<script type="math/tex">O(1)</script>地求出<script type="math/tex">q_{|b'|},c_{|b'|}</script>（基于<script type="math/tex">q_{|b|},c_{|b|}</script>）。然后我们可以<script type="math/tex">O(\log_2n)</script>利用<script type="math/tex">v_{|b|}</script>求出<script type="math/tex">v_{|b'|}</script>。</li><li>否则，我们要删除<script type="math/tex">b'</script>的后缀，直接舍弃对应变量即可。时间复杂度<script type="math/tex">O(1)</script>。</li></ul><p>回答询问：我们可以<script type="math/tex">O(1)</script>查询<script type="math/tex">c_i</script>，<script type="math/tex">O(\sqrt{n})</script>查询<script type="math/tex">p_i</script>来回答询问。</p><p>总时间复杂度<script type="math/tex">O(n(\log_2n+\sqrt{n}))</script>。</p><h2><a id="数据" href="#数据" class="headerlink" title="数据"></a>数据</h2><p>首先肯定有随机数据，然后还要有一些 corner 的情况，还有<script type="math/tex">O(n\sqrt{n})</script>的没有三折数据。</p><p>验题的时候，丁神在比赛开始前一晚，写了一个暴搜剪枝过了。当时把我吓傻了，然后就赶紧研究了一下，hack 掉了这个暴搜。生成器长这样：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cur <span class="token operator">=</span> <span class="token number">3</span>
a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    b <span class="token operator">=</span> a<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
    a<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token comment"># new fuck</span>
    cur <span class="token operator">+=</span> <span class="token number">1</span>
    a<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>
    a<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment"># link</span>
    a<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token comment"># fuck</span>
    a<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
a<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> x <span class="token keyword">in</span> a<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'&#123;&#125; '</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2021年2月4日 第2次修订</li><li class="post-history-item">2020年8月23日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/Graph/Tri-Four-Cycle/">三元环与四元环计数</a></div><div class="prev-post"><a href="/Math/Linear-Algbra/Matrix-Tree/">矩阵树定理学习笔记 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>