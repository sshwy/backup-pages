<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>偏序结构第 K 小问题算法小结 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">偏序结构第 K 小问题算法小结</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2021年7月14日星期三下午2点51分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2021年7月14日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 2,840 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> 当前文章</div><div class="post-tags"><span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Notes/">Notes</a></span></div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#【例题】子集第-K-小问题"><span class="toc-number">2.</span> <span class="toc-text">【例题】子集第 K 小问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法一"><span class="toc-number">2.1.</span> <span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法二"><span class="toc-number">2.2.</span> <span class="toc-text">方法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法三"><span class="toc-number">2.3.</span> <span class="toc-text">方法三</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-number">2.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#【例题】-扩域版第-K-小问题"><span class="toc-number">3.</span> <span class="toc-text">【例题】 扩域版第 K 小问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#传统算法能否给劲"><span class="toc-number">4.</span> <span class="toc-text">传统算法能否给劲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#【另解】（扩域）子集第-K-小问题"><span class="toc-number">5.</span> <span class="toc-text">【另解】（扩域）子集第 K 小问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#【应用】树上第-K-小连通块"><span class="toc-number">6.</span> <span class="toc-text">【应用】树上第 K 小连通块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#【应用】购物计划"><span class="toc-number">7.</span> <span class="toc-text">【应用】购物计划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#子问题"><span class="toc-number">7.1.</span> <span class="toc-text">子问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原问题"><span class="toc-number">7.2.</span> <span class="toc-text">原问题</span></a></li></ol></li></ol></div><hr></div><div class="post-content"><p>本文绝大部分参考 <a target="_blank" rel="noopener" href="https://naitir.gitee.io/2021/04/25/trick/">Naitir - 「技巧总结」第k小和贪心问题</a>，是在此基础上的解说。</p><p>符号约定：<script type="math/tex">[n]</script>表示集合<script type="math/tex">\{1, 2, \ldots, n\}</script>。</p><h2><a id="前言" href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第 k 小（大）的问题定义在全序集合上，相关算法不胜枚举。常用的方法有二分转化为计数问题解决、数据结构直接维护、离线后整体二分等等。</p><p>大部分方法都建立在所求答案结构相对简单，亦或是全序结构比较特殊，容易计数的前提下。然对于一类全序结构无特殊性质，只可知前驱后继，甚至连前驱后继都难以判断，只能断言比之优劣的结构，上述算法将难以有效。这也是本文的算法解决的问题。</p><p>为了方便大家理解，我们以一个例题引入。</p><h2><a id="【例题】子集第-K-小问题" href="#【例题】子集第-K-小问题" class="headerlink" title="【例题】子集第 K 小问题"></a>【例题】子集第 K 小问题</h2><blockquote><p>有一个长度为<script type="math/tex">n</script>的<strong>正整数</strong>序列<script type="math/tex">a_1, \ldots, a_n</script>。对于一个<script type="math/tex">[n]</script>的子集<script type="math/tex">T</script>，记<script type="math/tex">f(T) = \sum_{i \in T} a_i</script>表示一个子序列的价值。对于所有<script type="math/tex">2^n</script>个子序列的价值，求其中的第<script type="math/tex">k</script>小值，并输出方案。</p><p><script type="math/tex">n, x, k\le 10^6</script>。</p></blockquote><p>本题的特点是：全序结构规模过大（<script type="math/tex">O(2^n)</script>），并且结构没有特殊性质，难以计算一个方案的前驱后继。</p><p>但是对于子集<script type="math/tex">T \subseteq S</script>，我们可以容易地判断<strong>某些</strong>方案一定是比它大的。例如对于<script type="math/tex">e \notin T</script>，一定有<script type="math/tex">f(T\cup \{e\}) &gt; f(T)</script>。换言之对于一些与<script type="math/tex">T</script>相关的方案我们可以断言它们与<script type="math/tex">T</script>的大小关系。</p><p>分析出这些信息后，容易想到维护一个小根堆。初始时将空集加入堆。每次取出堆顶的集合，记作<script type="math/tex">T</script>。并将【一部分与<script type="math/tex">T</script>相关的比<script type="math/tex">T</script>大】的集合都加入堆中。这样做<script type="math/tex">k</script>次操作后得到的就是第<script type="math/tex">k</script>小的方案。</p><p>问题转化为：【一部分与<script type="math/tex">T</script>相关的比<script type="math/tex">T</script>大】的集合究竟是哪些集合？</p><p>为了方便叙述，我们称【一部分与<script type="math/tex">T</script>相关的比<script type="math/tex">T</script>大】为<strong>被<script type="math/tex">T</script>拉入堆中</strong>。称<script type="math/tex">T</script>是它们的<strong>引子</strong>。它们是<script type="math/tex">T</script>的<strong>继子</strong>。</p><h3><a id="方法一" href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>对于所有<script type="math/tex">e\notin T</script>，将<script type="math/tex">T\cup \{e\}</script>加入堆中。</p><p>这个方法显然不具备正确性，因为一个集合具有多个引子，会出现重复加入的情况。</p><h3><a id="方法二" href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>只在子序列末尾加入，即对于<script type="math/tex">T</script>中的最大值<script type="math/tex">i_{\max}</script>（对于空集，<script type="math/tex">i_{\max} = 0</script>），考虑所有<script type="math/tex">i_{\max} &lt; e \le n</script>，将<script type="math/tex">T\cup \{e\}</script>加入堆中。</p><p>这个方法具备正确性，因为每个非空集合<strong>有且仅有</strong>一个引子。</p><p>而这个方法的时间复杂度是<script type="math/tex">O(nk\log (nk))</script>，空间复杂度<script type="math/tex">O(nk)</script>。因为一个集合有<script type="math/tex">O(n)</script>个继子。</p><details open><summary>详细的正确性说明</summary><p>每个集合有且仅有一个引子，说明每个集合一定会在某个时刻被拉入堆中。</p><p>而根据小根堆的性质，对于一个集合<script type="math/tex">T</script>，只有比他小的集合都被取出过堆顶后，它才会被取出。</p><p>因此第<script type="math/tex">k</script>次取出的堆顶一定是第<script type="math/tex">k</script>小的方案。</p><p>换言之，【非初始集合具有唯一引子】的方法都是正确的算法。</p></details><h3><a id="方法三" href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>方法二的主要缺陷是继子过多，导致时空复杂度过大。换言之我们需要找到一个引子唯一，继子<script type="math/tex">O(1)</script>的偏序结构。</p><p>考虑将<script type="math/tex">a</script>从小到大排序。</p><p>那么对于集合<script type="math/tex">T</script>，我们将<script type="math/tex">T</script>中某一元素<script type="math/tex">i</script>加<script type="math/tex">1</script>（前提是<script type="math/tex">i + 1</script>不在<script type="math/tex">T</script>中）得到的集合<script type="math/tex">T'</script>一定是比<script type="math/tex">T</script>大的。</p><p>因此我们的方法是对于集合<script type="math/tex">T</script>，设其中的最大值是<script type="math/tex">i_{\max}</script>（对于空集，<script type="math/tex">i_{\max} = 0</script>）。若<script type="math/tex">i_{\max} &lt; n</script>，那么我们就将<script type="math/tex">T \cup\{i_{\max} + 1\}</script>和<script type="math/tex">T\cup \{i_{\max} + 1\}\setminus \{i_{\max}\}</script>分别加入堆中。通俗地说，要么我们将子序列最后一个下标加一，要么就加一个数到子序列中。</p><p>这个方法显然具备正确性。并且复杂度足够优秀，为<script type="math/tex">O(k\log n)</script>。</p><h3><a id="小结" href="#小结" class="headerlink" title="小结"></a>小结</h3><p>由于全序结构的不明显，因此传统的全序算法在这个问题上难以适用。</p><p>上述的算法的本质是利用结构中隐藏的偏序性质（一些与<script type="math/tex">T</script>相关的方案我们可以断言它们与<script type="math/tex">T</script>的大小关系）组合构建出全序结构，通过小根堆维护以优化复杂度。</p><p>简单来说传统的方法是从最小值开始找<script type="math/tex">k</script>次后继，找的是<strong>一个集合</strong>的后继。而堆维护偏序算法干的事情是，找若干个集合的后继，即踢掉最小的，将更多可能的后继加入。</p><h2><a id="【例题】-扩域版第-K-小问题" href="#【例题】-扩域版第-K-小问题" class="headerlink" title="【例题】 扩域版第 K 小问题"></a>【例题】 扩域版第 K 小问题</h2><blockquote><p>给出<script type="math/tex">n</script>个正整数集合，第<script type="math/tex">i</script>个集合记作<script type="math/tex">A_i</script>，其中的第<script type="math/tex">j</script>小的数记作<script type="math/tex">A_{i, j}</script>。现在要从每个集合里拿出了一个数，方案的价值是拿出的数的和，求第<script type="math/tex">k</script>小的代价是多少。</p><p><script type="math/tex">n, \sum |A_i|, k \le 10^6</script>。</p></blockquote><p>延续子集第 K 小的思路，考虑用堆维护偏序。</p><p>考虑一个选数方案<script type="math/tex">(j_1, \ldots, j_n)</script>其中<script type="math/tex">j_i</script>表示第<script type="math/tex">i</script>个集合选<script type="math/tex">A_{i, j_i}</script>。可以发现，将其中任意一个（可以增大的）<script type="math/tex">j_t</script>加一得到的方案都是比它大的。</p><p>那么初始时将<script type="math/tex">(1, 1, \ldots, 1)</script>加入堆中。同时我们将集合按照<script type="math/tex">A_{i, 2} - A_{i, 1}</script>从小到大排序。</p><p>为了保证引子唯一，我们找到方案中最大靠后的<script type="math/tex">&gt;1</script>的元素对应的下标<script type="math/tex">t</script>（即最大的<script type="math/tex">t</script>使得<script type="math/tex">j_t &gt; 1</script>，若没有则<script type="math/tex">t = 0</script>）：</p><ul><li>若<script type="math/tex">t &gt; 0</script>且<script type="math/tex">j_t &lt; |A_t|</script>，将<script type="math/tex">(j_1, \ldots, j_{t - 1}, j_t + 1, j_{t + 1}, \ldots, j_n)</script>加入堆中。</li><li>若<script type="math/tex">t &lt; n</script>，将<script type="math/tex">(j_1, \ldots, j_t, j_{t + 1} + 1, \ldots, j_n)</script>（等价于<script type="math/tex">(j_1, \ldots, j_t, 2, \ldots, j_n)</script>）加入堆中。排序保证了这一步的正确性。</li></ul><p>这样可以保证引子唯一，进而保证算法正确性。时间复杂度<script type="math/tex">O(k\log n)</script>。</p><h2><a id="传统算法能否给劲" href="#传统算法能否给劲" class="headerlink" title="传统算法能否给劲"></a>传统算法能否给劲</h2><p>对于这类问题，其实传统算法<strong>思想</strong>并非毫无用武之地。</p><p>利用传统算法思想我们可以获得复杂度稍劣但更为普遍的解法。</p><h2><a id="【另解】（扩域）子集第-K-小问题" href="#【另解】（扩域）子集第-K-小问题" class="headerlink" title="【另解】（扩域）子集第 K 小问题"></a>【另解】（扩域）子集第 K 小问题</h2><p>仍然是子集第 K 小问题，这次我们从二分的角度思考。</p><p>二分答案<script type="math/tex">x</script>后，问题转化为求权值和小于等于<script type="math/tex">x</script>的方案数。</p><p>仍考虑用堆维护答案。我们用堆维护前<script type="math/tex">i</script>个元素的方案中权值和小于等于<script type="math/tex">x</script>的所有方案。</p><p>考虑加入<script type="math/tex">a_{i + 1}</script>，那么我们枚举堆中每一个元素<script type="math/tex">s</script>，如果<script type="math/tex">a_{i + 1} + s\le x</script>就将<script type="math/tex">a_{i + 1} + s</script>加入堆中。</p><p>一旦堆的大小超过<script type="math/tex">k</script>就停止 check。</p><p>这个算法的复杂度视实现情况为<script type="math/tex">O(k\log k\log V)</script>或者<script type="math/tex">O(k\log V)</script>。</p><p>上述过程甚至可以改成线段树分治后做堆合并。合并也是按上述方式暴力合并。</p><p>对于扩域子集第 K 小问题，按类似的方法做也可以做到<script type="math/tex">O(k\log k\log V)</script>。</p><h2><a id="【应用】树上第-K-小连通块" href="#【应用】树上第-K-小连通块" class="headerlink" title="【应用】树上第 K 小连通块"></a>【应用】树上第 K 小连通块</h2><blockquote><p>给出一棵<script type="math/tex">n</script>个点带正整数点权的树，求其上点权和第<script type="math/tex">k</script>小的连通块。<script type="math/tex">n\le 10^5</script>。</p></blockquote><p>这个问题则只能用二分思想解决。</p><p>二分答案后问题转化为连通块计数。将连通块按其中深度最浅的点分类，就转化为树上堆合并的过程了。</p><p><a target="_blank" rel="noopener" href="https://oj.qingyu.us/problem/1548">QOJ 1548</a></p><h2><a id="【应用】购物计划" href="#【应用】购物计划" class="headerlink" title="【应用】购物计划"></a><a target="_blank" rel="noopener" href="https://loj.ac/p/3322">【应用】购物计划</a></h2><blockquote><p>有<script type="math/tex">n</script>个商品，具有种类<script type="math/tex">a_i</script>和价值<script type="math/tex">c_i</script>。</p><p>现在要求购物，第<script type="math/tex">i</script>种的物品购买个数要在<script type="math/tex">[l_i, r_i]</script>之间。</p><p>求价值和第<script type="math/tex">k</script>小的代价。</p><p><script type="math/tex">n, m, k\le 2\times 10^5</script>。</p></blockquote><p>本题实际上是两个第 K 小问题的套娃。先在同一种类里做，然后对原问题做。</p><h3><a id="子问题" href="#子问题" class="headerlink" title="子问题"></a>子问题</h3><p>现在问题转化为大小在<script type="math/tex">[l, r]</script>范围内的子集第<script type="math/tex">k</script>小问题。</p><p>不妨将物品按价值排序，假设分别为<script type="math/tex">b_1, \ldots, b_t</script>。为了方便转移我们将末尾的连续下标记作一段区间，可以用<script type="math/tex">(x, y, z)</script>表示，其含义是我们选择的物品的末尾的极长下标连续段是<script type="math/tex">[x + 1, \ldots, x + y - 1]</script>，并且<script type="math/tex">b_x</script>是我们选择的第<script type="math/tex">z</script>个物品。其他信息可以忽略。初始状态<script type="math/tex">(1, l, 1)</script>。</p><p>转移有：</p><ul><li><script type="math/tex">(x, y, z) \to (x + 1, y, z)</script>。</li><li><script type="math/tex">(x, y, z) \to (x + 1, y - 1, z + 1)</script>。</li><li>若<script type="math/tex">x = z = 1</script>且<script type="math/tex">y &lt; r</script>，则有<script type="math/tex">(x, y, z) \to (x, y + 1, z)</script>。</li></ul><p>容易证明引子的唯一性。</p><p>可以堆维护。</p><h3><a id="原问题" href="#原问题" class="headerlink" title="原问题"></a>原问题</h3><p>原问题即为扩域第 K 小问题。</p></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2021年7月14日 第3次修订</li><li class="post-history-item">2021年7月3日 第2次修订</li><li class="post-history-item">2021年7月3日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/Math/Polynomial/EGF/">指数生成函数学习笔记</a></div><div class="prev-post"><a href="/AFO/">OI 退役杂谈 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>