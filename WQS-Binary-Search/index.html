<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>WQS 二分学习笔记 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">WQS 二分学习笔记</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2020年6月11日星期四晚上8点59分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2020年6月11日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 2,626 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> 当前文章</div><div class="post-tags"><span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Notes/">Notes</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/DP/">DP</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Quadrangle-Inequality/">Quadrangle-Inequality</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Convex/">Convex</a></span></div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#例一：分段平方和"><span class="toc-number">1.</span> <span class="toc-text">例一：分段平方和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例二：分-k-段平方和"><span class="toc-number">2.</span> <span class="toc-text">例二：分 k 段平方和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法一"><span class="toc-number">2.1.</span> <span class="toc-text">算法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法二：斜率优化"><span class="toc-number">2.2.</span> <span class="toc-text">算法二：斜率优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法三：决策单调性"><span class="toc-number">2.3.</span> <span class="toc-text">算法三：决策单调性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法四：WQS-二分"><span class="toc-number">2.4.</span> <span class="toc-text">算法四：WQS 二分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例三：限权最小生成树"><span class="toc-number">3.</span> <span class="toc-text">例三：限权最小生成树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WQS-二分问题-·-一般化"><span class="toc-number">4.</span> <span class="toc-text">WQS 二分问题 · 一般化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Akvizna"><span class="toc-number">5.</span> <span class="toc-text">Akvizna</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#林克卡特树"><span class="toc-number">6.</span> <span class="toc-text">林克卡特树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文献"><span class="toc-number">7.</span> <span class="toc-text">参考文献</span></a></li></ol></div><hr></div><div class="post-content"><p>WQS 二分，也称带权二分 / DP 凸优化。</p><h2><a id="例一：分段平方和" href="#例一：分段平方和" class="headerlink" title="例一：分段平方和"></a>例一：分段平方和</h2><blockquote><p>把长度为<script type="math/tex">n</script>的正整数序列<script type="math/tex">a</script>分成若干段。一段的代价是和的平方加一个常数<script type="math/tex">c</script>。求最小代价。</p></blockquote><p>设<script type="math/tex">f(i)</script>表示<script type="math/tex">i</script>个数的最小代价。</p><script type="math/tex;mode=display">f(i)=\min_{j=0}^{i-1}\{ f(j) +(S_i-S_j)^2+c \}</script><p>可以斜率优化。时间复杂度<script type="math/tex">O(n)</script>。</p><h2><a id="例二：分-k-段平方和" href="#例二：分-k-段平方和" class="headerlink" title="例二：分 k 段平方和"></a>例二：分<script type="math/tex">k</script>段平方和</h2><blockquote><p>把长度为<script type="math/tex">n</script>的正整数序列<script type="math/tex">a</script>分成<script type="math/tex">k</script>段。一段的代价是和的平方。求最小代价。</p></blockquote><p>首先我们可以设<script type="math/tex">f(i,j)</script>表示前<script type="math/tex">i</script>个数分成<script type="math/tex">j</script>段的最小价值。</p><h3><a id="算法一" href="#算法一" class="headerlink" title="算法一"></a>算法一</h3><p>可以有一个<script type="math/tex">O(n)</script>的转移</p><script type="math/tex;mode=display">f(i,j)=\min_{k=0}^{i-1}\{ f(k,j-1)+(S_i-S_k)^2 \}</script><p>时间复杂度<script type="math/tex">O(n^2k)</script>。</p><h3><a id="算法二：斜率优化" href="#算法二：斜率优化" class="headerlink" title="算法二：斜率优化"></a>算法二：斜率优化</h3><p>在算法一的基础上，由于<script type="math/tex">(S_i-S_k)^2=S_i^2+S_k^2-2S_kS_i</script>，因此可以固定<script type="math/tex">j</script>，然后使用斜率优化。时间复杂度为<script type="math/tex">O(nk)</script>。</p><h3><a id="算法三：决策单调性" href="#算法三：决策单调性" class="headerlink" title="算法三：决策单调性"></a>算法三：决策单调性</h3><p>观察决策单调性。设<script type="math/tex">p(i,j) = \operatorname{opt} k:f(k,j-1)+(S_i-S_k)^2\to f(i,j)</script>，也就是<script type="math/tex">f(i,j)</script>的最优转移决策。</p><p>首先<script type="math/tex">p(i-1,j)\le p(i,j)</script>。因为你加入一个<script type="math/tex">a_i</script>，只会使最后一段的价值增加。因此最后一个分割点只可能往后移。</p><p>其次<script type="math/tex">p(i,j)\le p(i,j+1)</script>。因为你多分一段，显然分割点更靠后。</p><p>因此如果我们能先计算出<script type="math/tex">p(i-1,j)</script>和<script type="math/tex">p(i,j+1)</script>，那么<script type="math/tex">p(i,j)</script>就有上下界了！</p><p>因此我们可以按照<script type="math/tex">i-j</script>从小到大的顺序计算<script type="math/tex">p(i,j)</script>和<script type="math/tex">f(i,j)</script>（初始时<script type="math/tex">i=j</script>，那么就是一个数单独一段）。因此对于<script type="math/tex">i-j</script>相同的那些 DP 值，我们只需要考虑<script type="math/tex">O(n)</script>个决策即可。时间复杂度<script type="math/tex">O(n^2)</script>。</p><h3><a id="算法四：WQS-二分" href="#算法四：WQS-二分" class="headerlink" title="算法四：WQS 二分"></a>算法四：WQS 二分</h3><p>我们稍微修改一下代价。我们要求，每一段有一个附带的常数代价<script type="math/tex">c</script>。也就是说</p><script type="math/tex;mode=display">f'(i,j)=\min_{k=0}^{i-1}\{ f'(k,j-1)+(S_i-S_k)^2 +c\}</script><p>那么这样计算出来，相当于代价多了<script type="math/tex">kc</script>。因此<script type="math/tex">f(i,j)+jc=f'(i,j)</script>。</p><p>从直观的角度，<script type="math/tex">c</script>越大，意味着分段的成本越高。换言之，设<script type="math/tex">x=\arg_i\min f'(n,i)</script>（也就是最小的代价对应的段数），那么当<script type="math/tex">c</script>越大，<script type="math/tex">x</script>就会越小。因此我们可以二分<script type="math/tex">c</script>来让<script type="math/tex">x=k</script>。这时我们可以使用例题一的算法求出<script type="math/tex">f'(n,k)</script>。那么<script type="math/tex">f(n,k)=f'(n,k)-kc</script>，也就求出了答案。</p><p>我们还可以从计算几何的角度理解这个过程。</p><p>考虑二维平面上建立<script type="math/tex">k</script>个点<script type="math/tex">(i,f(n,i))</script>（<script type="math/tex">1\le i\le k</script>）。</p><p><script type="math/tex">c</script>则对应一条过原点的直线<script type="math/tex">t(x)=xc</script>。那么<script type="math/tex">f(n,k)+t(k)=f'(n,k)</script>，可以借此构造<script type="math/tex">f'</script>的<script type="math/tex">k</script>个点：<script type="math/tex">(i,f(n,i)+t(i))</script>。</p><p>我们可以理解为是把原来的<script type="math/tex">k</script>个点按照<script type="math/tex">t(x)</script>的斜率拉伸得到了<script type="math/tex">f'</script>的<script type="math/tex">k</script>个点。</p><p>从直观的角度，<script type="math/tex">c</script>越大，意味着分段的成本越高。在<script type="math/tex">t(x)</script>斜率增大的过程中，这<script type="math/tex">k</script>个点中高度最低（纵坐标最小）的点的横坐标是在不断变小（单调不升）的。因此这<script type="math/tex">k</script>个点构成一个<strong>下凸壳</strong>。注意，这是我们使用直观理解来感性证明的。</p><p>以某一个斜率拉伸一个凸壳，会导致它的顶点横坐标发生单调的变化。这就是为什么我们可以使用二分的方式找到顶点横坐标为<script type="math/tex">k</script>的情况。那么这时把凸壳拉伸回去就可以得到<script type="math/tex">(k,f(n,k))</script>的纵坐标，也就是答案。</p><p>也就是说，如果我们能快速求出凸壳顶点的纵坐标，那么我们就先想办法把我们要求的点调整为顶点，然后求出它的纵坐标，然后还原。</p><p>例题一的算法，实际上就是在求这个凸壳顶点的坐标（横坐标可以在 DP 的时候附带求出）。</p><p>这样的二分算法是王钦石（WQS）首次提出的，因此我们以 WQS 二分为之命名。</p><p>该算法的复杂度是<script type="math/tex">O(n\log_2w)</script>，<script type="math/tex">w</script>是值域。</p><h2><a id="例三：限权最小生成树" href="#例三：限权最小生成树" class="headerlink" title="例三：限权最小生成树"></a>例三：限权最小生成树</h2><p>WQS 二分不局限于 DP 优化。考虑这个问题：</p><blockquote><p>给出一张<script type="math/tex">n</script>个点<script type="math/tex">m</script>条边加权无向图（边权）。每条边是黑色或者白色。求白色边数恰好为<script type="math/tex">k</script>的最小生成树。</p></blockquote><p>设<script type="math/tex">f(i)</script>表示白色边数恰好为<script type="math/tex">i</script>的 MST 边权和。</p><p>那么同样地，考虑<script type="math/tex">n</script>个点<script type="math/tex">(i,f(i))</script>。然后有一条直线<script type="math/tex">t(x)=xc</script>。在这道题目中它表示把白边的边权额外加<script type="math/tex">c</script>。那么<script type="math/tex">n</script>个点被<script type="math/tex">t(x)</script>拉伸出的点就是<script type="math/tex">(i,f(i)+t(i))</script>。</p><p>从直观的角度，白边权值越大，那么 MST 中白边的数量就越少。因此随着<script type="math/tex">t</script>斜率增大，凸壳的顶点会左移。因此这是一个下凸壳。</p><p>那么使用 WQS 二分即可。时间复杂度<script type="math/tex">O(m\log_2m\log_2w)</script>。可以使用一些简单的优化降到<script type="math/tex">O((m+n)\log_2w)</script>。</p><h2><a id="WQS-二分问题-·-一般化" href="#WQS-二分问题-·-一般化" class="headerlink" title="WQS 二分问题 · 一般化"></a>WQS 二分问题 · 一般化</h2><p>大多数能够使用 WQS 二分的问题可以归为以下两类：</p><p>题型一：</p><blockquote><p>给出一个长度为<script type="math/tex">n</script>的正整数列<script type="math/tex">a</script>，分成不超过<script type="math/tex">k</script>段，一段区间的代价<script type="math/tex">w(l,r)</script>满足四边形不等式，求最小的代价。</p><p>注：若<script type="math/tex">\forall L\le l\le r\le R</script>，均有<script type="math/tex">w(L,r)+w(l,R) \le w(L,R)+w(l,r)</script>，称<script type="math/tex">w</script>满足四边形不等式（简记为“交叉小于包含”）。</p></blockquote><p>题型二：</p><blockquote><p>给出一个长度为<script type="math/tex">n</script>的正整数列<script type="math/tex">a</script>，分成不超过<script type="math/tex">k</script>段，一段区间的代价<script type="math/tex">w(x)</script>满足四边形不等式，求最小的代价。</p><p>注：单元函数的四边形不等式是指，<script type="math/tex">\forall a\le b,c\ge 0</script>，<script type="math/tex">w(a)+w(b)\le w(a-c)+w(b+c)</script>。也就是<strong>内</strong>小于等于<strong>外</strong>。</p></blockquote><p>这样的问题仍然可以使用 WQS 二分来去掉段数的限制。</p><p>注：考场上证明是凸的，建议打表。</p><h2><a id="Akvizna" href="#Akvizna" class="headerlink" title="Akvizna"></a><a target="_blank" rel="noopener" href="https://loj.ac/problem/3132">Akvizna</a></h2><blockquote><p>你有<script type="math/tex">n</script>个人。你要干掉他们。假设当前还剩下<script type="math/tex">a</script>个人，则在一轮里，你可以选择<script type="math/tex">b</script>个人（<script type="math/tex">1&lt;b\le a</script>）干掉，得分是是<script type="math/tex">\frac{b}{a}</script>，剩下<script type="math/tex">b-a</script>个人。你需要在<strong>恰好</strong><script type="math/tex">k</script>轮里干掉所有人。求最大得分。</p><p><script type="math/tex">k\le n\le 10^5</script>。</p></blockquote><p>容易写出一个二维 DP。权值函数<script type="math/tex">w(l,r)=1-\frac{l}{r}</script>，容易证明它满足四边形不等式（实际上在本题里是反过来的。你求的是最大值，因此这里的不等式应该是<script type="math/tex">\ge</script>的版本）。然后 WQS 二分即可。去掉<script type="math/tex">k</script>的限制后，可以斜率优化 DP。</p><p>时间复杂度<script type="math/tex">O(n\log_2w)</script>。精度开<script type="math/tex">10^{-15}</script>能过。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/loj/3132.cpp">代码</a></p><h2><a id="林克卡特树" href="#林克卡特树" class="headerlink" title="林克卡特树"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4383">林克卡特树</a></h2><blockquote><p>给出一棵边带权的树，要求删除其中恰好<script type="math/tex">k</script>条边，再加入<script type="math/tex">k</script>条<script type="math/tex">0</script>权边使得仍是一棵树，最大化新树的直径。</p><p>可能有负权边。</p><p><script type="math/tex">n\le 3\times 10^5,k\le 3\times 10^5,|v_i|\le 10^6</script>。</p></blockquote><p>题意转化：将原树分成<script type="math/tex">k+1</script>个连通块，最大化每个连通块直径的和。</p><p>我们将一个点当作退化的路径。那么进一步转化为，求原树上互不（点）相交的<script type="math/tex">k+1</script>条链的权值和的最大值。</p><p>考虑树形 DP，设<script type="math/tex">f_{i,j,k}</script>表示<script type="math/tex">i</script>的子树内有<script type="math/tex">j</script>条链，<script type="math/tex">i</script>的度数是<script type="math/tex">k</script>（<script type="math/tex">k\in\{0,1,2\}</script>）的权值和的最大值。<script type="math/tex">i</script>的度数是指，它是否作为链的端点、中间点或者不在链上。</p><p>转移是背包合并。</p><p>对于原树，设<script type="math/tex">F(k)</script>表示互不相交的<script type="math/tex">k</script>条链的权值和的最大值。仍然给他加一条直线<script type="math/tex">t(k)=kc</script>。那么直觉告诉我们<script type="math/tex">c</script>越大，最优的<script type="math/tex">k</script>越大（顶点随斜率的增大右移）。因此它是个上凸壳。打表也可以验证。</p><p>因此二分<script type="math/tex">c</script>求出最优的<script type="math/tex">k</script>即可。也就是说，一条链的额外代价是<script type="math/tex">c</script>，在不限制链数的情况下，最大化总的权值和。则把原 DP 的第二维去掉即可。</p><p>时间复杂度<script type="math/tex">O(n\log_2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/luogu/4383.cpp">代码</a></p><h2><a id="参考文献" href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>王钦石，浅析一类二分方法，IOI2012 中国国家集训队第二次作业自选部分。</p></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2020年6月11日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/Math/Polynomial/Binary-Lifting-Eval/">点值平移与倍增求值学习笔记</a></div><div class="prev-post"><a href="/String/Suffix-Automaton/">后缀自动机与后缀树 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>