{"meta":{},"pages":[{"path":"404/index.html","text":"看起来你访问了一个并不存在的链接？点此 回到首页哦～","title":"404 Not Found","updated":"2025-04-23T04:07:19.251Z"},{"path":"about/index.html","text":"大多数时候，我在各大网站的 ID 是 sshwy。有时候是 sshwyR。\n目前是 OI Wiki 的编辑之一，一个已经退役的 OIer。\nCodeforces ID: sshwyR\n这里是 Sshwy 的博客。\n总有人问 Sshwy 的 ss 是什么意思。其实这是我在刷水题阶段对自己的象征性定位——“水”手的首字母缩写。不过你也可以理解为傻傻 hwy，绅士 hwy，飒飒 hwy 之类的。\n我是高爸的忠实粉丝。只要你也是高爸的粉丝，我们就是朋友！\n在 OI 圈混这么久，我也感叹，当今 OI 圈的博客内容是如此雷同，我写博客的意义是什么。是一种形式的日记，自己努力的证明，或者各种各样的原因。总之我在一段时间内还不会放弃更博。当然，相比我最初的博客，随着我水平的提升，内容的质量也有所提升。\n博客使用 Hexo 构建，网站源代码是 Github 的私有仓库，CI 和 host 是 vercel。私有是因为有一些加密内容。加密主要是防止白嫖党。\n有关建站的技术性问题可以问，如果我能解答的话。\n2020 年 1 月，本博客主题更新为 Ssimple，这是我亲手为本站开发的主题（纯粹只是心血来潮）。\n这个主题并不是偷懒，而是我特别设计的极简主题。\n第一次搭建博客的时候，特别喜欢修改博客样式，搞成自己喜欢的外观。然而等热情过去之后才发现，并没有什么人看我的博客。既然如此，何必把博客弄得那么精致呢？\n2021 年 1 月，博客主题正式开源，并更名为 Essence，欢迎大家来用！这个主题属于麻雀虽小五脏俱全，样式设计得比较古朴，大家可以在其基础上自由改进。\n有什么想对博主说的可以在下方评论区留言。 评论区已经没了（\n有一个 Phaser 3 做的 小游戏。","title":"About","updated":"2025-04-23T04:07:19.277Z"}],"posts":[{"categories":[],"path":"NeRF/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"NeRF1 全称 Neural Radiance Field，是一个函数 F_{\\Theta}，将一个三维空间中的位置 \\mathbf{x} = (x,y,z) 和方向（可用二维球坐标表示）(\\theta, \\phi) 映射到密度 \\sigma 和颜色 \\mathbf{c} = (r, g, b)。这个 Formula 和图像渲染没太大区别，比如传统的计算机图形学中，光线追踪也是将一个三维空间中的位置 \\mathbf{x} = (x,y,z) 和方向 (\\theta, \\phi) 映射到颜色 \\mathbf{c} = (r, g, b)。NeRF 的输出多了一个密度，对应的就是 Volume Rendering。\nVolume Density \\sigma(\\mathbf{x}) 可以理解为射线（这里的射线是指从相机出发的采样射线，也就是光线的反方向）最终停在 \\mathbf{x} 处某个无穷小的粒子上的概率。\nVolume Rendering: 对于一个从 \\mathbf{o} 出发，沿 \\mathbf{d} 方向射出的射线 \\mathbf{r}(t) = \\mathbf{o} + t \\mathbf{d}（射线的范围是 [t_n, t_f]），它的期望颜色是 C(\\mathbf{r}) = \\int_{t_n}^{t_f} T(t) \\sigma(\\mathbf{r}(t)) \\mathbf{c}(\\mathbf{r}(t), \\mathbf{d}) \\mathrm{d} t其中 T(t) = \\exp(-\\int_{t_n}^{t} \\sigma(\\mathbf{r}(s)) \\mathrm{d}s)，也就是因为遮挡导致的颜色权重系数。本质上这个公式就是把每个点点密度和颜色乘起来，然后按照射线方向做一个 alpha blending 类似的累加。\n要算这个积分的话其实可以等距取点去算。但是如果 NeRF 的连续性足够好的话是可以做一个类似黎曼积分的方法（stratified sampling）：等距划分区间，每个区间里随机选一个点。\n前面讲了怎么去用一个 NeRF。接下来是怎么造一个 NeRF。这篇文章里一个 NeRF 就是一个 MLP。\nPositional Encoding：作者在这里提了一个观点来解释 Positional Encoding 的重要性。我理解了一下，举个例子，要想让神经网络在学习表示的过程中，学会把一个数字变成它的 onehot 是很困难的，所以不如我直接把这部分的 input 转成 onehot vector 再给到神经网络去学习。所以把三维坐标 (x, y, z) 中的每一维分别变成它的 Positional Encoding 能够极大程度提升训练效果。\nHierarchical Volume Sampling：allocating samples proportionally to their expected effect on the final rendering。初衷是因为有些对渲染结果影响很小的 volume（例如空气的部分）应该减少采样，提高效率。这里的方法是搞两个 NeRF 模型 coarse 和 fine。先用 stratified sampling 在 coarse 模型上拿到每个采样点的信息（不算积分），然后根据这些信息弄一个 PDF 出来，用这个 PDF 再采样一些点，然后把两部分的采样点合到一起去在 fine 模型上算积分来渲染。\n训练 NeRF 的输入是若干张图片以及其相机 Pose、内参（相机 Pose 可以用 SFM 算）。Loss 定义为 \\mathcal{L} = \\sum_{\\mathbf{r} \\in \\mathcal{R}} \\left[\n\\left\\Vert \\hat{C}_c (\\mathbf{r}) - C(\\mathbf{r}) \\right\\Vert_2^2\n+ \\left\\Vert \\hat{C}_f (\\mathbf{r}) - C(\\mathbf{r}) \\right\\Vert_2^2\n\\right]为啥要分 coarse 和 fine（个人思考）：因为 coarse 的采样点比较平均，fine 的采样点是有分布的，所以优化的效果是 coarse 在 average space 上整体预测都不错，而 fine 对于那些对渲染有较大影响的点的预测更准。 1. Mildenhall, B., Srinivasan, P. P., Tancik, M., Barron, J. T., Ramamoorthi, R., &amp; Ng, R. (2022). NeRF: representing scenes as neural radiance fields for view synthesis. In Communications of the ACM (Vol. 65, Issue 1, pp. 99–106). https://doi.org/10.1145/3503250 &#8617;","title":"速通 NeRF","updated":"2025-04-23T04:07:19.272Z"},{"categories":[],"path":"Technique/","tags":[],"text":"一个宝藏https://v.youku.com/v_show/id_XNTQ0MjA1NzUy.html\n卡时if(clock()>0.95*CLOCKS_PER_SEC)break;\n计数题：TopCoder 500-700 1000 分的题\nLatex 手动安装宏包：https://www.ctan.org/ 下载后把解压的文件夹丢/usr/share/texmf/tex/latex里，然后sudo texhash一下。如果是ins文件还得手动编译一下。\nLinux 自定义命令把可执行文件放到/usr/bin下即可\nLinux 权限设置chmod，一般是 755chown，可以设置所有者\nV2raybash &lt;(curl -s -L https:&#x2F;&#x2F;git.io&#x2F;v2ray.sh)\n生成 UUIDcat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;uuid\nCF 读题（解）小助手中 英 双 语\ndocument.querySelectorAll('p').forEach(function(item)&#123; item.innerHTML=item.innerHTML .replace(/You are given/g,\"给你\") .replace(/at least/g,\"至少\") .replace(/overlap/g,\"重叠\") .replace(/can not/g,\"不能\") .replace(/cannot/g,\"不能\") .replace(/can't/g,\"不能\") .replace(/twice/g,\"两次\") .replace(/tournament/g,\"锦标赛\") .replace(/simplify/g,\"简化\") .replace(/consists of/g,\"包含\") .replace(/contains/g,\"包含\") .replace(/bidirectional/g,\"双向\") .replace(/easily/g,\"容易地\") .replace(/convex/g,\"凸的\") .replace(/functions/g,\"函数\") .replace(/function/g,\"函数\") .replace(/path/g,\"路径\") .replace(/tricky/g,\"棘手的\") .replace(/definition/g,\"定义\") .replace(/coincides with/g,\"等价于\") .replace(/centroid decmoposition/g,\"点分治\") .replace(/decreases/g,\"递减\") .replace(/increases/g,\"递增\") .replace(/increasing/g,\"递增\") .replace(/vertex/g,\"结点\") .replace(/vertices/g,\"结点\") .replace(/exists/g,\"存在\") .replace(/contradict/g,\"否认\") .replace(/gradient/g,\"斜坡\") .replace(/efficiently/g,\"快速地\") .replace(/algorithms/g,\"算法\") .replace(/algorithm/g,\"算法\") .replace(/given/g,\"给定\") .replace(/dichotomy/g,\"二分法\") .replace(/no larger than/g,\"不大于\") .replace(/optimum/g,\"最优解\") .replace(/already/g,\"已经\") .replace(/as we can see/g,\"我们可以发现\") .replace(/As we can see/g,\"我们可以发现\") .replace(/ we /g,\" 我们 \") .replace(/We /g,\"我们 \") .replace(/subtrees/g,\"子树\") .replace(/subtree/g,\"子树\") .replace(/calculation/g,\"计算\") .replace(/global/g,\"全局\") .replace(/easy/g,\"容易\") .replace(/derivative/g,\"导数\") .replace(/degree/g,\"度\") .replace(/formula/g,\"公式\") .replace(/Indeed,/g,\"具体地说，\") .replace(/calculate/g,\"计算\") .replace(/Fix/g,\"固定\") .replace(/fix /g,\"固定 \") .replace(/ a single /g,\" 一个 \") .replace(/ a /g,\" 一个 \") .replace(/A /g,\"一个 \") .replace(/name/g,\"名字\") .replace(/substrings/g,\"子串\") .replace(/substring/g,\"子串\") .replace(/strings/g,\"字符串\") .replace(/string/g,\"字符串\") .replace(/Sometimes/g,\"有时\") .replace(/sometimes/g,\"有时\") .replace(/For example/g,\"举个例子\") .replace(/length/g,\"长度\") .replace(/sequence/g,\"序列\") .replace(/integer/g,\"整数\") .replace(/input/g,\"读入\") .replace(/Input/g,\"读入\") .replace(/lowercase/g,\"小写\") .replace(/the longest/g,\"最长的\") .replace(/longest/g,\"最长的\") .replace(/such that/g,\"满足\") .replace(/Print/g,\"输出\") .replace(/print/g,\"输出\") .replace(/except /g,\"除了 \") .replace(/set up/g,\"设立\")\n&#125;);\nC++ 多维数组指针声名int _f[MM][C][C],_g[MM][C][C];\nint (*f)[C][C]=_f,(*g)[C][C]=_g;\nm3u8 npm ci --registry https:&#x2F;&#x2F;registry.npmjs.org&#x2F; --https-proxy 127.0.0.1:1080\ncreat_ap创建热点\ncreate_ap wlo1 eno1 sshwy-manjaro 00000000\n遇到ERROR: Failed to initialize lock：\nsudo rm &#x2F;tmp&#x2F;create_ap.all.lock\nLinux 系统信息screenfetch\nAccess website was denied多半是服务器的文件权限问题。注意检查文件夹的可执行权限，这个东西在文件夹上面的意思是能否进入文件夹读取里面的文件，tar 解压出来的文件夹对其他用户多半没有这个权限。\n系统信息sudo inxi -Fxzz-\nSSH 小技巧正常的 ssh 命令形如\nssh -p [port] [user]@[hostname]\n要添加反向通道可以有\nssh -R [custom unoccupied port on remote]:localhost:[ssh port of target host, usually 22] -p [remote ssh port] [user]@[remote host name]\nssh -R 9124:localhost:22 -p 36164 root@region-45.autodl.pro\n要利用反向通道设置跳板可以有\nHost agibot_206 HostName localhost IdentityFile ~&#x2F;.ssh&#x2F;nopass Port [custom unoccupied port on remote] ProxyJump A User [user of target host] Host A HostName [remote host name] IdentityFile ~&#x2F;.ssh&#x2F;nopass Port [remote ssh port] User [user]\n如果要断线自动重连可以看 autossh\nVSCode SSH 遇到 “Remote Extension host terminated unexpectedly 3 times within the last 5 minutes”试试 code --disable-extensions 能不能成功。如果可以的话说明是插件开太多了，那就手动关一些莫名其妙的吧.\n文件权限处理有时候复制或者移动大批量文件之后，权限会发生变化。常用的处理方式包括\nsudo chown -R huangweiyao . # 递归修改文件 owner （group 不变）\nsudo chmod -R g+w . # 给 group 加上可写权限（因为一般来说 owner 是可写的，改了 owner 之后原来的 owner 可能就不可写了，这时给 group （通常是 root）加上可写权限就可以解决这个问题\n有关 Shell 歧视遇到一些莫名其妙的服务器，在 pip install -e . 如果涉及到 cuda 编译相关的内容，如果 conda 没配好的话可能会g，可以换个shell试试。\nVSCode Remote SSH 手动安装插件首先下载 VSIX 文件，然后传到远程服务器上，接着通过简单的 ls 手段找到 ~/.vscode-server/cli/servers/Stable-[HASH]/server/bin，其中 [HASH] 是一个哈希值（找一个最新版本的 server）。然后在其中执行 ./code-server --install-extension [VSIX path] 即可。","title":"非算法相关的笔记","updated":"2025-04-23T04:07:19.277Z"},{"categories":[],"path":"Programming-Languages/","tags":[],"text":"鉴于本人经常与朋友们进行编程语言的“高谈阔论”，思来想去就写了一篇随笔，这样下次再谈的时候就可以直接拿出来了。本文有很多喜闻乐见的暴论，其中一部分可能掺杂了作者的情绪因素，读者不必过于较真。\n当然，笔者撰写本文的目的也不全是情绪上的发泄或者无意义的拉踩。人各有所爱，或许我与读者可以借此思考一下，我们各自是建立在一个什么样的角度去评价一门编程语言，又是因为哪些地方的关注点不同而产生了分歧。\n当今程序语言之盛况我们直接略过程序语言的历史部分，概因这部分内容稍显陈旧和 trivial，很多当今语言流行的特性在当时还都没有被提出。笔者接触过的语言，按照喜爱程度、熟练程度和语言本身的能力综合评价，从高到底依次是 T0: Rust\nT1: C、JavaScript/TypeScript、Python\nT2: Haskell、Go\nT3: Agda、Coq\nT\\infty: C++ 个人的视角终归有局限性，因此我所谓盛况的讨论主要围绕上述我接触过的语言展开。相信点开本文的读者至少已经接触了一门图灵完备的编程语言，因此我们略去基础的计算概论部分。接下来我们花一些时间简单介绍一下上面提到的语言。\n程序语言中的设计范式有很多，但大致可以分为两个分支：指令式编程和函数式编程。但是就现在来看这种分法也有些过于粗暴了，因为很多语言已经逐渐开始兼容这两种范式。 指令式编程的代表有 C 以及在其基础上发展的 C++；JavaScript 和它的静态类型抽象 TypeScript；还有与人工智能密切相关的 Python；另一个是 Google 开发维护的 Go 语言，可以视为对 C++ 的删繁就简；Rust 的语义设计表达了部分函数式编程的思想，但其对函数的处理（全局函数和闭包）仍然没有足够丝滑地将函数视作 first-class citizen，并且也没有显式地处理函数的副作用，因此我们仍将其视作指令式编程语言。\n其余的语言归为函数式编程的范畴。事实上这部分语言是非常纯种的函数式编程语言，不带一点指令式编程语言的气息。 不同语言的爱好者想必认为上述天梯榜有失偏颇，对此我先给出如下的初步解释。在后文的随想中我们会随时 callback。 首先是垫底的 C++，即便笔者是退役的 OI 选手，对 C++ 十分熟悉，它仍然是笔者心中当之无愧的倒数第一。C++ 的致命扣分点是四不像，该语言的标准从 17 年开始到现在变得越来越臃肿，一滩烂泥，不禁让人想质问标准制定者 “Are you ok?”。依赖管理混乱固然是一个问题，但是它不算致命。例如 C 语言的依赖管理也称得上毫无章法，但我仍然把它排在 T1。\nT3 的语言主要是因为笔者不从事相关的研究方向，并且对这类学术语言的实用价值表示担忧，但总体来说是正面的评价。\nT2 的语言中，Haskell 处在一个零界点的位置。笔者常说，如果一个学术界的语言能够比 Haskell 还出圈（指语言的知名度和生态都能超过 Haskell），那它大概率能大规模投入生产使用。Go 语言则是处在一个尴尬的位置。它是 C++ 的一个非常好的替代品，并且拥有成熟的依赖管理，但是它恰巧在热度上升疲软乏力的时候遇到了火速崛起的 Rust，就变成了现在尴尬的地位。\nT1 的语言在各自擅长的领域都是霸主的地位。这些语言不在 T0 只是因为笔者对 Rust 的极端推崇。C 语言的地位自不必多说，它可以说是绝大多数现代编程语言的祖宗和基石，它的工具链也是很多现代语言编译过程中的一环。JavaScript/TypeScript 做为前端几乎唯一指定语言，除了给浏览网页提供更好服务，配合 NodeJS、deno 等运行时环境，以及异军突起的 WebAssembly，在系统原生应用、网页游戏移植、网站后端、等方面也大行其道，具备相当成熟和丰富的生态系统。Python 的地位随着如今人工智能大模型的高歌猛进自不必多说。说实话，Python 属于入门门槛低但隐性门槛高的语言，并且它的依赖管理也比较混乱。若不是人工智能如今的热度让我不得不给它面子，它得排 T2。\nT0 的语言，它的地位无需解释。它就是唯一真神。所有没有接触过 Rust 语言的读者都形同顽固不化的野蛮人，你们需要神的光辉来指引方向；而对于那些对 Rust 颇有微词的异教徒，你悔改吧（无慈悲）。 「草稿」我如何看待一门程序语言世界上使用人数最多的语言，不一定是实质上的全球通用语言。但最通用的语言却不一定具备最高的信息密度。我们评价一门自然语言是从多方面综合评价的。\n同理，一门程序语言的评价角度也很多。但与自然语言不同的是，自然语言的目的是实现信息的传递和共享，而程序语言的目的是表达计算的过程。这其中最基本的要素包括 实体的指代：各类符号代表的变量，代表计算的结果（简单值）或者计算的过程（函数）\n对于指令式语言，我们会考虑使用流程控制描述计算的过程。三大基本的流程控制包括顺序结构，分支结构和循环结构。\n对于函数式语言，我们直接将函数视作 first-class citizen，通过高阶函数来定义计算结果。两者最直接的区别是，指令式语言中可能会存在某种时间感，因为计算是一个机器运作的过程。而函数式语言中没有所谓的时间感，只有逻辑上的因果联系。 上述程序语言的本身特质，对于现代编程语言而言已经是基础中的基础，因此没有比较的余地。函数式语言的通病是不够快，不够直观，因此可以看到 T0 T1 中均没有函数式语言一席之地。它们可能具备较高的理论价值，但是笔者对此并不了解。而对于指令式编程语言，在基础的要素完全具备之后，考虑的一个重要因素就是如何高效、安全地表达复杂的，大规模的计算过程，在这其中诞生的范式有 模块化：将计算过程拆分成若干个可复用的单元，并隐藏内部琐碎的逻辑；\n构建模式优化：通过引入依赖管理的机制，在降低编译成本的同时提升软件的可移植性；\n宏与语法糖：在基础语法的基础上补充方便使用的简化语法，提高开发效率；\n代码生成：在编译前通过简洁，容易编写的源文件生成复杂但功能重复的源代码，降低代码耦合度；\n自动检查：提供代码检查工具，通过一些预定义的规则检查项目中是否存在不可靠的代码。 除此之外，程序语言与自然语言的一个重要区别是，程序语言在任何意义上都不是赖以生存的。它需要具备一定的迭代更新机制，配合一定的宣传，来保持它的生命力，否则它就会渐渐被人遗忘。\n有了上面的基础逻辑，我们就可以详细地讨论这些程序语言的特点了。\nC++ 之原罪与 C 语言之功成首先便拿我最恨铁不成钢的 C++ 开刀。C++ 的原罪正是 “++”。这个语言的标准制定者铁了心似的想把所有特性都加到 C++ 里去（补充：一门程序语言的标准是指人为规定的若干语法规则和语义，描述这个程序语言的行为。而语言的编译器则是指遵循语言的标准将源代码翻译成机器指令的程序）。\n以下是我在粗略浏览了 C++ 近年来的标准更新内容后，结合自身的使用情况作出的总结： C++98 和 C++03 是在 C 语言基础上引入了基本的面向对象和标准库； C++11 引入了引用类型的变量、lambda 表达式、range for、可变参数模板和自动类型推导，这些特性在当时来说都是十分前沿的设计，因此也算实打实的一个阶梯； C++14 是对 C++11 的小改进，可以接受。事实上到目前为止，C++ 都是一个欣欣向荣，日趋完善的现代语言。 C++17 开始，一系列冗余，或者看似冗余的特性被加入了进来，包括 std::variant, std::optional, typename。这些特性往往是从别的现代语言中照搬过来，也许它们的出发点没有问题，但是它们传达给开发者的是标准逐渐变得混乱。给我这么多特性，我到底用哪个？有时候开发者甚至因为这些无聊的喜好吵起来，可真正的问题是 C++ 正在逐渐变得像一个 CISC 指令集。 C++20 引入了一些更加摸不着头脑的特性，比如 concepts，以及一些完全冗余的特性，比如 modules。更搞笑的是 reference 原文中写道：“Modules are orthogonal to namespaces.” 现在 C++ 的模块化系统里除了有继承自 C 的头文件模块化，还有 namespace 命名模块，以及这个不长眼的 modules 模块。顺带一提这个 modules 的示例代码是这样的\n// helloworld.cpp\nexport module helloworld; // module declaration import &lt;iostream>; // import declaration export void hello() &#123; // export declaration std::cout &lt;&lt; \"Hello world!\\n\";\n&#125; // main.cpp\nimport helloworld; // import declaration int main() &#123; hello();\n&#125;\n在它新加入的标准库中，出现了一些诸如 &lt;compare&gt;，&lt;numbers&gt; 的标准库，让人不禁搞不懂它和现有的重载比较运算符和 &lt;cmath&gt; 的关系；&lt;ranges&gt; 里引入的大量函数和标准库 container 的成员函数之间又有什么纠葛。这一系列天才的设计让 C++ 逐渐成为一个非常合格的没有明确语言标准的造屎语言。你真的很难不写出屎山代码。 C++23 继续高歌猛进，它引入的 Multidimensional subscript operator 还算合理，紧随其后的 Explicit object parameters, Explicit object member functions, Monadic operations, std::unreachable, std::expected 企图将 Go、Rust 等语言的特性抄过来，可表现出的只是某种拙劣的模仿。新引入的 &lt;print&gt; 似乎是在对古老的 &lt;cstdio&gt; 和坚挺的 &lt;iostream&gt; 的另一种形式的宣战。一切都是一如既往的混乱，C++ 的标准早就不再统一。 还有即将到来的 C++26。 这其中还有一个巨大的笑点：从 C++20 开始（注意，这已经是 4 年前的标准），没有任何一个编译器实现了 C++ 标准的完整的所有内容，没有任何一个。这还是在我们放过了 C++11 中关于垃圾回收的标准的前提下（这个特性甚至没有一个编译器实现过）。按常理来说，一门语言的编译器应当是紧跟这门语言的标准，或者说一门语言的标准应当结合其编译器的运作机理来设计。C++ 编译器与其语言标准之间的距离给这门语言蒙上了一个巨大的不稳定性，因为你永远不知道未来 C++ 的语言标准会变得多么抽象。\n这里我需要纠正一些读者的驳斥：有的读者在讨论 C++ 时只以 C++ 语言特性的一个子集为代表而谈论 C++ 如何好，对这门语言的糟粕则冠以 “你自己不选择好的写法，非得用这些垃圾的写法，怪谁”，将责任推在开发者上。如果是十年前 C++ 尚如日中天的时候，这么说倒也罢了。但如今众多程序语言早已弯道超车，C++ 早就被超麻了，你还玩这一套，就显得没有眼力见了。\nC++ 这门语言上出现的诸多不合理的现象，其实可以归结为标准制定者自身的维护不善。这所谓的不善是相对于其他现代编程语言而言。要知道 C 语言早就没有更新了，但是它做为一个上世纪基本完工的产物到现在依然屹立不倒，除了如今的 linux 系统是用 C 语言编写外，另一个重要原因是它没有胡乱地扩充语言特性。如今的 C 语言更像是从现代编程语言到汇编的一个中间表示，它不具备泛型、闭包、垃圾回收、异常捕获、反射、依赖类型、Monad、元编程等等现代语言要素，但是它快，它的工具链足够成熟可靠。而 C++ 的维护者匆匆忙忙把这些现代特性往语言上面堆砌，却根本没有好好思考各个特性之间的配合和用途，最终造成了现在尴尬的局面。\n即便 C++ 做得这么差，它仍然是许多现代程序语言的大哥。倒不如说它就像是一个试验田，给后来者提供了非常好的错误示范。即便我对这门语言如此失望，也不能否认其重要的历史意义。\nPython 与人工智能我对于 Python 的观感相对复杂。Python 有很多令人深恶痛绝的屎点，但也有不少亮点。但是这样的观感一定是建立在如今人工智能的高速发展的基础上的。从这个角度，Python 更像是一个实验性的语言。理想情况下，它的易用性可以大大提高科研项目的工程效率，即使它的运行效率不高。但事实上，Python 如今的立足点已经和易用性毫无关系。\n如今人工智能的研究项目中 Python 代码早已不是几行代码构成的脚本，而是在一个庞大的软件生态系统中的一个工程项目。也因此，缺乏强力的静态类型检查反而成为 Python 的痛点。Python 的立足点仅仅只是若干个核心的人工智能和数据处理库，例如 PyTorch、Tensorflow、NumPy、Scipy 等等。Python 当然也有后端框架，有游戏引擎，但是这些只能支撑一些玩具项目的开发，不能代表 Python 的核心生产力。另外，与其说这是 Python 的亮点，不如说它是 Python 目前还能苟延残喘的救命稻草。例如 Mojo 就存在完全替代 Python 的可能性，只要它能将这些核心库移植过来。\n让 Python 的易用性变差的另一个主要原因是，它的依赖管理仍然称得上混乱。不仅官方提供的软件包构建工具就有很多，让人不知道如何下手；而且软件包在指定依赖时可以完全不指定版本，导致软件的可靠性极差。为了解决这些问题，许多虚拟环境管理软件应运而生，诸如 conda，pyenv，venv 等等，让 Python 软件的安装步骤越发多样，给大家提供了各种正面或负面意义上的情绪价值。复现过 AI 方向的 paper 的同学想必很了解这一点，正所谓配环境是 AI 最屎的一步，而这一切的苦难都得感谢 Python。\n不要瞧不起 Python 的依赖管理，事实上我之所以不谈 C++ 的依赖管理，是因为它没有依赖管理。Python 比 C++ 好的地方主要在于，抛开它的社区生态不谈，Python 语言本身以及其官方库都是比较科学的。没有冗余的特性，没有过度的抽象。就程序语言本身的特质而言，它属于十分合格，标准明确的语言，算是唯一让我安心的点了。\n如何评价 Rust熟悉我的读者一定被我强推过 Rust 编程语言。首先，我们需要承认，Rust 语言的发展是建立在前辈们的基础上的，毕竟它应当是天梯榜里最年轻的语言之一。但它绝不止是简单地把前辈们的优秀特性融合提炼。\nRust 最让人陌生，也就是最创新的部分，是引入了前无古人（就笔者的认知而言）的生命周期管理和所有权约定，以一种令人意外的优雅的方式近乎解决了内存泄漏的问题。但是，若只有如此，Rust 仍然称不上惊艳。毕竟在编程语言的研究领域，我相信有许多具有更加深刻的理论背景的程序语言，具备安全的类型和内存管理机制；另外我也相信，若是取 C++、Go 或者甚至 Python 的一个子集，配合精心编写的依赖库，仍然能达到同样的内存安全效果。\nRust 在目前我接触，或者未接触的编程语言中一骑绝尘，最超前的理念，我将之总结为：类型约束式的行为控制。这并不是一个非常明显的编程技巧，而是 Rust 在降低了诸多方面的编程成本之后，形成的独特范式。举一个简单的例子：我们希望定义一个邮箱地址的类型，要求其保存的邮箱地址必须是合法的邮箱地址。在 Rust 语言中你可以写成\nstruct EmailAddress(String); impl EmailAddress &#123; pub fn create(s: &amp;str) -> Option&lt;EmailAddress> &#123; if /* the address is valid */ &#123; Some(s.to_string()) &#125; else &#123; None &#125; &#125;\n&#125;\ncreate 如果返回的不是 None，那么这个邮箱地址必然合法。Option&lt;T&gt; 是一个类型，其中的值要么是 Some(T)，要么是 None。可以将其等价为一个动态分配的 T*，其中 null 指针对应 None 的情况。对于 C++，可以通过将构造函数私有化，然后定义另外一个公共的构造函数来调用构造函数实现：\nclass EmailAddress &#123; string s; EmailAddress(string s) : s(s) &#123;&#125; public: static optional&lt;EmailAddress> create(string s) &#123; if (/* the address is valid */) &#123; return make_optional(EmailAddress(s)); &#125; else &#123; return nullopt; &#125; &#125;\n&#125;;\n这种范式在别的编程语言中也可以使用类似的技巧实现。但是你会注意到，Rust 语言中使用这个技巧是在降低编程成本，但在 C++/Go/Java/Python 里使用这个技巧是在提高编程成本。原因很简单：Option 是 Rust 的标准类型，它的标准库里大量使用了 Option，因此你可以丝滑地结合标准库和语法糖处理 create 的返回值。但是其他语言则不是，需要你自己实现相应的 utils 和 helper。\n这时有读者就要问了：为什么我非得用这个 Option&lt;T&gt; 类型？这里我想通过举例的方式让大家理解这种编程范式的好处。以 C++ 为例： 一个显然的想法是，create 函数返回一个动态分配的地址 string*。如果邮箱字符串不合法，就返回一个空指针。这个方法弊端很显然：如果你不小心忘了做空指针检查，那么程序就会直接 UB。我不确定现代的 C++ 编译器是否会在运行时拒绝空指针寻址的操作，但是这种不负责任的行为始终是不保险的。\n很多指令式编程语言都有异常处理机制，例如 Python 的 try-raise-except，C++/JavaScript 的 try-throw-catch。因此我们可以直接让 create 的返回值类型为 string，或者一个具有公共成员变量的 struct。而如果邮箱地址不合法，我们可以直接在 create 函数里抛出错误。这样的编程范式固然可以避免内存泄漏和 UB，但也存在一个明显的缺陷：你的程序总是有可能在莫名其妙的地方暴毙，因为每一个函数都可能抛出错误，而你一旦忘记写 try-catch，程序就有可能在关键的地方暴毙，导致整个程序终止（多线程的程序可能好点，比如网站后端）。内存泄漏的确是不会发生了，但是程序的行为却有些脱离了控制，带来的后果是开发成本和后期运维的成本较高。\n事实上一些现代编程语言也的确没有引入异常处理，例如 Go 语言。Go 语言的处理方式也十分粗暴：create 的返回值设为一个二元组 (string, appError)，并且手动写 if 判断 appError 是否为 nil，如果不是则说明出现了错误。编辑器插件会检查是否存在没有使用的变量，算是变相提供了一种不太强的错误处理约束。1\nRust 也没有引入异常处理，但依仗 Option 是基础类型，它提供了非常方便的语法糖来代替类似 Go 语言的 if 判断。2 类型约束式的行为控制，在很大程度上提升了代码编写的门槛，并且它的学习成本和理解成本也不低，或许有些读者也没有想明白为什么非得这么干，希望这个例子能提供一些启发。\n举一反三，Rust 中的互斥锁是一个泛化类型 Mutex&lt;T&gt;，例如 Mutex&lt;AppData&gt; 将 AppData 用互斥锁保护起来，必须使用成员函数 .lock() 获取数据。而在其他编程语言中，往往是将 mutex 作为一个成员变量，每次都手动 lock（这里的手动是指，你需要记得这个类型得先 lock 再访问，写代码时需要格外小心；而在 Rust 中，你没有办法在不 lock 的情况下访问到内部数据），等访问完了再释放。要模仿 Rust 的范式并非不可，但正如前文所言，它会增加代码编写的成本。比如 C++ 里面你就得手动定义一个抽象类，写一坨又臭又长的 template 和类型约束。\n促成这一范式的形成也离不开 Rust 的枚举类型和模式匹配，它们与上文的 Optional 均借鉴自函数式编程语言。函数式编程语言没有促成这一范式，是因为它们的约束太强了，这类语言本身就不太能高效地表达循环和指针，根本就没什么复杂的行为能够表达，因此也用不着类型去约束行为。 1. https://go.dev/blog/error-handling-and-go &#8617; 2. https://doc.rust-lang.org/rust-by-example/error/option_unwrap/question_mark.html &#8617;","title":"「随笔」有关程序语言的若干观点","updated":"2025-04-23T04:07:19.275Z"},{"categories":[],"path":"Math/Stirling-Number/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"},{"name":"Stirling-Number","slug":"Stirling-Number","permalink":"https://notes.sshwy.name/tags/Stirling-Number/"}],"text":"斯特林数常用于各类计数问题中。\n第一类斯特林数记为 s(n,k)，表示把 n 个数分成 k 个圆排列的方案数，有两个递推式： \\begin{aligned}\ns(n,k)&=s(n-1,k-1)+s(n-1,k)(n-1)\\\\\ns(n,k)&=\\sum_{i=1}^n \\binom{n-1}{i-1}(i-1)!s(n-i,k-1)\n\\end{aligned}第一个递推式的组合意义是枚举最后一个元素的选择；第二个递推式的组合意义是枚举第一个所在排列的状态。\n生成函数设 G_n(x)=\\sum_{i}s(n,i)x^i，那么根据 s(n,k) 的递推式有 G_n=xG_{n-1}+(n-1)G_{n-1}=(x+n-1)G_{n-1}因此可以得到 G_{n}(x)=\\prod_{i=0}^{n-1}(x+i)=x^{\\overline{n}}那么我们可以分治多项式乘法求出 G_n。\n第二类斯特林数记为 S(n,k)，表示把 n 个数分成 k 个集合的方案数： \\begin{aligned}\nS(n,k)&=\\sum_{i=1}^nS(n-i,k-1)\\binom{n-1}{i-1}\\\\\nS(n,k)&=S(n-1,k-1)+S(n-1,k)k\n\\end{aligned}相似地，可以从两个角度理解两个递推式。关于 S(n,k) 有一个恒等式： m^n=\\sum_{i=0}^mS(n,i)m^{\\underline{i}}=\\sum_{i=0}^nS(n,i)m^{\\underline{i}}组合意义：n 个不同的物品放到 m 个不同的箱子里： 左边：正常数法为 m^n。\n中间：枚举有多少个非空盒子，那么我们先把 n 个不同的球分成 i 个非空集合，方案数为 S(n,i)，然后再枚举这 i 个盒子的位置。\n右边：和中间等价。 对上式使用二项式反演： F(n)=\\sum_{i=0}^nG(i)\\binom{n}{i}\\iff G(n)=\\sum_{i=0}^nF(i)(-1)^{n-i}\\binom{n}{i}可以得到： m^n=\\sum_{i=0}^nS(n,i)\\binom{m}{i}i! \\iff S(n,m)=\\frac{1}{m!}\\sum_{i=0}^m(-1)^{m-i}\\binom{m}{i}i^n这个式子也可以用容斥理解。结合 S(n,m) 的组合意义，我们先假设集合有序。然后我们枚举有多少个空的集合，然后我们可以在剩下的集合中随遍填数。最后再除一个 m! 即可。\n继续转化可以得到 S(n,m)=\\sum_{i=0}^m\\frac{(-1)^i}{i!}\\cdot\\frac{(m-i)^n}{(m-i)!}这样可以使用多项式乘法计算 S(n,i),i\\in[0,n]。注意这个恒等式在 n&lt;m 的时候也成立（这时 S(n,m)=0）。\n代码\n斯特林反演首先，根据第一列斯特林数的生成函数有 x^{\\overline{n}}=\\sum_{i=0}^ns(n,i)x^i \\tag{1}根据第二类斯特林数的恒等式有 x^n=\\sum_{i=0}^nS(n,i)x^{\\underline{i}} \\tag{2}由于 x^{\\underline{n}}(-1)^n=(-x)^{\\overline{n}}，那么 (1)，(2) 同时代入 -x 并化简可以得到 \\begin{aligned}\nx^{\\underline{n}}&=\\sum_{i=0}^ns(n,i)(-1)^{n-i}x^i & (3)\\\\\nx^{n}&=\\sum_{i=0}^nS(n,i)(-1)^{n-i}x^{\\overline{i}} & (4)\n\\end{aligned}结合 (2)，(3) 可以得到 \\begin{aligned}\nx^n &=\\sum_{i=0}^nS(n,i)\\sum_{m=0}^is(i,m)(-1)^{i-m}x^m\\\\\n&=\\sum_{m=0}^n x^m\\sum_{i=m}^nS(n,i)s(i,m)(-1)^{i-m}\n\\end{aligned}当然，结合 (1)，(4) 同样可以得到 \\begin{aligned}\nx^n &=\\sum_{m=0}^n x^m\\sum_{i=m}^nS(n,i)s(i,m)(-1)^{n-i}\n\\end{aligned}把结合的方式交换一下又是另一个关于上升幂或者下降幂的多项式，也对应了反演公式。综上： \\begin{aligned}\n\\sum_{i=m}^nS(n,i)s(i,m)(-1)^{i-m}&=[m=n]\\\\\n\\sum_{i=m}^ns(n,i)S(i,m)(-1)^{i-m}&=[m=n]\n\\end{aligned}如何应用斯特林反演？假设固定 m 是常量，我们要求的是 f(m)。那么等价于求 [m=n]f(n)。设 g(i)=\\sum_{n}f(n)S(n,i)那么答案就是 \\sum_{i=m}^n g(i)s(i,m)(-1)^{i-m}。而 g 则需要通过其他的转化或者组合意义来求。\n例题Count the Buildings\n求有多少个 n 的排列满足前缀最大值的个数是 F，后缀最大值的个数是 B。\nn,F,B\\le 2000。 除掉高度为 n 的那个房子，剩下的我们可以把看得到的房子之间的部分与这些看得到的房子理解为一个圆排列。相当于这个组内的房子可以任意排列，但最高的那个一定要放在左边 / 右边，因此这是一个圆排列。于是容易想到第一类斯特林数。\n具体地，我们把 n-1 个房子分成 F+B-2 个圆排列后，相当于要选择 F-1 个放左边。因此总方案数为 \\dbinom{F+B-2}{F-1}s(n-1,F+B-2)。\n代码\nTJOI2016 求和\n求 f(n)=\\sum_{i=0}^n\\sum_{j=0}^iS(i,j)2^jj!n\\le 10^5。 算法一直接推。类似求第二类斯特林数的的公式，使用二项式反演展开，并整理成卷积的形式： \\begin{aligned}\n&\\sum_{i=0}^n\\sum_{j=0}^iS(i,j)2^jj!\\\\\n=&\\sum_{i=0}^n\\sum_{j=0}^nS(i,j)2^jj!\\\\\n=&\\sum_{i=0}^n\\sum_{j=0}^n\\frac{1}{j!}\\sum_{k=0}^j\\binom{j}{k}(-1)^k(j-k)^i2^jj!\\\\\n=&\\sum_{j=0}^n2^j\\sum_{k=0}^j\\binom{j}{k}(-1)^k\\sum_{i=0}^n(j-k)^i\\\\\n=&\\sum_{j=0}^n2^jj!\\sum_{k=0}^j\\frac{(-1)^k}{k!}\\cdot \\frac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}\\\\\n\\end{aligned}这样可以直接 FFT 了，复杂度 O(n\\log_2n)。\n算法二这个式子长得很奇怪。设 g(i)=\\sum_{j=0}^iS(i,j)2^jj!考虑其组合意义，相当于把 i 个元素分成若干个集合，集合之间有序，并且每个集合有两种状态，问总方案数。考虑递推，枚举最后一个集合的状态，可以得到 g(i)=\\sum_{j=1}^i2\\binom{i}{j}g(i-j)稍作变换可以得到 \\frac{g(i)}{i!}=\\sum_{j=0}^{i-1}\\frac{2}{(i-j)!}\\frac{g(j)}{j!}这样就可以分治 FFT 了。时间复杂度 O(n\\log_2^2n)。\n代码\n算法三by Entropy Increaser (origin)\n仍然是推式子： \\begin{aligned}\n&\\sum_{i=0}^n\\sum_{j=0}^iS(i,j)2^jj!\\\\\n=&\\sum_{i=0}^n\\sum_{j=0}^nS(i,j)2^jj!\\\\\n=&\\sum_{i=0}^n\\sum_{j=0}^n2^j\\sum_{k=0}^j(-1)^{j-k}\\binom{j}{k}k^i\\\\\n=&\\sum_{j=0}^n2^j\\sum_{k=0}^j(-1)^{j-k}\\binom{j}{k}\\sum_{i=0}^nk^i\\\\\n=&\\sum_{k=0}^n\\frac{1-k^{n+1}}{1-k}\\sum_{j=k}^n\\binom{j}{k}(-1)^{j-k}2^j\n\\end{aligned}在算法一中，我们直接使用卷积完成了本题。但注意到，这是一个特殊的卷积。\n对于生成函数 G(x)=\\sum_{i\\ge 0}g_i，考虑 \\begin{aligned}\nG(x+q)&=\\sum_{i\\ge 0}g_i\\sum_{j\\ge 0}\\binom{i}{j}x^{j}q^{i-j}\\\\\n&=\\sum_{j\\ge 0}x^j\\sum_{i\\ge j}\\binom{i}{j}g_iq^{i-j}\n\\end{aligned}因此 [x^j]G(x+q)=\\sum_{i\\ge j}\\binom{i}{j}g_iq^{i-j}。\n不妨设 F(x)=\\sum_{i=0}^n 2^ix^i=\\frac{1-(2x)^{n+1}}{1-2x}。那么原式就变成了 \\sum_{k=0}^n\\frac{1-k^{n+1}}{1-k}[x^k]F(x-1)那么只要我们能快速求出 \\frac{1-k^{n+1}}{1-k} 和 F(x-1) 的各项系数即可。前者可以线性筛，后者可以递推（除以一个一次式）。因此时间复杂度就是 O(n) 的。\nCrash 的文明世界\n给一棵 n 个结点边权为 1 的树，对于每个 i 求出 \\sum_{j=1}^n \\text{dist}(i,j)^mn\\le 5\\times 10^4,m\\le 500。 考虑到 x^m=\\sum_{i=0}^mx^{\\underline{i}}S(n,i)。因此我们考虑维护每个子树 u 到 u 距离 m 次方和用下降幂展开后的 S(n,i) 的系数，记为 f(u,i)。则对于根结点 root，答案为 \\sum_{i=0}^mf(root,i)S(n,i)。因此在此基础上换根即可求出答案。\n考虑如何计算 f(u,i)。考虑到 (x+1)^{\\underline{i}}=x^{\\underline{i}}+ix^{\\underline{i-1}}则对于若干条路径 a_1,a_2,\\cdots,a_k，对 f(u,i) 的贡献为 \\sum_{i=1}^ka_i^{\\underline{i}}如果我们将他们都加 1，则贡献变成 \\sum_{i=1}^k(a_i+1)^{\\underline{i}}=\\sum_{i=1}^ka_i^{\\underline{i}}+i\\sum_{i=1}^ka_i^{\\underline{i-1}}而我们如果添加一条长度为 1 的路径，即把 a=1 加入到序列中，则将会对 f(u,0) 和 f(u,1) 都产生 1 的贡献。f(u,0) 可以理解为是路径数。因此我们得到了 f(u,i) 的转移式： f(u,i)\\gets\\sum_{v\\in Son(u)}f(v,i)+i\\cdot f(v,i-1)\\\\\nf(u,1)\\gets|Son(u)|\\\\\nf(u,0)\\gets|Son(u)|注意处理上边界的转移，对于子树中最长的链，要把长度的阶乘贡献到对应的 DP 值上。\n然后再换根即可。\n时间复杂度 O(nm)。\n代码\nPartitions\n给你一个长度为 n 的序列 w，对于一个下标集合 S，定义它的价值 W(S)=|S|\\sum_{i\\in S}w_i。\n对于一个将 [1,\\cdots,n] 划分到 k 个集合的方案，记这 k 个集合的集合是 R。那么这种划分的价值定义为 P(R)=\\sum_{S\\in R}W(S)。\n现在求 [1,\\cdots,n] 的所有划分方案的价值和。\nk\\le n\\le 2\\times 10^5, w_i\\le 10^9。 可以直接写出一个暴力式子： \\sum_{i=1}^nw_i\\sum_{j=1}^n\\binom{n-1}{j-1}S(n-j,k-1)j两边可以分别计算。看到组合数和斯特林数的乘积，考虑将它转化为斯特林数递推式的形式： \\begin{aligned}\n&\\sum_{j=1}^n\\binom{n-1}{j-1}S(n-j,k-1)j\\\\\n=&\\sum_{j=1}^n\\binom{n-1}{j-1}S(n-j,k-1)+\\sum_{j=1}^n\\binom{n-1}{j-1}S(n-j,k-1)(j-1)\\\\\n=&\\sum_{j=1}^n\\binom{n-1}{j-1}S(n-j,k-1)+(n-1)\\sum_{j=1}^n\\binom{n-2}{j-2}S(n-j,k-1)\\\\\n=&S(n,k)+(n-1)S(n-1,k)\n\\end{aligned}这样只需要算两个斯特林数即可。时间复杂度 O(n\\log_2n)。\n代码\n图的价值\n一个带标号的图的价值定义为每个点度数的 k 次方的和。\n给定 n 和 k，请计算所有 n 个点的带标号的简单无向图（不一定连通）的价值之和。\nn\\le 10^9,k\\le 2\\times 10^5。 对每个点的贡献分别计算： \\begin{aligned}\nAns=&n\\sum_{i=0}^{n-1}\\binom{n-1}{i}2^{\\binom{n-1}{2}}i^k\\\\\n=&n2^{\\binom{n-1}{2}}\\sum_{i=0}^{n-1}\\binom{n-1}{i}i^k\n\\end{aligned}这里我们考虑一个经典的套路：通常幂转下降幂（第二类斯特林数）：（把 n 减了 1） \\begin{aligned}\n&\\sum_{i=0}^n\\binom{n}{i}i^k\\\\\n=&\\sum_{i=0}^n\\binom{n}{i}\\sum_{j=0}^k\\binom{i}{j}j!S(k,j)\\\\\n=&\\sum_{i=0}^n\\sum_{j=0}^k\\frac{n!}{(n-i)!(i-j)!}S(k,j)\\\\\n=&\\sum_{i=0}^n\\sum_{j=0}^k\\binom{n-j}{i-j} n^{\\underline{j}}S(k,j)\\\\\n=&\\sum_{j=0}^kn^{\\underline{j}}S(k,j)\\sum_{i=j}^n\\binom{n-j}{i-j} \\\\\n=&\\sum_{j=0}^kn^{\\underline{j}}S(k,j)2^{n-j}\n\\end{aligned}我们 O(n\\log_2n) 计算出 S(k,j),j\\in[0,k] 即可。复杂度 O(n\\log_2n)。\n代码\n经典问题\n求 n 个点 m 条边带标号无向连通图的个数。\nn\\le 200。 我们对连通块数做斯特林反演。设 F(i) 表示 n 个点 m 条边 i 个连通块的方案数。那么答案就是 F(1)。\n应用斯特林反演，设 g(j)=\\sum_{i=1}^n F(i)S(i,j)。\n答案是 \\sum_{j}g(j)s(j,1)(-1)^{j-1}=\\sum_{j}g(j)(j-1)!(-1)^{j-1}。\n考虑 g(j) 的组合意义：枚举 i，对于 n 个点 m 条边 i 个连通块的方案，再把 i 个连通块划分到 j 个非空集合中。\n这个组合意义等价于：枚举 n 个点划分成 j 个集合的方案，每个方案只能集合内连边，一共连 m 条边的方案数之和。\n又可以转化为：枚举 n 个点划分成 j 个集合的方案，每个方案总共有 t 条可用边，那么这个方案的贡献是 \\binom{t}{m}。\n考虑 DP。设 f_{i,j,k} 表示 i 个点有 j 条可用边，划分成 k 个集合的方案数。转移时枚举 1 号点所在集合： f_{i,j,k}=\\sum_{z=1}^i\\binom{i-1}{z-1}f_{i-z,j-\\binom{z}{2},k-1 }那么 g(j)=\\sum_{t} f_{n,t,j}\\binom{t}{m}。这是个 4D/1D 的 DP，复杂度 O(n^5)。\n考虑优化。\n答案是 \\sum_{j}g(j)(j-1)!(-1)^{j-1}=\\sum_t\\binom{t}{m}\\sum_jf_{n,t,j}(j-1)!(-1)^{j-1}。\n设 f'_{i,j,k}=f_{i,j,k}(-1)^{k-1}，则答案是 \\sum_t \\binom{t}{m}\\sum_j f'_{n,t,j}(j-1)!。\n考虑求 g_{n,t}=\\sum_j f'_{n,t,j}(j-1)!。\n如果系数是 j! 那么可以在转移的时候枚举任意集合，这样划分成 j 个集合就被算了 j! 次： g_{n,t}=\\sum_i \\binom{n}{i}g_{n-i,t-\\binom{i}{2}}如果系数是 1，就枚举 1 号点所在子集： g_{n,t}=\\sum_i \\binom{n-1}{i-1}g_{n-i,t-\\binom{i}{2}}因此为了让系数是 (j-1)!，我们可以在求 g_{i,t}（i&lt;n）的时候使用第一种转移，在求 g_{n,t} 的时候使用第二种转移。这样就确保每个划分为 j 个集合的方案，1 号点所在集合的位置是固定的，其他集合可以任意排列，也就是 (j-1)! 种方案。注意，这个方法不能做 (j-k)!。\n异或图\n定义两个结点数相同的图 G 与图 H 的异或为一个新的图 I， 其中如果 (u, v) 在 G 与 H 中的出现次数之和为 1，那么边 (u, v) 在 I 中，否则这条边不在 I 中。\n现在给定 s 个结点数相同的图 G_1,\\cdots,G_s，设 S = {G_1, G_2,\\cdots, G_s}，请问 S 有多少个子集的异或为一个连通图？\nn\\le 10,s\\le 60。 考虑容斥连通块的个数。\n设 f(i) 表示在所有连通块个数大于等于 i 的方案（即异或出来的图）中，将连通块划分为 i 个集合的方案数。定义比较奇怪，但考虑如何计算。\n对于点集，考虑枚举所有的集合划分方案（方案数与贝尔数同阶），同一个集合内的点任意连通，而不同集合的点强制不连通。问满足这个条件的异或图的个数。\n考虑线性基，我们只考虑跨过集合的边对应的位，把图插入到线性基中，问题转化为求异或和为 0 的方案数，显然为 2^{S-tot}，其中 tot 表示线性基的大小。因为线性基外的图任意异或，都可以用线性基里的图唯一地异或出一个反图，使得异或和为 0。\n于是我们枚举所有的集合划分方案，O(Sn^2) 计算贡献，贡献到对应的 f 上。这样就计算出了 f。我们现在要求的是 g(i)，表示连通块个数恰好为 i 的方案数（等价于在所有连通块个数等于i 的方案中，将连通块划分为 i 个集合的方案数）。考虑到 f(i)=\\sum_{x=i}^nS(x,i)g(x)根据斯特林反演得到 g(i)=\\sum_{x=i}^ns(x,i)(-1)^{x-i}f(x)则得到 g(1)=\\sum_{x=1}^n(x-1)!(-1)^{x-1}f(x)于是我们在实现的时候不需要斯特林反演，直接做即可。\n时间复杂度 O(B_nSn^2)。\n代码","title":"斯特林数学习笔记","updated":"2025-04-23T04:07:19.271Z"},{"categories":[],"path":"Score-Based-Diffusion/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"\\gdef\\vx{\\mathbf{x}}\n\\gdef\\vy{\\mathbf{y}}\n\\gdef\\vw{\\mathbf{w}}\n\\gdef\\vL{\\mathbf{L}}\n\\gdef\\vP{\\mathbf{P}}\n\\gdef\\vm{\\mathbf{m}}\n\\gdef\\vbeta{\\boldsymbol{\\beta}}\n\\gdef\\vf{\\mathbf{f}}\n\\gdef\\md{\\mathrm{d}}\n\\gdef\\norm2#1{\\left\\Vert { #1 } \\right\\Vert_2}\n\\gdef\\grad{\\nabla}\n\\gdef\\tr{\\mathrm{tr}}Score FunctionScore function：对于 \\mathbb{R}^n 上的概率密度函数（probability density function）为 p: \\mathbb{R}^n \\to \\mathbb{R}，则 p 之 score function 定义为其对数函数的梯度： s(\\vx) = \\frac{\\partial \\log p(\\vx)}{\\partial \\vx} = \\grad_{\\vx} \\log p(\\vx) = \\grad \\log p(\\vx)（省略的梯度下标一般可以通过上下文直接推断）\n这是 Score-Based 生成模型的核心概念。类比一个实函数的导数可以相当程度地刻画原函数的特征，那么 p. d. f. 之 score func. 也可以刻画原本的概率分布。\nLangevin Algorithm1该算法的名称有很多： Metropolis-adjusted Langevin algorithm (MALA) or Langevin Monte Carlo (LMC)。Langevin 算法可以利用 score function 来生成服从该分布的随机变量。用到的公式是（\\dot{\\vx} 表示 \\md\\vx） \\dot{\\vx} = \\grad_{\\vx}\\log p(\\vx) + \\sqrt{2}\\dot{\\vw}其中 \\vw 表示一个标准布朗运动。使用离散化的算法实现它的方法有很多，比较简单的是 Euler–Maruyama method： \\vx(k + 1) = \\vx(k) + \\tau \\grad p(\\vx(k)) + \\sqrt{2\\tau} \\xi(k)其中 \\xi(k) 服从 n 维高斯分布 \\mathcal{N}_n(0, \\mathbf{I})2。\nGenerative Modeling生成模型可以理解为：输入的数据 \\vx 服从某个先验分布 \\pi（例如均匀分布或者正态分布），输出的数据 \\vy 服从目标分布 p_{\\pi}（例如人脸的分布）。因此生成模型的问题主要分为两个阶段： 训练一个模型 f(\\vx) 能够很好地表达分布 p_{\\vy | \\vx}(\\vx) 的特征，例如去拟合 p 的 p. d. f.\n根据模型 f 生成服从目标分布的值。 而事实上，对于实际问题来说，目标分布常常由大量的样本点来代表，因此目标分布本身其实是一组样本点的最大似然。基于此，又可以对于生成模型的训练思路进一步分类： likelihood-based models：以最大似然估计为目标来拟合。\nimplicit generative models：使用一些别的最优化目标来拟合（比如 GAN）。 Score-based 则代表另一种流派：拟合 p. d. f. 的梯度。同样的，我们面临两个阶段的问题：如何训练模型，以及如何生成服从目标分布的值。后者在上文中已经给出了一种思路，放在前面的原因是不涉及太多的背景知识。下文主要关注模型的训练。\nTrainning Objective任何模型的学习过程都是以最优化一个目标为导向。假设我们训练的模型是 s(\\vx; \\theta) = s_{\\theta}(\\vx)，表示带有参数 \\theta 的一个函数（分号用来区分自变量和参数）。那么一个最优的参数 \\theta^{\\ast} 即为 \\arg\\min_{\\theta} E_{p(\\vx)}\\left[\\norm2{s_{\\theta}(\\vx) - \\grad \\log p(\\vx)}^2\\right]更清楚地可以写成 \\arg\\min_{\\theta} \\int_{\\vx \\in \\mathbb{R}^n} p(\\vx)\\norm2{s_{\\theta}(\\vx) - \\grad_{\\vx} \\log p(\\vx)}^2\\md\\vx如果 p 满足一些条件 3，那么我们可以把范数的部分写成离散求和的形式： \\arg\\min_{\\theta} \\int_{\\vx \\in \\mathbb{R}^n} p(\\vx)\n\\sum_{i = 1}^n\n\\left[\n[\\grad_{\\vx} (s_{\\theta}(\\vx)_i)]_i + \\frac{1}{2} s_{\\theta}(\\vx)_i^2\n\\right] \\md\\vx可以发现 \\grad \\log p(\\vx) 被消了，但是出现了一个 s_{\\theta}(\\vx) 的梯度（也就是 p. d. f. 的二阶梯度），这东西是一个矩阵，非常不好求。\n考虑现实情况的 T 个样本点 \\vx^{(1)}, \\ldots, \\vx^{(T)}，那么上式的积分部分就变成了离散形式 \\arg\\min_{\\theta} \\frac{1}{T}\n\\sum_{t = 1}^T\n\\sum_{i = 1}^n\n\\left[\n[\\grad_{\\vx} (s_{\\theta}(\\vx^{(t)})_i)]_i + \\frac{1}{2} s_{\\theta}(\\vx^{(t)})_i^2\n\\right]简写一下可以变成 \\arg\\min_{\\theta} \\frac{1}{T}\n\\sum_{t = 1}^T\n\\tr\\left( \\grad_{\\vx} s_{\\theta}(\\vx^{(t)}) \\right) + \\frac{1}{2} \\norm2{s_{\\theta}(\\vx^{(t)})}^2这个式子显然还是没法直接求，对此有人开发了一套 score matching 理论来求解。\nDenoise Score Matching4这个方法的 Trainning Objective 是 \\frac{1}{2} E _{p_{\\mathrm{data}}(\\vx)}\nE_{p_{\\sigma}(\\tilde\\vx | \\vx)}\n\\left[\\norm2{\ns_{\\theta}(\\tilde\\vx) -\n\\grad_{\\tilde\\vx}\\log p_{\\sigma}(\\tilde\\vx | \\vx)\n}^2\\right]其中 p_{\\sigma}(\\tilde\\vx | \\vx) \\triangleq \\mathcal{N}_n(\\tilde\\vx; \\vx, \\sigma^2\\mathbf{I}) 是一个扰动核（perturbation kernel），是 \\vx 的一个微小高斯扰动。p_{\\mathrm{data}} 表示数据分布。扰动后的数据分布可以表示为 p_{\\sigma}(\\tilde\\vx) = \\int_{\\vx} p_{\\sigma}(\\tilde\\vx | \\vx)p_{\\mathrm{data}}(\\vx)\\md\\vx。\n对于这里的高斯分布，性质比较好，带入 \\mathbf{\\Sigma} = \\sigma^2\\mathbf{I} 可以写出它的数学形式5 p_{\\sigma}(\\tilde\\vx | \\vx) = \\frac{\\exp (-\\frac{1}{2\\sigma^2} \\norm2{ \\tilde\\vx - \\vx }^2 )}{\\sqrt{(2\\pi)^k\\sigma^2}}这样就可以自然推出 \\grad_{\\tilde\\vx} \\log p_{\\sigma} (\\tilde\\vx | \\vx) =\\frac{1}{\\sigma^2}(\\vx - \\tilde\\vx)因此上面的 Objective 可以进一步写为 \\frac{1}{2} E _{p_{\\mathrm{data}}(\\vx)}\nE_{p_{\\sigma}(\\tilde\\vx | \\vx)}\n\\left[\\norm2{\ns_{\\theta}(\\tilde\\vx) -\n\\frac{1}{\\sigma^2}(\\vx - \\tilde\\vx)\n}^2\\right]DSM 的 Objective 被证明，在 \\sigma 充分小的时候，与原始的 Objective 在最优化的角度是等价的。\nAnnealed Langevin Dynamics顾名思义，这是一个在 Langevin Dynamics 采样方法上加入了退火思想的一个变种。它想要解决的问题是：即使我们训练出一个优秀的 s_{\\theta} \\approx\\grad_{\\vx}\\log p(\\vx)，也不一定能够在采样时得到目标分布。尤其是空间维度很大时，目标分布有时候会很稀疏，而如果迭代时的初始值位置不够好，就会很难在可接受的时间内收敛到对应的目标分布。\n但注意到我们不一定非得一步到位。取 \\sigma_1, \\ldots, \\sigma_L 为一个递减的序列（例如等比数列）。假设初始的随机变量 \\vx 服从先验分布 \\pi(\\vx)。我们首先使用 Langevin 算法将 \\vx 转化为 p_{\\sigma_1}(\\vx) 的一个采样，再以此为基础去生成 p_{\\sigma_2}(\\vx) 的一个采样，以此类推，一步一步得到最终的目标分布 p_{\\sigma_L}(\\vx) 的一个采样。这可以理解为，从前一个分布到达下一个分布是相对简单的，因为初始值距离下一个目标分布足够“近”，有较大可能收敛。\n这个采样方法需要我们求出 \\grad_{\\vx} \\log p_{\\sigma_i}(\\vx)（i = 1, \\ldots, L），我们可以直接把 \\sigma_i 作为网络的输入，训练出一个 s_{\\theta}(\\vx, \\sigma) \\approx \\grad_{\\vx} \\log p_{\\sigma}(\\vx) 的模型。\nStochastic Differential Equation从 Annealed Langevin Dynamics 进一步出发。当 L\\to \\infty 时，实际上 \\sigma 就变成了一个连续变化的值。为了刻画 \\sigma 的变化过程，我们可以把离散的迭代指标 i 替换为时间 t，并不妨设 t \\in[0, 1]。那么 \\sigma = \\lambda(t) 就是一个随时间变化的扰动系数。引入了时间，很容易想到使用物理的方法去描述采样的过程。于是我们引入以下形式的随机微分方程： \\md\\vx = \\vf(\\vx, t)\\md t + g(t)\\md \\vw其中 \\vw 是一个标准布朗运动（Wiener process，类似标准高斯分布），\\vf(\\cdot, t) 称作平移系数（drift coef.），而 g(t) 称作扩散系数（diffusion coef.）。在 SBGM 的情境下，SDE 描述的是从一个数据分布 p_{\\mathrm{data}} 出发，逐渐随机运动到先验分布的过程。不妨 p_t(\\vx) 表示在 t 时刻 \\vx 服从的分布，我们有 p_0 = p_{\\mathrm{data}}，p_1 = \\pi。\n要描述采样的过程，我们需要求解上述 SDE 的时间倒流过程6： \\md\\vx = [\\vf(\\vx, t) - g^2(t)\\grad_{\\vx} \\log p_{t}(\\vx)] \\md t + g(t)\\md \\bar\\vw要训练 s_{\\theta}(\\vx, t) \\approx \\grad_{\\vx} p_t(\\vx)，记 \\vx(t) 表示 t 时刻的随机变量 \\vx，p_{0t} 表示从 p_0 到 p_t 的变换核（即上文的扰动核），\\lambda(t) 是一个正的系数，那么最优的参数可以写成： \\arg\\min_{\\theta}E_t\nE _{\\vx(0)}\nE_{\\vx(t) | \\vx(0)}\n\\left[\\lambda(t)\\norm2{\ns_{\\theta}(\\vx(t), t) -\n\\grad_{\\vx(t)}\\log p_{0t}(\\vx(t) | \\vx (0)) }^2\\right]当 \\vf(\\cdot, t) = 0 时，p_{0t} 始终是一个高斯扰动（和 g 有关），此时 Trainning Objective 可以写成 \\min E_t E_{\\vx(0)} E_{\\vx(t) | \\vx(0)}\\left[ \\lambda(t) \\norm2{\ns_{\\theta}(\\vx(t), t) -\n\\frac{\\vx(0) - \\vx(t)}{\\sigma_{0t}^2}\n}^2\\right]其中 \\sigma_{0t}^2 = 1/ E\\left[\\norm2{\\grad_{\\vx(t)} \\log p_{0t}(\\vx(t) | \\vx(0))}^2\\right] 表示 p_{0t}(\\vx(t) | \\vx(0)) 的方差。另外论文中 E\\left[\\norm2{\\grad_{\\vx(t)} \\log p_{0t}(\\vx(t) | \\vx(0))}^2\\right] = \\frac{1}{\\sigma_{0t}^2}。\n取 \\lambda(t) \\propto \\sigma^2_{0t} 就会得到 \\min E_t E_{\\vx(0)} E_{\\vx(t) | \\vx(0)} \\norm2{\ns_{\\theta}(\\vx(t), t)\\sigma_{0t} + \\frac{\\vx(t) - \\vx(0)}{\\sigma_{0t}}\n}^2并且由经验可以得出 \\norm2{\\sigma_{0t} s_{\\theta}(\\vx, t)} \\propto 1. 因此在训练神经网络时可以手动 normalize.\n此时可以得到原本的 SDE 为 \\md\\vx = \\sqrt{\\lambda(t)}\\md\\vw对应的 Reverse SDE： \\md \\vx = -\\lambda(t)\\grad_{\\vx}\\log p_t(\\vx)\\md t + \\sqrt{\\lambda(t)}\\md\\bar\\vwMore SDE接下来我们探索一些 SDE 的具体内容，可能会作为上文的引用。主要参考 Applied Stochastic Differential Equation7。\nBrownian Motion首先我们给出布朗运动（Brownian motion）的定义：\\vbeta(t) \\in \\mathbb{R}^n 是一个具有以下性质的随机过程： \\Delta\\vbeta_k = \\vbeta(t_{k + 1}) - \\vbeta(t_k) 服从一个均值为 0，协方差8矩阵为 \\mathbf{Q}(t_{k + 1} - t_k) 的高斯分布，其中 \\mathbf{Q} 是布朗运动的扩散矩阵（diffusion matrix）。\n时间段不相交的 \\Delta \\vbeta_k 是独立的。\n\\vbeta(0) = 0。 关于它有两点需要注意：\\vbeta(t)处处不可微，不过白噪声可以作为布朗运动的形式上的导数：\\vw(t) = \\frac{\\md \\vbeta(t)}{\\md t}。\nThe Stochastic Integral of Itô一个随机过程，在任何时刻运动到的位置和速度等等都没有上下界，不是一个确定性的收敛的过程，因此没法用黎曼积分去刻画。\nSDE 所对应的积分过程是 The Stochastic Integral of Itô，定义为 L_2 意义下的极限： \\int_{t_0}^t \\vL(\\vx(t), t) \\md\\vbeta(t) = \\lim_{n\\to \\infty} \\sum_k \\vL(\\vx(t), t)[\\vbeta(t_{k + 1}) - \\vbeta(t_k)]其中 t_0 &lt; t_1 &lt; \\cdots &lt; t_n = t，\\vL 是一个矩阵函数。注意到这个积分不像黎曼积分，在分划的小区间里面随便取一个值。如果这样做其实会导致积分不收敛。\n这个积分也解释了上文 \\vbeta(t) 的形式导数的具体含义。因此随机微分方程 \\md\\vx = \\vf(\\vx, t)\\md t + \\vL(\\vx, t)\\md \\vbeta的具体定义也就清楚了，也可以写成 \\frac{\\md\\vx}{\\md t} = \\vf(\\vx, t) +\\vL(\\vx, t) \\frac{\\md \\vbeta}{\\md t}\n1. https://en.wikipedia.org/wiki/Metropolis-adjusted_Langevin_algorithm# &#8617; 2. https://en.wikipedia.org/wiki/Multivariate_normal_distribution &#8617; 3. Estimation of non-normalized statistical models by score matching. A. Hyvarinen. https://www.jmlr.org/papers/volume6/hyvarinen05a/hyvarinen05a.pdf &#8617; 4. A Connection Between Score Matching and Denoising Autoencoders. P. Vincent. https://www.iro.umontreal.ca/~vincentp/Publications/smdae_techreport.pdf &#8617; 5. https://en.wikipedia.org/wiki/Multivariate_normal_distribution#Non-degenerate_case &#8617; 6. Reverse-Time Diffusion Equation Models. Brian D.O. Anderson. https://core.ac.uk/download/pdf/82826666.pdf &#8617; 7. Simo Särkkä and Arno Solin (2019). Applied Stochastic Differential Equations. Cambridge University Press. https://users.aalto.fi/~asolin/sde-book/sde-book.pdf &#8617; 8. https://en.wikipedia.org/wiki/Covariance &#8617; 9. https://en.wikipedia.org/wiki/Partial_derivative#Definition &#8617;","title":"Score-Based Diffusion 学习笔记","updated":"2025-04-23T04:07:19.276Z"},{"categories":[],"path":"Math/Burnside-and-Polya/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"群给定一个集合 G 和集合上的二元运算 \\circ，满足 封闭性：\\forall a,b\\in G,a\\circ b\\in G。\n结合律：\\forall a,b,c\\in G,(a\\circ b)\\circ c=a\\circ(b\\circ c)。\n单位元：\\exists e\\in G,\\forall a\\in G, a\\circ e=e\\circ a=a。\n逆元：\\forall a\\in G,\\exists b\\in G, a\\circ b=b\\circ a=e，记 b=a^{-1}。 称 G 在运算 \\circ 下是一个群。如整数加法群。\n置换狭义的置换可以理解为排列。\nn 个元素 1,2,\\cdots,n 之间的一个置换 \\begin{pmatrix}\n1&2&\\cdots&n\\\\\np_1&p_2&\\cdots&p_n\n\\end{pmatrix}表示 i 被 p_i 取代，可以表示为 i \\to p_i。\n置换群置换是集合的元素，运算的置换的连接。对于两个置换 a_i,b_i，他们的连接可以理解为 i\\to a_i\\to b_{a_i}。\nBurnside 引理对于一个集合 S 以及与之相关的置换群 G，我们说将置换群 G 作用于 S，意味着对于 x, y\\in S，若存在 p\\in G 使得 p(x) = y，那么我们认为 x 和 y 是等价的。\n记 S/G，为 G 作用在 S 上的轨道数，即本质不同的元素个数。\n那么 Burnside 引理用于计算 |S/G|，其公式为 |S/G|=\\frac{1}{|G|}\\sum_{p\\in G}D(S, p)用 D(S, p) 表示在置换 p 关于 S 的不动点个数，即 D(S, p) = \\sum_{e\\in S}[p(e) = e]。\nPolya 定理如果是处理染色问题，那么我们将置换进行轮换分解（分解成若干个环），那么每个环上的点必须染同一种颜色。假设一个置换有 e_i 个大小为 i 的轮换（1 \\le i\\le n），那么使用多元生成函数表示置换群 G 中各类轮换数目组合的置换数为 [z_1^{e_1} \\cdots z_n^{e_n}]p_G(z_1, \\ldots, z_n)。那么用 m_j 个颜色 j 染色（m_1 + \\cdots + m_t = n）的方案数可以表示为 [x_1^{m_1} \\cdots x_t^{m_t}]p_G(\\{ x_1^i + x_2^i + \\cdots + x_t^i \\})He’s Circles\n有一个长度为 N 的环，上面写着X和E，问本质不同的环有多少种。N\\le 2\\times 10^5。 这道题的环指 \\begin{pmatrix}\n1&2&\\cdots&n\\\\\n1+k&2+k&\\cdots&n+k\n\\end{pmatrix}\\pmod n构成的置换群。（0 当成 n）其中 0\\le k&lt;n。把置换理解为若干个环的话，你发现这个置换的环数恰好为 \\gcd(k,n)。如果方案中一个环上的颜色相同的话，那么作用这个置换后方案是不会变的。而总共有两种颜色，于是 D(a_i=i+k\\bmod n)=2^{\\gcd(k,n)}。这样就可以统计了。\nHNOI2008 Cards考虑 Burnside 引理。对于一个置换不变的方案显然在它的一个环是同色的。因对于一个置换处理出环长后，我们做一个三维背包求方案数即可。\n注意，题目给的并不是一个完整的置换群，它少了一个恒等置换。\n代码\nIsomorphism\n给定一个 N 个结点的无向完全图（ 任意两个结点之间有一条边）， 现在你可以用 M 种颜色对这个图的每条边进行染色，每条边必须染一种颜色。\n若两个已染色的图，其中一个图可以通过结点重新编号而与另一个图完全相同， 就称这两个染色方案相同。问本质不同的染色数。\nN\\le 53, M\\le 1000。 我们要求的就是边的置换的环数。考虑将边的置换分类。\n这题的置换群对点而言是一个全排列，但对于边而言就不是了。对于两个点 i,j，他们的置换为 P_i,P_j，则边的置换为 (i,j)\\to (P_i,P_j)。\n考虑将点的置换分类，那么每个置换可以由 k 个大小分别为 L_i 的环表示。\n对于两个点 i,j，如果他们分别在长度为 L_1,L_2 的环上，那么考虑边的置换的环数。这样的边总共有 L_1\\times L_2 个，而每个环的长度为 [L_1,L_2]，则环的个数为 \\gcd(L_1,L_2)。\n如果这两个点都在长度为 L 的同一个环上，那么这样的边总共有 \\dbinom{L}{2} 个。 如果 L 是奇数，则每个环长度为 L，则环的个数为 \\dfrac{\\binom{L}{2}}{L}=\\frac{L-1}{2}。\n如果 L 是偶数，那么当 i+\\frac{L}{2}\\equiv j 时环长为 \\frac{L}{2}，其他时候环长为 L。则环的个数为 \\dfrac{\\binom{L}{2}-\\frac{L}{2}}{L}+1=\\frac{L}{2}。 综上，形如 L_1,L_2,\\cdots,L_k 的点置换对应的边置换的环数为 C=\\sum_{i=1}^k\\left\\lfloor \\frac{L}{2} \\right\\rfloor +\\sum_{i=1}^k\\sum_{j=1}^{i-1}\\gcd(L_i,L_j)然后我们要求的就是形如 L_1,L_2,\\cdots,L_k 的点置换的个数，我们规定 L_i\\le L_{i+1}。\n首先考虑多项式定理，则把 n 个点分到大小分别为 L_i 的集合的方案数是 \\dbinom{n}{L_1,L_2,\\cdots,L_k}。而每个集合内的元素构成一个环，方案数是 \\frac{L!}{L}=(L-1)!（圆排列），于是乘上一个 \\prod_{i=1}^k(L_i-1)!。再考虑到，L 长度相同的环我们是不计他们之间的顺序的，因此设长度为 x 的环有 B_j 个，则还得除掉一个 \\prod_{j=1}^tB_j!，t 表示长度本质不同的环的个数。整理一下得到 S=\\frac{n!}{\\prod_{i=1}^kL_i\\prod_{j=1}^tB_j!}根据 Burnside 引理，这部分的贡献为 Sm^C。\n最后，我们怎么枚举形如 L_1,L_2,\\cdots,L_k 的置换？置换的数量是 n 的拆分数，n=53 时大概是 3\\times 10^5 级别的，因此直接 DFS 枚举即可。\n代码\n染色\n对一个长度为 n 的项链黑白染色，并且规定旋转、翻转、反色等操作后的方案等价。问本质不同方案数。\n对 998244353 取模。n\\le 10^{12}。 这道题集合了许多 Burnside 题的技巧和难点。题目本身也有很多理解方式。\n一个基础的知识点是旋转和翻转构成的置换群大小是 2n。我们把反色也可以当成一种置换。容易发现这种特殊的置换是满足群的性质的。这样反色、翻转、旋转置换群大小是 4n 的。考虑 Burnside 定理。 旋转不反色。显然贡献是 \\sum_{i=1}^{n}2^{(i,n)}=\\sum_{d|n}\\varphi\\left(\\dfrac{n}{d}\\right)2^{d}。\n翻转不反色。这时要分 n 奇偶考虑。n 是偶数，则贡献为 \\dfrac{n}{2}(2^{\\frac{n}{2}}+2^{\\frac{n}{2}+1})；否则 n 是奇数，则贡献为 n2^{\\left\\lfloor\\frac{n}{2}\\right\\rfloor+1}。\n旋转并强制反色，则我们环上是交替填色的，环长是偶数。因此贡献是 \\sum_{i=1}^{n}\\left[2\\mid\\dfrac{n}{(i,n)}\\right]2^{(i,n)}=\\sum_{d|n}\\left[2\\mid \\dfrac{n}{d}\\right]\\varphi\\left(\\dfrac{n}{d}\\right)2^d。\n翻转并强制反色。则环长必须是偶数（2），则 n 是偶数时才有贡献：\\dfrac{n}{2}\\cdot 2^{\\frac{n}{2}}。 于是总的贡献是 \\begin{aligned}\n&[2\\mid n]\\frac{n}{2}(2^{\\frac{n}{2}}+2^{\\frac{n}{2}+1}+2^{\\frac{n}{2}})+[2\\nmid n]n2^{\\left\\lfloor\\frac{n}{2}\\right\\rfloor+1}+\\sum_{d|n}\\varphi\\left(\\frac{n}{d}\\right)2^d+\\left[2\\mid \\frac{n}{d}\\right]\\varphi\\left(\\frac{n}{d}\\right)2^d\\\\\n=&n2^{\\left\\lfloor\\frac{n}{2}\\right\\rfloor+1}+\\sum_{d|n}\\varphi\\left(\\frac{2n}{d}\\right)2^d\n\\end{aligned}这里使用了 \\varphi(2) 的一个小技巧。由于置换群的大小是 4n，因此答案为 \\frac{n2^{\\left\\lfloor\\frac{n}{2}\\right\\rfloor+1}+\\sum_{d|n}\\varphi\\left(\\frac{2n}{d}\\right)2^d}{4n}=2^{\\left\\lfloor\\frac{n}{2}\\right\\rfloor-1}+\\frac{\\sum_{d|n}\\varphi\\left(\\frac{2n}{d}\\right)2^d}{4n}最后计算的时候要注意 p\\mid n 的情况。这时 n 在模 p 意义下就没有逆元了。我们把 p 平方，然后在模 p^2 意义下求出分子。由于在非模意义下分子是 4n 的倍数，而 p\\mid n。因此在模 p^2 意义下分子是 p 的倍数。于是我们直接分子分母模数同时除以 p（p^2 变回 p）。由于 n\\le p^2，因此 p\\nmid \\dfrac{n}{p}。则现在分母就有逆元了，可以直接算了。\n参考文献[1] 陈瑜希，Pólya 计数法的应用","title":"Burnside 引理入门","updated":"2025-04-23T04:07:19.267Z"},{"categories":[],"path":"Brief-Neural-Network/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"最近有好多朋友受困于手写神经网络的作业，因此我将自己的学习思路总结成本文，希望能提供一定的帮助～\n向量在神经网络中，高维向量（vector）和张量（tensor）没有太大区别。从代码层面，两者的实现都是一个高维数组。\n引入向量的原因是，神经网络解决的问题往往不是数字到数字的映射，而是一个事物到另一个事物的变换。在写代码时我们可以用结构体或者类来表示一个对象，但这样的编程范式和语法设计主要是为了方便人的阅读。而神经网络读不懂这些。另一方面，数学上定义一个对象通常采用元组（tuple）和序列（sequence）来描述，例如我们说图灵机是一个七元组 M = \\langle Q, \\Gamma, b, \\Sigma, \\delta, q_0, F \\rangle。而元组可以粗暴理解为长度固定的序列，也就是向量。\n因此，神经网络只认向量，我们需要将信息转化为向量后传递给网络。\n神经网络概述神经网络本身是一个函数。它接受一个向量作为输入， 返回一个向量作为输出。具体是什么形状的输入向量和什么形状的输出向量，看你怎么设计。\n以手写数字识别为例：数据集是由大量 28\\times 28 的灰度（只有黑白灰）图片组成。如果神经网络的第一层是一个线性层（linear，也称全连接 full connected，或者稠密层，dense），那么我们传递的就是一个长度为 28 * 28 = 784 的一维向量。而如果第一层是卷积层（convolutional），那我们传递的就是一个 28 \\times 28 的二维向量。\n在手写数字识别这个问题中，输出向量的形状大多是长度为 10 的一维向量。但是这个向量的含义也是不唯一的。比如说你可以利用 softmax 函数让神经网络直接输出一个离散概率分布（即输出一个向量 p，其中 x = i 的概率是 p_i），也可以让神经网络直接输出一个向量表示每个数字的权重，然后你再自己根据权重分析出神经网络预测的概率最高的那个数字。这个其实也和误差函数的选择有关。\n学习与误差神经网络本身确实是一个函数，怎么把这个函数造出来？\nC++ 里写一个函数，我们直接给出它的定义就行，这是因为你脑子里是知道函数的计算过程的，只需将它从数学语言翻译为 C++ 就行。但神经网络不一样。我们不知道手写数字的计算过程（太复杂），就没法直接给出一个满足要求的函数。为此人们开发了一套学习理论。\n假设这个函数是 f^{\\ast}。以下我们只讨论神经网络的学习。\nf^{\\ast} 是由训练数据来拟合的。也就是说我有 n 组训练数据 (x_i, f^{\\ast}(x_i))，要求你写出一个函数，满足 \\forall i, \\;f(x_i) = f^{\\ast}(x_i)。当然，实际情况下我们不知道 f^{\\ast}，所以能看到的就是人工标记的训练数据 (x_i, y_i = f^{\\ast}(x_i))。\n学习是指调整神经网络，使其输出的向量尽可能服从训练数据的分布（也就是说提高在训练数据集上的准确率）。\n但是无论你怎么学，都是有误差的。 首先这个网络拟合训练数据分布的程度，对应训练数据集上的准确率。对于这个我们就需要选择一个误差函数，使得误差函数的降低能够提高神经网络的拟合程度（大多数误差函数都是这样的），将我们的目标转化为最小化误差函数。\n其次训练数据的分布拟合 f^{\\ast} 的程度，这个的解决方法是提供更多的数据，或者使用一些数据增强方法。 综上，神经网络的学习就转化为最小化误差函数。\n有误差，怎么根据误差来调整神经网络？由于误差函数和神经网络上的运算大多是初等函数相关的运算，因此我们可以通过类似牛顿迭代的方式，配合一些随机化的方法，通过求导来更新网络，寻找一个足够优秀的局部最优解。\n神经网络我们先说简单的分层神经网络。用 a 表示神经网络某一层的计算结果（第 0 层表示读入）用上指标表示层的编号。一个 L 层的神经网络中，每一层都对应一个函数 f^{(l)}。整个神经网络就是这 L 个函数的复合。也就是说 \\begin{aligned}\ny & = f(x) \\\\\n& = f^{(L)} (f^{(L - 1)} (\\cdots f^{(2)}( f^{(1)}(x) ) \\cdots )) \\\\\n& = \\left[f^{(L)}\\circ f^{(L - 1)} \\circ \\cdots \\circ f^{(2)} f^{(1)}\\right](x)\n\\end{aligned}记 a^{(0)} = x，a^{(l)} = f^{(l)} \\left(a^{(l - 1)} \\right)，其中 a^{(0)}, \\ldots, a^{(L)} 均为（高维）向量。\n我们称一个高维向量每一维的长度组成的元组为向量的形状（shape）。那么自然地，你需要保证 f^{(l - 1)} 的输出的形状与 f^{(l)} 输入的形状是一样的。\n下面我们列举一些典型的层。下面的域 F 可以简单视为为 \\mathbb{R}。\n线性层首先我们给出一个简洁的定义：一个线性层对应一个函数 f: F^n \\to F^m，f(x) = wx + b 其中 n, m 是已知常数，w \\in M_{m\\times n}(F), b\\in F^m。\n重复一遍：f: a^{(l - 1)} \\mapsto a^{(l)} 满足： a^{(l)}_j = \\left( \\sum_{i = 0}^{n - 1} w_{ji} a^{(l - 1)}_i \\right) + b_jw, b 都是属于这一层的参量，他们的值是无法直接给出的，需要在学习的过程中不断更新。一个线性层的参量规模是所有参量的分量总数，也就是 nm + m。\n激活层有的地方讲解时，喜欢把激活层当成一个激活函数，放在别的层里面。但是这种混杂在一起的做法不利于后面讲反向传播。所以我们把它直接拿出来作为一个层。\n一个激活层对应一个函数 f: F^n \\to F^n，且对 f: a^{(l - 1)} \\mapsto a^{(l)} 满足 a^{(l)}_i = \\sigma (a^{(l - 1)}_i)其中 \\sigma: F \\to F 被称作激活函数。常用的激活函数有 Sigmoid：x \\mapsto \\frac{1}{1 + e^{-x}}；\nReLU：x \\mapsto [x &gt; 0]x；\nLeaky ReLU：x \\mapsto [x&gt;0]x + \\alpha[x &lt; 0]x。 这东西不是一个线性变换，所以没法用矩阵来简洁定义。\n激活函数层的参量数取决于 \\sigma 的参量数。在上面的例子里，Sigmoid 和 ReLU 没有参量，而 Leaky ReLU 中的 \\alpha 如果会在学习的过程中变化，那就算一个参量，否则不算参量。\n设置激活层的意义在于使神经网络变得不那么线性，有助于表示更多的计算方式。\n卷积层卷积层对应一个函数 f: F^{p\\times n\\times m} \\to F^{q\\times n'\\times m'}。p 和 q 表示读入的通道数和输出的通道数。另外 n', m' 不能随意指定。为了准确描述卷积层，我们需要先介绍它的参量： 核（kernel）：w \\in F^{p\\times q\\times n_k\\times m_k} 表示 p\\times q 个大小为 n_k\\times m_k 的卷积核。\n偏移（bias，可以没有）： b\\in F^{p\\times q}，分别表示每个卷积核的偏移量。 对 f: a^{(l - 1)} \\mapsto a^{(l)}，我们先考虑简单的情况。\np=1, q=1\n这时 w 的形状退化为 n_k\\times m_k，b 退化为一个单独的参量。首先我们给出二维卷积的计算： z_{i, j} =\n\\sum_{x = 0}^{n_k - 1}\\sum_{y = 0}^{m_k - 1} a^{(l - 1)}_{i+x,j+y} w_{x, y}\n+ b平凡情况下，a^{(l)}_{i, j} = z_{i, j}，在这种情况下不难算出 n' = n - n_k + 1, m' = m - m_k + 1。\n但是 z_{i, j} 到 a^{(l)}_{i, j} 过程中可以有猫腻。假设两个维度上的步长（stride）分别是 r_x, r_y。一般地，我们有 a^{(l)}_{i, j} = z_{r_xi, r_yj}平凡情况即 r_x = r_y = 1。可以发现 n' = \\lceil \\frac{n - n_k + 1}{r_x} \\rceil, m' = \\lceil\\frac{m - m_k + 1}{r_y}\\rceil。\n设置步长的意义是减小神经网络的规模。\n一般情况\n为了防止巨大多的公式，我们把 F^{n\\times m} 和 F^{n_k\\times m_k} 的步长为 (r_x, r_y) 的二维卷积（也就是上面那个式子）记作 \\begin{aligned}\nC: F^{n\\times m}\\times F^{n_k\\times m_k}\\times F\n&\\to F^{n'\\times m'} \\\\\n(x, w, b) & \\mapsto y\n\\end{aligned}这里的 x 对应上面 p=1 时的退化的 a^{(l - 1)}，y 对应 q = 1 时的退化的 a^{(l)}。在一般情况下： a^{(l)}_t = \\sum_{s = 0}^{p - 1} C(a^{(l - 1)}_s, w_{s, t}, b_{s, t})卷积层的参量规模为 pq(n_km_k + 1)（注意这和 n, m 无关，也就是说和读入图片的规模无关）。\n与卷积层相关的还有很多，例如池化层，反卷积层等等。除此以外还有一些优化训练的层，比如 dropout 层。\n反向传播概述在接下来的表述中，f 表示神经网络对应的函数，f^{(l)} 表示某一层的函数。\n对于一组训练数据 (x, y)，神经网络一个基本的学习包含以下几个步骤： 前向传播：计算 \\hat{y} = f(x)。\n计算误差：c = C(y, \\hat{y})。\n计算梯度：首先是误差梯度 \\dfrac{\\partial c}{\\partial \\hat{y}}。由于 \\hat{y} = a^{(L)}，因此最后一层的输出的梯度就是误差梯度。然后我们一层一层倒推，对每个 a^{(l)} 均求出 \\dfrac{\\partial c}{\\partial a^{(l)}}，同时对神经网络的每一层的参量求出关于 c 的梯度。\n根据梯度更新神经网络的参量。 误差函数下面列举一些简单的误差函数。\n交叉熵（cross entropy）：两个分布（离散分布可以等价于向量） p, q 的交叉熵定义为 H(p, q) = - \\sum_{n\\in\\mathcal{N}} p_n \\log q_n关于交叉熵有 H(p, q) = H(p) + D_{KL}(p \\mid\\mid q)，其中 D_{KL} 是 KL 散度，定义为 D_{KL}(p \\mid\\mid q) = \\sum_{n\\in\\mathcal{N}} p_n \\log \\frac{p_n}{q_n} = H(p) + H(p, q)KL 散度可以衡量两个概率分布的差异程度，因此固定 p，那么交叉熵也可以。两者都是在 p = q 时取到最小值。\n均方差（mean square error）n 表示分量个数： C(p, q) = \\frac{1}{n}\\sum_{i = 1}^n (p_i - q_i)^2这两个函数都可以用于估计神经网络的误差。交叉熵算出来的误差值的梯度会大一些，利于梯度下降。\n另外，要将一个向量的分量转化为概率分布，常用 softmax 函数： \\begin{aligned}\n\\text{softmax}: x \\mapsto y\\\\ y_i = \\frac{e^{x_i}}{\\sum_{j = 0}^{n-1} e^{x_j}}\n\\end{aligned}反向传播偏导数与梯度：偏导数可以粗暴地理解为对多元函数中的某个变元求导数（把其他变元当作系数）。神经网络中，向量对误差的偏导数被称作梯度（gradient）。\n对向量求偏导其实就是对它的每个分量分别求偏导，也就是说对于向量 v = \\{v_0, \\ldots, v_{n - 1}\\}，它的梯度定义为 \\frac{\\partial c}{\\partial v} = \\left\\{\n\\frac{\\partial c}{\\partial v_0},\n\\frac{\\partial c}{\\partial v_1},\n\\ldots,\n\\frac{\\partial c}{\\partial v_{n-1}}\n\\right\\}高维向量同理。\n下面我们来推导一下简单的分层神经网络的反向传播关系式。\n线性层前向传播：f: a^{(l - 1)} \\mapsto a^{(l)} 满足： a^{(l)}_j = \\left( \\sum_{i = 0}^{n - 1} w_{ji} a^{(l - 1)}_i \\right) + b_j已知 \\dfrac{\\partial c}{\\partial a^{(l)}}，我们要求 \\dfrac{\\partial c}{\\partial a^{(l-1)}}，那么根据上面的公式，结合链式法则，可以推导出 \\begin{aligned}\n\\frac{\\partial c}{\\partial a^{(l-1)}_i} &= \\sum_{j = 0}^{m - 1} \\frac{\\partial a^{(l)}_j}{\\partial a^{(l - 1)}_i} \\frac{\\partial c}{\\partial a^{(l)}_j} \\\\\n&= \\sum_{j = 0}^{m - 1} w_{ji} \\frac{\\partial c}{\\partial a^{(l)}_j}\n\\end{aligned}这里用到的一个简单事实是 \\dfrac{\\partial a^{(l)}_j}{\\partial a^{(l - 1)}_i} = w_{ij}。对 j 求和的原因是，改变 a^{(l-1)}_i 会造成所有的 a^{(l)}_j（0 \\le j &lt; n）都发生变化，所以 a^{(l - 1)}_i 的偏导就是它们变化的和除以 a^{(l - 1)}_i 的变化量。\n然后对于这一层的参量 w, b，我们都要求出他们的梯度： \\begin{aligned}\n\\frac{\\partial c}{\\partial w_{ji}} &= \\frac{\\partial a^{(l)}_j}{\\partial w_{ji}} \\frac{\\partial c}{\\partial a^{(l)}_j} \\\\\n&= a^{(l - 1)}_i \\frac{\\partial c}{\\partial a^{(l)}_j}\n\\end{aligned}这里用到的一个简单事实是 \\dfrac{\\partial a^{(l)}_j}{\\partial w_{ji}} = a^{(l - 1)}_i。接下来对 b： \\frac{\\partial c}{\\partial b_j} = \\frac{\\partial c}{\\partial a^{(l)}_j}所求的 \\dfrac{\\partial c}{\\partial a^{(l-1)}} 用于向上一层传递，\\dfrac{\\partial c}{\\partial w} 和 \\dfrac{\\partial c}{\\partial b} 则是这一层的参量对应的梯度。\n细心的朋友还会发现，线性层的反向传播同样可以写成矩阵乘法的形式： \\begin{aligned}\n\\frac{\\partial c}{\\partial a^{(l-1)}} &= w^{T} \\frac{\\partial c}{\\partial a^{(l)}} \\\\ \\frac{\\partial c}{\\partial w} &= \\frac{\\partial c}{\\partial a^{(l)}} \\left(a^{(l - 1)}\\right)^{T} \\\\ \\frac{\\partial c}{\\partial b} &= \\frac{\\partial c}{\\partial a^{(l)}}\n\\end{aligned}激活层前向传播： f: a^{(l - 1)} \\mapsto a^{(l)} 满足 a^{(l)}_i = \\sigma (a^{(l - 1)}_i)已知 \\dfrac{\\partial c}{\\partial a^{(l)}}，我们要求 \\dfrac{\\partial c}{\\partial a^{(l-1)}}，那么非常显然 \\begin{aligned}\n\\frac{\\partial c}{\\partial a^{(l-1)}_i} &= \\frac{\\partial a^{(l)}_i}{\\partial a^{(l-1)}_i} \\frac{\\partial c}{\\partial a^{(l)}}\\\\\n&= \\sigma'\\left(a^{(l-1)}_i\\right) \\frac{\\partial c}{\\partial a^{(l)}}\n\\end{aligned}激活层通常没有参量，所以不需要给参量求梯度。有的话推一下式子就行。\n梯度下降通过反向传播，我们就得到了神经网络的所有参量 V 的梯度。每一层的梯度拼起来就是整个网络的梯度，记作 g = \\dfrac{\\partial c}{\\partial V}。\n接下来我们来说怎么梯度下降（gradient descent）来最小化误差函数。\n我们在讨论梯度下降时是对着整个网络的梯度 g 讨论，但落实到具体的代码实现时其实还是对每一层的参量分别拿它自己的梯度更新（毕竟梯度下降的公式一般是 element-wise 的）。\n朴素的梯度下降是指 V \\gets V - \\alpha g，其中 \\alpha 是学习率，一般 0 &lt; \\alpha &lt; 1。\n通俗来说，对于一维的情况，如果导数大于 0，那就得往回走；否则就继续向前，这样才能走到一个极小值。所以要找到一个极小值那么我们往导数的反方向走就可以了。\n分批处理数据（batch）为了提高梯度下降的稳定性，我们可以先求出多个数据的梯度 g_1, \\ldots, g_T，将它们求一个平均值 \\overline{g}，再用 \\overline{g} 去做梯度下降。这样做的好处是梯度下降的方向会更加“正确”，训练时的波动幅度也会降低。\n随机梯度下降随机梯度下降（stochastic gradient descent）是指通过将测试数据随机打乱，然后采用朴素的梯度下降公式不断更新网络的参量。打乱数据是一种数据增强的方式。\n自适应梯度下降自适应梯度下降是一个大的分类，包含一大堆梯度下降的优化算法。这里放一个比较著名的 Adam 算法（没啥好讲的，毕竟我也没研究）： 代码实现困扰大家的除了神经网络本身，恐怕还有 python 和 NumPy 的使用。\npython 本身不算难，有 C++ 基础的同学可以在半天甚至一个小时内基本学会。但是 NumPy 就比较恶心了，这个库的学习成本远高于 python 本身。\n举个例子：\n>>> import numpy as np\n>>> a = np.array([0, 1, 2])\n>>> b = np.array([4, 5, 6])\n>>> c = np.array([\n... [1, 2, 3],\n... [4, 5, 6],\n... [7, 8, 9]\n... ])\n>>> a + 3 # 向量加数字\narray([3, 4, 5])\n>>> a + b # 形状相同的两个向量相加\narray([4, 6, 8])\n>>> a + c # 形状不同的两个向量相加\narray([[ 1, 3, 5], [ 4, 6, 8], [ 7, 9, 11]])\n>>> b[a] # ???\narray([4, 5, 6])\n>>> c[a] # ???\narray([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n如果你看懂加号 + 的用法了，说明你具有一些基本的举一反三能力。而如果你能看懂中括号 [] 的使用方法，那么相信 NumPy 对你来说非常容易上手。\nNumPy 入门NumPy 提供了向量的一系列运算，非常适合数据处理。\nnp.zeros 可以创建全为 0 的向量：\n>>> a = np.zeros((3, 2, 1)) # 创建一个 3 x 2 x 1 的三维向量。内层括号是 tuple 的括号，不能省\n>>> a\narray([[[0.], [0.]], [[0.], [0.]], [[0.], [0.]]])\n>>> a.shape # a 的形状\n(3, 2, 1)\nnp.random.normal 可以创建一个服从正态分布的随机向量。\n当然，如同上面的示例，np.array 也可以用于创建向量。\n要理解 NumPy 中各种各样函数和运算符的用法，我们需要理解它的一个概念：广播（broadcasting）。\nBroadcasting1NumPy 中大多数的运算是“点对点”计算的（element-wise）。也就是说如果两个向量 a, b 形状相同，那么 a + b, a - b, a\\times b, a \\div b 都是点对点的数值运算：\n>>> a = np.array([0, 1, 2])\n>>> b = np.array([4, 5, 6])\n>>> a + b\narray([4, 6, 8])\n>>> a - b\narray([-4, -4, -4])\n>>> a * b\narray([ 0, 5, 12])\n>>> a / b\narray([0. , 0.2 , 0.33333333])\n>>> 但是当两个向量形状不同时，NumPy 会按照一定的 broadcast 规则将小的向量补成大的向量，然后执行 element-wise 的计算（这个是对于常规的函数，有的函数比如点积 dot 的 broadcast 规则是不同的）。\n具体来说，假设 a 的形状是 (s_1, \\ldots, s_n)，b 的形状是 (t_1, \\ldots, t_m)。不妨 n &gt; m。\n首先在 b 的开头补 1，把它从 m 维变成 n 维向量。因此我们不妨设 b 的形状是 (t_1, \\ldots, t_n)。\n然后我们按照 i = n, n - 1, \\ldots, 2, 1 的顺序从最后一维倒着开始依次比较。如果 s_i = t_i 或者 s_i = 1 或者 t_i = 1，那么我们认为这两个维度兼容，否则就不兼容。\n如果存在不兼容的维度，那么 NumPy 会直接报错，中断程序。\n如果 s_i = 1 &lt; t_i，那就把 s_i 补成 t_i，相应下标的数值直接复制过来，即 a_{j_1,j_2, \\ldots, j_n} = a_{j_1,j_2, \\ldots, j'_i = 1, \\ldots, j_n}。t_i = 1 &lt; s_i 同理。\n操作完之后，两个数组的形状就相同了，然后就正常做计算就可以了。\nIndexing2在 C++ 中，a[i] 表示获取数组 a 下标为 i 的元素。NumPy 对此有一些狂野的用法。\n假设 a 的形状是 (s_1, \\ldots, s_n)，那么 a[x1, x2, ..., xn] 表示获取 a_{x1, \\ldots, x_n} 的值。\na[[r1, ..., rs]] 表示将第 r_1, \\ldots, r_s 行取出来组成一个新的高维向量：\n>>> c\narray([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n>>> c[[0, 2]] # 取出第 0 行和第 2 行\narray([[1, 2, 3], [7, 8, 9]])\n有了这两个基本常识后，再去理解 NumPy 的函数就会容易很多。\n指南接下来我们给出一些 NumPy 实现手写数字识别时会用到的实现，帮大家少走一些弯路。 首先我们在实现的时候，向量一般是一维，也就是行向量，而不是 n\\times 1 的列向量，因此上面的前向传播和反向传播公式其实得转置。 矩阵乘法调用 np.matmul 即可，具体用法查看文档。 a.reshape 可以在总的元素数不变的情况下调整向量的形状，例如 a.reshape((n, 1)) 可以将 a 变成 n\\times 1 的二维数组（前提是 a 的元素数为 n，否则会报错）。 np.transpose 和 a.T 都可以实现矩阵的转置。 ReLU 函数和 ReLU 的导数分别可以写成\n# 这里的 x 的类型是 NumPy 的数组 def ReLU(x): return (x > 0) * x def ReLU_prime(x): return (x > 0) * 1 softmax 函数当 x_i 较大时，e^{x_i} 会爆精度。因此需要使用一些计算技巧。注意到将 x 所有分量减掉同一个数，softmax 不变，因此我们可以将他们都减掉最大值。而 np.sum 可以求出一个高维向量的所有分量的和。于是 softmax 函数可以写成\ndef softmax(x): x = np.exp(x - x.max()) return x / x.sum() 交叉熵函数可以写成\ndef crossentropy(p, q): # p, q 长度相同 return -(p * np.log(q)).mean() # mean 表示平均值，log 底数默认为 e np.eye(n) 可以创建 n 阶单位矩阵；np.tile 可以将一个向量复制若干次。 如果基础的 NumPy 操作你已经熟练，想要优化一个 batch 的反向传播的复杂度，在计算线性层的 \\dfrac{\\partial c}{\\partial w} 时会遇到这样的式子： \\frac{\\partial c}{\\partial w_{ji}}\n= \\sum_{t=0}^{T} a^{(l - 1)}_{t,i} \\left(\\frac{\\partial c}{\\partial a^{(l)}}\\right)_{t, j}\n= \\sum_{t=0}^{T} A_{t,i} B_{t, j}这种情况可以使用 np.tensordot 3函数：np.tensordot(B, A, ([0, 0]))，表示将两者的第 1 维一起枚举并求和，其他维按顺序依次排下来。 其他常用的函数有 np.atleast_2d, np.flatten, np.concatenate。 Norms\n总体的计算公式为 y = \\frac{x - E[x]}{\\sqrt{Var[x] + \\varepsilon}} \\ast \\gamma + \\beta\n1. https://numpy.org/doc/stable/user/basics.broadcasting.html &#8617; 2. https://numpy.org/doc/stable/user/basics.indexing.html &#8617; 3. https://numpy.org/doc/stable/reference/generated/numpy.tensordot.html#numpy-tensordot &#8617;","title":"神经网络入门","updated":"2025-04-23T04:07:19.261Z"},{"categories":[],"path":"Math/Reflection-Inc-Exc/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"问题描述：考虑从 (0, s) 走到 (n, t)，可行的步为 (1, \\pm 1)，要求不能经过 x = a 和 x = b（a &lt; s, t &lt; b）。求路径方案数。\n如果只要求不能经过 x = -1，那么做一次反射就可以算出不合法的情况。\n首先从 (0, s) 到 (n, t) 任意游走的方案数为 c(s, t) = \\dbinom{n}{\\frac{1}{2}(n + s - t)}。当然如果 n + s - t 是奇数或者超过了范围那么组合数为 0。\n我们需要考虑的是交替反射的情况。假设先经过 x = a，则不合法的情况可以描述为 \\begin{aligned}\n&c(s, 2a - t) - c(s, 2b - 2a + t) + c(s, 4a - 2b - t) - \\cdots \\\\\n=& \\sum_{i\\ge 0} c(s, 2a - t - 2i(b - a)) -\\sum_{i\\ge 1} c(s, t + 2i(b-a))\n\\end{aligned}如果先经过 x = b： \\begin{aligned}\n&\\sum_{i\\ge 0} c(s, 2b - t + 2i(b-a)) -\\sum_{i\\ge 1}c(s, t - 2i(b-a)) \\\\\n=&\\sum_{i\\ge 0} c(s, 2a - t + 2(i+1)(b-a)) -\\sum_{i\\ge 1}c(s, t - 2i(b-a))\n\\end{aligned}于是我们可以得到从 s 到 t 的总的合法路径方案数为 \\begin{aligned}\n&\\sum_{i = 0, \\pm1, \\pm2, \\cdots} c(s, t + 2i(b - a))\n- \\sum_{i = 0, \\pm1, \\pm2, \\cdots} c(s, 2a - t + 2i(b - a)) \\\\\n=&\n\\sum_{i}\\binom{n}{\\frac{1}{2}(n + s - t + 2i(b - a))}\n-\n\\sum_{i}\\binom{n}{\\frac{1}{2}(n + s + t - 2a + 2i(b - a))}\n\\end{aligned}假设我们想对所有的 s', t'（a &lt; s', t' &lt; b）都计算出路径方案数。假设 b - a &lt; n。\n如果暴力计算上面的式子，复杂度 O(n(b - a))。观察上面的两个组合数级数，可以发现前者只与 s - t 有关，后者只与 s + t 有关。因此预处理一下即可 O(1) 计算。总复杂度 O(n + (b - a)^2)。","title":"反射容斥学习笔记","updated":"2025-04-23T04:07:19.271Z"},{"categories":[],"path":"Randomized/Summary/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"Count-min Sketch这是一种，估计出现次数的数据结构，适用于数据流（强在线），不同的元素数不多的情况。\n基本思想是一个哈希表可以估计某个值的出现的次数，但是会估多，因此多个哈希取最小值即可。这里的哈希要取均匀哈希才能保证理论复杂度的正确性。\n详见 「随机算法专题」Count-min Sketch 入门。\nKarp-Rabin Hash简单的字符串哈希：h(s) \\triangleq \\sum_{i = 1}^{|s|} s_ix^{|s| - i}。区间哈希： h(s[l, r]) = h(s[1, r]) - h(s[1, l-1])x^{r-l+1}二维的情况：h(a_{n\\times m})\\triangleq \\sum_{i = 1}^{n}\\sum_{j = 1}^m a_{ij}x^{n - i}y^{n - j}。矩阵哈希（差分）： h(a[l_1, r_1][l_2, r_2]) = [h(a[1, r_1][1, r_2]) - h(a[1, r_1][1, l_2 - 1])y^{r_2 - l_2 + 1}]\\\\\n-[h(a[1, l_1-1][1, r_2]) - h(a[1, l_1-1][1, l_2 - 1])y^{r_2 - l_2 + 1}]x^{r_1 - l_1 + 1}Min-Hash估计两个集合（这里考虑整数集）的相似度，可以使用交并比来描述：J(A, B) = \\frac{|A\\cap B|}{|A\\cup B|}1。\n同样是考虑一个数据流的背景，每个集合只能遍历一次（预处理），然后我们若干次询问两个集合的相似度。\n考虑一个均匀随机哈希 h。那么 J(A, B) = J(h(A), h(B)) = E_x[x\\in h(A)\\cup h(B)]。我们的大致思路是构造 T 个不同的哈希 h，每次随机一个 x，判断是否 x\\in h(A) \\cup h(B)，然后取平均值。\n考虑每次随机的 x = \\min h(A \\cup B)。显然 x\\in h(A) \\cup h(B)\\iff x = \\min h(A) = \\min h(B)。这样的 x 由于每个哈希函数 h 不同的随机性，可以看成是随机的。\nSim-Hash估计两个高维向量的相似度，可以考虑估计他们的夹角 \\theta(x, y)2。\n考虑一个高维随机高斯向量（每一位高斯分布，然后单位化）w，那么 E[\\mathbf{1}_{(x, w)\\ge 0} \\oplus \\mathbf{1}_{(y, w)\\ge 0}] = \\frac{\\theta(x, y)}{\\pi}。\n设 h(x, w) = \\mathbf{1}_{(x, w)\\ge 0}，取 T 个随机的高斯向量 w_1, \\ldots, w_T，那么可以视 x\\mapsto \\{h(x, w_i)\\} 为一个”保度量“的 \\mathbf{R}^n\\to \\mathbf{H}^T 变换3。\nHamming-NN Approximation在 \\mathbf{H}^d （d 约为 64 左右）中给定 p_1, \\ldots, p_n，每次询问 q，查询 p_i 到 q 的最近邻。\nHamming 空间的度量是特殊的，并且每个维度只有 0 或 1。因此距离的分析可以转化为不同分量个数的分析。\n考虑把这件事变得随机一点。我们把每个点（q 和 p_i）作用一个排列 \\sigma 来均匀随机打乱坐标。然后我们在 \\{ \\sigma p_i \\} 中找与 \\sigma q 的 LCP 最大的 N 个点加入候选集合 S。多次取不同的排列 \\sigma，最后求 S 到 q 的最近邻即可4。\n总体思路类似于将 Hamming 距离通过重排列来近似转化为 LCP 长度。\nWell-Separated Pair Decomposition对点集 P 的一个 \\varepsilon-WSPD 是一系列欧氏空间点集对 \\{ (A_i, B_i) \\} 满足 \\max(\\operatorname{diam} A_i, \\operatorname{diam} B_i) \\le \\varepsilon \\operatorname{dist}(A_i, B_i)（点集的距离为点对距离的最小值）；\n\\bigcup A_i\\times B_i = P\\times P。 基于任意递归的空间划分形成的树形结构都可以有一个朴素的 \\varepsilon-WSPD 构造方法： 初始的点集对为 (P, P)；\n对于当前的点集对 (A, B)，不妨 \\operatorname{diam}A &gt; \\operatorname{diam}B。如果 (A, B) 满足条件就直接返回，否则将 A 按照树形结构的划分拆分成子集 \\{A_i\\}，然后对 (A_i, B) 递归地构造 WSPD 即可。 复杂度 O(n\\varepsilon^{-d}\\log\\Delta)，\\Delta 为值域，d 为空间维度。二维平面的情况可以四分树或者 KD-Tree，后者事实上任意维度均通用。\n构造 \\varepsilon = \\frac{1}{2} 的 WSPD，则最近点对必然是某个孤点集对（但其实求最近点对可以直接 KD-Tree）。\nt-Spannert-Spanner7 是欧氏空间点集 P 的一个欧氏子图 H = (P, E)，其中 E\\subseteq P\\times P。H 上的距离定义为最短路，边长为欧氏距离。并且 \\forall x, y\\in P 有 \\Vert x - y \\Vert_2 \\le \\operatorname{dist}_H(x, y) \\le t\\Vert x - y \\Vert_2。\n可以用 WSPD 来构造 (1 + \\varepsilon)-Spanner：构造 \\frac{\\varepsilon}{4}-WSPD，然后将代表点连边（总共O(n\\varepsilon^{-d}\\log \\Delta) 条边）。\n证明可以通过对 \\Vert x - y \\Vert_2 归纳来完成。\n在 (1 + \\varepsilon)-Spanner 上求 MST 可以得到点集 P 的一个 (1 + \\varepsilon)-近似 MST。\nTree Embedding类似 Spanner，Tree Embedding 是将 d 维欧氏空间 [0, \\Delta]^d 上的点集 P 映射到一棵树 T = (V, E)（P\\subseteq V），将点对的距离用树上的最短路距离代替。衡量指标为 distortion：\\max_{x\\ne y} \\frac{\\operatorname{dist}_T(x, y)}{\\Vert x - y\\Vert_2}，越小越好。\n考虑构造一个 2^d 分树，然后将其随机平移（等价于固定 2^d 分树的总体范围，然后平移整个平面）。数据点构成树的叶子，高度为 i 的点到高度为 i + 1 的点的边权值为 \\sqrt{d}2^i（假设所有叶子结点深度相同）。\\sqrt{d} 可以理解为 d 维立方体对角线长度，是一个距离的常数。\n这个做法的 distortion 是期望 O(d h) 级别。h 是 2^d 分树的高度。\n也可以用 KD-Tree 做一个魔改版，但是会导致逼近效果减弱（相当于曼哈顿距离）。\nJohnson-Lindenstrauss TransformJohnson-Lindenstrauss 是一种降维变换 f: \\mathbf{R}^d \\to \\mathbf{R}^m，能够一定误差内保 n 个 \\mathbf{R}^d 上的点 p_i 两两之间的距离：\\Vert f(p_i) - f(p_j) \\Vert_2 \\in (1\\pm \\varepsilon) \\Vert p_i - p_j \\Vert_25。\n应用：快速 Linear Regression。其本质是求 \\arg\\min_w \\Vert Xw - y \\Vert_2（X\\in \\mathbf{R}^{n\\times d}, y\\in \\mathbf R^n, w\\in \\mathbf R^d）。这里 X 事实上可以看成 d 个 n 维空间上的点（转置），于是线性回归就变成了一个欧氏距离下的近似线性表出的问题。\nSubspace 版本 JL： 原始方法：构造 A = \\frac{1}{\\sqrt m} (w_1, \\ldots, w_m)^T，w_i\\in \\mathbf R^n 为随机高斯向量，A\\in \\mathbf R^{m\\times n}。\n更优的做法：生成每列（随机）只有一个非零元素的 01 矩阵 A_{m\\times n}。 问题转化为 \\arg\\min_w \\Vert AXw-Ay\\Vert_2。设 \\tilde X = AX, \\tilde y = Ay，取 m = d，则 \\tilde X^T\\tilde X 大概率可逆。于是 \\hat w \\approx (\\tilde X^T\\tilde X)^{-1} \\tilde X^T y6。\nPower Iteration主成分分析（Principal Component Analysis）是另外一种降维方法，主旨是对于 n 个 d 维空间上的点 p_i 找到 m 个单位正交向量 v_1, \\ldots, v_m，最大化 \\frac{1}{n} \\sum_{i = 1}^n\\sum_{j = 1}^m (x_i, v_j)^2（在此子空间上的投影长度和）。\nPower Iteration 一种粗暴的求最大主成分（Top Principal Component）的算法。\n不妨设 X = (x_1, \\ldots, x_n)^T \\in \\mathbf R^{n\\times d}，那么 TPC 的目标可以写成 \\max \\Vert Xv\\Vert _2 = \\max v^TX^TXv。\n设 A = X^T X 是实对称矩阵，可以对角化。设 A = Q^TDQ，并不妨设 D_{1,1} 是最大的特征值。则目标可以写成 \\max (Qv)^T DQv，结论是 \\hat v 取 Q^T 第一列时最大化（因为算出来就是 D_{1,1}）。\n注意到 A = Q^T D Q 的本质是先旋转，再拉伸，再旋转（单位球映射成椭球），拉伸的方向就对应了 TPC 的方向。因此我们对任意一个向量 u，只要其不垂直于 \\hat v，就可以在反复应用 A 后拉伸到 TPC 的方向。\n因此我们不断计算 A^k u 然后单位化即可。\n另外如果 X 足够稀疏，那么可以用 Au = X^T(Xu) 的方式计算。\nSparse Recovery数据流（Streaming）模型：可以描述为一个插入/删除的操作构成的序列，只允许单次、顺序访问，在结束后回答一些询问，一般不要求实时，但是会有较强的空间限制。\n前面的 Min-Hash，Sim-Hash，Hamming-NN 均可看作数据流算法。\n事实上数据集可以等价地用每个元素出现的频数构成的频数向量 x 表达8。\n记 \\operatorname{supp}(x) = \\{ p \\mid x_p \\ne 0\\} 表示数据流中出现过的所有元素。定义 \\ell_0 范数：\\Vert x\\Vert _0 = |\\operatorname{supp}(x)|。若 \\Vert x\\Vert_0 \\le k，称之 k-sparse。\nSparse Recovery 是一个数据流算法，能够给定 k： 检测数据流是否 k-sparse；\n将 k-sparse 的数据流的 \\operatorname{supp}(x) 完全恢复 直径估计：设 \\mathcal S_i 为 2^i\\varepsilon 边长的格点划分，i = 0, 1, \\ldots, O(\\log \\Delta)。在数据流的过程中对一个点的增删转化为其在 \\mathcal S_i 所在格子的代表点的增删。询问时，找到最小的 i_{\\min} 使得 \\mathcal S_{i_{\\min}} 是 k-sparse 的，然后在 \\mathcal S_{i_{\\min}} 上估计直径。\nStream’s Sparse Recovery对于一个 k-sparse 的数据流，我们可以设计算法来恢复其频数向量： 首先设计一种方法，能够保证对于每个数据流中的值 v，存在一个只保留了 v 相关特征的信息；\n找到这个信息，还原 v 的特征。 考虑构造 T = O(\\log k) 个 [n] \\to [2k] 的均匀哈希 h_1, \\ldots, h_T 来统计每个值的出现次数。那么对于 v \\in [n]，存在 h_i 满足没有别的值与 v 冲突的概率很高。\n具体地，我们可以用哈希维护三个量： c_1(v) = \\sharp v、c_2(v) = v\\times \\sharp v，c_3(v) = r^v\\times \\sharp v11。r 是事先确定的随机值（fingerprint）。那么如果 c_1(v) 整除 c_2(v) 且 r^vc_1(v) = c_3(v)，那么说明这个哈希的 v 没有与别的值冲突（只有整除并不一定能证明不冲突，需要用 fingerprint 来保证），并且我们可以计算 \\frac{c_2(v)}{c_1(v)} 来得到 v。事实上这是一个 1-sparse 信息。\n这算法事实上在不知道数据流是否 k-sparse 的情况下也能写。而我们可以通过把恢复出来的信息删掉来检验原数据流是否 k-sparse。\nLinear Sketch：上述算法相当于是将频数向量进行特定的线性变换，并从 Ax 来还原 x。其优点是具有线性可加性，也可以减。也就是说我们可以恢复一个区间的频数向量。\nCompressed Sensing压缩感知是一种从低维信息还原高维的（稀疏的）信息的方法。\n具体设定：找到一个 A\\in \\mathbf R^{m\\times n}\\; (m &lt; n) 使得对于任意 z \\in \\mathbf R^n，设 b = Az，那么我们总可以通过求解 Ax = b 来近似地找到 z。A 可以视为 m 个线性感知器（Linear Sketch）。\n我们可以构造随机高斯矩阵 A，然后使用线性规划 solver 暴力求解 x。若 x 是 n 维 k-sparse 向量，那么当 m = O(k\\log \\frac{n}{k}) 时这种方法基本上可以完美还原。\n\\ell_0-Sampling\\ell_0-Sampling 可以对于数据流返回一个 \\operatorname{supp}(x) 上的均匀采样 p，主要用于 support 比较大的情况。\n一个对于 \\operatorname{supp}(x) 的均匀采样可以这样得到： 将 \\operatorname{supp}(x) 中的元素以 \\frac{1}{t} 的概率采样（以 \\frac{1}{t} 的概率选择这个元素）；\n在选出来的元素中均匀采样。 事实上选出来的元素中只有一种值的概率是常数，因此可以用 1-Sparse Recovery 来找到这个元素9。\n因此我们分别取 t = 2^i，i = 1, \\ldots, O(\\log n) 构造采样哈希 h^{(i)} : [n] \\to \\{ 0, 1\\}，满足 \\Pr [h^{(i)} (p) = 1] = \\frac{1}{2^i}。然后任意找到其中的一个 1-Sparse 做为采样结果。算法的空间复杂度 O(\\operatorname{poly}(\\log n))，时间复杂度 O(\\log n)。以 1 - \\frac{1}{\\operatorname{poly}(n)} 的概率成功。重复若干次即可得到一个高成功的采样方法。但要注意，同样的采样哈希得到的采样是相同的，因此多次重复需要使用不同的哈希。\nStream MST Approximation图数据流是指点集不变，边集是一个数据流的模型。\n考虑在图数据流上求连通分量。\n考虑类似 Boruvka 算法的过程：维护当前连通块集合，每次将每个连通块的跨越边找出，然后连起来，更新连通块信息。这个算法的可拓展性在于记录跨越边的方法。\n考虑对于 u \\in V，定义当前边集 E 的频数向量为 x^u，满足 x^u(u, v) = \\operatorname{sgn}(u - v)。定义 x^S = \\sum_{u\\in S} x^u，那么可以发现 \\operatorname{supp}(x^S) 恰好是 S 的跨越边。于是可以使用 \\ell_0 采样的方式来找到跨越边。\n当然我们可以沿用这个思路去求图数据流的 (1 + \\varepsilon)-近似 MST。\n但是注意到我们只能做 \\ell_0 均匀采样，而不能很方便地找最小值。这里考虑一个暴力的做法：将边权离散化，然后从小到大暴力枚举。\n离散化：将边权 round 到最近的 (1 + \\varepsilon) 的方幂。仔细想想是有道理的，并且可以显著降低不同边权个数10，也就将数据流稀疏化了。\n离散化后就可以对每个边权 i 和每个结点 u 分别维护频数向量 x^{u, i}。查询跨越边时从小到大枚举 i，在 \\sum _{u\\in S} x^{u, i} 中查询即可。\n复杂度分析：设有 L 种边权。对于每种边权我们构造一个可加的 \\ell_0 采样，空间复杂度 O(nL\\operatorname{poly}(\\log |V|))，找到跨越边的复杂度是 O(L\\log n)，总时间复杂度 O(nL\\log^2 n)。\nComments &amp; References\n1. Jaccard Similarity，空集的情况为 0​​​ &#8617; 2. 有时也估计他们的 Cosine Similarity &#8617; 3. \\mathbf{H}​​​ 为 Hamming 空间，距离为曼哈顿距离，这里的保度量是指夹角和 Hamming 距离 &#8617; 4. 其实还需要再选择 2N​​ 个 LCP 最大的去求最近邻，不过实践证明不太需要 &#8617; 5. 这说明：对于近似算法来说，“⾼维” = O(\\log n)​ 维 &#8617; 6. 如何理解：Xw=y，则 w = X^{-1}y，而 X 不可逆，则形式上构造 X^{-1}y = X^{-1}X^{-T}X^Ty=(X^TX)^{-1}X^Ty &#8617; 7. 个人理解：命名为 Spanner 的原因是 H​ 是原图的一个生成子图 &#8617; 8. ⼀般假设：频数向量每⼀维的最⼤绝对值是 O(\\operatorname{poly}(n))​​ &#8617; 9. 1-Sparse 可以只需存那三个值 &#8617; 10. 例如 \\log_{1.1}(10^{10}) \\approx 242 &#8617; 11. 通过一些预处理方式可以 O(1)​ 计算 r^v​ &#8617;","title":"随机算法总结","updated":"2025-04-23T04:07:19.275Z"},{"categories":[],"path":"Data-Preprocess/","tags":[],"text":"本文的标题非常不负责任，概 AI 基础这门课本身的课程内容极具争议的缘故。\n拿到了数据后要先进行一些预处理才会拿去做模型训练。这里面的门道比想象中多。 \\gdef\\vx{\\mathbf{x}}概述首先我们理清数据预处理的流程，用到的比较具体的技术和方法会在下面专门讲。\n首先，我们需要清除一些错误的数据。一个比较有效的统计方法是使用箱线图来去除极端的值。\n有些数据的特征可能含有缺失项，如果确实不具备参考价值可以直接删除（pandas 中可以调用 dropna）。但是如果要利用含有缺失项的特征，我们需要适当给予补充修复。常见的做法是使用已有数据平均值/中位数/默认值/相邻的值补全，或者采用某种公式插值（线性插值，例如按照时间排序的温度信息）。\n接下来我们需要做一些数据转化。对于实数特征我们可以按照某种公式进行规范化，对于图片我们可以裁剪、压缩等等，对于文本数据可以做分词和词的分类（英文单词的不同变形）等等。\n在这之后，我们可以使用特征工程的一些方法来筛选、简化、合并特征，使得之后的（深度）学习过程更加容易。为此我们主要进行特征选择，很多特征选择的方法也会对应特征的合并或者训练上的调整。\n箱线图1箱线图主要用于检测数据中的离群值。\n设 Q_2 表示所有数值的中位数，Q_1 表示小于 Q_2 这部分值的中位数（第一四分位数），Q_3 为大于 Q_2 这部分值的四分位数（第二四分位数）。[Q_1, Q_3] 就是箱子的范围。\n称 Q_3 - Q_1 = \\mathrm{IQR} 为四分位间距 Interquartile range。则 [Q_1 - 1.5\\mathrm{IQR}, Q_3 + 1.5\\mathrm{IQR}] 就是线段的范围。\n落在线段之外的值就是离群值（outlier）。下面就是本次作业的房子数据各个特征的箱线图，可以发现确实有许多离群值： 用到的库是 python 的 seaborn。\n信息熵首先我们给出信息熵的定义：对于随机变量 X，和其服从的概率分布 p，定义 H(X) = -\\sum_{x} p(x)\\log p(x)信息熵可以理解为系统内不同事件信息量的期望。\n对于两个随机变量 X, Y 和其联合分布，我们可以定义联合熵： H(X, Y) = -\\sum_{x, y} p(x, y)\\log p(x, y)它描述一个联合分布 p(x, y) 的不确定程度。此外，已知 X 时 Y 的不确定程度可以用条件熵表征： \\begin{align}\nH(Y | X) &= \\sum_{x} p(x) H(Y | X = x) \\\\\n&= -\\sum_{x} p(x) \\sum_y p(y | x) \\log p(y | x) \\\\\n&= -\\sum_{x, y} p(x, y) \\log p(y | x) \\\\\n\\end{align}条件熵与联合熵的关系是 H(X, Y) = H(Y) + H(X | Y) = H(X) + H(Y | X) = H(Y, X)，可以通过推导证明。有了熵，我们就可以定义互信息 I(X, Y) = H(X) + H(Y) - H(X, Y)结合一下条件熵与联合熵的关系，可以发现 I(X, Y) = H(X) - H(X | Y) = H(Y) - H(Y | X)，可以画出直观易懂的维恩图。\n决策树决策树可以将一组数据按照其特征进行分类，其中 根节点包含所有数据\n每个非叶子节点中的数据会按照某个属性进行分类，将分类的数据放在子节点中\n每个叶子节点对应决策结果 要构建决策树，主要考虑的问题是选择什么属性来划分数据最优。直观上我们希望划分后尽量是“均分”的，而不是所有数据归为一类。为了衡量划分的优秀性，我们可以结合上文提到的信息熵。\n划分准则我们可以使用信息增益来度量划分的优秀性。为此首先我们要度量数据集 D 在分类标签集 K 下的纯度： H_K(D) = -\\sum_{k \\in K} \\frac{|D_k|}{|D|} \\log \\frac{|D_k|}{|D|}其中 D_k 表示标签为 k 的数据集合，\\frac{|D_k|}{|D|} 自然表示划分到 k 类别所占的比例。H(D) 越高意味着样本纯度越低。\n特征 A 对 D 的信息增益定义为 g(D, A) = H_K(D) - \\sum_a \\frac{|D^{A=a}|}{|D|} H_K(D^{A=a})单从实现的角度，H_K(D) 可以不管。后面的和式描述的是特征 A 的每个取值下样本的纯度。显然纯度越有利于分类，因此我们取一个负号在前面。\n信息增益还可以理解为属性与标签之间的互信息。\n但是信息增益的问题是如果 A 的取值过多，每个取值下的数据过少，这样的分类效率和泛化性都不高。\n我们还可以采用增益率作为划分准则： g_R(D, A) = \\frac{g(D, A)}{H_A(D)}这样就缓解了上述问题。\n另一种划分准则是基尼指数（Gini index，也称 Gini Impurity）： \\mathrm{Gini}(D) =\\sum_{k \\in K} \\frac{|D_k|}{|D|}\\left(1- \\frac{|D_k|}{|D|}\\right) = 1 - \\sum_{k\\in K} \\left( \\frac{|D_k|}{|D|} \\right)^2特征 A 对 D 的 Gini 指数为 \\mathrm{Gini}(D, A) = \\sum_{a \\in A} \\frac{|D^{A = a}|}{|D|}\\mathrm{Gini}(D^{A=a})\\mathrm{Gini}(D, A) 越小，意味着以特征 A 划分后信息量越少，说明这种划分对提升数据纯度的帮助越大。\n事实上我们可以类比信息增益定义 Gini Decrease 为 \\mathrm{Gini}(D) - \\mathrm{Gini}(D, A)。\n回归树上面描述的都是利用离散的特征对数据分类的问题。\n如果特征是连续的值，我们可以将其按照某种分度离散化。\n如果目标是对数据的标签做回归分析（例如房价预测），我们只需要稍微魔改一下决策树就能解决这个问题。为此我们引入回归树。\n回归树与决策树结构相同，但是对于集合纯度我们使用 L_2 估计。设 L(D) 表示数据集的方差，L(D, A) = \\sum_a L(D^{A = a})，那么最优特征定义为 A^{\\ast} = \\arg\\min_{A} L(D, A)决策树和回归树在 sklearn.tree 中均有对应的 API 可以调用。\n数值规范化常见的规范函数有 线性映射为 [a, b] 之间的值（min-max normalization）： x_i' = \\frac{x_i - \\min}{\\max - \\min}(b - a) + a\n映射成均值为 0，方差为 1 的数据分布（z-score normalization）： x_i' = \\frac{x_i - \\bar{x}}{\\mathrm{std}(x)}\n十进制缩放（decimal scaling）： x_i' = \\frac{x_i}{10^j}其中 j 为使得 \\max_i |x_i'| &lt; 1 的最小的 j。 对数缩放（log scaling）： x_i' = \\log x_i 特征选择特征选择解决问题是：当可用的特征过多时，选择其中最合适的作为子集，最大化训练模型的效率。首先我们可以使用 Pearson 相关系数、互信息、Gini index 等方法来判断两个特征的相关程度。我们也可以将特征选择的过程和模型训练结合到一起，也就是嵌入法。还可以将特征选择看成搜索问题。\nPearson 相关系数中学知识： r = \\frac{\\sum(x - \\bar x) (y - \\bar y)}{\\mathrm{std}(x)\\mathrm{std}(y)}在 scipy 中有对应的 API。\n嵌入法对于一个回归问题，以线性回归为例，特征可以抽象为 d 维向量 \\vx，回归目标为 y。对于多个数据 (\\vx_1, y_1), \\ldots, (\\vx_n, y_n)，目标函数是 \\min\\sum(y_i - \\hat{y}_i)^2。使用的模型是 \\hat{y}_i =\\mathbf{w}^T\\vx_i。\n而 Lasso 方法则在线性回归的基础上对 \\mathbf{w} 的值进行 L_1 正则化： \\min \\sum (y_i -\\hat{y_i})^2 + \\theta \\sum_{k = 1}^n |w_i|在 L_1 正则化下，大部分系数会是一个接近 0 的数字，剩下的绝对值很大的系数对应的是重要的特征。这种方法统称嵌入法。\n值得一提的是，Ridge2 回归也使用了相似的思想，即在最小化损失的同时对参数进行规范化，如果要用它做特征选择可能会需要做一些矩阵运算。\n迭代法如果将特征选择看成搜索问题，暴力搜索有 2^N 种情况，十分不优秀。\n此时我们可以使用贪心的方法，从空集开始每次加入一个特征，并计算模型的性能提升程度（递增）；或者从全集开始每次减少一个特征，并计算模型的性能降低程度（递减）。\nGini Importance3也称 Mean Decrease in Impurity (MDI)。Gini Importance 的实现方式目前存在争议。这里我们讲的是 sklearn 的实现方法45。\n设决策树的结点集合为 T，D_u 表示结点 u 上的数据，A_u 表示 u 上用于分割的特征。那么特征 A 的 Gini Importance 定义为 \\sum_{u}[A_u = A] [\\mathrm{Gini}(D_u) - \\mathrm{Gini}(D_u, A_u)]\\frac{|D_u|}{|D|}Permutation Importance也称 Mean Decrease in Accuracy (MDA)。\n我们可以将数据的某个特征打乱顺序，计算打乱前和打乱后的准确性 a_0, a_1，那么这个特征的重排重要性就是 \\frac{a_0 - a_1}{a_0}，以此来估计哪些特征具有保留价值。\n在 sklearn.inspection 中有对应的 API。\nSHAP6SHAP 是一个用于特征解释的工具，也可以用于特征选择。\n相关连接 1. https://en.wikipedia.org/wiki/Box_plot &#8617; 2. https://en.wikipedia.org/wiki/Ridge_regression &#8617; 3. https://medium.com/the-artificial-impostor/feature-importance-measures-for-tree-models-part-i-47f187c1a2c3 &#8617; 4. https://scikit-learn.org/stable/modules/tree.html#tree-mathematical-formulation &#8617; 5. https://github.com/scikit-learn/scikit-learn/blob/108486011b833cef8061615d926e2883941b9123/sklearn/tree/_tree.pyx#L1114 &#8617; 6. https://github.com/slundberg/shap &#8617;","title":"AI 系统速通笔记之数据预处理","updated":"2025-04-23T04:07:19.262Z"},{"categories":[],"path":"String/AC/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Automaton","slug":"Automaton","permalink":"https://notes.sshwy.name/tags/Automaton/"}],"text":"发现了一种 AC 自动机的科学讲法，能够更准确地描述自动机中的数学模型和代码中的对象之间的关系。\n字典树模型假设有 m 个字符串 s_1, \\ldots, s_m，字符集为 \\Sigma，这些字符串构成的字典树为 T = (Q_T, \\delta_T)。其中 Q_T 表示字典树的所有状态，即所有的结点，而 \\delta_T: Q_T\\times \\Sigma \\to Q_T 表示字典树的转移函数，即转移边。\n考虑到任意 q \\in Q_T 都唯一对应一个字符串，我们也认为 Q_T 是一个字符串集合。\nAC 自动机模型对 T 构建的 AC 自动机可以表示为 A = (Q_A, \\delta_A)。\n任意 q_T \\in Q_T，与 q_A \\in Q_A 唯一对应， q_A 定义为 Q_T 中所有 q_T 的后缀（包括 q_T）形成的字符串集合。也就是说 Q_A 是一个字符串集簇。不妨记这个双射为 \\sigma: Q_T \\to Q_A，\\sigma q_T = q_A。\n\\delta_A: Q_A\\times \\Sigma \\to Q_A 是 AC 自动机的转移函数。对于 q \\in Q_A，c \\in \\Sigma，假设 q = \\{ s_1, \\ldots, s_t \\}（s_i \\in Q_T 且 s_i 是 s_{i + 1} 的后缀）。若存在最大的 k 使得 \\delta_T(s_k, c) 存在，那么 \\delta_A(q, c) \\triangleq \\sigma\\delta_T(s_k, c)（否则不定义 \\delta_A(q, c)）。\n要求出 \\delta_A，我们需要一个辅助函数 f: Q_T\\to Q_T。对于 \\sigma s_t = \\{ s_1, \\ldots, s_t \\} \\in Q_A，f(s_t) \\triangleq s_{t - 1}。这也是所谓的失配指针。有了 f，我们就可以观察到 q。\n引理 1：设 \\sigma \\delta_T(s, c) = \\{s_1c, s_2c, \\ldots, s_tc\\}（s_t = s），那么 \\{s_1, \\ldots, s_t\\} \\subseteq \\sigma s。\n证明：不是所有的 \\hat{s} \\in \\sigma s 都存在 \\delta_T(\\hat{s}, c)。\n断言 1：\\forall c\\in \\Sigma, s \\in Q_T，若 \\delta_T(s, c) 存在，那么 \\sigma f(\\delta_T(s, c)) = \\delta_A(f( s), c)。\n证明：由引理 1，可以发现 \\sigma f( \\delta_T(s, c)) 末尾去掉 c 得到的集合 \\subseteq \\sigma f(s)。结合 \\delta_A 的定义，在 \\sigma f(s) 中最大的 k 使得 \\delta_T(s_k, c) 存在，一定也是 \\sigma f(\\delta_T(s, c)) 中最大的 k，那么一定有 \\delta_T(s_k, c) = f(\\delta_T(s, c))。\n断言 2：\\forall c\\in \\Sigma： \\delta_A(\\sigma s, c) =\n\\begin{cases}\n\\delta_T(s, c) & \\text{If exists}\\\\\n\\delta_A(\\sigma f(s), c) & \\text{Otherwise}\n\\end{cases}证明：由 \\delta_A 定义和 f 定义。\n根据上述断言可以得出 AC 自动机的代码实现：\nstruct AC &#123; int tr[SZ][ALP], fail[SZ], tot; void init() &#123; tot = -1, new_node(); &#125; int new_node() &#123; return ++tot, fail[tot] = 0, memset(tr[tot], 0, sizeof(tr[tot])), tot; &#125; void insert(const char *s) &#123; for(int u = 0; *s; ++s)&#123; int c = *s - 'a'; if (!tr[u][c]) tr[u][c] = new_node(); u = tr[u][c]; &#125; &#125; int q[SZ], ql, qr; // q里就是BFS序 void build() &#123; ql = 1, qr = 0; FOR(i, 0, ALP - 1) if (tr[0][i]) q[++qr] = tr[0][i]; while (ql &lt;= qr) &#123; int u = q[ql++]; FOR(c, 0, ALP - 1) &#123; if (tr[u][c]) fail[tr[u][c]] = tr[fail[u]][c], q[++qr] = tr[u][c]; else tr[u][c] = tr[fail[u]][c]; &#125; &#125; &#125;\n&#125;;","title":"AC 自动机入门","updated":"2025-04-23T04:07:19.276Z"},{"categories":[],"path":"Math/Linear-Algbra/Basis/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"基（basis）是线性代数中的一个概念，它是描述、刻画向量空间的基本工具。而在现行的 OI 题目中，通常在利用基在异或空间中的一些特殊性质来解决题目，而这一类题目所涉及的知识点被称作「线性基」。\n有关向量空间（Vector Space）、线性无关（linearly independent）、线性组合（linear combination）、张成（Span）、基（Basis）的概念就不讲了，请自行了解。\n线性基简单来说，线性基维护的是异或空间下的若干个线性无关向量，它们组成一个矩阵。在实现时我们使用 b_i 表示最高位为第 i 位且为 1 的向量的值。\n线性基可以使用上三角矩阵维护，插入一个向量时需要消元，复杂度 O(\\log_2n)。在特殊题目的要求下可能需要消元成对角矩阵，这时的插入复杂度就是 O(\\log_2^2n)。\n线性基的合并就是暴力插入的过程，复杂度 O(n\\log_2^2n)。\nHDU3949 Xor\n求去重后异或第 k 小。 消成对角矩阵的线性基可以解决异或第 K 小的问题。由于是模板题所以给出核心代码：\n/******************heading******************/ int n; long long b[70],lb;\nlong long p[70],lp;\nbool insert(long long x)&#123; ROF(i,63,0)&#123; if(!(x>>i&amp;1))continue; if(!b[i])&#123; b[i]=x,lb++; ROF(j,i-1,0) if(b[i]>>j&amp;1)b[i]^=b[j]; FOR(j,i+1,63) if(b[j]>>i&amp;1)b[j]^=b[i]; return 1; &#125; x^=b[i]; &#125; return 0;\n&#125;\nvoid print()&#123; int len=0; FOR(i,0,63)if(b[i])len=i; FOR(i,0,len)&#123; ROF(j,len,0) printf(\"%lld\",b[i]>>j&amp;1); puts(\"\"); &#125;\n&#125;\nvoid work()&#123; FOR(i,0,63) if(b[i])p[lp++]=b[i];\n&#125;\nvoid clear()&#123; memset(b,0,sizeof(b)); lb=0,lp=0;\n&#125;\nlong long query(long long x)&#123; long long res=0; FOR(i,0,63)if(x>>i&amp;1)res^=p[i]; return res;\n&#125;\nvoid go()&#123; cin>>n; clear(); bool fl=0; FOR(i,1,n)&#123; long long x; cin>>x; if(!insert(x))fl=1; &#125; work(); long long lim=(1ll&lt;&lt;lb)-1; int q; scanf(\"%d\",&amp;q); FOR(i,1,q)&#123; long long x; cin>>x; if(fl)x--; if(x>lim)cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;query(x)&lt;&lt;endl; &#125;\n&#125;\nint main()&#123; int t; cin>>t; FOR(i,1,t)cout&lt;&lt; \"Case #\" &lt;&lt; i&lt;&lt; \":\" &lt;&lt;endl,go(); return 0;\n&#125;\n平方数的套路有时要求一段区间选若干个数乘积的平方数。记录每一个数的质因数次数的奇偶性，即一个 01 向量，就转化为异或和为 0 的问题。如果他们线性相关就有解，否则无解。\n带删除的线性基形式化地，我们要求支持： 插入一个数\n删除一个数\n求这个集合的线性基 算法一我们可以求出每个数的存在时间。然后在时间线段树上 DFS 即可。复杂度是 O(n\\log_2n\\log_2w) 的。\nBZOJ4184 shallot\n例题：最大 xor 路径。\n算法二我们也有更优秀的做法（在线）。\n插入 x，我们直接按照线性基的方式插入即可。\n但删除 x 就有一些问题。\n如果 x 不在线性基里：直接删了完事。\n如果 x 在线性基里，那么我们就需要做两件事： 消除 x 在线性基中的影响。\n可能在删除 x 后，有新的数可以被加到线性基中。 第一部分我们知道，把 x 插入到线性基中时，会先异或一些基，最后当 x 找到一个没有被 span 的维度（基）那么就做为一个新的基 x' 加入到线性基中（x' 就是 x 异或到最后的那个数）。\n而在之后插入的数中，有一部分基会异或 x'，那么这些基里就含有 x' 的影响。我们要做的就是消除这些影响。\n方法 1：我们可以直接拿 x' 异或这些基然后再删除 x'（异或自己），这样的确能消除影响，但问题是你这么搞完之后，线性基就不一定是上三角矩阵了，你还得想办法维护一下。\n方法 2：方法 1 的问题的出现原因是异或过 x' 的基都比 x' 小。因此我们不妨找到异或过 x' 的基中最小的基，记做 y'。那么 y' 里有什么？它有 x' 的影响，和除了 x' 之外的影响（废话）。我们的目的是消除所有 x' 的影响——也就是给他异或一个 x' 上去。我们不妨用 y' 异或所有的，异或过 x' 的基。 当 x' 异或上 y'，它相当于把 y' 消除 x' 的影响后放到 x' 的位置上。\n当 y' 异或其他基时尽管会顺带将 y' 的部分影响加到（去掉）这个基上，但这无关紧要。因为 y' 的基它还在（在 x' 的位置上）\n当 y' 异或自己时，它把自己删掉了。但这无所谓，因为 x' 的位置就是它新的位置。 这么一番操作，x' 没了 y' 还在。我称之为借刀自杀。\n第二部分接下来的问题是，你删了 x 对应的 x' 后，可能会有线性基外面的数能够加到线性基中。那么哪些数能被加进来？在之前的线性基表示中包含了 x' 的数。于是我们记一个 S(x') 表示在线性基外面包含 x' 的数的集合。那么我们在里面随便选一个数 z，然后在它的线性基表示的集合中删掉 z，把 z 插入后令 S(z')\\gets S(x') 即可。\n算法三上述算法中会用到 set，在较大的数据范围（2e6）下运行速度较慢。我们有常数更小的离线做法。\n在删除的时候我们要消除 x' 在线性基里的影响。那么如果 x' 本身就是最后一个被加入的数呢？那我们直接删了它就完事了。\n离线的时候，我们可以计算出每个数的删除时间。进而可以在线性基里维护每个基的删除时间。当插入一个数的时候，如果它当前异或的基的删除时间比它早，那么我们不如直接交换这个基和你当前的数。让你当前的数代替这个位置，让那个基来继续执行插入的操作。容易发现这样构造的线性基，小的基的删除时间都比大的基早，因此删除就可以直接删除了。\n时间复杂度仍是 O(n\\log_2w)，如果使用排序而不是 set，常数会比较小。\n线性基的一个神奇应用BZOJ3569\n通过随机赋权，判断是否线性相关的方式来判图是否连通。\n题解：\n先找出一个 dfs 树，考虑在什么情况下无向图会变得不连通。\n当且仅当存在一条树边，满足所有覆盖这条树边的返祖边和这条树边都被删除时，无向图不连通。\n那么如何判断是不是存在这样一条树边呢，我们可以给每条返祖边随机一个权值，每条树边的权值就是所有覆盖它的返祖边的权值异或和。对于一次查询，如果查询的边权线性相关说明一定能找到一个子集异或和为 0，也就是满足无向图不连通的条件了。\n参考文献https://blog.csdn.net/a_forever_dream/article/details/83654397","title":"线性基学习笔记","updated":"2025-04-23T04:07:19.268Z"},{"categories":[],"path":"Intro-to-Search.rs/","tags":[],"text":"搜索复习，但是 Rust。\n在描述各类搜索算法之前，我们先给出一个通用的问题定义：\ntrait Problem &#123; type State: State + Trans&lt;Self::Action>; type Action: Clone; fn init_state(&amp;self) -> Self::State; fn actions_of(&amp;self, s: &amp;Self::State) -> Vec&lt;Self::Action>;\n&#125;\nA* 算法A* 算法的框架其实就是 Dijkstra 算法求解最短路。在这个算法中，问题的每个状态都有一个估价，我们希望求出满足条件的代价最小的状态。为此我们定义搜索树上的结点为\ntrait Node&lt;P: Problem>: Sized + Copy &#123; fn create(s: P::State) -> Self; fn state(&amp;self) -> &amp;P::State; fn extend(&amp;self, a: P::Action) -> Self;\n&#125;\n接下来我们定义维护开结点的数据结构\ntrait FrontierSet&lt;P: Problem, N: Node&lt;P>> &#123; fn new() -> Self; fn remove_with_state(&amp;self, s: &amp;P::State) -> Option&lt;N>; fn empty(&amp;self) -> bool; fn push(&amp;mut self, node: N); fn pop(&amp;mut self) -> N;\n&#125;\n然后就可以描述 A* 算法为：\nfn a_star_search&lt;P: Problem, N: Node&lt;P> + Cost, Q: FrontierSet&lt;P, N>>(p: P) -> Option&lt;N> &#123; let mut frontier = Q::new(); frontier.push(Node::create(p.init_state())); let mut explored: HashSet&lt;P::State> = HashSet::new(); loop &#123; if frontier.empty() &#123; break None; &#125; let node = frontier.pop(); if node.state().is_terminal() &#123; break Some(node); &#125; explored.insert(node.state().clone()); for action in p.actions_of(node.state()) &#123; let child = node.extend(action); if !explored.contains(child.state()) &#123; frontier.push(child) &#125; else &#123; if let Some(frontier_node) = frontier.remove_with_state(child.state()) &#123; if child.cost() &lt; frontier_node.cost() &#123; frontier.push(child) &#125; else &#123; frontier.push(frontier_node) &#125; &#125; &#125; &#125; &#125;\n&#125;\nUCS 只根据之前花费的代价 g(n) 搜索，贪婪搜索只根据当前状态到达目标的估价 h(n) 搜索。而 A* 算法则同时考虑这两者，也就是说 A* 算法中一个状态的估价为 f(n) = g(n) + h(n)。此时的 f(n) 被称为启发式函数。\n只要保证对未来的估计 h(n) \\le 未来的真实代价，就能证明 A* 会找到最优解（可采纳）。\n爬山算法朴素的爬山算法会选择走到当前相邻状态中估价最高的状态，然后继续爬山。这里给出一些辅助的 trait：\ntrait ArgMax&lt;T> &#123; fn arg_max(&amp;self, f: impl Fn(&amp;T) -> f64) -> Option&lt;&amp;T>;\n&#125;\n以及对应的实现\nimpl&lt;T> ArgMax&lt;T> for Vec&lt;T> &#123; fn arg_max(&amp;self, f: impl Fn(&amp;T) -> f64) -> Option&lt;&amp;T> &#123; self.iter() .max_by(|a, b| f(*a).partial_cmp(&amp;f(*b)).unwrap()) &#125;\n&#125;\n这样我们就可以描述爬山算法了：\nfn hill_climbing&lt;P: Problem, N: Node&lt;P> + Cost>(p: P) -> N &#123; let mut cur: N = Node::create(p.init_state()); loop &#123; let neighbor = p .actions_of(cur.state()) .into_iter() .map(|a| cur.extend(a)) .collect::&lt;Vec&lt;N>>() .arg_max(Cost::cost) .cloned(); if let Some(neighbor) = neighbor &#123; if neighbor.cost() &lt;= cur.cost() &#123; break; &#125; cur = neighbor &#125; &#125; cur\n&#125;\n但可以明显发现上述算法不是很完备。为此衍生了很多变种： 随机平移：遇到平台时不直接退出，而是随机跳到一个邻居上（有一个次数上限）。\n随机爬山：随机跳到更好的邻居，不要求最好。\n第一选择爬山：跳到第一个更好的邻居，减少计算量。\n随机重启：搜索到一定程度没有进展后，随机一个初始位置重新开始。 模拟退火模拟退火可以看作是爬山算法的一个激进的变种：它不保证跳到比当前更优的状态，而是以一定概率跳到更劣的状态：\nfn simulated_annealing&lt;P: Problem, N: Node&lt;P> + Cost>(p: P, temperature: impl Fn(i32) -> f64) -> N &#123; let mut rng = thread_rng(); let mut cur: N = Node::create(p.init_state()); for t in 1.. &#123; let te = temperature(t); if te &lt;= 1e-9 &#123; break; &#125; let nex = p .actions_of(cur.state()) .random_pick(&amp;mut rng) .map(|a| cur.extend(a.clone())); if nex.is_none() &#123; break; &#125; let nex = nex.unwrap(); let delta_e = nex.cost() - cur.cost(); if delta_e > 0. || rng.gen_bool((delta_e / te).exp()) &#123; cur = nex &#125; &#125; cur\n&#125;\n约束满足问题与最小冲突算法。上述搜索算法对问题的建模是以状态-操作的模式进行的，这里我们考虑另一种形式的建模：Constraint Satisfaction Problem。\n我们有 n 个变量 x_1, \\ldots, x_n 和 m 个约束 c_1, \\ldots, c_m，每个变量有自己的值域。我们要给变量一组赋值使得 m 个约束均被满足。\n最小冲突算法可以求解约束满足问题（或近似解）。基本思路很简单：对于存在不满足约束（冲突）的变量，我们将其更新为其值域中冲突个数（估价）最小的那个值。如此反复。\nMinimax 搜索Minimax 搜索常用于解决双人零和博弈问题。\n直观理解是，我们对每个局面有一个估价（1 为先手胜 -1 为先手负）。我们总是希望走到估价最小的后继局面（这代表让对手难以获胜）\n#[doc = \" 计算当前局面的估价\"]\nfn minimax_evaluate&lt;P: Problem, N: Node&lt;P> + Cost>(p: &amp;P, node: N) -> f64 &#123; let acts = p.actions_of(node.state()); if acts.is_empty() &#123; return node.cost(); &#125; let mut r = -1.; for a in acts &#123; let nex = node.extend(a); let c = -minimax_evaluate(p, nex); r = f64::max(r, c); &#125; r\n&#125;\nAlpha-Beta 剪枝Minimax 搜索中，先取最大值后取最小值的时候，可以发现当内层局面的估价小于当前外层最大值时，将不会对结果产生更新，因此可以直接返回。先取最小值后取最大值同理。\n进一步思考可以发现，这其实就是在搜索的过程中给了一组上下界的限制。\n严谨一点，考虑 minimax 搜索的数学形式： \\begin{aligned}\nE(u) &= \\max_{u \\to v} \\{ -E(v) \\} \\\\ &= \\max_{u \\to v} \\{ - \\max_{v \\to w} \\{ -E(w) \\} \\}\n\\end{aligned}假设对 E(u) 的上下界是 \\alpha_u &lt; E(u) &lt; \\beta_u。那么有 \\alpha_u &lt; \\max_{u \\to v} \\{ -E(v) \\} &lt; \\beta_u所以只保留上下界之间的部分即可。于是 \\alpha_u &lt; -E(v) &lt; \\beta_u。此外在枚举 v' 时我们设之前求出的最大值为 r那么我们当然要求 r &lt; -E(v')，不然这个 E(v') 求出来就不会对答案有更新，即 E(v') &lt; -r。因此我们有 -\\beta_u &lt; E(v') &lt; \\min(-r, -\\alpha_u)fn alpha_beta_minimax&lt;P: Problem, N: Node&lt;P> + Cost>(p: &amp;P, node: N, alpha: f64, beta: f64) -> f64 &#123; let acts = p.actions_of(node.state()); if acts.is_empty() &#123; return node.cost(); &#125; let mut r = -1.; for a in acts &#123; let nex = node.extend(a); let c = -alpha_beta_minimax(p, nex, -beta, f64::min(-r, -alpha)); if c >= beta || c &lt;= alpha &#123; return r; &#125; r = f64::max(r, c); &#125; r\n&#125;\nMonte Carlo 树搜索蒙特卡洛树搜索算法利用随机采样与环境交互，利用探索-利用平衡进行学习。我们先来看一下它的代码框架：\nfn search&lt;P: Problem, N: MctsNode&lt;P>>(p: &amp;P, root: N, c: f64, lim: i32) -> N &#123; for _ in 1..lim &#123; let v = tree_select(root, c); let s = default_policy(p, v.state().clone()); back_up(v, s) &#125; best_child(root, 0.).unwrap()\n&#125;\n这里我们定义了一个新的结点类型：\ntrait MctsNode&lt;P>\nwhere P: Problem, Self: super::Node&lt;P>,\n&#123; fn expand(&amp;self) -> Option&lt;Self>; fn childs(&amp;self) -> Vec&lt;Self>; fn parent(&amp;self) -> Option&lt;Self>; fn visits(&amp;self) -> f64; fn win_rate(&amp;self) -> f64; fn update(&amp;self, s: &amp;P::State);\n&#125;\nMCTS 首先按照 exploration-exploitation tradeoff 的权重公式： \\arg\\max_{v \\to v'} \\frac{Q(v')}{N(v')} + c \\sqrt{ \\frac{2 \\ln N(v)}{ N(v)} \\frac{N(v)}{N(v')} }从根节点开始，从上至下选择值得探索的状态：\nfn tree_select&lt;P: Problem, N: MctsNode&lt;P>>(root: N, c: f64) -> N &#123; let mut v: N = root; while !v.state().is_terminal() &#123; if let Some(u) = v.expand() &#123; return u; &#125; v = best_child(v, c).unwrap(); &#125; v\n&#125;\nfn best_child&lt;P: Problem, N: MctsNode&lt;P>>(u: N, c: f64) -> Option&lt;N> &#123; let h = |v: &amp;N| v.win_rate() + c * (2. * u.visits().ln() / v.visits()).sqrt(); u.childs().arg_max(h).cloned()\n&#125;\n然后从这个状态出发，进行随机模拟（默认策略）完成一局游戏：\nfn default_policy&lt;P: Problem>(p: &amp;P, s: P::State) -> P::State &#123; let mut s = s; let mut rng = thread_rng(); while !s.is_terminal() &#123; let a = p.actions_of(&amp;s).random_pick(&amp;mut rng).unwrap().clone(); s = s.trans(a) &#125; s\n&#125;\n然后将结果向上传播，更新路径上的结点信息：\nfn back_up&lt;P: Problem, N: MctsNode&lt;P>>(v: N, s: P::State) &#123; let mut maybe_v = Some(v); while let Some(v) = maybe_v &#123; v.update(&amp;s); maybe_v = v.parent(); &#125;\n&#125;\n如此重复。最后搜素到一定程度后，通过 best_child 选择最终确定的决策。此时我们将探索参数置为 0，表示完全依赖我们搜索得到的信息。","title":"搜索复习","updated":"2025-04-23T04:07:19.266Z"},{"categories":[],"path":"Randomized/Distance/","tags":[],"text":"Hamming 空间最近邻（近似）：设有 n 个 d 维的 Hamming 空间上的点，要求给定 q\\in\\mathbb{H}^d，在 O(n^{\\frac{1}{1 + \\varepsilon}})时间内找到 (1 + \\varepsilon)-近邻。预处理时间限制为 O(n(d + n^{\\frac{1}{1 + \\varepsilon}}))。\n要解决这个问题，我们首先需要需要引入一些估计方法。\nMin Hash集合相似度度量：如何判断两个集合 A, B \\in [n] 的相似度？\n朴素想法：我们可以 O(|A| + |B|) 一一比对其中的元素。\n考虑定义集合的相似度：J(A, B) = \\frac{|A \\cap B|}{|A \\cup B|}。特别地，J(\\varnothing, \\varnothing) = 0。\n假设存在一个随机哈希 h，能够将 [n] 中的元素均匀随机映射到某个域上。那么 A 和 B 中的元素可以近似看作在 [n] 中均匀随机生成的数。\n设 h_{\\min}(S) = \\min_{x \\in S} h(x)。由于随机哈希，h(x) = h_{\\min}(S) 的概率是 \\frac{1}{|S|}。也就是说重复若干次随机哈希的过程，我们可以让每个数的哈希值成为最小值的次数差不多一致。这启发我们在判断集合中是否存在某个相同元素时，可以通过随机哈希转化为比较最小值的问题。\n引理：\\text{Pr}[h_{\\min}(A)=h_{\\min}(B)] = J(A, B)。如果两者相等，说明此次哈希随机到的数在两边都出现了。否则必然只在一边出现。\nChernoff bound: 设 x_1, \\ldots, x_T 是 \\{0, 1\\} 上的独立随机变量，\\bar{x} 为其均值，\\mu = E[\\bar{x}]。则对 t\\in[0, 1] 有 \\text{Pr}\\left[ \\left| \\bar{X} - \\mu \\right| \\ge t \\mu \\right]\n\\le 2e^{-t^2T\\mu/3}使用上述不等式可以分析需要的哈希个数，但要注意这和答案本身是有直接的关系的。\nSim Hash向量的相似性度量：判断高维空间两个向量的相似度？\n相似度的定义：\\sigma(\\vec x, \\vec y) = \\frac{(\\vec x, \\vec y)}{||\\vec x||_2, ||\\vec y||_2}，即 \\cos\\theta(\\vec x, \\vec y)。范数：||\\vec{x}||_p = (\\sum x_i^p)^{\\frac1p}。\n类似 Min Hash，我们希望通过概率反映 \\sigma(\\vec x, \\vec y)。这样就可以通过多次重复随机来近似计算相似度。\n考虑生成 d 维空间的一个随机高斯向量 \\vec w（先每一维分别独立服从正太分布，然后单位化）。定义 h(x) =\\begin{cases}\n1 & (\\vec w, \\vec x)\\ge 0\\\\\n0 & \\text{Otherwise}\n\\end{cases}那么我们声称：\\text{Pr}[h(x)\\ne h(y)] = \\frac{\\theta(\\vec x, \\vec y)}{\\pi}。下图是二维的情况： 取 T 个独立随机哈希，重复计算即可逼近相似度。\n这时如果令 f(\\vec x) = [h^{(1)}(\\vec x), h^{(2)}(\\vec x), \\ldots, h^{(T)}(\\vec x)]，就会发现 \\sigma(\\vec x, \\vec y)\\approx \\frac{1}{T} \\text{popcount}(f(\\vec x)\\oplus f(\\vec y))。\n因此可以将 f 视作 \\mathbb{R}^d 到 T 维 Hamming 空间（超立方体空间）的映射。\n于是我们就得到了 T 维 Hamming 空间中距离的一个估计函数：\\text{dist}_H(f(\\vec x), f(\\vec y)) \\approx \\frac{T\\theta(\\vec x, \\vec y)}{\\pi}。\nHamming 空间近似最近邻注意到 Sim Hash 中给出的估计函数是关于 f(\\vec x) 和 f(\\vec y) 的距离。如果要直接估计 p, q\\in \\mathbb{H}^d 的距离的话，就需要找到某个映射 f: \\mathbb{H}^d \\to \\mathbb{H}^d，使得 \\text{dist}_H(f(p), f(q)) = \\text{dist}_H(p, q)。\n不难想到取 f 为随机 d 阶排列。生成随机排列：a_i 和前面随机一个数交换。\n当然这道题要求找到 (n + \\varepsilon)-近邻，因此对于询问的 q 我们要找到距离最小的点。\n其实结合刚刚的 Min Hash，如果将 Hamming 空间中的点视作 [d] 的子集，那么 f 就相当于是一个随机哈希。而如果取了足够多的 f，那么 q 与 q 的近似最近邻的相同部分总会在某个哈希中被 roll 到前几个位置上去。基于这样的思想，我们可以用 LCP 来去掉不优的点。\n假设取了N 个 f。\n考虑所有 \\{ \\text{LCP}(f^{(i)}(p), f^{(i)}(q)) \\}_{p\\in S,1\\le i\\le N}。我们找到其中长度最大的 2N 个LCP 对应的 p，然后计算这些点与 q 的最近邻。\n参数分析略（太复杂了没学会）。","title":"「随机算法专题」距离与相似度的度量","updated":"2025-04-23T04:07:19.275Z"},{"categories":[],"path":"Math/Counting-IM/","tags":[{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"SetAndSet\n给出一个长度为 n 的非负整数序列 a，要求将 a 中的元素染红或染蓝，使得： 至少有一个红色元素；\n至少有一个蓝色元素；\n红色元素的按位与等于蓝色元素的按位与。 问有多少种合法的染色方案。\nn\\le 50,a_i&lt;2^{20}。 容斥\n考虑二进制下第 x 位。如果所有数的第 x 位都是 1，那么就可以不管这一位。否则，这一位为 0 的数不能全部分在一个集合。\n考虑容斥，容斥哪些位的 0 分在同一集合。那么转化为无限制减去全部分在同一集合，用并查集统计有多少个连通块，容斥贡献就是 2^{cnt}-2，减 2 是因为要非空。\n使用 DFS 写容斥可以少一个 20，时间复杂度 O(2^{20}n)。\n代码\nEndless Spin\n给出 n 个球排成一排。初始时每个球都是白的。每次从 \\frac{n(n+1)}{2} 个区间中等概率选择一个区间，把里面的求染黑。问期望多少次可以把所有球染黑。\nn\\le 50。 期望 容斥 DP\n设随机变量 x_i 表示第 i 个球被染黑的时间，且 S=\\{x_1,\\cdots,x_n\\}。那么答案可以表示为 E(\\max S)=\\sum_{T\\subseteq S}E(\\min T)(-1)^{|T|-1}\\\\对于集合 T，我们需要求出，选到至少一个球的期望时间。期望是概率的倒数，转化为选到至少一个球的概率。那么假设对于集合 T 的元素，有 A 个区间可以让我们至少选到一个元素，那么概率就为 \\Pr(T)=\\frac{2A}{n(n+1)}，因此期望为 \\frac{1}{\\Pr(T)}。\n那么如果我们求出 F(k)\\sum_{T\\in S,|T|=k}\\frac{1}{\\Pr(T)}答案就为 \\sum_{k=1}^{|S|}F(k)(-1)^{k}考虑“至少选到一个”不好求，我们转化为，求一个都选不到。设 f(i,j,k) 表示考虑前 i 个点，有恰好 j 个区间，最后一个被选的点到第 i 个点的距离为 k ，使得这 j 个区间选不到白点的方案数（可以理解为这个概率的出现次数），再记一个 bit 表示这个部分的容斥系数： f(i,j,k,bit) \\to f(i+1,j,0,\\neg bit)\\\\\nf(i,j,k,bit) \\to f(i+1,j+k+1,k+1,bit)那么答案为 \\sum_{A=0}^{\\frac{1}{2}n(n+1)-1}\\sum_{k=0}^n\\frac{1}{1-\\frac{2A}{n(n+1)}}\\cdot f(n,A,k,bit)(-1)^{bit}高精度用 python 打表即可。\n时间复杂度 O(n^4)。\n代码\n代码 python\nCTS2019 随机立方体\n有一个 n\\times m\\times l 的立方体，立方体中每个格子上都有一个数，如果某个格子上的数比三维坐标至少有一维相同的其他格子（三个方向的格子的集合）里的数都要大的话，我们就称它是极大的。\n现在将 1,2,\\cdots,nml 随机填入到 n\\times m\\times l 个格子中，使得每个数恰出现一次，求恰有 k 个极大的数的概率，对 998244353 取模。\nn,m,l\\le 5\\times 10^6,k\\le 100。 二项式反演 概率 组合数 线性求逆元\n设 g(k) 表示恰有 k 个的概率。那么设 f(k) 表示至少有 k 个的概率。那么每个 g(i) 就被 f(k) 计算了 \\dbinom{i}{k} 次，根据二项式反演，得到 \\begin{aligned}\nf(k)&=\\sum_{i=k}^n\\binom{i}{k}g(i)\\\\\ng(k)&=\\sum_{i=k}^n\\binom{i}{k}f(i)(-1)^{i-k}\n\\end{aligned}考虑求 f(k)。显然我们可以钦定 k 个最大值，那么不妨设这 k 个最大值的位置分别在 (i,i,i),i\\in[1,k] 的地方。并且我们要求 a_{i,i,i}\\le a_{i+1,i+1,i+1},i\\in[1,k)。然后这 k 个数是各自的 3 个方向上切面的最大值。容易发现，这形成了一个树形结构（可以看二维的情况模拟得到），那么我们的问题等价于，给一棵树的每个结点分配一个标号，使得每个点是子树最大值的概率。答案即为每个子树的大小之和。由于这棵树的形态特殊，因此实际上可以得到概率为 \\prod_{i=1}^k\\frac{1}{nml-(n-i)(m-i)(l-i)}然后考虑这 k 个最大值的位置（刚才我们是钦定的位置，没有讨论过），那么第一个有 nml 种选择，第二个有 (n-1)(m-1)(l-1) 种选择，以此类推。则总方案数为 n^{\\underline{k}}m^{\\underline{k}}l^{\\underline{k}}。因此得到 f(k)=n^{\\underline{k}}m^{\\underline{k}}l^{\\underline{k}}\\prod_{i=1}^k\\frac{1}{nml-(n-i)(m-i)(l-i)}显然 f 是可以递推的： \\begin{aligned}\nf(i)&=f(i-1)(n-i+1)(m-i+1)(l-i+1)a_i\\\\\na_i&=\\frac{1}{nml-(n-i)(m-i)(l-i)}\n\\end{aligned}那么我们线性求 a_i 的逆元即可（注意，线性求逆元在 a_i 含有 0 的时候有 bug，但是本题中不会出现这种情况），时间复杂度 O(n)。\n代码\nSquare Constraints设 \\begin{aligned}\nf(i)&=\\left\\lfloor \\sqrt{n^2-i^2-1} \\right\\rfloor+1\\\\\ng(i)&=\\min\\left(\\left\\lfloor \\sqrt{4n^2-i^2} \\right\\rfloor+1,2n\\right)\n\\end{aligned}原题目的限制可以表示为 \\forall i\\in[0,2n),f(i)\\le P_i&lt; g(i)考虑容斥下界。那么我们就枚举这 2n 个数中有 k 个数 &lt; f(i)。假设我们确定了 k 个数 x_1,\\cdots,x_k(x_i\\in[0,n))，这个 k 个数的限制是 P_{x_i}&lt;f(x_i)，所有数的限制是 P_i&lt;g(i)（注意到 f(i)\\le g(i)，g 是包含了 f 的），求这样的方案数。那么我们把每个数的限制从小到大排序，形成一个长度为 2n 的数组 h，那么答案为 \\prod_{i=0}^{2n-1}(h_i-i)但是这 k 个数是不确定的。我们考虑把 f(i),i\\in[0,n) 和 g(i),i\\in[0,2n) 放在一起升序排序得到序列 A，并且我们把 f(i) 标记为a，把 g(i),i\\in[0,n) 标记为b，把 g(i),i\\in[n,2n) 标记为c。那么 A 的标记数组 B 一定长成aaccac...bbbbb的形式，即a、c全在前面，b在后面的形式。\n相当于我们从这 3n 个数中选择 2n 个出来，满足对于 i\\in[n,2n) 的部分我们选择 g(i)（即所有的c必选），然后我们选择 k 个 f(x_i)（相当于选择 k 个a），然后剩下的选 g(i)（相当于选择b）。\n由于 f(i),g(i) 都是非递增的，因此相当于你选了第 i 个a就不能选第 i 个b。因此我们就转化为了求出，选 k 个数的限制为 &lt;f(i) 的容斥贡献和。这个可以 DP 做，设 F(i,j) 表示在考虑前 i 个数以及对应的前若干个b，我们选 j 个a的容斥贡献和。设 b_i 表示当 B_i=a 时它对应的b的位置，方便转移。那么贡献和就是 F(2n,k)。\n代码\nTwo Histograms对于一个方案，如果存在 k_i,l_j 使得 k_i=j-1,l_j=i，那么我们就把它变成 k_i=j,l_j=i-1。如果不存在，就是一个“合法”的方案。\n我们只需要统计出所有“合法”的方案就是答案。证明见官题。\n考虑容斥，则答案为 \\sum_{i=0}^n\\binom{n}{i}\\binom{m}{i}i!(m+1)^{n-i}(n+1)^{m-i}(-1)^i代码\nHamiltonianPaths\n有一个 k 个点的无向简单图，你把它复制 n-1 次变成一个 nk 个点的图，然后求补图的哈密尔顿路径（有向）的数目。\nk\\le 14,n\\le 5\\times 10^4。 设原图上的边为不合法的边，我们要求不能经过不合法的边。考虑容斥，问题转化为，钦定经过 k 条不合法的边，其他点无限制，问哈密尔顿路径的数目，这样的容斥贡献是 (-1)^k。\n我们先不考虑复制的操作，考虑在原图及其补图上求出经过 k 条不合法的边的哈密尔顿的路径数的容斥贡献和。\n更具体地，设 f(S,x) 表示在原图上，点集 S 以 x 结尾的哈密尔顿路径数，乘上容斥系数，这个可以 DP 求出： f(S\\cup \\{y\\},y)=\\sum_{(x,y)\\in E}(-1)f(S,x)那么设 F(S) 表示在原图上点集 S 的哈密尔顿路径数，即 F(S)=\\sum_{x\\in S}f(S,x)。\n于是，我们设 g(S,x) 表示在原图上点集 S 被分成 x 条路径的方案数（单点算一条路径），显然可以枚举第一个点 / 最后一个点所在的子集 T，用 F(T) 转移： g(S,x)=\\sum_{T}F(T)g(S\\setminus T,x-1)那么，我们就求出了把原图划分为 x 条不合法的路径的方案数的容斥贡献和 G(x)=g(U,x)。考虑复制了 n-1 遍，能否求出新图的 G？\n答案是可以。注意到复制 n-1 遍的 G 即为 G^n(x)，因此做 n 次 FFT 即可（用快速幂）。\n求出了这个 G^n(x)，那么答案就为 \\sum G^n(i)i!，表示你把这 i 条不合法路径用 i-1 条合法的边（合法的边就是补图上的边）连起来，连成一个哈密尔顿通路的方案数，显然这 i 条路径的顺序可以任意安排，因此有 i! 种方案。至于容斥系数在一开始的时候就计算过了，因此不用乘 (-1)^k。\n时间复杂度 O(nk\\log_2n)。\n代码\nZJOI2016 小星星我们把双射放缩为一个函数 p(i)\\in[1,n]，那么我们希望 p(1),\\cdots,p(n) 中，1,\\cdots,n 都出现过。\n考虑容斥，我们枚举哪些值没有出现（即我们允许多个点对应一个点）。没有出现，我们就直接在图上删掉这个点。于是考虑 DP，设 f(u,v) 表示考虑 u 的子树，且 u 和原图上的 v 对应，问有多少种对应方案。转移时枚举每个儿子的对应方案： f(u,v)=\\prod_{x\\in Son(u)}\\sum_{(v,y)\\in E}f(x,y)DP 的复杂度是 O(n^3) 的，加上枚举的复杂度，总复杂度 O(n^32^n)。\n代码\nFireflies设 M=\\left\\lfloor\\frac{1}{2}\\sum_{i=1}^n(p_i+1)\\right\\rfloor问题可以通过一堆定理转化为，求 \\sum_{i=1}^nx_i=M 且 1\\le x_i\\le p_i 的解的方案数。\n考虑容斥，转化为枚举 S\\in[n] 集合内的元素不满足限制，则可以得到 \\sum_{S\\in[n]}(-1)^{|S|}\\max\\left(0,\\binom{M-1-\\sum_{x\\in S}p_x}{n-1}\\right)\\\\\n=\\sum_{S\\in[n]}(-1)^{|S|}\\binom{\\max(0,M-1-\\sum_{x\\in S}p_x)}{n-1}直接做的复杂度为 2^n，不能接受。考虑 meet-in-middle。\n根据范德蒙德卷积 \\binom{a+b}{n}=\\sum_{i=0}^n\\binom{a}{i}\\binom{b}{n-i}那么我们把 U 拆成两个集合 A,B，可以得到 \\binom{M-1-\\sum_{x\\in S}p_x}{n-1}=\n\\sum_{i=0}^{n-1}\\binom{M-1-\\sum_{x\\in S\\cap A}p_x}{n-1-i}\n\\binom{-\\sum_{x\\in S\\cap B}p_x}{i}因此，设 S\\in2^A,T\\in 2^B，那么上式可以等价地表示为 \\binom{M-1-\\sum_{x\\in S\\cup T}p_x}{n-1}=\n\\sum_{i=0}^{n-1}\\binom{M-1-\\sum_{x\\in S}p_x}{n-1-i}\n\\binom{-\\sum_{x\\in T}p_x}{i}那么原式即为 \\sum_{S\\in 2^A,T\\in 2^B}(-1)^{|S\\cup T|}\n\\sum_{i=0}^{n-1}\\binom{M-1-\\sum_{x\\in S}p_x}{n-1-i}\n\\binom{-\\sum_{x\\in T}p_x}{i}\\\\\n=\\sum_{S\\in 2^A,T\\in 2^B}\n\\sum_{i=0}^{n-1}(-1)^{|S|}\\binom{M-1-\\sum_{x\\in S}p_x}{n-1-i}\n(-1)^{|T|}\\binom{-\\sum_{x\\in T}p_x}{i}设出函数来简化问题 \\begin{aligned}\nf(S,i)&=(-1)^{|S|}\\binom{M-1-\\sum_{x\\in S}p_x}{n-1-i} & (S\\in 2^A)\\\\\ng(T,i)&=(-1)^{|T|}\\binom{-\\sum_{x\\in T}p_x}{i} & (T\\in 2^B)\n\\end{aligned}注意 f(\\varnothing,n-1)=g(\\varnothing,0)=1。那么原式进一步简化为 \\sum_{S\\in 2^A,T\\in 2^B}\\sum_{i=0}^{n-1}f(S,i)g(S,i)\n=\\sum_{i=0}^{n-1}\\sum_{S\\in 2^A}f(S,i)\\sum_{T\\in 2^B}g(S,i)那么我们在求和的过程中，只需要保证 M-1-\\sum_{x\\in S}p_x-\\sum_{x\\in T}p_x\\ge 0 即可。这个可以排序后双指针实现，再加上前缀和优化，就可以 O(2^{n/2}n) 合并答案。f，g 可以各自递推求出： \\begin{aligned}\nf(S,i)&=f(S,i+1)\\frac{M-1-\\sum_{x\\in S}p_x-(n-2-i)}{n-1-i}\\\\\ng(T,i)&=g(T,i-1)\\frac{-\\sum_{x\\in T}p_x-(i-1)}{i}\n\\end{aligned}注意，使用下降幂计算组合数，上部是可以为负数的： \\binom{n}{m}=\\frac{n^{\\underline{m}}}{m!}注意，范德蒙德卷积是可以做负数的。\n总复杂度 O(2^{n/2}n)。\n代码","title":"计数习题总结","updated":"2025-04-23T04:07:19.267Z"},{"categories":[],"path":"Randomized/Count-min-Sketch/","tags":[],"text":"Point Query 问题：给出 n 个数 a_1, \\ldots, a_n，0\\le a_i\\le M，你需要（近似）回答 x 的出现次数。\n容易想到直接开一个桶，空间复杂度 O(n)。我们希望在 n 很大时用更小的空间复杂度解决这个问题。\nCount-min SketchCount-min Sketch 是一个数据结构，通过随机哈希的方式来给出上述问题的近似解。\n考虑构造一个随机哈希函数 h: [M] \\to [m]，将输入的元素均匀映射到 m 个 bucket。\n利用这个哈希来计算每个哈希值的出现次数：C[x] = \\sum_i P[h(a_i) = x]。那么记 x 的真实出现次数为 c_x = \\sum_i[a_i = x]，显然有 C[h(x)] \\ge c_x，在哈希不冲突时取等。\n容易想到，多次采用不同的随机哈希 h_1, \\ldots, h_t 分别统计出现次数 C_1, \\ldots, C_t，那么取 \\min_{1\\le j\\le t} C_j[h_j(x)] 可以很好地逼近 c_x。\n对此进行更细致的期望分析： \\begin{align}\nE\\big( C[h(x)]\\big) &= E\\left(\\sum_i [h(a_i) = h(x)] \\right) \\\\\n&= E\\left(c_x + \\sum_{y\\in [M], y\\ne x} [h(y) = h(x)] c_y \\right) \\\\\n&= c_x + \\sum_{y\\in [M], y\\ne x} E\\big( [h(y) = h(x)] \\big) c_y \\\\\n&= c_x + \\sum_{y\\in [M], y\\ne x} \\text{Pr}[h(y) = h(x)]c_y \\\\\n\\end{align}假设哈希函数是均匀随机，那么 \\text{Pr}[h(y) = h(x)] = \\frac{1}{m}，于是 E\\big( C[h(x)]\\big) = c_x + \\frac{1}{m} (n - c_x) \\le c_x + \\frac{n}{m}于是我们对该随机算法进行误差估计： \\text{Pr}\\big[ C[h(x)] - c_x &gt; n\\varepsilon \\big] \\le \\frac{E\\big( C[h(x)] - c_x \\big)}{n\\varepsilon}\n= \\frac{1}{m\\varepsilon}这里面用到了 Markov Inequality：若 X\\ge 0，有 a\\cdot \\text{Pr}[X\\ge a] \\le E(X)。\n取 m = \\frac{2}{\\varepsilon} 可以控制上述概率不大于 \\frac{1}{2}，那么我们取 O(\\log_2n) 个独立随机哈希（若已知 n 的上界），即可求出绝对误差在 n\\varepsilon 内的近似解。\n空间复杂度 O(mt) = O(m\\log_2n)。\nK-Heavy HitterK-Heavy Hitter 问题：给出 n 个数 a_1, \\ldots, a_n，0\\le a_i\\le M，你需要（近似）求出出现次数前 k 多的所有数。\n对于上述问题我们仍然有空间复杂度 O(n) 的朴素算法。\n近似 K-Heavy Hitter：要求必须求出所有出现次数不少于 \\frac{n}{k} 的数，并且求出的所有数的出现次数不少于 \\frac{n}{k} - n\\varepsilon。\n若已知 n，那么求近似解可以直接使用 Count-min Sketch 解决。考虑 n 上界未知但 \\log_2n 上界已知的情况。\n我们维护当前插入的总元素个数 n'。在 Count-min Sketch 的基础上我们额外维护一个集合 L，用于记录 Count-min Sketch 意义下出现次数不小于 \\frac{n'}{k} 的数。每次插入元素后，我们将出现次数小于 \\frac{n'}{k} 的数从中删除。\n可以发现近似 K-Heavy Hitter 的误差主要是留给 Count-min Sketch。而上述 L 集合的维护其实是足够准确的。\n由于出现次数不小于 \\frac{n}{k} 的数字个数是 O(k) 的，因此 L 的空间大小有保证。在考虑到 Count-min Sketch 的误差后可以得出该算法的空间复杂度为 O(m\\log_2n + k + \\frac{1}{\\varepsilon})。\n一个可能的代码实现：\nclass Solver &#123;\npublic:\n#define FOR(a, b, c) for(int a = (int)(b); a &lt;= (int)(c); a++) int n1 = 0, k = 0; // current total numbers int* L, len = 0; static const int T = 6; // number of hash tables // const double eps = 0.01; static const int M = (5 * (1 &lt;&lt; 20)) / T; // 2 / eps + 11; // size of hash table struct hash_table &#123; int seed; int* bucket; hash_table() &#123;&#125; hash_table(int seed, int* bucket): seed(seed), bucket(bucket) &#123; FOR(i, 0, M - 1) bucket[i] = 0; &#125; void add(int val) &#123; bucket[fasthash64(val, seed) % M]++; &#125; int get(int val) &#123; return bucket[fasthash64(val, seed) % M]; &#125; &#125;; hash_table h[T]; int count_min(int e) &#123; int res = h[0].get(e); FOR(i, 1, T - 1) res = min(res, h[i].get(e)); return res; &#125; // arr 是题目提供的内存空间，约为 32MB void init(int* arr, int m, int _k) &#123; k = _k; FOR(i, 0, T - 1) &#123; h[i] = hash_table(1145140 + i, arr + M * i); &#125; L = arr + M * T; &#125; void add(int e) &#123; ++n1; FOR(i, 0, T - 1) h[i].add(e); FOR(i, 0, len - 1) &#123; if (count_min(L[i]) &lt; n1 * 1.0 / k) &#123; // delete it L[i] = L[len - 1]; --len, --i; &#125; &#125; if (count_min(e) >= n1 * 1.0 / k) &#123; FOR(i, 0, len - 1) &#123; if (L[i] == e) return; &#125; L[len++] = e; &#125; &#125; std::vector&lt;int> report() &#123; return vector&lt;int>(L, L + len); &#125;\n&#125;;","title":"「随机算法专题」Count-min Sketch 入门","updated":"2025-04-23T04:07:19.275Z"},{"categories":[],"path":"Texas_Holdem/","tags":[],"text":"作为一个大学生，想必德州扑克是基本的社交方式之一，今天就来写一个规则，以后方便大家看。\n德州扑克的规则分两部分。\n比大小比大小的规则决定谁是赢家。每个人手中会有两张手牌（仅自己看见），而公共区域有五张牌（所有人都可以看见），也就是说一个玩家一共可以看见七张牌。你需要从你看见的七张牌中选择恰好五张组成最大的牌型。最后将每个玩家的最大牌型做比较，最大的（可能不唯一）获得胜利。\n牌型从大到小分别是： 相同的牌型按照规定顺序排好后比较字典序。比如三条的规定顺序是三条排前面，两个单张排后面（大的在前小的在后）。\n需要注意：在顺子中 A 既可以当作 14 （10JQKA）也可以当作1（A2345，此为最小顺子）。\n游戏过程游戏的过程可以概括为： 小盲、大盲（小盲的两倍）下注，大盲是小盲的下家（逆时针）\n从小盲开始逆时针依次发牌，每人两张。\n（入场注）从大盲的下家开始依次下注，首轮下注为限定注，数额为大盲的数额，到小盲的上家为止。\n（首轮）从小盲开始下注为非限定注，可进行非连续的自由加注。\n发三张公共牌（都可看见），然后从小盲开始下注（非限定）。\n发一张公共牌，然后从小盲开始下注（非限定）。\n发一张公共牌，然后从小盲开始下注（非限定）。\n场上玩家公开手牌决定胜负。 下注在决定胜负前，奖池中的筹码是每个人分开计数的，不能混到一起。每轮下注从小盲开始逆时针依次询问。\n任何时候退出游戏，奖池中的筹码都无法收回。任何时候退出游戏，在游戏结束前不可公开手牌。\n下注的总体规则是：你需要将你下的注补到场上的最高注。只有一个例外：如果你没钱了，就可以不用补到最高注。否则视为退出游戏。\n在非限定注的情况下可以加注（也就是比最高注严格更多）。只要在场（即尚未退出的）玩家还有人没有下到最高注（并且不是没钱的那种）那么就得继续轮询下注。\n一个玩家不可连续加注：也就说如果本轮下注的上一次加注是你，那你无法再次加注。\n如果本轮下注开始时，你已经是场上的最高注（实际上本来就是这样），那么你可以不加注。\n筹码分配场上的赢家可以收回自己投入奖池的筹码。剩余的筹码可以平分。如果你梭哈了，那么你从每个失败的玩家中拿到的筹码不得多于你下注的筹码数。","title":"德州扑克规则（本地特色）","updated":"2025-04-23T04:07:19.277Z"},{"categories":[],"path":"Intro-to-Calculational-Programming-2/","tags":[],"text":"书接上文，在熟悉了基本的函数式编程的思想后，我们就来一起推导出最大子段和的线性算法。\n推导最大子段和线性算法回顾一下最大子段和的 Specification：\nmss = maximum . map sum . concat . map tails . inits\n以及上文中提到的基本函数：foldl，foldr，scanl，scanr 等等，忘了的自己回去看看。\n在此我们约定一个新的高阶函数：reduce，满足 reduce f === foldl f e === foldr f e。我们要求传递给它的二元函数具有结合律，并且 e 是这个运算的单位元。这主要是方便大家阅读。所有用到了 reduce 的地方默认如此（注意，传给 reduce 一个空序列的返回值是单位元，也就是说 reduce f [] = e）。\n我们要做的第一个变换是 map promotion：map sum . concat === concat . map (map sum)。通过简单的类型推导可以发现左右两边接受的参数都是三维列表。\nmss = maximum . concat . map (map sum) . map tails . inits\n下一步操作是 reduce promotion：maximum . concat === maximum . map maximum。也就是说你把一个二维数组先拼起来再求最大值，等价于把内层的数组分别求出最大值，再在这些求出来的结果中求出最大的那个。\nmss = maximum . map maximum . map (map sum) . map tails . inits\n接下来是 map 关于复合的分配律：map f . map g === map (f . g)。这个很好理解，你把一个数组里的数先全体加 2 再全体平方，等价于数组里的数分别做一次加 2 平方的操作。这里我们要求 g 的返回值类型与 f 接受的参数类型相同。带入这个定理可以得到\nmss = maximum . map (maximum . (map sum) . tails) . inits\n接下来我们先拆解 maximum 函数：maximum === reduce max，（max 具有结合律，单位元是负无穷，这也是上文 reduce promotion 可以用在 maximum 上的原因）。\n另一方面，sum === reduce (+)。对于 S 集合上的两个幺半群 (S, f, e_f)，(S, g, e_g)，若 g 对 f 有右分配律（g(f(a, b), c) = f(g(a, c), g(b, c))）那么\n-- Horner's Rule\nreduce f . map (reduce g) . tails === foldl h e-g\n其中 h(a, b) = f(g(a, b), e_g)。这里可能大家看得有点懵，不妨 f 带入加法，g 带入乘法感受一下。它表达的意思其实是 abcd + bcd + cd + d + 1 = (1\\times a + 1)\\times b + 1)\\times c + 1)\\times d + 1把 f 带入 max，g 带入加法，你会发现这个本质上是对最大后缀和这一问题的优化，于是我们得到\nh a b = max (a + b) 0\nmss = maximum . map (foldl h 0) . inits\n最后是 scanl 的定义。我们说 scanl 其实相当于把 foldl 的中间计算结果保留下来，也就是说它求出了每个前缀的计算结果：\n--- 别忘了 inits 会求出所有前缀\nscanl f z === map (foldl f z) . inits\n因此我们就得到了\nh a b = max (a + b) 0\nmss = maximum . scanl h 0\n仔细看看它，你会发现它和我们所写的最大子段和算法基本一致。\n整个推导过程如下：\nh a b &#x3D; max (a + b) 0 mss &#x3D; maximum . map sum . concat . map tails . inits &#x3D; maximum . concat . map (map sum) . map tails . inits &#x3D; maximum . map maximum . map (map sum) . map tails . inits &#x3D; maximum . map (maximum . (map sum) . tails) . inits &#x3D; maximum . map (foldl h 0) . inits &#x3D; maximum . scanl h 0\n后续为了方便大家理解，有关 Agda 的部分我删掉了，不然有的地方会很繁琐。程序演算的应用还有很多，比如推理 FFT 的算法等，希望大家看完后都能有所收获～","title":"函数式程序设计 / 程序演算入门 Part 2","updated":"2025-04-23T04:07:19.266Z"},{"categories":[],"path":"Intro-to-Calculational-Programming/","tags":[],"text":"本文是对胡振江老师所教授的计算概论课实验班内容的期末复习笔记，但因为这部分内容很有意思，所以我会尽量写得通俗易懂，能够让大家也“云课堂”。考虑到大家都是 OIer，所以我也不会写得很啰嗦，保证大家的阅读体验。\n首先简述一下这门课大致的学习路线：Haskell -&gt; Agda -&gt; Bird Meerteen Formalism。下面我们一个一个来说。\n函数式编程（Functional Programming）在这门课中首先你将会学习函数式编程的基本思想。函数式编程简单来说就是：只有常量，没有变量。各位对面向对象、面向过程这一类编程范式想必已经精通，但函数式编程和算法竞赛中学习的内容相去甚远。\nC++ 对函数式编程的支持近乎为零。虽然官方在很努力地抄 Haskell 了，但是它自身的历史包袱以及应用场景就决定了没人用它写函数式编程。例如它难以方便地对函数进行变换。我们还是可以勉强用 C++ 来写一些函数式编程：\nint fact(const int n) &#123; return n == 0 ? 1 : fact(n - 1) * n;\n&#125;\n这算是遵循 FP 思想写出来的最简单的函数式编程了，它的作用想必大家都了解，等价的 Haskell 代码如下：\nfact :: Int -> Int -- 其实这行可以省略\nfact n = if n == 0 then 1 else n * fact (n - 1)\n想必大家还在疑惑函数式编程有什么用。客观来说它有很多用处，但是要说现阶段最能说服诸位且又能短时间理解的用处，我们会在后面提到。下面我们来说一个简单的用处：描述一个计算（Specification）。\n课程中的例子是最大子段和。如果你要向计算机描述最大子段和的问题怎么做？我们可以定义一个函数，这个函数接受一个序列返回一个最大子段和。这样计算机就知道了最大子段和的计算要求。当然，聪明的各位肯定是会写最大子段和的线性算法的，但我们要探讨的不是这个算法，而是得到这个算法的过程。\n我们能够“推理”出最大子段和的线性算法吗？\n这个问题还是太模糊了，我们还缺很多前置知识，但是在这些前置知识里最先要确定的是问题的描述（Specification）。最大子段和最本质的含义是：一个序列所有子区间分别求和，再计算所得到的数中的最大值。我们需要把这个最本质的定义做出形式化地描述，再搞一些基本的推理规则（公理，就和大家写数学几何证明题一样），这样我们才能推导出最大子段和的线性算法。\n也就是说，算法不都是凭空想出来的，一个算法是可以被推理出来的，听起来还不错？\n要描述最大字段和问题当然得用我们的函数式语言描述，为什么 C++ 不行等会儿说。以 Haskell 为例：\nmss :: [Int] -> Int\nmss = maximum . map sum . concat . map tails . inits\n-- 等价写法 （haskell 里一个函数多个参数是不需要加逗号的）\nmss2 as = maximum (map sum (concat (map tails (inits as)))) 我们使用了一堆函数的复合（composition）来描述最大子段和问题。下面来一一解释一下上面的函数（按从右往左的顺序）： inits 会求出一个序列的所有前缀：inits :: [t] -> [[t]]\ninits [] = [[]]\n-- (a : as) 是非空序列的表示，a 的类型为 t（表示第一个元素），as 类型为 [t] 表示之后的其他元素\n-- 在 Haskell 中列表拆第一个元素比拆最后一个元素快（语言特性）\n-- 冒号 : 在这里是运算符\ninits (a : as) = [] : map (a :) (inits as)\ntails 会求出一个序列的所有后缀：tails :: [t] -> [[t]]\ntails [] = [[]]\ntails (a : as) = (a : as) : tails as\nmap f 会将一个序列里的元素 a_i 全部变成 f(a_i)：-- (t -> p) 表示接受一个类型为 t 的值，返回一个类型为 p 的值的函数\nmap :: (t -> p) -> [t] -> [p] map f [] = []\nmap f (a : as) = f a : map f as\nconcat 表示把一个 [[t]] 类型的列表“拍扁”拼成一个 [t] 类型的列表：concat :: [[t]] -> [t]\nconcat [] = []\n-- ++ 是运算符表示列表的拼接\nconcat (a : as) = a ++ concat as\nsum 是对一个列表中所有元素求和-- 之前的 t、p 都是任意类型（类似 C++ 的模板），而这里的 Int 是具体的类型\nsum :: [Int] -> Int sum [] = 0\nsum (a : as) = a + sum as\nmaximum 表示对一个列表中所有元素求最大值：maximum :: [Int] -> Int maximum [] = 0\nmaximum (a : as) = max a (maximum as) 不熟悉 Haskell 的同学可能有点看不下去了，所以我们给出与之等价的 C++ 实现：\n//by Yao\n#include &lt;iostream>\n#include &lt;vector>\n#include &lt;functional>\n#include &lt;climits>\nusing std::cout;\nusing std::vector;\nusing std::ostream;\nusing std::function;\n#define L vector\n#define F function // 调试用\nostream &amp; operator&lt;&lt;(ostream &amp; out, const L&lt;int> vs) &#123; out &lt;&lt; \"[ \"; for(int x : vs) out &lt;&lt; x &lt;&lt; \" \"; out &lt;&lt; \"]\\n\"; return out;\n&#125;\n// 模拟 : 运算符\n// 这是一个高阶函数，也就是说返回值为函数的函数\n// L&lt;int> as = &#123;1, 2, 3&#125;;\n// cout &lt;&lt; cons(5)(as);\ntemplate&lt;class t> F&lt; L&lt;t>(L&lt;t>) > cons(const t a) &#123; return [=](const L&lt;t> as) &#123; L&lt;t> res = as; res.insert(res.begin(), a); return res; &#125;;\n&#125;\n// F&lt;int(int)> square = [](int x) &#123; return x * x; &#125;;\n// cout &lt;&lt; map(square)(L&lt;int>&#123;1,2,3,4,5&#125;);\ntemplate&lt;class t, class p>\nF&lt; L&lt;p>(L&lt;t>) > map(const F&lt;p(t)> f) &#123; return [=](const L&lt;t> vs) &#123; if(vs.empty()) return L&lt;p>&#123;&#125;; const t a = vs[0]; const L&lt;t> as = L&lt;t>(vs.begin() + 1, vs.end()); return cons(f(a))(map(f)(as)); &#125;;\n&#125;\n// for(auto xs : inits(L&lt;int>&#123;1,2,3,4,5&#125;)) &#123;\n// cout &lt;&lt; xs;\n// &#125;\ntemplate&lt;class t>\nL&lt;L&lt;t>> inits(const L&lt;t> vs) &#123; if(vs.empty()) return &#123;&#123;&#125;&#125;; const t a = vs[0]; const L&lt;t> as = L&lt;t>(vs.begin() + 1, vs.end()); return cons(L&lt;t>&#123;&#125;)(map(cons(a))(inits(as)));\n&#125;\n// for(auto xs : tails(L&lt;int>&#123;1,2,3,4,5&#125;)) &#123;\n// cout &lt;&lt; xs;\n// &#125;\ntemplate&lt;class t>\nL&lt;L&lt;t>> tails(const L&lt;t> vs) &#123; if(vs.empty()) return &#123;&#123;&#125;&#125;; const t a = vs[0]; const L&lt;t> as = L&lt;t>(vs.begin() + 1, vs.end()); return cons(cons(a)(as))(tails(as));\n&#125;\n// cout &lt;&lt; cat(L&lt;int>&#123;1,2,3,4,5&#125;)(&#123;3,4,5,6,7&#125;);\ntemplate&lt;class t>\nF&lt; L&lt;t>(L&lt;t>) > cat(const L&lt;t> as) &#123; return [=](const L&lt;t> bs) &#123; if(as.empty()) return bs; const auto a = as[0]; const auto ass = L&lt;t>(as.begin() + 1, as.end()); return cons(a)(cat(ass)(bs)); &#125;;\n&#125;\n// cout &lt;&lt; concat(L&lt;L&lt;int>>&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5, 6, 7&#125;&#125;);\ntemplate&lt;class t>\nL&lt;t> concat(const L&lt;L&lt;t>> vs) &#123; if(vs.empty()) return L&lt;t>&#123;&#125;; const auto a = vs[0]; const auto as = L&lt;L&lt;t>>(vs.begin() + 1, vs.end()); return cat(a)(concat(as));\n&#125;\n// cout &lt;&lt; sum(&#123;1,2,3,4,5&#125;);\nint sum(const L&lt;int> vs) &#123; if(vs.empty()) return 0; const auto a = vs[0]; const auto as = L&lt;int>(vs.begin() + 1, vs.end()); return a + sum(as);\n&#125;\n// cout &lt;&lt; maximum(&#123;1,2,3,4,5&#125;);\nint maximum(const L&lt;int> vs) &#123; if(vs.empty()) return INT_MIN; const auto a = vs[0]; const auto as = L&lt;int>(vs.begin() + 1, vs.end()); return std::max(a, maximum(as));\n&#125;\nint mss(L&lt;int> vs) &#123; // 尖括号里的类型无法省略不然会 CE return maximum(map&lt;L&lt;int>, int>(sum)(concat(map&lt;L&lt;int>, L&lt;L&lt;int>>>(tails&lt;int>)(inits(vs)))));\n&#125;\nint main () &#123; cout &lt;&lt; mss(&#123;1,2,-4,4,5&#125;); return 0;\n&#125;\n相信各位已经明白了 C++ 为什么不行，毕竟它不是专为函数式编程设计的语言，写起来太麻烦还很别扭。在函数式编程领域，Haskell 是王者之一。\n你可能会说上面的 C++ 代码写法有很多复杂度较大而且很别扭的地方。这个是强行用 C++ 模拟函数式编程的结果。如果要以指令式编程来写，那当然又是另一种写法。\n为什么我们非要用函数式编程来描述 Specification 呢？ 为什么函数式可以：下面会讲。\n为什么指令式不可以：胡老师并没有详细讲。所谓的不可以，其实是指没人这么干，我的理解是指令式编程如果要用数学语言描述，会涉及到状态变换，而这个过程目前还不太好做形式化地处理（太复杂了）。 回到最大子段和的 Specification：\nmss = maximum . map sum . concat . map tails . inits\n如果你习惯了 Haskell，你其实是可以把它从右往左“读出来”的： 先求出原序列的所有前缀\n再把每个前缀变成它自己的后缀，这样我们就得到了原序列的所有子区间\n但是目前我们拿到的是个三维列表（数组），所以需要做一下顶层拼接转化为二维列表\n然后把每个子区间变成它的数字和（这样二维列表也就变成了一维列表）\n然后再把所有的数求出最大值 可以发现，函数式编程利用了基本函数的复合与变换，将原问题的语义清晰地表达出来。这也符合我们平时的语言习惯，函数就像是一个动作，一个指示。当然，这个方法并非万能，有些算法使用指令式语言来描述会更简洁。\n高阶函数（High Order Function）各位如果有仔细阅读上文的代码就会发现，Haskell 中大量使用了高阶函数。C++ 代码之所以如此丑陋就是因为我强行使用高阶函数写法来与 Haskell 代码形成准确对应。而在函数式编程里，高阶函数极其常见。把一个多参数函数变成高阶函数的方法不唯一（看用途），不过一个常见的方法叫做柯里化（curry）。以最大值函数为例，max(a, b) 是一个接收两个参数返回一个最大值的函数，我们可以将它改成 max(a)(b)，其中 max(a) 的返回值是一个函数，这个函数接收一个参数并将其与 a 比较，返回最大的那个。C++ 的写法见上文。多参数同理，f(a, b, c) 会被转化为 f(a)(b)(c)。\nHaskell 的确有元组的概念，使用 (a, b) 的方式可以表示二元组（多元组也可），但是你几乎见不到使用元组来表示参数类型的函数，Haskell 的库函数几乎全部柯里化。在 Haskell 中，max a 会返回一个函数（作用同理），而 max a b 等价于 (max a) b。\n柯里化的好处在于，我们可以更简洁地描述计算过程。比如说我们要把一个序列 as 中的数对 x 取最大值，那么使用 Haskell 来写就是 map (max a) as。而在 C++ 中你可能会需要用到 for 循环。\n不妨对照上文 Haskell 代码中的类型声明。以 map 为例：map :: (t -&gt; p) -&gt; [t] -&gt; [p] 等价于 map :: (t -&gt; p) -&gt; ([t] -&gt; [p]) （箭头符号默认右结合）。第一个参数的类型是一个从 t 类型到 p 类型的函数，第二个参数的类型是 [t]（类型为 t 的列表），返回值类型是 [p]。\n序列变换函数学习英语的基础是单词，单词背够了才能有效学习更多的内容。函数式编程同理，对于没有接触过函数式编程的同学来说，你们目前的词汇量都几乎为零，你们平时所编写的函数大多是为了降低耦合或者做模块化处理，归属于面向对象的范式。为了方便大家理解后续内容，我们列出一些基本的函数来打打基础。节约时间，这里只会列出有关列表的函数。\n当然，为了让大家快捷地理解 Haskell 代码，我们先讲讲 Haskell 代码中的列表的定义，以及它的用途。\n在 Haskell 中构造列表有两种方式：[] 代码任意类型的空列表（具体类型由上下文决定），而 (a : as) 表示将元素 a 插入到列表 as 的开头形成的列表（不会改变 as 的值）。顺带一提，Haskell 的类型检查是吊打 C++ 的，所以你在有的代码中没有看到类型声明是正常的事情，因为编译器会推断。\n[] 和 : 均可以理解为函数。[] 是不接受参数的函数（参数列表为空），而 : 是接受两个参数的函数。\n-- 列表的映射函数，用法见上文\nmap :: (t -> p) -> [t] -> [p] map f [] = []\nmap f (a : as) = f a : map f as -- 列表的拼接。\n-- 打括号的意思是 ++ 是一个二元运算符。Haskell 可以定义各种千奇百怪的自定义运算符\n-- ++ 的用法很多。a ++ b 是正常用法，等价于 (++) a b（当成函数用）\n-- 同理 (++) a 的返回值是一个函数，这个函数接受一个参数 b，返回在 b 前面拼接 a 的结果\n-- 针对二元运算符 Haskell 有一些巧妙的语法糖，(++) a 等价于 (a ++)，上文的 (a :) 同理。\n-- 类似，(++ b) a = (a ++) b = a ++ b = (++) a b = ((++) a) b，所有二元运算符都可以这么用。\n-- 这里相当于做了一个 switch。如果第一个是空列表就返回第二个。否则就递归把 as 和 b 拼起来再在开头插入 a\n(++) :: [t] -> [t] -> [t]\n[] ++ b = b\n(a : as) ++ b = a : (as ++ b) -- 右结合的运算\n-- 例如 foldr (+) 0 [1,2,3,4,5] 返回值为 1 + (2 + (3 + (4 + (5 + 0))))\n-- 同理 foldr f 0 [1,2,3] = f 1 (f 2 (f 3 0))\nfoldr :: (a -> b -> b) -> b -> [a] -> b\nfoldr f e [] = z\nfoldr f e (a : as) = f a (foldr f e as) -- 左结合的运算\n-- 例如 foldl (+) 0 [1,2,3,4,5] 返回值为 ((((0 + 1) + 2) + 3) + 4) + 5\n-- 同理 foldl f 0 [1,2,3] = f (f (f 0 1) 2) 3\nfoldl :: (b -> a -> b) -> b -> [a] -> b\nfoldl f e [] = z\nfoldl f e (a : as) = foldl f (f e a) as -- 与 foldr 差不多，唯一的区别是它会把中间计算结果全部返回\n-- scanr max 0 [1, 2, 3, 2, 1] = [3, 3, 3, 2, 1, 0]\nscanr :: (a -> b -> b) -> b -> [a] -> [b]\nscanr f e [] = [e]\nscanr f e (a : as) = let (xs : xss) = scanr f e as in f a xs : (xs : xss) -- 与 foldl 差不多，唯一的区别是它会把中间计算结果全部返回\n-- scanl max 0 [1, 2, 3, 2, 1] = [0, 1, 2, 3, 3, 3]\nscanl :: (b -> a -> b) -> b -> [a] -> [b]\nscanl f e [] = [e]\nscanl f e (a : as) = e : scanl f (f e a) as -- 把一个元素转化为一个单元素列表\nsingleton :: a -> [a]\nsingleton x = [x] -- 返回自身的函数\nid :: a -> a\nid x = x\n有了这些基础，我们已经可以做一些基本的程序演算了，大家不妨尝试证明以下定理（=== 表示等价于，不是赋值符号）：\nconcat . map singleton === id\n这里 === 表示两个函数等价，也就是说无论接受什么参数等式两边都返回相同结果（这个参数必须同时满足左右两边的类型要求）\n其实观察 concat 可以发现，它的递归写法等价于 foldr (++) []，因此大家可以再尝试证明\nfoldr (++) [] === foldl (++) []\n这些证明都非常简单，目的是让大家理解这样的函数式语言的思维表达方式。","title":"函数式程序设计 / 程序演算入门 Part 1","updated":"2025-04-23T04:07:19.266Z"},{"categories":[],"path":"BMF-FFT/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"BMF 是一种非常高妙的程序演算。我们用它来简单推导一下 FFT。 \\gdef\\concat{\\mathbin{+\\mkern-8mu+} }\n\\gdef\\map{\\operatorname{\\ast} }\n\\gdef\\red{\\operatorname{/} }\n\\gdef\\single{\\operatorname{[\\cdot]} }\n\\gdef\\comp{\\operatorname{\\circ} }\n\\gdef\\tri{\\operatorname{\\triangle} }\n\\gdef\\app{\\operatorname{\\$} }\n\\gdef\\repeat{\\operatorname{@} }\n\\gdef\\fk{\\operatorname{\\zeta} }\n\\gdef\\sq{\\operatorname{\\square} }\n\\gdef\\len{\\operatorname{\\ell} }\n\\gdef\\key#1{ {\\color{red}\\, #1 \\,} }基本运算符号\nf \\map 表示将一个列表中所有元素变为应用了 f 之后的结果（map）。\n\\oplus \\red 表示将列表中的元素按照具有结合律的运算 \\oplus 合并（reduce）。\n\\single 表示将某个元素转化为一个长度为 1 的仅包含它自己的列表（singleton）。\n\\concat 表示连接两个序列。\n\\Tau 表示二维列表的转置（transpose）。\n\\Gamma_{\\oplus} 表示将两个等长的列表对应项通过二元运算 \\oplus 计算出结果形成的新的列表（zip with）。\n\\len x 表示 x 的长度。 f \\tri x 的变换规则如下：(f\\tri x)_i = (f\\comp)^{i}(x_i)，其中 f 是一个映射，(f \\comp)^i 表示迭代 i 次。\nf \\sq x 的变换规则如下：(f \\sq x)_i = (f \\comp)^{\\len x}(x_i)。\nf \\app x 表示 f(x)。\nn \\repeat x 表示一个长度为 n 全是 x 的列表。\nn \\fk z = \\omega_n\\times z。 基本定理map 对 \\circ 有分配律：(f \\circ g)\\map = (f\\map)\\circ (g\\map)。\n关于 \\Tau 的一系列性质： \\Tau 的一个等价形式：\\Tau = \\Gamma_{\\concat} \\red\\circ \\single \\map \\map。\n\\Tau 对 map 有分配律：f \\ast \\ast \\circ \\Tau = \\Tau \\circ f \\ast \\ast。\n\\Tau 对 reduce 的影响：\\Gamma_{\\oplus}\\red = \\oplus \\red \\map \\comp \\Tau。因此可以把前者理解为竖着的 reduce。 我们称 \\map，\\tri，\\sq 为 pointwise 运算，下面的 \\oplus，\\otimes 均为 pointwise 运算： 关于 \\map 交换律：若 f \\circ g = g \\circ h，那么 f \\oplus\\comp g \\map = g \\map \\comp h \\operatorname\\oplus。\n若 f\\circ g = g\\circ f，那么 f \\oplus \\comp g \\operatorname\\otimes = g \\otimes \\comp f \\operatorname\\oplus，并且有 g\\oplus \\comp f \\operatorname\\oplus = (g\\comp f)\\oplus = (f\\comp g)\\oplus = f\\oplus\\comp g \\operatorname\\oplus。而且这也可以推导出 f\\oplus\\comp f\\operatorname\\otimes = f\\otimes \\comp f \\operatorname\\oplus。\nf\\oplus\\otimes\\comp \\Tau = \\Tau\\comp f\\otimes\\oplus。 有关 n\\fk 的一个性质是 (nm\\fk)^m = n\\fk。\n有关 n\\repeat 的性质： 分解：n\\repeat\\concat\\red = \\concat\\red \\comp q\\repeat \\comp p\\repeat \\circ\\concat\\red，其中 p\\times q = n。\n与 \\concat\\red 交换：n\\repeat\\comp\\concat\\red = \\concat\\red\\map\\comp n\\repeat。\n假设操作对象是一个矩阵（二维列表），那么 k\\repeat = \\Tau\\comp k\\repeat\\map。\\Tau 对于高维列表来说相当于交换第一二维的坐标，因此 y = (k\\repeat\\map) x 得到的结果是 y_{i,t, j} = x_{i, j}（0\\le t &lt; k），再转置一下就能得到 y_{t, i, j} = x_{i, j}。 描述 DFT对于序列 x_0, \\ldots, x_{n - 1} 的离散傅里叶变换可以描述为 \\mathcal{F}_n = +\\red\\map \\comp n\\fk\\tri\\tri \\comp n\\repeat理解方式如下： (n\\fk)\\tri 表示将序列 a_j 变成 a_jw_n^j。\n(n \\fk)\\tri\\tri 表示将第 i 个序列变成 a_jw_n^{ij}。\n+\\red\\map 表示分别求和。 分治观察上面的 specification，我们首先要处理的是形如 f\\tri\\tri 的变换。考虑分治。\n先考虑一个简单的情况：对一维列表做 f\\tri 变换。将这个过程分治，相当于将其切成若干段，不妨考虑切出来的段等长。那么把原列表做 f \\tri 变换就可以转换为，把矩阵每行分别做变换，再连起来。写成 BMF 就是 f\\tri\\comp\\concat\\red = \\concat\\red\\comp f\\sq\\tri\\comp f \\tri \\map同理，f\\tri\\tri 是针对二维列表的变换： f\\tri\\tri 相当于对第 i 行第 j 列的元素迭代 i\\times j 次。\nf \\map\\tri 相当于对第 i 行第 j 列的元素迭代 i 次。\nf \\tri\\map 相当于对第 i 行第 j 列的元素迭代 j 次。 这个过程也可以分治。这里我们的分治方法是：对于一行，按照一维的情况来做。此外，我们也可以将所有行分成若干组，每一组行数相等。分割后我们拿到的其实是一个四维列表。把四维列表拼成二维列表的变换是 \\concat/\\circ\\concat \\red \\map\\map。\n接下来做一些 BMF 推导： \\begin{aligned} & \\key{f\\tri\\tri\\circ \\concat\\red}\\circ\\concat\\red\\map\\map \\\\\n= & \\concat\\red\\comp f\\tri\\sq\\tri\\comp f\\tri\\tri\\key{\\map}\\comp \\concat\\red\\map\\key{\\map}\\\\\n= & \\concat\\red\\comp f\\tri\\sq\\tri\\comp (\\key{f\\tri}\\tri\\circ \\key{\\concat\\red}\\map)\\map\\\\\n= & \\concat\\red\\comp f\\tri\\sq\\tri\\comp (\\concat\\red\\map \\comp (f\\sq\\tri\\comp f \\tri \\map) \\tri)\\key{\\map} \\\\\n= & \\concat\\red \\comp f\\tri\\sq\\tri\n\\comp \\concat\\red\\map\\map \\comp (f\\sq\\tri\\comp f \\tri \\map) \\tri\\map \\\\\n\\end{aligned}这里我们单独把 f\\tri \\sq \\tri \\comp \\concat \\red \\map \\map 拿出来给大家变换一下： f\\tri\\comp\\concat\\red = \\concat\\red\\comp f\\sq\\tri\\comp f \\tri \\map。\n\\key{f\\tri} \\sq \\comp \\key{\\concat\\red} \\map = \\concat\\red\\map \\comp (f\\sq\\tri\\comp f \\tri \\map)\\sq。\n\\key{f\\tri\\sq}\\tri\\comp \\key{\\concat\\red\\map}\\map = \\concat\\red\\map\\map \\comp (f\\sq\\tri\\comp f \\tri \\map)\\sq\\tri。 根据基本定理，f\\sq\\tri\\comp f\\tri\\map = f\\tri\\map\\comp f\\sq\\tri（可交换）因此 \\begin{aligned}\n& \\concat\\red\\comp f\\tri\\sq\\tri\\comp \\concat\\red\\map\\map \\comp (f\\sq\\tri\\comp f \\tri \\map) \\tri\\map \\\\\n= & \\concat\\red\\comp\\concat\\red\\map\\map \\comp (\\key{f\\sq\\tri\\comp f \\tri \\map})\\sq\\tri \\comp (\\key{f\\sq\\tri\\comp f \\tri \\map}) \\tri\\map \\\\ = & \\concat\\red\\comp\\concat\\red\\map\\map \\comp f\\sq\\tri\\sq\\tri \\comp f \\tri\\map\\sq\\tri\n\\comp f\\sq\\tri\\tri\\map \\comp f\\tri\\map\\tri\\map \\\\\n\\end{aligned}在 FFT 当中，f = n\\fk。我们假设 f\\sq\\tri\\sq\\tri 应用到的列表是一个 a\\times b\\times c\\times d 的四维列表，且 bd = n。那么 \\begin{aligned}\nf\\sq\\tri\\sq\\tri & = n\\fk \\sq\\tri\\sq\\tri \\\\\n& = (n\\fk)^d \\map\\tri\\sq\\tri \\\\\n& = ((n\\fk)^d \\map\\tri)^b\\map\\tri \\\\\n& = (n\\fk)^{db}\\map\\tri\\map\\tri \\\\\n& = 1\\fk\\map\\tri\\map\\tri \\\\\n& = 1\\fk\\map\\map\\map\\map \\\\\n\\end{aligned}相当于啥都不干。\n推导 FFT设 n = p\\times q，\\mathcal{F} \\comp\\concat\\red 作用于一个 p\\times q 的二维列表。那么 \\begin{aligned}\n\\mathcal{F}_n\\comp \\concat\\red & = +\\red\\map \\comp n\\fk\\tri\\tri \\comp \\key{n\\repeat \\circ \\concat\\red} \\\\ & = +\\red\\map \\comp n\\fk\\tri\\tri \\comp \\concat\\red\n\\comp \\key{q\\repeat \\comp p\\repeat \\comp\\concat\\red} \\\\ & = +\\red\\map \\comp \\key{n\\fk\\tri\\tri \\comp \\concat\\red\n\\comp\\concat\\red\\map\\map}\n\\comp q\\repeat \\comp p\\repeat \\\\ \\end{aligned}这里我们设 K = n\\fk\\sq\\tri\\sq\\tri \\comp n\\fk \\tri\\map\\sq\\tri\n\\comp n\\fk\\sq\\tri\\tri\\map \\comp n\\fk\\tri\\map\\tri\\map： \\begin{aligned}\n& +\\red\\map \\comp \\key{n\\fk\\tri\\tri \\comp \\concat\\red\n\\comp\\concat\\red\\map\\map}\n\\comp q\\repeat \\comp p\\repeat \\\\ = & \\key{+\\red\\map \\comp \\concat\\red} \\comp\\concat\\red\\map\\map\n\\comp K \\comp q\\repeat \\comp p\\repeat \\\\ = & \\concat\\red \\comp \\key{+\\red\\map\\map \\comp \\concat\\red\\map\\map}\n\\comp K \\comp q\\repeat \\comp p\\repeat \\\\ = & \\concat\\red \\comp (+\\red\\circ \\concat\\red)\\map\\map\n\\comp K \\comp q\\repeat \\comp p\\repeat \\\\ = & \\concat\\red \\comp (+\\red\\circ +\\red\\map)\\map\\map\n\\comp K \\comp q\\repeat \\comp p\\repeat \\\\\n\\end{aligned}最后一步用到了加法结合律。然后我们推导一下后面的 K \\comp q\\repeat \\comp p\\repeat。注意到 q\\repeat\\comp p\\repeat 作用于 p\\times q 的结果是得到一个 q\\times p \\times p\\times q 的列表，因此 \\begin{aligned}\nK & = pq\\fk\\key{\\sq}\\tri\\key{\\sq}\\tri\n\\comp pq\\fk \\tri\\map\\key{\\sq}\\tri\n\\comp pq\\fk\\key{\\sq}\\tri\\tri\\map \\comp n\\fk\\tri\\map\\tri\\map \\\\ & = \\key{1\\fk\\map\\tri\\map\\tri}\n\\comp q\\fk \\tri\\map\\map\\tri\n\\comp p\\fk\\map\\tri\\tri\\map \\comp n\\fk\\tri\\map\\tri\\map \\\\ & = q\\fk \\tri\\map\\map\\tri\n\\comp \\key{p\\fk\\map\\tri\\tri\\map}\n\\comp \\key{n\\fk\\tri\\map\\tri\\map} \\\\ & = q\\fk \\tri\\map\\map\\tri\n\\comp n\\fk\\tri\\map\\tri\\map\n\\comp p\\fk\\map\\tri\\tri\\map \\\\ \\end{aligned}K 的类型为 q\\times p\\times p\\times q\\to q\\times p\\times p\\times q。接下来来推导 \\mathcal{F}_n\\comp \\concat\\red\\comp\\Tau： \\begin{aligned}\n&\\mathcal{F}_n \\comp\\concat\\red \\comp \\Tau\\\\ = &\\concat\\red \\comp (+\\red\\circ +\\red\\map)\\map\\map\\\\\n& \\comp q\\fk \\tri\\map\\map\\tri\n\\comp n\\fk\\tri\\map\\tri\\map\n\\comp p\\fk\\map\\tri\\tri\\map \\\\\n& \\comp q\\repeat \\comp p \\repeat \\comp \\key{\\Tau}\\\\ = &\\concat\\red \\comp (+\\red\\circ +\\red\\map)\\map\\map\\\\\n& \\comp \\key{q\\fk \\tri\\map}\\map\\tri\n\\comp \\key{n\\fk\\tri\\map}\\tri\\map\n\\comp \\key{p\\fk\\map\\tri}\\tri\\map \\comp \\key{\\Tau}\\map\\map \\\\\n&\\comp q\\repeat \\comp p \\repeat\\\\ = &\\concat\\red \\comp (+\\red\\circ +\\red\\map)\\map\\map \\comp \\key{\\Tau\\map\\map}\\\\\n& \\comp q\\fk \\map\\tri\\map\\tri\n\\comp n\\fk\\map\\tri\\tri\\map\n\\comp p\\fk\\tri\\map\\tri\\map \\\\\n& \\comp q\\repeat \\comp p \\repeat\\\\ = &\\concat\\red \\comp (+\\red\\circ +\\red\\map\\comp \\Tau)\\map\\map\\\\\n& \\comp q\\fk \\map\\tri\\map\\tri\n\\comp n\\fk\\map\\tri\\tri\\map\n\\comp p\\fk\\tri\\map\\tri\\map \\\\\n& \\comp q\\repeat \\comp p \\repeat\\\\ = &\\concat\\red \\comp (+\\red\\circ +\\red\\map)\\map\\map\\\\\n& \\comp q\\fk \\map\\tri\\map\\tri\n\\comp n\\fk\\map\\tri\\tri\\map\n\\comp p\\fk\\tri\\map\\tri\\map \\\\\n& \\comp q\\repeat \\comp p \\repeat\\\\\n\\end{aligned}最后一步用到了加法交换律。注意到 k\\repeat\\comp f = f \\map \\comp k \\repeat\n分配律：+\\red \\comp k\\fk \\map =k\\fk\\comp+\\red 因此 \\begin{aligned}\n&\\concat\\red \\comp (\\key{+\\red\\circ +\\red\\map})\\map\\map\\\\\n& \\comp q\\fk \\map\\tri\\map\\tri\n\\comp n\\fk\\map\\tri\\tri\\map\n\\comp p\\fk\\tri\\map\\tri\\map \\\\\n& \\comp q\\repeat \\comp p \\repeat\\\\ = &\\concat\\red \\comp +\\red\\map\\map \\comp \\key{+\\red}\\map\\map\\map \\\\\n& \\comp \\key{q\\fk\\map}\\tri\\map\\tri\n\\comp \\key{n\\fk\\map}\\tri\\tri\\map\n\\comp p\\fk\\tri\\map\\tri\\map \\\\\n& \\comp q\\repeat \\comp p \\repeat\\\\ = &\\concat\\red \\comp +\\red\\map\\map \\comp q\\fk\\tri\\map\\tri \\\\\n& \\comp n\\fk\\tri\\tri\\map\n\\comp +\\red\\map\\map\\map\n\\comp p\\fk\\tri\\map\\tri\\map \\\\\n& \\comp \\key{q\\repeat} \\comp p \\repeat\\\\ = &\\concat\\red \\\\\n&\\comp +\\red\\map\\map \\comp q\\fk\\tri\\map\\tri \\comp q \\repeat \\\\\n&\\comp n\\fk\\tri\\tri \\\\\n&\\comp +\\red\\map\\map \\comp p\\fk\\tri\\map\\tri \\comp p \\repeat \\\\ \\end{aligned}设 G(k) = +\\red\\map\\map\\comp k\\fk\\tri\\map\\tri\\comp k\\repeat。 \\begin{aligned}\nG(k) & = +\\red\\map\\map\\comp k\\fk\\tri\\map\\tri\\comp \\key{k\\repeat} \\\\\n& = +\\red\\map\\map\\comp \\key{k\\fk\\tri}\\map\\tri\\comp \\key\\Tau \\comp k\\repeat\\map \\\\\n& = \\Tau\\comp+\\red\\map\\map\\comp k\\fk\\tri\\tri\\map \\comp k\\repeat\\map\\\\\n& = \\Tau\\comp(+\\red\\map\\comp k\\fk\\tri\\tri \\comp k\\repeat)\\map \\\\\n& = \\Tau\\comp\\mathcal{F}_k\\map\n\\end{aligned}因此 \\begin{aligned}\n\\mathcal{F}_n\\comp \\concat\\red & = (\\mathcal{F}_n\\comp \\concat\\red\\comp\\Tau) \\comp \\Tau \\\\ & = (\\concat\\red\n\\comp \\Tau\\comp\\mathcal{F}_q\\map\n\\comp n\\fk\\tri\\tri\n\\comp \\Tau\\comp\\mathcal{F}_p\\map)\n\\comp \\Tau\n\\end{aligned}记 (\\concat\\red)^{-1}_{p\\times q} 表示将一个长度为 p\\times q 的序列分成一个 p\\times q 的二维列表，我们就得到了 FFT 的最终表示： \\begin{aligned}\n\\mathcal{F}_n\n& = \\concat\\red\n\\comp \\Tau\\comp\\mathcal{F}_q\\map\n\\comp n\\fk\\tri\\tri\n\\comp \\Tau\\comp\\mathcal{F}_p\\map\n\\comp \\Tau\\comp (\\concat\\red)^{-1}_{p\\times q}\n\\end{aligned}平时我们写的 FFT 是取 p = 2 或者 q = 2（二分治），这时 \\mathcal{F}_2 就会退化为 x_0, x_1\\to x_0 + x_1, x_0 - x_1（不需要乘法）。\n参考文献Deriving the fast Fourier Algorithm","title":"使用 Bird-Meertens Formalism 推导 FFT","updated":"2025-04-23T04:07:19.260Z"},{"categories":[],"path":"PFPL/Part1/","tags":[],"text":"\\gdef\\Op{\\mathcal{O}}\n\\gdef\\So{\\mathcal{S}}\n\\gdef\\X{\\mathcal{X}}\n\\gdef\\Ast{\\mathcal{A}}\n\\gdef\\Abt{\\mathcal{B}}\n\\gdef\\imply{\\Rightarrow}本文是 Practical Foundations for Programming Languages 的学习笔记。\n抽象语法树（Abstract Syntax Trees）这里我们直接给出形式化定义： 设 \\So 为一有限类型集合。\n设 \\Op = \\{\\Op_s\\}_{s\\in \\So} 表示每一个类型 s 拥有的运算符构成集合 \\Op_s，所有的 \\Op_s 构成 \\{\\Op_s\\}_{s\\in\\So}，称作类型索引的运算符集合族（sort-indexed family of operators）。n 元运算符 o\\in \\Op_s，的元数（计算所需参数个数，arity）记作 ar(o) = (s_1, \\ldots, s_n)，其中 s_1, \\ldots, s_n\\in\\So，而 o 的运算结果类型为 s。\n类似地，定义 \\X = \\{\\X_s\\}_{s\\in\\So} 表示类型索引的变量集合族。 这样，我们就可以定义 AST 的集合族 \\Ast [\\X] = \\{ \\Ast [\\X]_s \\}_{s\\in\\So} 为最小非空集合族满足： 一个变量构成一个 AST：x\\in \\X_s \\imply x\\in\\Ast[\\X]_s。变量可以理解为类型为 s 的未知 AST。\n一个运算符可以构造 AST：对于 o\\in\\Op_s，ar(o) = (s_1, \\ldots, s_n)，若 a_1\\in\\Ast[\\X]_{s_1}, \\ldots, a_n\\in\\Ast[\\X]_{s_n}，那么 o(a_1, \\ldots, a_n)\\in \\Ast[\\X]_s。 \\Ast[\\X]_s 可以理解为返回值类型为 s 的表达式。\n有了这个定义，那么我们可以有一个类似的归纳推导性质的做法。比如我们要证明性质 P 对所有 a\\in \\Ast[\\X] 成立，就可以按照 AST 的两条构造规则一一证明。\n如果上下文里隐含了 x 的类型为 s，那么我们就记 \\X, x 表示把 x 插入到 \\X_s 构成的新的变量集合族。\n变量的替换：将 x = b 作用于 AST 记作 [b/x]。也就是说 [b / x] x = b，[b/x]y = y\\, (y\\ne x)。\n[b/x]o(a_1, \\ldots, a_n) = o([b/x]a_1, \\ldots, [b/x]a_n)。 显然这个替换的结果是唯一的。\n但是我们知道在编程语言中还存在一种现象：某些语法/运算符只能在特定的上下文使用。这催生了作用域（scope）的概念。\n举例来说，let x = x * x in x + x 展开之后就会变成 x * x + x * x。通常来说，这里的 let x 中的 x 作用于 x + x，而 x * x 中的 x 只是恰好与其名字相同，实质是另一个变量。类似 C++ 里局部变量和同名全局变量的关系。不过这个东西的行为因语言而异，比如 haskell 是允许循环定义的。\n抽象语法限定树（Abstract Binding Trees）ABT 是 AST 的扩展。它给出了变量作用域的限定方式。比如我们想声明一系列的变量 x_1, \\ldots, x_t 只作用于语法树 a，我们记作 x_1, \\ldots, x_t. a。其中 x_1, \\ldots, x_t 类型各异。为了方便，我们记为 \\vec{x}.a。\n我们称 \\vec{x} 的类型为 \\vec{s} 当且仅当对任意 i 有 x_i 的类型是 s_i。\n在 ABT 中，运算符的类型表示为 ar(o) = ((\\vec{s_1})s_1, \\ldots, (\\vec{s_n})s_n)。s_i 表示该语法树的类型，而 \\vec{s_i} 表示该语法树的作用域下用到的各个变量的类型。\n形式化地： 设 \\Op 为一个类型索引的运算符集合族。\n设 \\X 为一个类型索引的变量集合族。\n为了处理不同作用域的变量名字相同，对于 \\vec{x} 我们定义它的一个重命名（双射） \\pi : \\vec{x} \\leftrightarrow \\vec{x}'，对于类型为 (\\vec{s})s 的语法树 a，\\pi(a) 的含义就是对所有 j 将 a 中出现的所有 (\\vec{x_i})_j 替换为 (\\vec{x_i}')_j。 那么定义关于 \\X 的 ABT \\Abt[\\X] 为 x\\in \\X_s \\imply x\\in \\Abt[\\X]_s。\n对于 o\\in \\Op_s，且 ar(o) = ((\\vec{s_1})s_1, \\ldots, (\\vec{s_n})s_n)，设 \\vec{x_i} 的类型是 \\vec{s_i}。对于 \\vec{x_i} 我们定义它的重命名 \\pi_i : \\vec{x_i} \\leftrightarrow \\vec{x_i}'，其中 (\\vec{x_i}')_j \\notin \\X。则对满足 \\pi_i (a_i)\\in \\Abt[\\X, \\vec{x_i}'] 的 a_i，有 o(\\vec{x_1}.a_1, \\ldots, \\vec{x_n}.a_n) \\in B[\\X]_s。 \\X, \\vec{x} 的含义与 \\X, x 类似，就是把 \\vec{x} 里的变量插入到 \\X 对应类型的集合里。\n这里的重命名起到的作用其实是与父节点中的参数取消绑定关系（freshness condition on binders）。\n于是我们就会发现，在 ABT 中两个参数名字（变量）一样不代表他们真的一样，这得看他们是不是在一个作用域里面。相关判断非常符合经验直觉。如果两个 ABT 本质相同，称作 \\alpha-equivalence，互相称作 \\alpha-variants。它的说法是 fresh renaming（也就是重命名成原来没有的）不影响相等性。\n变量的替换：这里要注意如果子树中有同名的参数得停止替换（capture avoidance），即 [b / x] x = b，[b/x]y = y\\, (y\\ne x)。\n[b/x]o(\\vec{x_1}.a_1, \\ldots,\\vec{x_n}.a_n) 的情况，对于 x\\in\\vec{x_i} 的情况我们设 a_i' = a_i，否则 a'_i = [b/x]a_i，这样有 [b/x]o(\\vec{x_1}.a_1, \\ldots,\\vec{x_n}.a_n) = o(\\vec{x_1}.a'_1, \\ldots, \\vec{x_n}.a'_n)。 但其实还可以换一种定义，就是我们先随便把子树里的参数做 fresh rename，这个时候直接替换 [b/x] 就没有任何问题了，即 [b/x]o(\\vec{x_1}.a_1, \\ldots,\\vec{x_n}.a_n) = o(\\vec{x_1'}.[b/x]\\pi_1(a_1), \\ldots, \\vec{x_n'}.[b/x]\\pi_n(a_n))。\n归纳（Inductive Definitions）下面是一点数理逻辑的基础知识。\n讲了一堆 Haskell 和 Agda 的东西，想必大家都会。\n一个 judgement form 可以理解为 Haskell 里的 type constructor，或者 Agda 里的 data constructor。judgement form 也可以理解为一个函数定义。\n规则集合 R 以若干个公理/定理的形式给出，而它代表所有遵循且仅遵循 R 的 judgement 构成的集合。也就是说对于其中的 judgement J，它能够从 R 中推导出来（closed under R），并且 R 蕴含推导出 J 的必要前提（strongest），如果 J 无法从 R 中推导那它就被视为不成立（vacuously true）。\n这其中有一个有意思的叫做 mode specification，是指一个函数对其参数的限定关系。例如 R = \\left\\{ \\frac{a \\in\\mathbb{N}}{\\sum(0, a, a)}, \\frac{\\sum(a, b, c)}{\\sum(\\text{suc}(a), b, \\text{suc}(c))} \\right\\}这两条规则定义了一个 judgement， \\sum(a, b, c) 指 a + b = c 成立。这时你会发现，对于任意 a, b\\in \\mathbb{N} 都存在 c 满足它，记作 (\\forall, \\forall, \\exist)。当然它甚至其实是存在唯一，可以记作 (\\forall, \\forall, \\exists!)。而 \\forall b, c\\in \\mathbb{N}，存在至多一个 a 满足它，这个可以记作 (\\exists^{\\le 1}, \\forall, \\forall)。这些被称作 mode specifications。\n一般来说，\\forall 对应的是函数的输入，而 \\exists 对应函数的输出。这样我们就可以用若干条规则定义函数了。当然为了写出来方便也会直接在上下使用 = 符号来代表函数的输入输出归纳关系。\n条件判断（Hypothetical Judgments）对于一个规则集合 R，记 J_1, \\ldots, J_k \\vdash_R K 表示，在假设 J_1, \\ldots, J_k 成立（公理）后可以借助 R 中的规则推导得到 K。常用 \\Gamma 或者 \\Delta 表示 judgement 集合，记 R[\\Gamma] 表示 R 由 \\Gamma 拓展得到的规则集合，上式亦可表示为 \\Gamma \\vdash_R K，\\Gamma 为空时可省略。\\Gamma \\vdash _R \\Delta 指 \\Delta 中每一个 judgement 都可以由 R[\\Gamma] 推导。\\vdash 满足以下性质： 稳定性（stability）：\\Gamma\\vdash_R K \\imply \\Gamma\\vdash_{R\\cup R'} K。\n自反性（reflexivity）：\\Gamma, J\\vdash_R J。写成 J\\vdash_{R[\\Gamma]} J 更清楚。\n传递性（transitivity）：若 \\vdash_{R[\\Gamma]}K 且 K\\vdash_{R[\\Gamma]} J，则 \\vdash_{R[\\Gamma]}J。 另一方面，记 \\Gamma \\models_R J 表示 \\vdash_R\\Gamma\\imply\\; \\vdash_R J。这个的意思是说只要你能用 R 推导出 \\Gamma（其中的全部 judgement），你就可以推导出 J。\n\\models 不稳定。因为你往 R 里面随便加一点公理（记为 R'），就能使 J 不能被 R' 推导。\n举个例子。我们搞两个规则定义自然数：R = \\{\\frac{}{\\text{zero nat}}, \\frac{\\text{a nat}}{\\text{suc(a) nat}} \\}。那么显然有 \\text{suc(a) nat} \\models_R \\text{a nat}，这个可以归纳证明。然后我们往 R 里面加一条垃圾公理 \\vdash \\text{suc(juck) nat}，记作 R'。那么如果 \\models 稳定，则有 \\vdash_{R'}\\text{suc(juck) nat} \\imply\\; \\vdash_{R'} \\text{junk nat}，但是这里的 \\text{junk} 很可能不是自然数（比如说 -1），也就是说它没法被 R' 里的规则推导出来，即 \\nvdash_{R'}\\text{junk nat}。故 \\text{suc(a) nat}\\not\\models_{R'} \\text{a nat}。\n注：这里说 \\text{junk nat} 没法被推导其实并不是说非得举出一个 -1 的反例，主要想表达的意思是它没有证据（vacuously true）。\n在 \\Gamma \\vdash_R J 中，\\Gamma 是你推导出 J 的前提之一，R 是辅助的推导规则集合。因此该命题体现的是在 R 辅助下，\\Gamma 到 J 的可推导性（derivable）。\n在 \\Gamma\\models_R J （\\vdash_R\\Gamma\\imply\\; \\vdash_R J）中，究竟能不能推导出 J 其实与 \\Gamma 无关，与 R 有关。命题的前提 \\vdash_R \\Gamma 描述的是 R 具有某种性质（使得它能推导出 \\Gamma），而这种性质提供了推导出 J 的充分条件。所以说如果 \\Gamma\\models J 在 R 下成立，意味着 R 具有这种性质，称作可接受的（admissible）。当然，也可以反客为主，称在 R 下 \\Gamma\\models J 是可接受的。\n\\vdash 明确指出了要推导出 J 的充分前提；而 \\models 只是指出，你要推导出 J 需要使得 R 具有某种性质。故也称 \\models 是 \\vdash 的一个 weaker form。\\models 满足以下性质： 自反性：J \\models_R J，这个很显然。\n传递性：若 \\Gamma \\models_R K 且 \\Gamma, K\\models_R J，那么 \\Gamma \\models_R J。 条件归纳（Hypothetical Inductive Definitions）我们可以用 \\vdash 来拓展规则的定义。条件规则（hypothetical rules）的形式如下： \\frac{\\Gamma\\Gamma_1\\vdash J_1, \\ldots, \\Gamma\\Gamma_n \\vdash J_n}{\\Gamma \\vdash J}其中 \\Gamma 为大前提（global hypotheses）。而 \\Gamma_i 为 J_i 的前提假设。\n如果一个条件规则不需要大前提，称作一致（uniform）条件规则，可以简写为 \\frac{\\Gamma_1\\vdash J_1, \\ldots, \\Gamma_n \\vdash J_n}{J}条件归纳定义为形式可推导的 judgement（formal derivability judgment）\\Gamma\\vdash J，其中 \\Gamma 是一个有限的基本 judgement 集合，J 是一个基本的 judgement。\n而条件规则集合 R 代表了一个可从 R 中推导（closed under R）的且必须从 R 中推导（strongest）的结构化（structural）的 formal derivability judgment 集合。可推导和必须推导前面已经解释过了。结构化的意思其中的 judgement 满足 \\vdash 的三个性质： 自反性：\\dfrac{}{\\Gamma, J\\vdash J}。\n稳定性：\\dfrac{\\Gamma\\vdash J}{\\Gamma, K\\vdash J}。\n传递性：\\dfrac{\\Gamma\\vdash K\\quad \\Gamma, K\\vdash J}{\\Gamma \\vdash J}。 同样地，这里可以用 \\Gamma\\vdash_R J 表示借用 R 的规则，从 \\Gamma 出发可以推导出 J。\n泛化判断（General judgements）大概就是在 judgement 里引入变量。设 \\Gamma, J 分别是含有变量 \\vec{x} 的前提集合与目标 judgement，记 \\vec{x} \\mid \\Gamma\\vdash_{R}^{\\X} J 表示利用包含变量 \\X 的规则集合 R，我们可以从 \\Gamma 推导出 J。这里 \\vec{x}\\not \\subseteq\\X。换句话说对于任何重命名 \\pi : \\vec{x}\\leftrightarrow\\vec{x'}，有 \\pi(\\Gamma)\\vdash_{R}^{\\X, \\vec{x'}} \\pi(J)。\n比如说 \\text{x nat}\\imply \\text{(x + 2) nat} 可以表示为 x \\mid \\text{x nat}\\vdash_{R}^{\\X}\\text{suc(suc(x)) nat}。\n更准确地说，在 \\Gamma\\vdash_{R}^{\\X} J 中，我们将所有 judgement 视为对 ABT 的判断。这样才能说清楚含有变量的 judgement、重命名、变量替换是什么。刚才的例子里，\\Gamma = \\{\\text{x nat}\\} 中的 x 自己就是一个 ABT。\n泛化判断有几个显然的基本性质： 扩张性（Proliferation）：\\vec{x}\\mid \\Gamma\\vdash_R^{\\X} J\\imply \\vec{x}, x\\mid \\Gamma\\vdash_{R}^{\\X} J。\n重命名-等价性（Renaming）：\\vec{x}, x\\mid \\Gamma\\vdash_R^{\\X} J\\imply \\vec{x}, x'\\mid [x\\leftrightarrow x'](\\Gamma)\\vdash_R^{\\X}[x\\leftrightarrow x'](J)，对于任意 x'\\notin\\X, \\vec{x}。","title":"「PFPL」 Judgements and Rules 学习笔记","updated":"2025-04-23T04:07:19.272Z"},{"categories":[],"path":"String/PAM/","tags":[{"name":"Automaton","slug":"Automaton","permalink":"https://notes.sshwy.name/tags/Automaton/"},{"name":"PAM","slug":"PAM","permalink":"https://notes.sshwy.name/tags/PAM/"},{"name":"Palindrome","slug":"Palindrome","permalink":"https://notes.sshwy.name/tags/Palindrome/"}],"text":"之前一直不是很会用 PAM，现在感觉可以稍微写点东西了。\nPAM 结构PAM 虽然是一个自动机，但是绝大多数时候是被当成一个回文树来用的。\nPAM 的构造算法证明了一个字符串的本质不同回文子串个数是 O(n) 的。\nPAM 上的一个结点就代表一个回文子串。\nfail(u) 指向 u 的最长回文后缀所在的结点。\\ell(u) 表示 u 代表回文串的长度。\n那么想必你已经差不多了解 PAM 的结构了。\n有关回文串的性质我们知道 KMP 与 border 和循环节是有很大关系的。\n对于回文串 s，s 的回文后缀也是它的前缀，即 border。\n那么咱们翻一翻字符串导论的那篇博客，不难得出结论：回文后缀也是由 O(\\log_2|s|) 个等差数列构成的。\n那么根据回文树的结构是可以轻松找出这些等差数列的。\n一类回文 DP 问题假设 s[1, i] 对应的回文树结点为 u，且 u 的祖先为 S(u)。那么考虑以下形式的 DP： f(i) = \\sum_{v \\in S(u)} f(i - \\ell(v))比如经典的回文划分计数。\n既然已知 S(u) 可划分为 \\log 个等差数列，那我们可以优化这个转移。\n不妨记 d(u) = \\ell(u) - \\ell(fail(u))，表示公差。\n这样我们其实可以用 \\log 个结点来代替 S(u)，它们是等差数列的末尾（最长的那个串对应的结点），记作 v_1, \\ldots, v_t。那么转移就可以写成 f(i) = \\sum_{j = 1}^t \\sum_{k = 0}^{\\displaystyle \\frac{\\ell(v_j) - \\ell(v_{j - 1})}{d(v_j)} - 1} f(i - \\ell(v_j) + kd(v_j))后面那个很丑，但本质上就是枚举 v_i 所在等差数列的所有数。不妨记 g(v_j) = \\sum_{k = 0}^{\\displaystyle \\frac{\\ell(v_j) - \\ell(v_{j - 1})}{d(v_j)} - 1} f(i - \\ell(v_j) + kd(v_j))这样我们就可以写出 f(i) = \\sum_{j = 1}^t g(v_j)。\n其实我们记 top(u) 表示 u 祖先中第一个不在 u 等差数列中的结点，那么上式可以比较优雅地写成 g(u) = \\sum_{k = 0}^{\\displaystyle \\frac{\\ell(u) - \\ell(top(u))}{d(u)} - 1} f(i - \\ell(u) + kd(u))然后我们来思考一下，从 i - 1 \\to i，有哪些 g 的值会发生变化：显然是 u 到根路径上的点。\n但是我们在计算 f(i) 的时候需要用到哪些结点的 g 的值：只需要 u 到根路径上等差数列末尾结点。\n然后我们再想想，假设 p 是 u 到根路径上某个等差数列末尾结点。那么要计算 g(p) 关于 i 的值我们需要用到哪些结点的值。\n为此首先思考 f(i - d(u)) 对应的结点是什么：一定是 fail(u)。这个地方你如果想证明，对着 f(i - d(u)) 想可能不太行，不妨思考 fail(u) 对应的回文串在 i 之前最晚出现的位置。然后去 fail(u) 的定义那里推矛盾。\n那么我们就可以分析得到： 首先如果 fail(p) 与 p 不在同一等差数列（fail(p) =top(p)），那么我们可以简单计算 g(p) 关于 i 的值（利用之前的 DP 值）\n如果 fail(p) 与 p 在同一等差数列，那么我们可以借助 g(fail(p)) 关于 i - d(u) 的值。 可以发现，上面的条件是归纳的。只要你能保证你将 u 到根路径上等差数列末尾结点的 g 更新为关于 i 的值，那么之后的更新也是对的。\n第二种情况具体如何借助？比较 g(u) 和 g(fail(u))，可以发现两者只是差了长度最短的回文后缀对应的转移，那么加上即可。实际上这个转移正是第一种情况的转移。所以可以合起来写。\n#include \"head.h\"\nconst int SZ = 1e6 + 500, ALP = 26;\n// 0 号结点表示 0 结点，1 号结点表示 -1 结点，长度为 -1\n// las 记录上一次插入的字符所在结点的编号\nint tot, las, s[SZ], ls; // 字符串的内容 -'0'\nint len[SZ], tr[SZ][ALP], fail[SZ];\n// d[u] == len[u] - len[fail[u]]，等差数列公差\n// top[u]: u 所在等差数列的开头父亲，第一个 d[u] != d[top[u]] 的结点\nint d[SZ], top[SZ];\nint newNode(int l) &#123; ++tot, len[tot] = l, fail[tot] = 0; FOR(i, 0, ALP - 1) tr[tot][i] = 0; return tot;\n&#125;\nint getfail(int u) &#123; // 将 u 的 fail 链状态上的状态尝试去用 s[ls] 扩展，返回第一个可扩展结点 while (s[ls - len[u] - 1] != s[ls]) u = fail[u]; return u;\n&#125;\nvoid insert(int c) &#123; // assert(0 &lt;= c &amp;&amp; c &lt; ALP); s[++ls] = c; int cur = getfail(las); if (!tr[cur][c]) &#123; // 如果没有转移就添加 int u = newNode(len[cur] + 2); fail[u] = tr[getfail(fail[cur])][c], tr[cur][c] = u; d[u] = len[u] - len[fail[u]]; // assert(d[u] >= d[fail[u]]); if (d[u] != d[fail[u]]) top[u] = fail[u]; else top[u] = top[fail[u]]; &#125; las = tr[cur][c];\n&#125;\nvoid init() &#123; tot = -1, newNode(0), newNode(-1), fail[0] = 1, las = 0; d[0] = d[1] = 0, top[0] = 1; s[ls = 0] = -1; // -1 表示非匹配字符\n&#125; const int N = 1e6 + 5, P = 1e9 + 7;\n// f: 回文划分方案数\n// g[u]: sum f[i - len[v]]，v 是 u 的祖先（含）top[u] 的子孙（不含）\nint g[SZ], f[N];\nint solve(string str) &#123; int n = str.size(); init(); f[0] = 1; FOR(i, 1, n) &#123; insert(str[i - 1] - 'a'); for (int u = las; u > 1; u = top[u]) &#123; g[u] = f[i - len[top[u]] - d[u]] % P; if (fail[u] != top[u]) g[u] = (g[u] + g[fail[u]]) % P; &#125; for (int u = las; u > 1; u = top[u]) f[i] = (f[i] + g[u]) % P; &#125; return f[n];\n&#125;","title":"回文自动机小结","updated":"2025-04-23T04:07:19.276Z"},{"categories":[],"path":"Tricks/","tags":[],"text":"差比数列不知为什么想要补一下这个。\n一个等差数列 a_n=a+(n-1)d，等比数列 q_n=bq^{n-1}，则差比数列 c_n=a_n\\cdot q_n. c_n=[a+(n-1)d]bq^{n-1}差别数列求和，使用裂项法，公式为 S_n=\\sum_{i=1}^nc_n=\\frac{[a+(n-1)d]bq^n}{q-1}-\\frac{ab}{q-1}-\\frac{dbq(q^{n-1}-1)}{(q-1)^2}拉格朗日插值2019.6.29\n对于一个 n 次多项式，可以由 n+1 个点唯一确定：(x_0,y_0),(x_1,y_1),\\cdots,(x_n,y_n).\n现在我们想要求这个表达式在某个位置的值。\n构造一个多项式 l_j(x)=\\prod_{i=0,i\\neq j}^k\\frac{x-x_i}{x_j-x_i}它被成为拉格朗日基本多项式。也称插值基函数。这个表达式有什么特点？ \\begin{aligned}\nl_j(x_j)&=\\prod_{i=0,i\\neq j}^k\\frac{x_j-x_i}{x_j-x_i}=1\\\\\nl_j(x_i)&=\\cdots\\times \\frac{x_i-x_i}{x_j-x_i}\\times\\cdots=0\n\\end{aligned}于是可以构造这样一个多项式 L(x)=\\sum_{i=0}^kl_i(x)y_i它显然经过了 (x_0,y_0),(x_1,y_1),\\cdots,(x_n,y_n)。于是代入一个点即可得到对应位置上的值。\n化简后可以得到这个多项式的系数表示法。\n取值连续我们考虑一种特殊的情况，当 x_i=i 时，我们得到 l_j(x)=\\prod _{i=0,i\\neq j}^k\\frac{x-i}{j-i}=\\frac{F_{j-1}G_{j+1}}{j!(k-j)!(-1)^{(k-j)}}其中 F_j=\\prod_{i=0}^j(x-i),G_j=\\prod_{i=j}^k(x-i)。于是得到的多项式为 L(x)=\\sum_{i=0}^k\\frac{y_iF_{i-1}G_{i+1}}{i!(k-i)!(-1)^{(k-i)}}预处理 F,G 可以 O(n) 求 L(x)。\n欧拉回路欧拉回路指一个图中经过所有边的回路。分有向图欧拉回路和无向图欧拉回路两种。求欧拉回路可以直接采用 DFS 的方法。我们首先沿着路径不停地搜索，途中可能会掠过一些环，但我们不担心。因为我们是在回溯的时候记录路径，而回溯的时候会遍历这些没有走过的环。因此不会走漏。在搜索时可以更改前向星的头指针来剪枝。对于无向图的情况，需要记录每一条无向边（一条无向边在存的时候相当于两条有向边）是否访问过。\nUOJ117\n#include&lt;algorithm>/*&#123;&#123;&#123;*/\n#include&lt;cctype>\n#include&lt;cassert>\n#include&lt;cmath>\n#include&lt;cstdio>\n#include&lt;cstring>\n#include&lt;cstdlib>\n#include&lt;ctime>\n#include&lt;iostream>\n#include&lt;map>\n#include&lt;queue>\n#include&lt;set>\n#include&lt;vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair&lt;int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i&lt;=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)/*&#125;&#125;&#125;*/\n/******************heading******************/\nconst int M=1e6+5,N=1e6+5;\nint t,n,m;\nint a[M],la; struct qxx&#123;int nex,t,v;&#125;;\nqxx e[M];\nint h[N],le;\nvoid add_path(int f,int t,int v)&#123;e[++le]=(qxx)&#123;h[f],t,v&#125;,h[f]=le;&#125; bool vis[N];\nint d1[N],d2[N];\nvoid dfs(int u)&#123; for(int i=h[u];i;i=h[u])&#123; while(i&amp;&amp;vis[e[i].v])i=e[i].nex; h[u]=i; const int v=e[i].t,w=e[i].v; if(i)vis[w]=1,dfs(v),a[++la]=i%2?w:(t==2?w:-w); &#125;\n&#125; int main()&#123; scanf(\"%d%d%d\",&amp;t,&amp;n,&amp;m); int u1,v1; FOR(i,1,m)&#123; scanf(\"%d%d\",&amp;u1,&amp;v1); add_path(u1,v1,i); if(t==1)add_path(v1,u1,i); d1[u1]++,d2[v1]++; &#125; FOR(i,1,n)if((d1[i]&amp;1)^(d2[i]&amp;1)||(t==2&amp;&amp;d1[i]!=d2[i]))return puts(\"NO\"),0; dfs(u1); if(la&lt;m)return puts(\"NO\"),0; puts(\"YES\"); ROF(i,la,1)printf(\"%d \",a[i]); return 0;\n&#125;\n欧拉回路有一些经典的应用 对于一个无向图，将其中的每一条边定向，要求每个结点的入度和出度的差不超过 1。 首先找到图中所有的奇点，将他们连向一个虚点 s。由于奇点的个数一定是偶数个，因此连完后整个图是欧拉图，跑一遍欧拉回路可以定向。然后再删掉 s 以及连接 s 的边，点的度最多变化 1。 平面上 n 个整点 (x,y)，要求将他们染成红色或者蓝色，且每行每列红蓝点个数差不超过 1。 把 (x,y) 当作 x,y 之间连一条无向边，则染红色蓝色相当与给无向边定向，转化为上一题的模型。 生成长度为 2^n 的首位相接的串使得所有长度为 n 的 01 串都出现过。 这道题其实有两种转化模型的方式。对于一个串，你可以在后面加一个 0/1 然后删除首个字符得到下一个串，因此一个串连向两个串。问题转化为寻找哈密尔顿回路问题，貌似不太可做。\n另一种转化方式是，把一个形如abcd的串拆成 (abc,bcd) 的边。这样建出来的图是可能有自环的，然后我们在这个有向图上跑欧拉回路就行了。 给一个无向图（不一定连通）加边使之成为一个欧拉图。 首先处理每一个连通块。对于有奇点的连通块们显然可以连一个大环搞掉两个奇点，剩下的奇点随便匹配就行。\n然后就考虑剩下若干个没有奇点的连通块，那么我们也连一个大环就行了。 在遇到一些和欧拉回路有关的问题的时候，有时是不需要建图的，直接搞度数 ；混合图求欧拉回路需要用网络流；欧拉回路只和每个点的奇偶性有关；出一道欧拉回路的好题非常难。\nDFS 及其应用手写栈模拟 DFS：相当于把状态丢到结构体里，手动开栈，跑一个 while 循环。搜索相当于圧栈。状态不仅仅包括函数参数，还有递归结构内的一些变量的值，比如循环变量 i 的值。同时还有递归、回溯的状态之分（总之先口糊一波，以后再补）\n有一些图论构造题，可以在一棵 DFS 生成树上构造而忽略非树边。这常用在证明中，也有显示的构造。\n一个无向图的 DFS 生成树，每一条非树边对应一个简单环。这个可以应用在仙人掌判定上。即把每个环的结点做标记，最后判断每条树边是否只覆盖一次。\n连通分量的应用强连通分量容易让人想到缩点 DP；边双连通分量缩点后构成一棵树，称作边双树；对于点双连通分量，一个点可能在多个点双中出现。\nabs 与 fabsabs 是憨批。如果不 using namespace std 直接调用 abs 可能调用的是 int abs(int)。使用 fabs 是最保险的。\n维护连续段今天写了一个感觉很妙的 set 维护连续段的代码，感觉很简洁：\nstruct Interval &#123; int l, r, w, t; // a[l..r] = w, assigned time bool operator&lt;(Interval a) const &#123; return l &lt; a.l; &#125;\n&#125;;\nset&lt;Interval> s; void mergeInterval(Op cur, int t) &#123; // [cur.l, cur.r] 是我们要合并的区间 auto st = s.upper_bound(&#123;cur.l&#125;); // 因为 l 是 struct 里第一个参数所以这里可以这么写 --st; auto ed = s.upper_bound(&#123;cur.r&#125;); vector&lt;Interval> v(st, ed); // 拿出所有与之相交的区间 s.erase(st, ed); auto &amp; vst = v[0], &amp; ved = v[v.size() - 1]; if(vst.l &lt; cur.l) &#123; // 把不在 [cur.l, cur.r] 里的区间塞回去 s.insert(&#123;vst.l, cur.l - 1, vst.w, vst.t&#125;); vst.l = cur.l; &#125; if(cur.r &lt; ved.r) &#123; // 把不在 [cur.l, cur.r] 里的区间塞回去 s.insert(&#123;cur.r + 1, ved.r, ved.w, ved.t&#125;); ved.r = cur.r; &#125; for(auto i : v) &#123; // 处理被删掉的区间 if(t - 1 >= 0) qs[t - 1].push_back(&#123;i.l, i.r, 1, i.w&#125;); if(i.t - 1 >= 0) qs[i.t - 1].push_back(&#123;i.l, i.r, -1, i.w&#125;); &#125; s.insert(&#123;cur.l, cur.r, cur.w, t&#125;); // 插入 [cur.l, cur.r]\n&#125;","title":"小技巧","updated":"2025-04-23T04:07:19.277Z"},{"categories":[],"path":"Graph/Connected-components-algorithm/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Tarjan","slug":"Tarjan","permalink":"https://notes.sshwy.name/tags/Tarjan/"}],"text":"有向图 DFS 生成树\n有向图的搜索树主要有 4 种边（不一定全部出现）： 树边（tree edge）：绿色边，每次搜索找到一个还没有访问过的结点的时候就形成了一条树边。\n反祖边（back edge）：黄色边，也被叫做回边，即指向祖先结点的边。\n横叉边（cross edge）：红色边，它主要是在搜索的时候遇到了一个已经访问过的结点，但是这个结点并不是当前结点的祖先时形成的。\n前向边（forward edge）：蓝色边，它是在搜索的时候遇到子树中的结点的时候形成的。 强连通分量强连通图：对于有向图 G=(V,E)，如果对于任意结点 u,v，存在一条 u 到 v 的有向简单路径，也存在一条 v 到 u 的有向简单路径，则称 G 是强连通图。\n强连通分量：另外，对于有向图 G 点集 V 的一个子集 V'，如果 G 关于 V' 的导出子图 G[V'] 是强连通图，则称 G[V'] 是 G 的强连通分量。\n我们考虑 DFS 生成树与强连通分量之间的关系。\n如果结点 u 是某个强连通分量在 DFS 树中遇到的第一个结点（这通常被称为这个强连通分量的根），那么这个强连通分量的其余结点一定在 DFS 树中以 u 为根的子树中。\n证明：反证法。假设有个结点 v 在该强连通分量中但是不在以 u 为根的子树中，那么 u 到 v 的路径中肯定有一条离开子树的边。但是这样的边只可能是横叉边或者反祖边，然而这两条边都要求指向的结点已经被访问过了，这就和 u 是第一个访问的结点矛盾了。\nTarjan 算法：\nTARJAN(int u,int k) vis[u]&#x3D;true low[u]&#x3D;dfn[u]&#x3D;k 将 u 圧入栈中 for 与 u 相邻的结点 v if 结点 v 未被访问过 TARJAN(v,k+1)&#x2F;&#x2F; 搜索 low[u]&#x3D;min(low[u],low[v])&#x2F;&#x2F; 回溯 else if v 在栈中 low[u]&#x3D;min(low[u],dfn[v]) if low[u] &#x3D; dfn[u] 则将栈中 u 以及 u 之上的结点全部弹出 这些结点构成一个强连通分量\n无向图 DFS 生成树\nDFS 生成树：即对图进行 DFS 遍历时所有递归到的边组成的树。\n设以 x 为根的子树为 T_x。\n\\text{low}(x) 定义为以下结点的 DFN 的最小值（与 Tarjan 有向图中的 \\text{low}(x) 区分）： T_x 中的结点；\n通过一条不在搜索树上的边能到达 T_x 的结点。 不难发现，\\text{low}(x) 按 DFS 生成树的递归遍历顺序是单调递增的，因此可以在回溯的过程中求出 \\text{low}(x)。\n无向图的割点与割边割点：对于无向图 G=(V,E) 中的结点 u，如果删掉它以及与它相连的边后，整个图连通块数量增加，则结点 u 被称为无向图的割点。\n割边：对于无向图 G=(V,E) 中的边 (x,y)，如果删掉它后，整个图连通块数量增加，则 (x,y) 被称为无向图的割边，也称作桥。 判定割边判定割边 (x,y) 的条件： (x,y) 是 DFS 树上的边。\n令 x 是 y 的父结点，则满足 \\text{DFN}(x)&lt;\\text{low}(y)。也就是说，从 T_x 出发，不经过 (x,y) 的前提下无法走到更早访问的结点，则 (x,y) 作为 T_x 与图 G[V\\setminus T_x] 的唯一连接，即为割边。 int dfn[N],low[N],dfn_cnt;\nint ans[N],cnt;\nvoid tarjan(int k,int p)&#123; //tarjan 找桥，根结点的父节点为 0 dfn[k]=low[k]=++dfn_cnt; for(int i=h[k]; i; i=e[i].nex)&#123; int u=e[i].t; if(!dfn[u])&#123; tarjan(u,k); low[k]=min(low[k],low[u]); if(dfn[k]&lt;low[u])ans[++cnt]=e[i].idx;// 桥 &#125; else if(u!=p) low[k]=min(low[k],dfn[u]); &#125;\n&#125;\n判定割点判定割点 x 的条件： 若 x 不为根结点，则要求，存在 x 的子结点 y，满足 \\text{DFN}(x)\\leq \\text{low}(y)。 即 T_y 中的结点最多能走到结点 x，那么将 x 删除就会导致 T_y 不连通。\n若 x 是根结点，则要求存在至少 2 个的子结点 y，满足 \\text{DFN}(x)\\leq \\text{low}(y)。 int dfn[N],low[N],totdfn;\nbool cut[N];\nint ans[N],la;\nvoid tarjan(int u,int p)&#123; dfn[u]=low[u]=++totdfn; int cnt=0; for(int i=h[u];i;i=e[i].nex)&#123; const int v=e[i].t; if(!dfn[v])&#123; tarjan(v,u); low[u]=min(low[u],low[v]); cnt+=dfn[u]&lt;=low[v]; &#125;else low[u]=min(low[u],dfn[v]); &#125; if(cnt-(p==0)>=1)cut[u]=1;\n&#125;\n无向图的双连通分量\n边双连通分量对于无向图 G=(V,E)，若其子图 G' 内不存在割边，则称 G' 是 G 的边双连通分量。\n对于图 G，直接删掉所有割边，剩下分量的就是边双连通分量。\n将边双连通分量缩点，就得到了 G 的边双树。\n点双连通分量无向图 G 的子图 G' 内不存在割点，则称 G' 是图 G 的点双连通分量。\n对于图 G，割点可能同时属于多个点双连通分量，但每一条边一定只属于一个点双连通分量。\n图中通过边的不同颜色来标记点双连通分量。\n求点双连通分量，需在 Tarjan 算法中维护一个栈： 当结点 x 被第一次访问时，把该结点入栈。\n当割点判定条件 \\text{DFN}[x]\\leq \\text{low}[y] 成立时，无论 x 是否为根：\n从栈顶不断弹出结点，直到 y 被弹出。\n刚才弹出的所有结点与结点 x 一起构成一个点双连通分量。 点双连通分量与圆方树有密切联系。","title":"连通分量相关算法","updated":"2025-04-23T04:07:19.264Z"},{"categories":[],"path":"Monad/","tags":[],"text":"Haskell 的学习曲线和 Vim 完全是反的。后者前期是一个竖直上升的难度，后来就平了。然而 haskell 看起来人畜无害，但是学了几节课后突然就进入了未知领域。笔者认为是有写一点东西的必要了。\n多态、泛型首先我们从最普通的函数开始。比如说\nmap :: (Int -> Int) -> [Int] -> [Int]\n这是一个 map 函数，可以根据它的类型推断出它大概是接受一个修改 Int 类型值的函数与一个初始数组，然后它可以返回将这个函数应用于初始数组的每一个元素得到的最终数组。\n这东西可以等价地理解为\nmap :: (Int -> Int) -> ([Int] -> [Int])\n这时 map 的含义就变成了把一个 Int -&gt; Int 的函数变换为一个 [Int] -&gt; [Int] 类型的函数。\n由此我们再做抽象，首先可以把底层类型多态化：\nmap' :: (a -> b) -> ([a] -> [b])\n这样对于任意一个 a -&gt; b 的函数我们都可以定义它对数组的 map 操作。\n然后我们可以将外层类型泛型化：\nfmap :: (a -> b) -> (f a -> f b)\n这样对于任何一个类型构造符 f 和底层类型变换函数 a -&gt; b，我们就都可以完成从 f a 到 f b 的变换。\n听起来很简单，但是这个过程省略了很多东西： map&#39; 中 [a] 是如何构造的？对于任意的类型 a 我们均可以构造关于此类型的列表。这是因为类型构造符 [] 提供了多态的支持。也就是说 fmap 中的 f 也应当是支持多态的。\nmap&#39; 的具体实现我们没有给出，但是显然这无法由编译器自动完成。也就是说 fmap 的实现也需要我们自己给出。 这样以来就出现了一些迷惑的地方。map&#39; 尚且是有用的，因为它可以避免我们对不同类型的列表定义不同类型的 map。但是这个 fmap 就有点无用了。对不同的类型构造符，他们的构造方式各不相同，因此我们得各自声明一个针对该类型的 fmap 函数。这有什么意义呢？\n类簇为了解释上文提到的问题，我们需要理解 Haskell 中类簇的意义。Haskell 不是面向对象语言，因此它的 class 和通常意义的 class 有本质的区别。简单来说 Haskell 的 class 更接近于一种性质集合。具有公共性质的一些类型可以抽象出一个共同的 class。比如说\nclass Plusable a where (+) :: a -> a -> a\n也就是说我们认为一个“可加”的类型应当具有一个加法运输符。class 中可以只声明运算符的类型，而其定义则在具体的类型中分别给出。\n这样做的好处是可以将类型的性质划分到不同的 class 中，形成性质的依赖，这样就可以通过一些基本性质导出其他的性质。比如一个经典的例子\nclass Eq a where (==) :: a -> a -> Bool (/=) :: a -> a -> Bool a /= b = not (a == b)\n对于具有“可判等”性质的类型，我们可以定义它们的“不等于”运算符。\nFunctor回到上文。对于具有 fmap 函数的类型，我们可以抽象出它们的 fmap 作为一个性质，得到一个 class：\nclass Functor f where fmap :: (a -> b) -> f a -> f b (&lt;$) :: a -> f b -> f a (&lt;$) = fmap . const\nFunctor（函子）类型不仅是 “可 fmap” 的，而且具有一个导出的运算符 &lt;&#36;。从它的定义我们可以推测它的作用是将第二个参数 f b 的类型构造符 f 应用在第一个参数 a 上。也就是说如果只给我们一个 f b 类型的变量（而且我们不知道 f 怎么用），让我们把 a 变成 f a，我们可以直接利用 &lt;&#36; 运算符完成同化。\n除此以外我们可以将 fmap 理解为一个变种 &#36;：\n($) :: (a -> b) -> a -> b\n(&lt;$>) :: Functor f => (a -> b) -> f a -> f b\n(&lt;$>) = fmap\n也就是说对于一个具有 Functor 性质的类型 f a，我们可以将任意 a -&gt; b 的函数应用其上。\n这时根据 Haskell 柯里化函数的特点，不难想到如下操作：\nadd :: a -> a -> a\nadd a b = a + b\n那么问题来了：我们有两个 f a 类型的变量 fa 和 fb，我们想将他们利用 add 函数都加起来，怎么做？\nfmap add 的类型为 f a -&gt; f (a -&gt; a)，也就说传入第一个参数后就会得到一个 f (a -&gt; a) 类型的函数，怎么样把剩下的参数传进去？\n直觉上你可能回想把 a -&gt; a 从 f 中 “拿出来”。但是仔细一想就会发现这是拿不出来的。比如说当 f 是 [] 的时候。[a -&gt; a] 代表的是一系列的函数，你无法取出一个函数代表其中所有。更本质地说，类型构造符不是可逆的。所以“拿出来”和“放进去”的过程是不能等价变换的。\nApplicativeFunctor 做不了的事，我们就让别人来做：\nclass Functor f => Applicative f where pure :: a -> f a (&lt;*>) :: f (a -> b) -> f a -> f b\nApplicative（可应用的）具有的性质是，首先它可以将一个任意类型 a 的变量同化为 f a，也称为纯化。\n然后它可以将 f (a -&gt; b) 类型的函数变量应用于 f a 和 f b。\n这样也就解答了上文的疑惑。如果 f 也是 Applicative 的一个实例，那么我们可以\nadd &lt;$> fa &lt;*> fb\n来实现函数的调用。当然我们可以直接使用 pure 将所有的计算全部放在 f 中进行：\npure add &lt;*> fa &lt;*> fb\n当然为了不干碎直觉，我们要求你实现的 pure 和 &lt;*&gt; 满足一些性质（其实 Functor fmap 也有要求）。这样上述两种写法才能等价。\n于是你会发现，add 的作用效果还取决于 &lt;*&gt; 的定义。而 pure 和 &lt;&#36;&gt; 是有一定关系的，后者是 fmap 的一种快捷写法。\n于是我们可以理解为，要把 add 函数“拿进” f 当中，需要经过 fmap 的过程，或者说 pure 的纯化。即便如此在应用 fmap add 的时候还是有 &lt;*&gt; 来时不时插一脚。因为 add 描述的是 a -&gt; a -&gt; a 的变换，而 f (a -&gt; a -&gt; a) 与 f a 的组合过程中还是需要一些粘合剂，来引导 f a 变成 a （如果能）再应用函数 a -&gt; (a -&gt; a) 然后变回 f (a -&gt; a) 的过程。第二个参数的计算过程同理。\n当然 Applicative 还提供了一些有用的函数\n(*>) :: f a -> f b -> f b\n(&lt;*) :: f a -> f b -> f a\n分别是取右和取左。\nMonad在 Applicative 的基础上我们引入 Monad：\nclass Applicative m => Monad m where (>>=) :: m a -> (a -> m b) -> m b return :: a -> m a return = pure\nMonad 定义了一个新的运算符 &gt;&gt;= 来描述对 m a 应用一个 a -&gt; m b 的操作。然后把 pure 改写为了 return。\n事实上 &gt;&gt;= 并不是任意定义的，它与 Applicative 的运算符 &lt;*&gt; 也得满足一些性质，但是这个性质比较不可读。我们可以从另一个推论来理解：\nf &lt;$> xs = fmap f xs = xs >>= return . f\n也就是说 &gt;&gt;= 和 fmap 其实作用相似。要理解 &gt;&gt;= 的意义我们需要思考 a -&gt; m b 与 a -&gt; b 的区别。\n不难发现，a -&gt; m b 的返回值是被包裹在一个 Monad 的类型构造符中，这意味着函数的返回值将不再那么确切，因为我们知道所有关于底层类型的函数如果要放在 Applicative 的类型构造符中应用的话，势必会用到 fmap 和 &lt;*&gt;，这两者将会在你提供的函数的基础上做进一步的包装和变换。\n但是为什么我们需要一个返回值不那么确切的函数？要对 m b 类型做变换的成本显然比 b 更高。\n这是因为很多计算方式并不具备非常好的函数式编程的特点，如果要将返回值清楚地写出来的话，将会有许多无用的信息（比如，返回值可能是一个巨大的元组）。而且这会增加我们理解它的成本。有了 Monad，相当于我们只需要提供一个 a -&gt; m b 的函数。从一个确切的 a 类型变换到 m b 我们是会的，因为 Monad 会提供 return，Applicative 也有 pure 函数可以使用。其他的部分（如何调用 a -&gt; m b 的函数）则交给 &lt;&#36;&gt; 和 &lt;*&gt; 完成。它的返回值究竟是不是确切的那个数已经不重要了。因为我们所有要做的事都写成了一个 a -&gt; m b 的函数。\n换言之，不要去向怎么把 b 从 m b 中取出来（因为 Monad 会帮我们做）。不妨直接写我们要把取出来的 b 做怎样的变换。\n当然，Monad 也提供了一些其他的运算符来帮助我们变换：\n(>>) :: m a -> m b -> m b\n(>>) = (*>)\n这个操作相当于忽略前一个 Monad 的值，取后一个 Monad 的值。\n另外，Haskell 为 Monad 设计了专门的语法糖，也就是 do：\neval :: Expr -> Maybe Int\neval (Val n) = Just n\neval (Div x y) = eval x >>= (\\n -> (eval y >>= (\\m -> safediv n m)))\n-- 等价于\neval' :: Expr -> Maybe Int\neval' (Val n) = Just n\neval' (Div x y) = do n &lt;- eval x m &lt;- eval y safediv n m\n&lt;- 可以理解为把上一个 Monad 的返回值取出来继续用。当然如果两个普通的 Monad 在 do 中相邻的话连接符就是 &gt;&gt;。\n另外，每一个 a -&gt; m b 都可以被视作一个状态更新器。函数传入的 a 指代上一个状态，而返回的 m b 显然是下一个状态。\n但是在这里还得扯几句。也许目前咱们已经对 Maybe a 这种 Monad 比较懂了，但是对于 Monad 到底是怎么做到辅助状态转移，将纯函数包装成“有状态的函数”，可能还是不太能上手。\n为此我们需要思考 Haskell 状态保存的本质——通过函数传参实现。也就是说根本就没有全局变量，只不过是函数多加了一万个参数。\n因此我们将 m a 的类型理解为 state -&gt; (a, state)。那么 a -&gt; m b 本质上是要求你根据捕获的 a 类型的值来返回一个 state 修改器，这个修改器还得顺便将 a 转换为 b 类型。\n这个设计的妙处在于，你只需要写出 state 将会发生什么样的变化，而不需要关系 state 怎么被捕获的，和上文的地方也有相似之处。\n运算律探究接下来我们来分析一下 Functor、Applicative、Monad 各自满足怎样的运算律。这可以更好地帮助我们了解和阅读相关代码。\n对于 Functor，它最基本的运算符是fmap，也就是 &lt;&#36;&gt;，首先它是有（左）单位元的：\nid :: a -> a\nid a = a\n-- identity law\nid &lt;$> a == a\n另外它有复合律：\n-- composition law\n(f . g) &lt;$> a == f &lt;$> (g &lt;$> a)\n-- or\nfmap (f . g) == fmap f . fmap g\n不过阅读 link 可以知道，在 Haskell 中只要 fmap 的单位元性质成立，那么复合律自动成立。\nApplicative 的运算律会更有意思。首先 &lt;*&gt; 有（左）单位元：\n-- identity law\npure id &lt;*> a == a\n它也有复合律，不过这里的复合不再是 .，得用 pure (.)：\n-- composition law\npure (.) &lt;*> u &lt;*> v &lt;*> w == u &lt;*> (v &lt;*> w)\n-- or\n(.) &lt;$> u &lt;*> v &lt;*> w == u &lt;*> (v &lt;*> w)\n关于 pure 函数它还有同构律：\n-- homomorphism law\npure f &lt;*> pure x == pure (f x)\n也就是说先纯化再应用等价于先应用再纯化。接下来是交换律：\n-- interchange law\nu &lt;*> pure y = pure ($ y) &lt;*> u\n-- or\n(&lt;*> pure y) u = (&lt;*> u) (pure ($ y))\n也就是说先给你一个函数再告诉你传入的参数等价于先给你参数再告诉你应用到的那个函数。\nMonad 的运算律就比较抽象了。为此我们先引入 Monad 复合运算：\n-- The monad-composition operator\n-- defined in Control.Monad\n(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)\nf >=> g = \\x -> f x >>= g\n这样我们就可以发现 return 是它的单位元：\n-- identity law\nreturn >=> h == h\nh >=> return == h\n同时 &gt;=&gt; 具有结合律：\n-- associativity law\n(a >=> b) >=> c == a >=> (b >=> c)","title":"浅谈 Monad","updated":"2025-04-23T04:07:19.271Z"},{"categories":[],"path":"Probset/21-March-2/","tags":[],"text":"序列\n有一个序列，初始为空。\n每次往序列末尾等概率随机地添加一个 [1,m] 中的整数。如果出现两个相邻相同的数，值为 x 且 x&lt;t，那么就会合并为 x+1。如果序列长度为 n 且无法合并，那么操作结束。\n求结束时序列中所有数的和的期望。对 10^9+7 取模。\nn, m \\le 1000, m\\le t\\le 10^9。 期望 DP\n概率期望二元组对于事件 A，设其发生的概率是 P(A)，设其期望的贡献为 E(A)。那么称 (P(A), E(A)) 为事件 A 对应的概率期望二元组。\n相对严谨地说，事件 A 等价于若干个基本事件的集合 x_1, \\cdots, x_n。每个基本事件发生的概率不一定相同，但是每个基本事件都是不可再拆分的，也是互斥的。\n事件 A 的发生等价于 A 中恰好有一个基本事件发生。\n因此 P(A) = \\sum_{x\\in A} P(x)，E(A) = \\sum_{x\\in A}P(x)v(x)。其中 v(x) 表示基本事件 x 对随机变量的值的贡献。\n例如 x_0 = 4 是一个事件，如果 x_0 在 1,2,3,4 中等概率随机，那么 P(x_0=4) = \\frac{1}{4}，v(x_0 = 4) = 4。\n对于两个互斥事件 A, B，A 和 B 中有一个发生等价于 A\\cup B 这个事件的发生，记作 C=A+B。那么对应的概率期望二元组可定义如下运算： (p_a, e_a) + (p_b, e_b) = (p_a + p_b, e_a + e_b) = (p_c, e_c)对于两个互斥事件 A, B，那么 A 和 B 同时发生等价于 A 中恰有一个基本事件 x_i 和 B 中恰有一个基本事件 y_j 同时发生，记作 AB。\nP(AB) = P(A)P(B) 是很好证明的，因此我们主要证明 E(AB) = P(A)E(B) + E(A)P(B)。 \\begin{aligned}\nE(AB) &= \\sum_{x\\in A}\\sum_{y\\in B}P(x)P(y)(v(x)+v(y))\\\\\n&= \\sum_{x\\in A}P(x)v(x)\\sum_{y\\in B}P(y) + \\sum_{x\\in A}P(x)\\sum_{y\\in B}P(y)v(y)\\\\\n&= E(A)P(B) + P(A)E(B)\n\\end{aligned}因此可以对概率期望二元组定义如下运算： (p_a, e_a)\\cdot (p_b, e_b) = (p_ap_b, p_ae_b+e_ap_b) = (p_c, e_c)可以证明乘法对加法有分配律。乘法的单位元是 (1, 0)，加法的单位元是 (0, 0)。\n题解设 x(i, j) 表示把长度为 i 的空序列的第一个位置变成 j 的概率（不考虑第一个位置的前一个位置上的数是啥）。 x(i, j) = [j\\le m]\\frac{1}{m} + x(i, j-1)x(i-1, j-1)设 f(i, j) 表示把长度为 i 的空序列填满，且第一个位置的前一个位置上是 j。并且要求在填的过程中 j 不能被合并的概率。 f(i, j) = \\sum_{k + [j\\ne t] \\le j}x(i, k) f(i-1, k) + \\sum_{j&lt;k\\le t} f(i-1, k) \\sum_{j &lt; p \\le min(m, k)} \\frac{1}{m} \\prod_{p\\le q &lt; k} x(i-1, q)写的时候用概率期望二元组来实现会很方便。答案是 f(n, t) 对应的期望。\n注意到我们合成的最大的数是 n+m。因此 t 可以对 n+m 取 min，因此朴素算法的时间复杂度是 O(n(n+m)^2m^2) 的。\n使劲前缀和后缀和优化可以做到 O(n(n+m))。\n代码\n取石子\n有 n 堆石子，第 i 堆石子有 x_i 个。A 和 B 轮流取，A 先手。规则如下： 每次可从一堆中取 [a,b] 数量的石子。\n如果谁取完某一堆，立刻判此人胜。 求谁获胜。 博弈论 SG 函数\n我们回忆一下 SG 需满足的条件： 双人回合制：轮流执步。\n公平竞争：两人遵守的游戏规则一样。\n有限：对于任意局面，都可以在有限步数内结束。\n一般游戏条件：不能动的输。 对于这个游戏而言，第 4 个条件似乎不太满足。因为如果你取完了某一堆，不论对手是否能动，都会判你胜利。\n那么我们能否避免取完某一堆的局面出现？\n如果给出的初始局面里出现了 a\\le x_i\\le b 的堆，那么先手必胜。\n否则两人在执步过程中必然不会造出 a\\le x_i \\le b，因为这会导致对方必胜。\n因此我们可以将游戏规则改成： 每次可从一堆中取 [a,b] 数量的石子，且取完后该堆石子的数量不能落入 [a,b] 中。 原问题的第二个规则就可以不要了。\n我们发现新的游戏满足 SG 条件，同时与老游戏等价。\n因此就可以计算 SG 值找规律了。\nSG 值暴力计算\nFood Court1\n有 n 个序列，要求维护 q 次操作： \\text{Join}(l, r, c, k)：在第 l 到第 r 个序列的末位处分别插入 k 个数字 c。\n\\text{Leave}(l, r, k)：删除第 l 到第 r 个序列的开头的 k 的数字。如果序列长度不足 k 就把整个序列清空。\n\\text{Service}(a, b)：询问第 a 个序列的第 b 个数字是啥。如果序列长度不足 b 输出 0。 n, q, c \\le 2\\times 10^5, k\\le 10^9, b\\le 10^{15}。 线段树 树状数组\n这是一道基本功题。\n考虑只有 Join 和 Service 操作的情况。\n如果要在线处理，那么难以避免信息的分裂。以线段树为例，就需要将操作标记到 log 个区间上，查询的时候得在 log 个集合上二分，复杂度至少有两个 log，常数不小。\n考虑离线处理。这时我们就需要关注操作的执行时间。不过我们发现，序列里的数的位置与操作的执行时间是正相关的——操作执行地越晚，数字的位置相对越靠后。因此我们想要在序列上定位，可以在时间上二分。\n具体地，我们从 1 到 n 依次考虑第 i 个序列与其相关的操作。从第 i-1 个序列变到第 i 个序列，需要在某些时刻上加入操作，在某些时刻上减少操作。\n设 a_i 表示在时刻 i 被插入的数字个数。设 c_i 表示在时刻 i 被插入的数字的值。\n容易发现询问就变成了在 a 上 lower_bound。修改则变成在 a_i 上单点修改。这可以用树状数组维护。\n接下来考虑 Leave 操作。\n我们考虑去掉 Leave 操作。也就是说我们想办法求出每个 Service 操作真正询问的位置（相当于加上离开的人数）。这时我们不需要考虑插入的数字具体是啥，只需要考虑插入数字的个数。换言之我们要求维护 区间加\n区间取 max\n求单点的值 这可以用线段树维护。注意，这不用吉老师线段树。\n总复杂度 O(n\\log_2n)。\nRoad Construction2\n给出 n 个点 (x_i, y_i)，求曼哈顿距离下前 k 小的点对。输出他们的距离。\nn, k\\le 2.5\\times 10^5。 注：时限 10 秒。\nK-D Tree 切比雪夫距离 二维数点\n算法一暴力的做法是维护一个堆，枚举点 u，再枚举 v，然后计算 u 到 v 的距离，插入到堆中，并且始终保持堆的大小在 k 以内。\n考虑用 K-D Tree 优化这个过程。如果堆的大小已经达到 k，并且 u 到 v 的距离大于堆中的最大元素，那么 (u,v) 就是无用的。\n2-D Tree 上一个结点代表某个矩形以及这个矩形中按某一维排序的中位点。考虑将枚举 v 的过程改成在 2-D Tree 上 DFS。如果我们发现当前 DFS 到的矩形的四个角与 u 的距离的最小值大于堆中的最大元素（且堆的大小为 k）那么我们就可以直接回溯了。\n算法复杂度未知。\n能过，而且跑得飞快。\n代码\n算法二转成切比雪夫距离。然后二分。问题可以转化为求方形内的点数，可以二维数点。\n复杂度 O(n\\log^2n)。\n简\n给出一个长度为 n-1 的 01 序列 a_1,\\ldots, a_{n-1}，问有多少长度为 n 的排列 p_1,\\ldots, p_n，使得 \\forall 1\\le i &lt; n，有 [a_i = 1] = [p_i = 2p_{i+1} \\vee 2p_i = p_{i+1}]。\nn\\le 40。 DP 状圧\n考虑把 1,2,\\ldots, n 划分为 2 的倍数的链。那么对于 a 中长度为 k 的 1 的连续段，我们得拿出一段长度为 k+1 的链放上去。计算方案数的过程中有两个条件需要考虑： a_i=0 的两边的数不能是 2 倍关系。\na_i=1 的两边得是 2 倍关系。 老规矩。计数题的思路有两个：不重不漏，或者容斥。本题很难不重不漏地计数，因此考虑容斥。有两种容斥方法都是可行的： 枚举所有长度为 n-1 的 01 序列 b_1, \\ldots, b_{n-1}，计算关于 b 合法的排列数，容斥系数是 (-1)^{\\sum_{i = 1}^n [a_i \\ne b_i]}。\n枚举所有长度为 n-1 且当 a_i = 1 时有 b_i = 1 的 01 序列 b_1, \\ldots, b_{n-1}，计算关于 b 合法的排列数，容斥系数是 (-1)^{\\sum_{i = 1}^n [a_i \\ne b_i]}。 第一种相当于是把两个条件同时容斥了。第二种相当于把第一个条件容斥了。\n以第二种容斥为例。考虑使用 DP 实现。\n记 f(i, j, c_1, c_2, c_3, c_4, c_5, c_6) 表示考虑排列的前 i 个数字，其中最后的 j 个数字构成 2 的倍数链，除去前 i-j 个数字用掉的链，长度为 x 的链还剩下 c_x 个，的带上容斥系数的和。\n因为 n\\le 40，所以状态里只用记长度小于等于 6 的链数。\n转移时考虑 b_i 的值： 若 b_i = 1，那么相当于延长最后一段链，转移到 f(i+1, j+1, c_1, c_2, c_3, c_4, c_5, c_6)。\n若 b_i=0，那么就要把最后一段链结尾，然后从剩下的链中截一段出来填进去。会转移到 f(i+1, 1, d_1, d_2, d_3, d_4, d_5, d_6)。这里的 d 指截一段长度为 j 的数链出去后新的状态。具体实现见代码的 trans 函数。 接下来考虑复杂度。\n本题的状态数是很小的，可以再想办法压状态。比如用 BFS 写 DP。但简单计算一下可以发现，在 DP 过程中： 长度为 1 的链不超过 26 个。\n长度为 2 的链不超过 11 个。\n长度为 3 的链不超过 5 个。\n长度为 4 的链不超过 3 个。\n长度为 5 的链不超过 1 个。\n长度为 6 的链不超过 1 个。 因此直接开个 8 维数组就行了。\n时间复杂度 O(n\\cdot 6\\cdot 27\\cdot 12\\cdot 6\\cdot 4\\cdot 2\\cdot 2)。\n代码\nLiterary Trick\n给出两个字符串 S, T，判断他们的编辑距离是否大于 k。如果大于 k 输出 -1，否则输出他们的编辑距离。\n|S|, |T| \\le 5\\times 10^5, k\\le 5000。\n时限 7s。 DP SA\n有关编辑距离的 DP 方法有这么几种： 设 f(i, j) 表示 S[1, i] 与 T[1, j] 的最小编辑距离。这个 DP 的时间复杂度为 O(|S||T|)。\n设 f(i, j) 表示 S[1, i] 与 T[1, i-j] 的最小编辑距离。这个 DP 的时间复杂度为 O(|S|k)。\n设 f(i, j) 表示最大的 a，使得 S[1, a] 与 T[1, a-j] 的编辑距离为 i。 本题使用的则是第 3 种 DP。在转移的过程中需要使用 LCP 优化转移。\n时间复杂度 O(n\\log_2n + k^2)。\n（但其实 SA 跑得没有暴力 LCP 快）\n代码\nLovely Painting\n给出一个 n\\times m 的正整数矩阵 M，定义一个四元组 (a, b, x, y) 是个框当且仅当： 1\\le a &lt; x\\le n, 1\\le b &lt; y\\le m。\n\\forall a\\le i \\le x, \\; M_{ib} = M_{iy}。\n\\forall b\\le j\\le y, \\; M_{aj}=M_{xj}。 也就是说四条边上的数相同的视作一个框。问 M 中框的个数。 分治 数点\n首先我们设 L_{i,j}, R_{i,j}, U_{i,j},D_{i,j} 分别表示从 (i,j) 往左右上下能延伸的最长距离。\n那么对于两个点 (a,b) 和 (x, y)，若 x-L_{x, y}\\le a &lt; x\\le a+R_{a,b} 且 y-U_{x, y} \\le b &lt; y \\le b+D_{a, b}，则以 (a, b) 为左上角，(x, y) 为右下角的矩形构成一个框。\n直接四位数点是 O(n\\log^3n) 的。\n考虑分治。对于当前的 r\\times c 的矩形，不妨设 r \\le c。\n那么我们将其分为左右两部分，计算跨过中线的框的个数。\n对于左边我们记 c_1(i, j) 表示从中线上第 i 行（即 (i, mid)）出发，到中线上第 j 行结束的 “C” 型路线的个数。同样的，对右边记 c_2(i, j) 表示从中线第 i 行出发到第 j 行结束的 “反C” 型路线的个数。\n那么跨过中线的框的个数就是 c_1\\cdot c_2 = \\sum_i \\sum_j c_1(i, j)\\times c_2(i, j)。\n由于两者是对称的，以计算 c_1 为例。\n对于左边的一个点 (a, b)，若 b + R_{a, b} \\ge mid，那么这个点就有可能成为 “C” 型路线的一部分。这时可能会想到：枚举 i，其中 a &lt; i \\le a+D_{a, b}，然后判断 (i, b) 是否能延伸到中线，即判断 b + R_{i, b} \\ge mid 是否成立。不过这个思路目前看不到很好的优化。\n不妨换个角度。想办法强制 b + R_{i, b} \\ge mid 成立。也就是说我们按照某种顺序来计算贡献和。\n具体地，考虑 “C” 型路线的上下边界，假设分别是 i 和 j（i &lt; j）。如果 L_{i, mid} \\le L_{j, mid}，那么不论从第 i 行的哪一列出发，只要 “C” 型路线的竖线能从第 i 行延伸到第 j 行，就一定可以再沿着第 j 行走到中线。\n所以我们记 d_1(i, j) 表示：从 (i, mid) 出发，往左走到任意的某一列，然后往下走走到第 j 行（i &lt; j）的方案数。\n同时记 d_2(i ,j) 表示：从 (i, mid) 出发，往左走到任意的某一列，然后往上走走到第 j 行（i &gt; j）的方案数。\n这两个都可以简单地前缀和处理出来。\n那么有 c_1(i, j) = d_1(i, j) [L_{i, mid} \\le L_{j, mid}] + d_2(j, i)[L_{i, mid} &gt; L_{j, mid}]。换言之我们将点对 (i, j) 分两类分别计算方案数。\n考虑时间复杂度。每次分治我们都选择 r 和 c 中较小的作为中线。设 S = rc，那么中线长度就是 O(\\sqrt{S}) 的。根据主定理 T(S) = T(S/2) + O(S + (\\sqrt{S})^2) = O(S\\log_2S)代码 1. 来源：JOISC（Japanese Olympiad in Informatics Spring Camp Online Contest） 2021 Day1 T3。 &#8617; 2. 来源：JOISC（Japanese Olympiad in Informatics Spring Camp Online Contest） 2021 Day2 T2。 &#8617; Sequence CountingDP\n本题的难点在于 DP 状态的设计。对于计数 DP 来说，DP 的状态一般会表示为「满足某种条件的方案数」。而这里的条件既可以限定要统计的对象本身的性质，也可以限定当前的方案空间的性质。\n以本题为例，设 f(i, j, k) 表示考虑已经填好了 a_1, \\ldots, a_i，并且前 i 个数的最大值为 j，且钦定 a_{i+1},\\ldots, a_n 的最小值是 k 的方案数。\n这个状态里的第三维限定的并非前 i 个数，而是后 n-i 个数。但实际上后 n-i 个数是未知的。因此它实际上限定的是方案空间，用通俗的话讲就是：它限定了这个状态能够转移到的状态集合。\nDP 的转移则是枚举 a_{i+1} 的值，然后转移到对应的位置。\n答案是 \\sum_j \\sum_k [j\\ne k] f_{n-1, j, k}。\n朴素的 DP 时间复杂度 O(nk^3)，前缀和优化一下可以做到 O(nk^2)。\n注意到序列里不同的数最多有 n 个，因此我们可以想办法算出 g_i 表示序列中只出现了 1, 2, \\ldots,i 且每个值都出现过的方案数。那么答案就是 \\sum_i \\binom{K}{i} g_i（K 是题面中的 k）。这个可以容斥计算（也可以理解为是二项式反演）。\n这样时间复杂度就优化为了 O(n^3)。\n代码","title":"2021 省选三轮跟训日志 2","updated":"2025-04-23T04:07:19.273Z"},{"categories":[],"path":"Divide/","tags":[],"text":"区间分治A1\n求所有区间最大值之和 元素从大到小排序，用 ST 表预处理区间最大值的位置，然后按照最大值的位置分治即可。复杂度分析为 f(n)=f(a)+f(n-a)+O(1)=O(n)算上 ST 表和排序的话复杂度 O(n\\log_2n)。\n当然，还可以用并查集解决。\nA2\n求所有区间的最大值乘最小值的和。 这种不知道怎么搞的题就先一通分治。于是我们就要求跨过 mid 的区间的贡献。但这样直接做似乎还不够，于是大力讨论一波： 最大值最小值都在 mid 左边的区间。显然我们可以钦定一个 [i,mid] 的区间，求出这个区间的最大值 max_i 和最小值 min_i，然后可以想办法求出它往右可以扩张的最大范围 x，使得 [i,x] 的最大值和最小值也是 max_i,min_i，这样就可以统计贡献了；\n最大值在左边，最小值在右边。我们枚举一个左端点 i(i\\le mid)，然后看右端点的取值范围。于是我们找到右边第一个比当前最大值大的数，并且在第一个比最小值小的数之后。然后这部分的最大值乘最小值就可以算了。事实上由于最大值的变化是单调递增的，因此我们右端点也是单调移动的，于是在移动的过程中统计贡献即可；\n剩下两种情况是对称的；\n对于有相同元素的情况，可能要钦定一下最左边的那个是最大的，然后处理一下细节问题，不然可能算重。 这样我们预处理一下 Lmax_i 表示第 i 个数左边第一个比它大的数的位置。同理处理一下 Lmin,Rmax,Rmin，它们都可以线性处理，这样上述问题就可以 O(r-l+1) 求解了，总复杂度 O(n\\log_2n)。\nA3\n求所有区间的 GCD 之和 这道题是可以不分治直接做的。维护一个三元组集合，(l,r,v) 表示区间 [i,R],l \\le i\\le r 的 \\gcd 为 v。那么我们从小到大枚举 R，并计算对应的三元组集合。在同一个时刻 v 只有 O(\\log_2V) 种取值，因此集合的大小是 O(\\log_2V) 的。而在 R 自増的过程中 v 不会增加，于是整体的均摊复杂度是 O(\\log_2n) 的。\n要分治的话，强行分一个中点，然后限制左端点和右端点的范围，按照上面的做即可。复杂度 O(n\\log_2^2n)。\nA4\n给定一个排列 p，求有几个区间 [L,R] 满足足 \\left\\langle p_i \\right\\rangle_{i=L}^R 排序后是连续的。 这题显然可以用析合树直接做。但是大材小用。由于这是一个排列，因此我们要求的就是满足 \\max_{i=L}^Rp_i-\\min_{i=L}^Rp_i=R-L的区间的个数。于是又可以分类讨论一下： 最大值最小值在左边。那么我们枚举左端点 i，则右端点是单调递增的，在移动的过程中判断是否存在有合法的情况（即 mid-i\\le \\max-\\min\\le R-i）。\n最大值在左边，最小值在右边。则我们枚举左端点 i，然后像 A2 一样如法炮制找到右端点的一段合法区间。于是我们可以获得如下的信息：(l,r,x) 表示 [i,R],l\\le R\\le r 的最小值在右边且为 x。三元组序列的 x 是非严格单减的。于是我们检查 l-i\\le \\max-x\\le r-i 即可判断是否合法。在 i 向左扩展的时候，\\max 是非严格递增的。 ZJOI2016 旅行者\n给定一个 N\\times M 的网格图，有 Q 次询问，每询问两点之间的最短路。n,m\\le 2\\times 10^4, q\\le 10^5。 切一条中线考虑在左右的点对的最短路。枚举中线上的点 x，dis(a,b)=\\min(dis(a,b),dis(a,x)+dis(x,b))，于是直接对中线上的点跑单源最短路即可。设 S=mn。中线可以横着切，也可以竖着切。因此我们总能找到一种切法使得中线长度小于等于 \\sqrt{S}，因此复杂度分析为 f(S)=2f(S/2)+O(S\\sqrt S\\log_2S)\n=O(S\\sqrt S\\log_2S)代码\n平面最近点对\n给出平面上 n 个点，求最近的两个点之间的距离。 做平面分治，考虑跨过中线的点对，设当前的答案为 d。x- x_{mid}\\le d。范围缩小到两平行线间。这时我们枚举左边的点 x，则右边的点的 y 的距离不超过 d，框出一个大小为 d\\cdot 2d 的矩形。右边的矩形任意两个点的距离大于等于 d，发现矩形内至多有 6 个点。于是计算距离然后更新 d 即可。复杂度分析为 f(n)=2f(n/2)+O(6n)=O(n\\log_2n)","title":"分治","updated":"2025-04-23T04:07:19.263Z"},{"categories":[],"path":"Turing-Entrance-Exam-2022/","tags":[],"text":"笔试\n问你能否将有限个单位正方形摆放在平面上使得 任意两个正方形至多有一个顶点重合\n每个正方形的每个顶点都与其他某个正方形的顶点重合 求 (\\frac{1+\\sqrt{5}}{2})^{12} 的整数部分 对于一个加法乘法群，要求你利用 乘法结合律、交换律、对加法的分配律、逆元\n加法结合律、逆元 来证明加法的交换律 给出一个 n 个非空数集 a_i \\subseteq \\mathbb N 构成的序列 a_1, \\ldots, a_n。其中 |a_i| = i + 1。我们称该序列的一个特征分划为一个数集 \\{x_1, x_2, \\ldots, x_n\\} 且满足 x_i \\in a_i（x_i 互不相同）。 特征分划的方案数最坏情况下有多少个（至少有多少个）。\n在特征分划的方案数最少时 a_1, a_2, \\ldots, a_n 满足的条件。 Alice 和 Bob 博弈。Alice 先选一个数 m，然后 Bob 选一个数 n（n &gt;m），并构造一个 n 个点的竞赛图。Alice 如果能从中选出 m 个不同的点，满足不存在某个点 x 到这 m 个点都有出边，那么 Alice 赢，否则 Bob 赢。问是否有人存在必胜策略。 考场答案\n不会\n暴力计算，好像化简到中间某个步骤的时候把加号改成减号可以得到一个界\n构造 (a+1)(b+1)，然后展开的时候用两种方式。\n简单题\n猜的 m = 2 时甲必胜，然后做一些伪证。","title":"2022 北京大学图灵班选拔考试","updated":"2025-04-23T04:07:19.277Z"},{"categories":[],"path":"Constructive/","tags":[{"name":"Constructive","slug":"Constructive","permalink":"https://notes.sshwy.name/tags/Constructive/"}],"text":"A 组A1\n给出 n，问是否存在三个 n 的排列 a,b,c 使得 \\forall 1\\le i\\le n, \\; a_i+b_i=c_i\\pmod n。\n如果有解，给出构造。 当 n 是偶数时，左边的和是 (n-1)n，右边的和是 \\frac{1}{2}n(n-1)，不同余，因此无解。\n当 n 是奇数时，令 a 和 b 都是 [1,2\\ldots,n] 即可。\nA2\n给出一个 n=2^m-1 个点的无向完全图 G，从中找出尽量多的不交的三元环。m\\le 10。 G 的边数是 3 的倍数，因此猜测是可以取完所有边的。\n我们考虑对每条边 (x,y)，找到它所属的三元环。\n如果将边按照 (x+y)\\bmod n 分类，会有冲突。\n将边按照 x\\oplus y 分类即可（假设点的编号是 1,\\ldots,2^m-1）。\n取出所有 x\\oplus y\\oplus z = 0 的三元环 (x,y,z) 即可。\n任意两个三元环互不冲突是显然的。\n如果 x\\ne y 且 x,y,z 非 0，则一定有 z\\ne x 且 z\\ne y，这也显然。\n因此我们可以取完所有三元环，且这些三元环互不冲突，且没有不合法的情况。\nA3\n一个 2n 个点的无向完全图，你需要把这些边分成 2n-1 组，每组 n 条边，且每组都是一个匹配。n\\le 1000。 考虑按照模数分类。\n先不考虑与点 2n 相邻的边，我们将边 (x,y) 按照 (x+y)\\bmod (2n-1) 分类。\n容易发现每个类都是一个 n-1 条边的匹配。\n对于 (x+y)\\equiv z\\pmod {2n-1} 的类，我们给他分配 (2n,k) 这条边，其中 2k\\equiv z \\pmod {2n-1} 即可。\nA4\n一个 n 个点的完全图，你需要从中选出尽量多的不交的 n 个点的树。n\\le 1000。 考虑 n 是偶数的情况。上界是 \\frac{n}{2} 个树。\n考虑序列 a_x = [x,x+1,x-1,x+2,x-2,\\ldots, x+\\frac n2-1, x-(\\frac n2-1),x+\\frac n2]\\pmod n。则 (a_{x,i},a_{x,i+1}) 这 n-1 条边构成一条链，也就是树。\n容易发现 a_x 和 a_y （x\\not\\equiv y\\pmod {\\frac n2}）构成的树是不相交的。因此我们构造出了达到上界的方案。\n考虑 n 是奇数的情况。上界是 \\frac{n-1}{2}。\n则我们先对前 n-1 个点按偶数的方式构造，然后让每个 x 连一条边到 n 即可。\nB 组B1\nNFLSPC #3 G\n平面上有 n 个不三点共线蓝色的点，你需要加上 k 个红色的点，使得任意三个蓝点组成的三角形内部都必须至少有一个红点。注意红点必须在三角形内部，不能在边上。\n你需要最小化 k 的大小。n\\le 100。 考虑答案的下界。\n考虑这个 n 个点构成的凸包，假设凸包上点数是 m。对这 n 个点三角剖分，会有 2n-m-2 个互不相交的三角形。这是因为，把凸包三角剖分有 m-2 个三角形，而在凸包内每加一个点，就会多 2 个三角形，所以总数是 (m-2)+2(n-m) = 2n-m-2。\n三角形内角和是平角。\n考虑把整个平面随机旋转一个角度，使得任意两个蓝点的连线都不水平。对于每个蓝点 (x,y)，我们在 (x-\\Delta,y) 和 (x+\\Delta,y) 的位置各放一个红点。\\Delta 是一个极小的值。\n根据抽屉原理，三角形三个角平移一下可以拼成平角。因此每个三角形里都有至少一个红点，构造是合法的。这个构造用了 2n 个红点。\n容易发现，凸包外面的红点是没用，这部分红点有 m+2 个（最高的点和最低的点左右两边的红点都是没用的）。去掉它们，刚好达到下界。因此这是最优构造。\nB2\n给定一个 n^2+n 的排列，你需要从中选出一个长度为 2n 的子序列使得子序列中第 2k 和第 2k-1 大的数相邻。\n试构造出一个子序列，或说明不可能。n\\le 1000。 把序列分成 n 段，每段 n+1 个数。\n设第 i 段的最小值和次小值分别是 A(i),B(i)。\n每次我们找到 B(i) 最小的段 i，然后取出 A(i),B(i)，然后删除这一段，然后把其他段 \\le B(i) 的数删除。容易发现，其他段最多被删掉一个数。\n做 n 次得到一个长度为 2n 的序列，即可。\nB3\n有个 2n\\times m 的棋盘，有 nm 个红格子和 nm 个蓝格子。保证棋盘的左上角是红色，右下角是蓝色。你需要把蓝色格点中心两两连出一个向量，红色格子中心两两连出一个向量，你需要让这些向量之和为 0。 当 nm 是奇数时，分别连欧拉回路即可，或者分解为几个环也行。\n当 nm 是偶数时，去掉棋盘左上角的红色和右下角的蓝色，可以按照偶数的方法做。然后把所有红点连一个向量到左上角，蓝点连一个向量到右下角即可。\n证明：交换两个红蓝格子（不是左上角或者右下角的），向量和不变。\nB4\n给定一个环，环上每个点是三种颜色（RGB）之一，若一个点左右两边点的颜色不一样，你就可以任意改变这个点的颜色。\n问能否在 10n 次操作内，把一个环变成另一个。如果能，给出构造。5\\le n\\le 10^5。 首先注意到，本题操作可逆。\n如果这个环一个修改都做不了，那就是 trival 情况。\n否则我们可以想办法把这个环变成：任意两个距离为 2 的点异色的环。\n然后让两个环走到中间状态就行。\nC 组Robot Arms\n规定一个机械臂是 m 段臂，第 i 段长度为 d_i。其中一端连在 (0,0) 的位置。机械臂只允许平行于坐标轴（上下左右）放置。\n二维平面给你 n 个点 (x_i,y_i)。要求你构造一个 m\\le 40 的机械臂（长度自定），使得机械臂的另一端可以通过恰当的放置来分别落在这 n 个点上（n 个方案）。要求给出构造方案，以及落在这 n 个点上的方案。\n|x_i|,|y_i|\\le 10^9。 如果 (x_i+y_i) 的奇偶性都一样，才可能有解。\n容易想到二进制构造。设 d_i=2^{m-i}，则可以归纳法证明，满足 |x_i|+|y_i|&lt;2^m 的点都可以落到。\n如果 (x_i+y_2)\\bmod 2=0，需要在开头加一段长度为 1 的臂。\n至于落在一个点上的方案，可以递归构造。\n时间复杂度很小。\n代码\nNot Same\n大小为 n 的序列 a_1, a_2,\\cdots, a_n，满足 1 \\le a_i \\le n。每次你可以选择一个子集的元素并且把这个子集的元素都 -1，你需要在至多 n + 1 次操作之内把所有数变成 0。每次选择的子集不能相同。\n1 \\le n \\le 1000。 按降序排序，考虑这样构造： 复杂度 O(n^2)。\nInverse of Rows and Columns\n给定一个 n \\times m 的 01 矩阵 A，你可以选择任意行翻转、任意列翻转。问能否使得 A_{11},A_{12},\\cdots,A_{1m},A_{21},\\cdots,A_{2m},\\cdots,A_{n1},\\cdots,A_{nm} 变成非降序列。\n1\\le n,m\\le 200。 特判 n=1 的情况。\n容易发现，我们最终的方案，要么第一行全 0，要么最后一行全 1。而这样就可以确定列的选择。然后再判一下选择行是否有解即可。\n时间复杂度 O(nm)。\n代码\nConstruct the Binary Tree\n给定 n,d，构造一个 n 个点的二叉树，满足所有节点的深度之和等于 d。1000 组询问。\nn,d\\le 5000。 先考虑构造一棵完全二叉树。然后我们每次让总深度加 1。\n方法很简单。固定一条最长的链。 每次选择一个深度最深不在链上的点，把它往下移一个位置，或者接在链上在往下移一个位置即可。合理安排顺序以避免 3 叉的情况。\n时间复杂度 O(nT)。\n代码\nSkolem XOR Tree\n给定 n，构造一棵 2n 个节点的树，其中点权 v_i = v_{n+i} = i，要求 i 和 i + n 路径上所有点权的异或和恰好是 i（包含端点）。\n1 \\le n \\le 10^5。 如果 n=2^k 则无解。\n考虑到 2k\\oplus(2k+1)=1，因此我们想办法围着 1 构造菊花。对于 k(1\\le 2k&lt;n)，我们构造 {\\color{blue}2k}-{\\color{red}2k+1}-1-{\\color{blue}2k}-{\\color{red}2k+1}的链。这样 2k 和 2k+1 的条件就同时满足了。\n对于 1 的条件，则构造 {\\color{red}1}-2-3-{\\color{blue}1} 即可。\n这样对于 n 的奇数的情况是适用的。对于 n 是偶数的情况，我们要再加一对 n 的点进去。\n那么我们找到 1\\le x,y&lt;n,x\\oplus 1\\oplus y=n 的两个数 x,y（可以证明一定存在），然后构造 {\\color{red}n}-x-1-y-{\\color{blue}n} 即可。\n时间复杂度 O(n)。\n代码","title":"构造题选讲","updated":"2025-04-23T04:07:19.261Z"},{"categories":[],"path":"Probset/BJOI2019/","tags":[{"name":"Complete-Solution","slug":"Complete-Solution","permalink":"https://notes.sshwy.name/tags/Complete-Solution/"}],"text":"奥术神杖\n给你一个长度为 n 的串 T，字符集为1234567890.。另外给你 m 个小串 s_i，字符集为1234567890。每个小串有一个权值，对应为 v_i。设 f(x) 表示 s_x 在 T 中出现的次数。现在要求你把 T 中所有的.替换为一个数字。设 C=\\sum_{i=1}^mf(i)，则要求你在替换后，最大化 \\sqrt[C]{\\prod_{i=1}^mv_i^{f(i)}}。不用输出答案，输出任意一个替换方案。\nn,m,\\sum s_i\\le 1501, v_i\\le 10^9。 摘要：对数，二分，AC 自动机上 DP，精度。\n设答案为 ans，则做一下对数可以变成 \\ln ans = \\frac{1}{c}\\sum f(i)\\ln v_i，就是一个经典的 01 分数规划问题了。你把 f(i)\\ln v_i 理解为是 f(i) 个 \\ln v_i。设 mid=\\ln ans，那么得到 \\sum (\\ln v_i-mid)。就可以二分了。\n相当于，字符串每一次出现的权值变成了 \\ln v_i-mid，问是否存在一个替换方案使得权值和大于 0（or 小于）。这个可以对 s_i 建立 AC 自动机后 DP，设 F(i,j) 表示 T[1,i] 对应 AC 自动机上的状态 j 时的最大权值和。转移的时候记一下前驱和方案即可。\n注意精度，大于 0 要写成大于 eps。\n代码\n光线\n有 n 层玻璃。第 i 层玻璃的透光率和反光率分别是 a_i\\%,b_i\\%。问 n 层玻璃从上到下依次叠一起时，从上到下的透光率。\nn\\le 10^5,1\\le a_i+b_i\\le 100。 摘要：叠一起后，你从上往下和从下往上就是不对称的情况（如果只有一层玻璃仍然是对称的）。\n设 f(i) 表示前 i 个玻璃叠一起时，从上往下的透光率。答案就是 f(n)。特别地，f(0)=1。\n如何转移？考虑从 f(i-1) 转移到 f(i)，相当于我们这一束光先透过前 i-1 层玻璃，然后透过第 i 层。但是会有一部分光反弹回第 i-1 层玻璃上去，这部分又可能弹回来。\n因此我们还需要再设 g(i) 表示前 i 个玻璃，从下往上的反光率。这样我们就可以得到 \\begin{aligned}\nf(i)&=f(i-1)(a_i+b_ig(i-1)a_i+(b_ig(i-1))^2a_i+\\cdots)\\\\\n&=f(i-1)a_i\\sum_{j\\ge 0}(b_ig(i-1))^j\n\\end{aligned}由于 b_ig(i-1)\\le 1，因此无穷级数可以化简封闭形式。类似地，g(i) 也从 g(i-1) 转移： g(i)=b_i+g(i-1)a_i^2\\sum_{j\\ge 0}(b_ig(i-1))^j时间复杂度 O(n\\log_2n)。\n代码\n勘破神机\n题意：设 F(n) 表示用多米诺骨牌填满 2\\times n 的矩阵的方案数，G(n) 表示用多米诺骨牌填满 3\\times n 的矩阵的方案数。给出 l,r,k，请分别求出 A,B： A=\\frac{1}{r-l+1}\\sum_{n=l}^r\\binom{F(n)}{k}\\\\\nB=\\frac{1}{r-l+1}\\sum_{n=l}^r\\binom{G(n)}{k}对 998244353 取模。\nT\\le 5,l\\le r\\le 10^{18},k\\le 501。（T 组数据） 摘要：斯特林反演下降幂转普通幂，特征方程求通项公式，然后做等式数列求和。要对根号扩域。\nA 部分对于 A，可以先转化为求 \\sum_{i=0}^n\\binom{F(i)}{k}，然后有 \\sum_{i=0}^n\\binom{F(i)}{k}\n=\\frac{1}{k!}\\sum_{i=0}^n F(i)^{\\underline{k}}根据第二类斯特林数的普通幂转下降幂，再套一个斯特林反演上去就可以反过来做： x^{\\underline{k}}=\\sum_{i=0}^k(-1)^{k-i}s(k,i)x^i于是得到 \\sum_{i=0}^n F(i)^{\\underline{k}}=\\sum_{j=0}^k(-1)^{k-j}s(k,j)\\sum_{i=0}^nF(i)^j我们要快速算后面这部分，就得再做更多转化。容易发现 F(n)=F(n-1)+F(n-2) 且 F(0)=F(1)=1，相当于是一个斐波那契数列（其实 F(i)=F_{i+1}，移了一位）。由于 F_n=\\frac{1}{\\sqrt{5}}\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n-\\frac{1}{\\sqrt{5}}\\left(\\frac{1-\\sqrt{5}}{2}\\right)^n设 A=\\frac{1}{\\sqrt{5}},x=\\left(\\frac{1+\\sqrt{5}}{2}\\right),B=-\\frac{1}{\\sqrt{5}},y=\\left(\\frac{1-\\sqrt{5}}{2}\\right)，于是我们得到 \\begin{aligned}\n\\sum_{i=0}^nF(i)^j\n&=\\sum_{i=1}^{n+1}F_{i}^j\\\\\n&=\\sum_{i=1}^{n+1}(Ax^i+By^i)^j\\\\\n&=\\sum_{i=1}^{n+1}\\sum_{d=0}^j\\binom{j}{d}A^dx^{id}B^{j-d}y^{i(j-d)}\\\\\n&=\\sum_{d=0}^j\\binom{j}{d}A^dB^{j-d}\\sum_{i=1}^{n+1}(x^{d}y^{j-d})^i\\\\\n\\end{aligned}后面是个等比数列求和，可以写成封闭形式加速。\n做到这里看似没有问题。但是 \\sqrt{5} 在模 998244353 意义下不是二次剩余！但这也不难。我们对数扩域，把每个数表示成 a+b\\sqrt{5} 的形式即可。最后算出来的答案一定满足 b=0。因此不必担心。\nB 部分B 的难点在于递推式的推导。容易发现 G(n) 在 n 为奇数时等于 0，因此我们设 g_n=G(2n)。我们尝试推导 g_n 的递推式。\n经过一番推导可以发现 g_n=4g_{n-1}-g_{n-2}。然后解一下特征方程就得到了 g_n=\\left(\\frac{1}{2}+\\frac{\\sqrt{3}}{6}\\right)(2+\\sqrt{3})^n+\\left(\\frac{1}{2}-\\frac{\\sqrt{3}}{6}\\right)(2-\\sqrt{3})^n这样就可以求答案了。注意有点小细节，就是在这里是没有移一位的，所以 i\\in[0,n] 而不是 [1,n+1]。\n时间复杂度 O(k^2\\log_2n)。\n代码\n排兵布阵\n你有一个 s\\times n 的非负整数矩阵 A，满足 \\forall i\\in[1,s],\\sum_{j=1}^nA_{ij}\\le m。你可以任意构造一个长度为 n 的非负整数序列 B，使得 \\sum_{i=1}^nB_i\\le m。你的序列的权值为 \\sum_{i=1}^s\\sum_{j=1}^n [2A_{ij}&lt;B_j]j求最大权值。\nn,s\\le 100,m\\le 20000。 摘要：简单 DP。\n发现每一列是独立的，把每一列的当作一组背包起来即可。\n换一个说法，你想一个时间复杂度为 O(nms) 的算法就随便过了。\n写的时候想写一个小优化，结果边界没处理好被卡 90 了好久……\n代码\n送别\n题面太长。 摘要：估计是让你送别 OI 才出的这道题。\n把一堵墙拆成两条并列的边。那么摸着墙走相当于在边上走。\n进一步发现，整个图一定由若干个环构成。\n于是我们用平衡树维护环，对于询问操作就先看他们在不在一个环上，在就查询距离，不在就输出 -1。\n修改操作相当于要考虑加一个环，删一个环，把两个环连起来，把环断开。讨论即可。\n时间复杂度 O((nm+q)\\log_2(nm))。平均代码复杂度 7k。\n代码\n删数\n对于任意一个数列，如果能在有限次进行下列删数操作后将其删为空数列，则称这个数列可以删空。一次删数操作定义如下：记当前数列长度为 k，则删掉数列中所有等于 k 的数。\n现在有一个长度为 n 的数列 a，有 m 次修改操作： 单点修改；\n所有数 \\pm 1。 求第 i 次修改后的 a，至少需要修改几个数才能删空？\nn,m\\le 1.5\\times 10^5,1\\le a_i\\le n。 线段树 构造\n对于一个静态的序列如何求出答案？\n考虑建立权值数组，c_i 表示 i 的出现次数。那么不妨把 c_i 当成一摞方块，那么我们把这个柱子向左平推推倒，这样会覆盖 [i-c_i+1,i]。对每个权值这样操作后，没有被覆盖的位置的个数就是答案。证明：从合法性和最优性两个角度。\n那么对于修改操作，所有数 \\pm 1 相当于是数组的平移，记个指针就行。单点修改也很好维护。\n使用线段树维护。时间复杂度 O((n+m)\\log_2n)。","title":"BJOI 2019","updated":"2025-04-23T04:07:19.273Z"},{"categories":[],"path":"Math/Expectation/Classic/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"},{"name":"Expectation","slug":"Expectation","permalink":"https://notes.sshwy.name/tags/Expectation/"}],"text":"一些概念随机变量 X：有多种可能取值的变量。\nP(A)：A 事件发生的概率。\nE(X)：随机变量 X 的期望值，E(X)=\\sum_iP(X=i)\\cdot i。\n独立事件：两个事件互不影响，满足 P(AB)=P(A)P(B),E(AB)=E(A)E(B)。证明： \\begin{aligned}\nE(AB)&=\\sum_{i}\\sum_jP(A=i\\wedge B=j)\\cdot i\\cdot j\\\\\n&=\\sum_{i}\\sum_jP(A=i)P(B=j)\\cdot i\\cdot j\\\\\n&=E(A)E(B)\n\\end{aligned}期望的线性性：对于任意两个随机变量 X,Y,E(X+Y)=E(X)+E(Y)。证明： \\begin{aligned}\nE(X+Y)&=\\sum_i\\sum_jP(X=i\\wedge Y=j)(i+j)\\\\\n&=\\sum_i\\sum_jP(X=i\\wedge Y=j)i+\\sum_i\\sum_jP(X=i\\wedge Y=j)j\\\\\n&=\\sum_ii\\sum_jP(X=i\\wedge Y=j)+\\sum_jj\\sum_iP(X=i\\wedge Y=j)\\\\\n&=\\sum_ii\\cdot P(X=i)+\\sum_jj\\cdot P(Y=j)\\\\\n&=E(X)+E(Y)\\\\\n\\end{aligned}前缀和技巧：对于离散变量（取值只有整数）x，P(x=k)=P(x\\le k)-P(x\\le k-1)。\nA\n有 n 个随机变量 \\langle X_i\\rangle，每个随机变量量都是从 [1,m] 中随机一个整数，求 \\max\\left\\langle X_i\\right\\rangle 的期望。 设 S=\\max \\left\\langle x_i\\right\\rangle_{i=1}^n，则我们要求的是 E(S)。根据期望的定义式得到 E(S)=\\sum_{i=1}^mP(S=i)i我们使用前缀和技巧，得到 P(S=i)=P(S\\le i)-P(S\\le i-1)。然后我们推一波式子，你发现 S\\le i 等价于 \\left\\langle x_j\\right\\rangle_{j=1}^n \\le i，那么就可以得到 P(S\\le i)=P(\\left\\langle x_i\\right\\rangle_{i=1}^n\\le i)=\\left(\\frac{i}{m}\\right)^n\\\\\nP(S=i)=\\left(\\frac{i}{m}\\right)^n-\\left(\\frac{i-1}{m}\\right)^n\\\\于是得到 E(S)=\\sum_{i=1}^mi\\left(\\left(\\frac{i}{m}\\right)^n-\\left(\\frac{i-1}{m}\\right)^n\\right)=m-\\frac{1}{m^n}\\sum_{i=1}^{m-1}i^nB\n证明：概率为 p 的事件期望 \\frac{1}{p} 次发生。 设随机变量 x 表示这个事件在第 x 次发生。于是我们需要求 E(x)。套公式得到 \\begin{aligned}\nE(x)=&\\sum_iP(x=i)i\\\\\nE(x)=&\\sum_i(P(x\\ge i)-P(x\\ge i+1))i\\\\\n\\end{aligned}于是问题转化为我们要求 P(x\\ge i)，它表示这个事件在第 i 次及以后发生。显然它在前 i-1 次都未发生过，概率为 (1-p)^{i-1}。因此得到 \\begin{aligned}\nE(x)&=\\sum_{i=1}^\\infty ((1-p)^{i-1}-(1-p)^i)i\\\\\n&=\\sum_{i=0}^\\infty(1-p)^i\n\\end{aligned}根据小 Trick 得到 E(x)=\\frac{1}{1-(1-p)}=\\frac{1}{p}事实上，对于求期望，可以将其转化为求概率的和： \\begin{aligned}\nE(x)=&\\sum_{i=1}^\\infty P(x=i)\\sum_{j=1}^i1\\\\\n=&\\sum_{j=1}^\\infty\\sum_{i\\ge j} P(x=i)=\\sum_{j=1}^\\infty P(x\\ge j)\n\\end{aligned}C 拿球C1\n箱子里有 n 个球 1,2,\\cdots, n，你要从里面拿 m 次球，拿了后放回，求取出的数字之和的期望。 这题是一个标准的一眼题。每次取的期望是一样的，所以很容易得到答案为 \\dfrac{(n+1)m}{2}。但我们还是严谨地做一下。\n设随机变量 x_i 表示第 i 次取出来的值。那么数字之和的期望即为 E\\left(\\sum_{i=1}^mx_i\\right)=\\sum_{i=1}^mE(x_i)根据期望的定义得到 E(x_i)=\\sum_{j=1}^nP(x_i=j)j于是我们要求 P(x=j) 的概率。显然不论 j 取何值，概率都是相等的，为 \\dfrac{1}{n}，因此得到 E(x_i)=\\sum_{j=1}^n\\frac{j}{n}=\\frac{1}{n}\\frac{(n+1)n}{2}=\\frac{n+1}{2}于是答案即为 \\dfrac{(n+1)m}{2}。\nC2\n箱子里有 n 个球 1,2,\\cdots, n，你要从里面拿 m 次球，拿了后不放回，求取出的数字之和的期望。 我们设随机变量 x_i 表示 x_i=\\begin{cases}\ni&\\text{if i is chosen}\\\\\n0&\\text{if i isn't chosen}\n\\end{cases}设答案为 S，得到 S=\\displaystyle\\sum_{i=1}^nx_i，于是我们要求 E(S)=E\\left(\\sum_{i=1}^nx_i\\right)=\\sum_{i=1}^nE(x_i)\\\\展开 E(x_i) 得到 E(x_i)=\\sum_{j}P(x_i=j)j=P(x_i=i)i显然 P(x_i=i) 表示 i 被取出的概率。而拿球后不放回，相当于在 n 个球中取 m 个，因此概率为 \\dfrac{m}{n}，于是得到 E(x_i)=\\frac{m}{n}\\cdot i\\\\\nE(S)=\\sum_{i=1}^n\\frac{m}{n}\\cdot i=\\frac{m(n+1)}{2}C3\n箱子里有 n 个球 1,2,\\cdots, n，你要从里面拿 m 次球，拿了后以 p_1 的概率放回，p_2 的概率放回两个和这个相同的球（相当于增加一个球），求取出的数字之和的期望。 我们仍然设一个随机变量 x_i，它表示 i 被拿出来的次数乘 i，即对答案的贡献。形式化地，我们设 y_i 表示 i 被拿了几次，那么 x_i=y_i\\cdot i。假设数字之和为 S，那么 \\begin{aligned}\nS&=\\sum_{i=1}^nx_i\\\\\nE(x_i)&=E(y_i)\\cdot i\\\\\nE(S)&=\\sum_{i=1}^nE(y_i)\\cdot i\\\\\n\\end{aligned}\\\\然后我们考虑求 E(y_i)。首先我们知道，每一个球是平等的，意味着概率是均等的，意味着它们被拿出来的次数的期望是一样的，即 E(y_1)=E(y_2)=\\cdots=E(y_n)。而我们知道，他们被拿出来的次数的和是 m（因为你只拿了 m 个球出来），而 E(m)=m，即 E\\left(\\sum_{i=1}^ny_i\\right)=\\sum_{i=1}^nE(y_i)=m因此得到 E(y_i)=\\dfrac{m}{n}，带回上式得到 E(S)=\\dfrac{m(n+1)}{2}。\nD 游走D1\n在一条 n 个点的链上游走，求从一端走到另一端的期望步数。 假设步数是 S，求 S 的期望。我们定义一个随机变量 x_i 表示从 i 出发随机游走，第一次到 i+1 的步数。 \\begin{aligned}\nS&=\\sum_{i=1}^{n-1}x_i\\\\\nE(S)&=E\\left(\\sum_{i=1}^{n-2}x_i\\right)=\\sum_{i=1}^{n-1}E(x_i)\\\\\n\\end{aligned}我们手推一下期望的式子，发现 \\begin{array}{l}\nE(x_1)&=&1\\\\\nE(x_2)&=&\\frac{1}{2}+\\frac{1}{2}(1+E(x_1)+E(x_2))&=&3\\\\\nE(x_i)&=&\\frac{1}{2}+\\frac{1}{2}(1+E(x_{i-1})+E(x_i))&=&E(x_{i-1})+2\n\\end{array}就可以递推做了。但算出来就会发现，E(S)=(S-1)^2。\nD2\n在一个 n 个点的完全图上游走，求从一个点走到另一个点的期望步数。 设期望步数为 E，得到 E=\\frac{1}{n-1}+\\frac{n-2}{n-1}E+1解得 E=n-1。\nD3\n在一个 n 个点的完全二分图上游走，求从一个点走到另一个点的期望步数。 E_1 表示异侧点的期望，E_2 表示同侧点的期望。 \\begin{aligned}\nE_1&=\\frac{1}{n}+\\frac{n-1}{n}(E_2 + 1)\\\\\nE_2&=E_1+1\\\\\nE_1&= 2n - 1\n\\end{aligned}D4\n在一个 n 个点的菊花图上游走，求从一个点走到另一个点的期望步数。 类似的方法。\nD5\n在一棵 n 个点的树上游走，求从根走到 x 的期望步数。 对每条边 (u\\to v) 记录从 u 走到 v 的期望步数。S_u 表示 u 的儿子数（有根树） \\begin{aligned}\nE(u,v)&=\\frac{1}{|S_u|+1}+\\sum_{(u\\to v')\\in E,v'\\neq v}\\frac{1}{|S_u|+1}(1+E(v',u)+E(u,v))\\\\\nE(u,v)&=|S_u|+1+\\sum_{(u\\to v')\\in E,v'\\neq v}E(v',u)\\\\\n\\end{aligned}怎么算这个式子？把 v 当作 u 的父节点，那么 v' 一定是 u 的子节点。这就是一个树形 DP。算完到 root 后再从根到子节点算一下向下走的边的期望。这题本来可以直接 f[u] 表示从 u 走到 u 的父节点的期望步数来 DP，但上述方法更可拓展（多组询问）。\nD6\n构造一张 200 个点的无向图, 使得上面从 S 走到 T 的随机游走期望步数大于等于 1000000 步。 我们构造一个 n=100 个点的团，以及一个 100 个点的链，考虑他们的连接点 u，则 u 沿着链走一步的期望步数为 E(u)=\\frac{1}{n}+\\frac{n-1}{n}(n-1+E(u))\\\\\nE(u)=1+(n-1)^2而我们知道在链上走的期望，于是得到走到终点的总期望为 \\frac{(E(u)+E(u)+2n)(n+1)}{2}可以达到要求。\nE 经典题E1\n每次随机一个 [1,n] 的整数, 问期望几次能凑齐所有数。 设 f[i] 表示凑齐了 i 个数，期望几次凑齐所有数。 f[i]=\\frac{i}{n}(f[i]+1)+\\frac{n-i}{n}(f[i+1]+1)\\\\\nf[i]=f[i+1]+\\frac{n}{n-i}有一个有趣的问题，就是这个问题的答案为什么不是每个数第一次被凑出的时间的和的期望？如果这样算那么 E(S)=n^2。但事实上凑出的时间相当于次数的前缀和，因此是不对的。\nE2\n随机一个长度为 n 个排列 p，求 \\langle p_j\\rangle_{j=1}^i 中 p_i 是最大的数的概率。 其实这题很简单。由于每个数是均等的，因此他们成为最大值的概率也是一样的，于是答案为 \\dfrac{1}{i}。\nE3-1\n随机一个长度为 n 个排列 p，求 \\langle p_{j}\\rangle_{j=1}^i 中 p_i 是最大的数的个数（即前缀最大值的个数）的期望。 设随机变量 x_i x_i=\\begin{cases}\n1 & p_i=\\max\\left\\langle p_j\\right\\rangle_{j=1}^i\\\\\n0 & \\text{Otherwise}\n\\end{cases}则可以得到 E(S)=\\sum_{i=1}^nE(x_i)=\\sum_{i=1}^nP(x_i=1)=\\sum_{i=1}^n\\frac{1}{i}E3-2\n随机一个长度为 n 个排列 p，求 \\langle p_{i}\\rangle_{j=1}^i 中 p_i 是最大的数的个数（即前缀最大值的个数）的平方的期望。 首先要明确一点，就是平方的期望不等于期望的平方，即 E(x^2)\\ne E^2(x)，因为 x 是随机变量不是常量。\n于是我们按套路出牌，设随机变量 x_i x_i=\\begin{cases}\n1&p_i=\\max \\left\\langle p_j\\right\\rangle_{j=1}^i\\\\\n0&\\text{Otherwise}\n\\end{cases}于是我们得到 E(S^2)=E\\left(\\left(\\sum_{i=1}^nx_i\\right)^2\\right)=\\sum_{i\\ne j}E(x_ix_j)+\\sum_{i=1}^nE(x_i^2)由于 x_i\\in\\{0,1\\}，因此其实 x_i^2\\Leftrightarrow x_i，于是我们需要求 E(x_i)。仔细理解一下，其实这就是 p_i=\\max \\left\\langle p_j\\right\\rangle_{j=1}^i 的概率！于是我们得到 E(x_i)=\\dfrac{1}{i}。\n接下来考虑 E(x_ix_j)，在此之前我们思考一下 x_ix_j 的取值，有 x_ix_j=\\begin{cases}\n1& (p_i=\\max \\left\\langle p_k\\right\\rangle_{k=1}^i) \\wedge( p_j=\\max \\left\\langle p_k\\right\\rangle_{j=1}^i)\\\\\n0& \\text{otherwise}\n\\end{cases}那么一个有趣的问题是，p_i=\\max \\left\\langle p_k\\right\\rangle_{k=1}^i 与 p_j=\\max \\left\\langle p_k\\right\\rangle_{j=1}^i 两个事件是否相关？\n答案是，他们不相关！不管他们是在何种情况下同时发生，要么 i&lt;j 要么 i&gt;j，其中一个总是覆盖另一个的范围，即比另一个的所有数都大，因此不会受到另一个的选择的影响。于是我们得到 E(x_ix_j)=E(x_i)E(x_j)=\\frac{1}{ij}综上，我们得到 E(S^2)=\\sum_{i\\ne j}\\frac{1}{ij}+\\sum_{i=1}^n\\frac{1}{i}E4\n随机一个⻓度为 n 的排列 p，求 i 在 j 的后面的概率。 直观理解，i 和 j 是平等的，因此谁在前面的概率是相等的，答案即为 \\begin{cases}\n\\frac{1}{2}&i\\ne j\\\\\n0&i=j\n\\end{cases}E5-1 随机一个⻓度为 n 的排列 p，求它包含 \\left\\langle w_i\\right\\rangle_{i=1}^m 作为子序列的概率。 对于一个排列 p，你把 w_i 中的元素抽出来，那么这一定是一个 w 的排列，而我们不关心其他的数的情况，因此概率显然为 \\dfrac{1}{m!}。一个有趣的问题是：根据之前的问题，i 在 j 后面的概率是 \\frac{1}{2}，那这题的概率为什么不是 \\frac{1}{2^{m-1}}？原因是你想在一个数的后面接一个数，但它不一定放得了。\nE5-2\n随机一个⻓度为 n 的排列 p，求它包含 \\left\\langle w_i\\right\\rangle_{i=1}^m 作为连续子序列的概率。 我们设一个随机变量 x_i，其中 i 表示一个排列 p 的情况，（相当于我们有 \\dbinom{n}{m}m! 个随机变量） x_i=\\begin{cases}\n1&\\left\\langle w_i\\right\\rangle_{i=1}^m\\text{ occurs as a continuous subsequence}\\\\\n0&\\text{Otherwise}\n\\end{cases}由于 p 中出现连续的 w 做为子序列只有 n-m+1 种位置，因此我们设 T=\\displaystyle\\sum_{i=1}^{\\binom{n}{m}m!}x_i=n-m+1。现在我们想知道 w 做为连续子序列的概率，相当于求 x_i 的期望。而根据平等原则，每一种情况出现的概率是相等的，因此得到 P(x_i=1)=E(x_i)=\\frac{n-m+1}{\\binom{n}{m}m!}E6\n有 n 堆石头，第 i 堆个数为 a_i。每次随机选一个石头然后把那一整堆都扔了，求第 1 堆石头期望第几次被扔。 设随机变量 x_i 表示第 i 堆石头是第几个被拿走的，显然我们有 x_1=1+\\sum_{i=2}^n[x_i&lt; x_1]于是我们要求 E(x_1)，根据期望的线性性转化为 E([x_i&lt;x_1])，由于艾弗森括号表达式是一个布尔表达式，因此这个期望等价于 P(x_i&lt;x_1)，于是得到 E(x_1)=1+\\sum_{i=2}^nP(x_i&lt;x_1)而根据 E4，我们稍作拓展，其实 \\dfrac{a_i}{\\sum_{i=1}^na_i} 表示的就是第 i 堆石子被拿走的概率。因此 P(x_i&lt;x_1) 表示的就是第 i 堆石子比第 1 堆石子先被拿走的概率，显然为 \\dfrac{a_i}{a_i+a_1}，于是得到 E(x_1)=1+\\sum_{i=2}^n\\frac{a_i}{a_i+a_1}E7\n随机一个长度为 n 的 01 串，每个位置是 1 的概率是 p ，定义 S 是每段连续的 1 的⻓度的平方之和，求 S 的期望。 令 x_i 表示 \\left\\langle s_j\\right\\rangle_{j=1}^i 中所有为 1 的段的长度的平方之和，因此 E(S)=E(x_n)。再令 y_i 表示 \\left\\langle s_j\\right\\rangle_{j=1}^i 中最后一段 1 的长度。我们先求 x_i,y_i 的转移式。考虑第 i 位上的值。 \\begin{aligned}\n&y_i=\\begin{cases}\n0&s_i=0\\\\\ny_{i-1}+1&s_i=1\n\\end{cases}\\\\\n&x_i=\\begin{cases}\nx_{i-1}&s_i=0\\\\\nx_{i-1}-y_{i-1}^2+(y_{i-1}+1)^2=x_{i-1}+2y_{i-1}+1&s_i=1\n\\end{cases}\n\\end{aligned}于是我们考虑求 E(x_i),E(y_i)，于是我们简单地把概率套到上面的转移式就能得到 \\begin{aligned}\nE(y_i)&=p(E(y_{i-1})+1)\\\\\\\\\nE(x_i)&=p(E(x_{i-1})+2E(y_{i-1})+1)+(1-p)E(x_{i-1})\\\\\n&=E(x_{i-1})+2pE(y_{i-1})+p\n\\end{aligned}E8\n给一个序列 1,2,\\cdots,n，每次随机删除一个元素, 问 i 和 j 在过程中相邻的概率。 直接组合计数一波，相当于考虑一个排列中 i,j 相邻的概率。我们只用考虑他们中间的数，不用关心外面的数，于是得到 P=\\frac{(j-i-1)!2!}{(j-i+1)!}=\\frac{1}{\\binom{j-i+1}{2}}E9\n给定一棵树，将他的边随机一个顺序后依次插入，求 u,v 期望什什么时候连通。 那么我们只需要考虑在插入边的序列中，u,v 路径上出现时间最晚的边的位置（位置即时间）的期望。\n假设 u,v 路径长度为 k，总边数是 n-1，那么枚举最后一条边的位置 i，那么首先我们考虑剩下 k-1 条边的选法，然后是这 k 条边的顺序，然后是剩下的 n-k-1 条边的顺序（总共 n-1 条边），最后除以全排列即可。 \\frac{\\sum_{i=k}^{n-1}k!\\binom{i-1}{k-1}(n-k-1)!}{(n-1)!}E10\n给 1,2,\\cdots,n 这 n 个数，每次随机选择一个还在的数，删掉他的所有约数。求期望几次删完。 直接做的话，每一次删掉的数的个数不方便统计，不妨换一下思路。我们考虑这个问题：给 1,2,\\cdots,n 这 n 个数，初始时每个数都是白的。每次随机选择一个还在的数，如果它是黑的就删掉它，否则就把它的约数标黑再删掉它。求期望删掉几个白色的数。\n仔细思考可以发现，这个问题与原问题是等价的。原因是删除黑色的点不影响白色点被选到的概率。这样转化的好处在于，我们每次只会删掉一个数。于是我们可以定义随机变量 x_i 表示 x_i=\\begin{cases}\n1&\\text{The i-th number is white}\\\\\n0&\\text{The i-th number is black}\n\\end{cases}（注意，这里的第 i 个数是指删到第 i 个数时这个数的颜色）于是我们要求的是 E(S)=\\sum_{i=1}^nE(x_i)根据这个随机变量的定义，E(x_i)\\Leftrightarrow P(x_i=1)，于是我们要求 i 被删时是白色的概率。显然如果 i 是白色，那么 i 的所有倍数都没被删，且为白色。我们选到不是 i 的倍数时，对 i 的概率不影响，我们只需要考虑这 \\left\\lfloor\\dfrac{n}{i}\\right\\rfloor 个数中 i 最先被选中的概率。显然为 \\dfrac{1}{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}，于是得到 E(S)=\\sum_{i=1}^nE(x_i)=\\sum_{i=1}^n\\frac{1}{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}F 期望线性性练习题F1\n给定 n 个硬币，第 i 个硬币的价值为 w_i，每次随机取走一个硬币，获得的收益是左右两个硬币的价值的乘积，求期望总价值。 设随机变量 x_{i,j} 表示 x_{i,j}=\\begin{cases}\n1&i,j\\text{ contributed}\\\\\n0&\\text{Otherwise}\n\\end{cases}总价值为 S=\\displaystyle\\sum_{i&lt;j}x_{i,j}w_iw_j，于是得到 E(S)=\\displaystyle\\sum_{i&lt;j}E(x_{i,j})w_iw_j，问题转化为求 P(x_{i,j}=1)，显然就是这两个数相邻的概率，相当于是说中间的数都在他们前面被删完的概率，于是把这 j-i+1 个数抽出来，那么 i,j 排最后的概率就是 \\dfrac{2}{(j-i+1)(j-i)}。于是得到 E(S)=\\sum_{i&lt;j}\\frac{2w_iw_j}{(j-i+1)(j-i)}F2\n有 N 个数 \\left\\langle a_i\\right\\rangle_{i=1}^n，每次等概率选出两个数，然后合并成一个新的数放回来，得到的收益是新的数的值，求总收益的期望。 我们设随机变量 x_i 表示 a_i 对答案的贡献次数，显然收益为 S=\\displaystyle\\sum_{i=1}^nx_ia_i。一波套路转化为求 E(x_i)。要求期望的贡献次数，就是求期望的合并次数。每次合并都会减少一个数，而在 k 个数中选两个数，选到包含 a_i 的概率是 \\dfrac{2}{k}，于是就可以统计每次合并的期望，得到 E(x_i)=\\sum_{j=1}^{n-1}\\frac{2}{n-j+1}\\\\于是收益期望为 E(S)=\\sum_{i=1}^na_i\\sum_{j=1}^{n-1}\\frac{2}{n-j+1}F3\n给定一个数列 \\left\\langle w_i\\right\\rangle_{i=1}^n，随机一个排列 H，如果 H_i 比 H_{i-1} 和 H_{i+1} 都大，就获得 w_i 的收益，求期望收益。 设随机变量 x_i x_i=\\begin{cases}\n1 & h_i&gt;\\max (h_{i-1},h_{i+1})\\\\\n0 & \\text{Otherwise}\n\\end{cases}得到 S=\\displaystyle\\sum_{i=1}^nx_iw_i，一波套路转化为求 P(x_i=1)，即相邻三个数中中间的数最大的概率。众生平等，答案为 \\dfrac{1}{3}，如果在边上就为 \\dfrac{1}{2}。于是计算一下答案即可。\nF4\n给出一棵树, 一开始每个点都是白的, 每次选一个白点将他子树里所有点染黑，求期望几次染黑整个树。 染黑相当于删除，问题转化为每个点在它到根的路径上的点集中最先被删的概率，答案为 E(S)=\\sum_{i=1}^n\\frac{1}{dep_x}总结需要使用期望的性质解决的问题，通常都可以设出随机变量，并利用期望转概率、前缀和（容斥）、组合计数等技巧去解决。在解题的过程中也要灵活应用，重在理解题目的含义，发掘一些性质。","title":"期望经典问题入门","updated":"2025-04-23T04:07:19.268Z"},{"categories":[],"path":"Probset/NOI2020/","tags":[],"text":"有一些阴间题就咕咕了。\n题目列表\n美食家矩阵快速幂\n由于路径长度 \\le 5，因此可以将一条路拆成若干条单位长度的边。\n本题看起来很矩阵快速幂，难度在于有 k 次美食节。\n暴力做的复杂度是 O(k(nw)^3\\log T) 的。不太能过。\n注意到本质上答案是一个向量左乘若干个矩阵得到的。矩阵乘法的复杂度是 (nw)^3 的，但是向量和矩阵的乘法是 (nw)^2 的。这启发我们用 (nw)^3\\log T 的时间预处理转移矩阵在 2^k 处的矩阵幂，在计算答案的过程中做 \\log T 次向量乘矩阵即可。\n这样时间复杂度就优化到了 O(k(nw)^2\\log T + (nw)^3\\log T)。\n命运树形 DP 线段树合并\n首先这题看起来就很树形 DP。然而状态空间稍显复杂，需要转化。\n首先我们发现不是所有的限制都是有用的。包含关系的限制都可以去掉。这样我们可以预处理出 a_u 表示 u 到其祖先 a_u 的边中至少有一条边会被标记（相当于 n 个 (a_i, i) 的限制）。a 等价于题目中给的 m 个限制。\n为了划分子问题，我们站在子树的角度考虑问题。考虑结点 u 及其子树。\nA. 完全包含在 u 子树内的限制可以划分到关于 u 的问题上。\nB. 我们不关心与 u 的子树无交集的限制。\nC. 有一些限制一半在 u 子树内，另一半在 u 子树外，它们的归属有些模棱两可。\n注意到 C 类的限制与 (a_u, u) 必然相交且不包含。因此如果我们确定了 (a_u, u) 路径上的边的标记情况，就足以表达 C 类的限制受到子树外的影响。更进一步，我们只用关心 (a_u, u) 中被标记的深度最大的边即可。\n因此设 f(u, i) 表示 u 的子树，且 (a_u, u) 的路径上被标记的边的深度最大值是 i，只考虑 u 子树中的边的满足所有限制方案数（也就是说总方案数是 2^{|T_u| - 1} 的）。\n从 u 的儿子 v 转移到 u 时先枚举 (u, v) 这条边是否被标记，然后转移即可： f(u, i) = \\prod_{v} f(v, i) + f(v, d_v) \\quad (d_{a_u} &lt; i\\le d_u)其中 d_u 表示结点的深度。\n然后线段树合并优化即可。\n时间复杂度 O(n\\log n)。\n制作菜品背包 结论 构造\n首先若 \\forall i, \\,d_i\\ge k，那么很容易构造出方案。方法是把所有的 d_i 调整成 k 的倍数。\n若存在 d_i &lt; k 会比较难处理。但注意到本题的 m 范围特殊：m\\ge n - 2。\n当 m \\ge n - 1 时可以证明一定存在解。证明的方法是找到 d_i 中的最小值，设为 x。然后通过平均数放缩之类的方法证明最大值一定 \\ge k - x，即最大值加上最小值一定 \\ge k。这样你就可以凑出一个菜品，消掉最小值，然后就变成了一个规模减一的子问题（归纳法）。\n对于 m = n - 2 的情况，我们有一个奇思妙想：将这堆原材料分成两组 A, B，使得 \\sum_{i\\in A} d_i = k(|A| - 1) 且 \\sum_{i\\in B} d_i = k(|B| - 1)，即拆成两个形如 m = n - 1 的问题。\n如果拆不了那么无解。\n为啥无解：这个要稍微绕一下。简单来说 m = n - 2 无法直接按照 m = n - 1 做的，必须拆着做。\n拆着做的话假设拆成若干个形如 m = n - x_i 的不可再拆子问题。\n且 x_i 中必有一个数大于 1，不然就会拆成两 m = n - 1 的问题。\n结合 2, 3，这个问题就既不能拆也不能做，就无解了。 拆分问题就是个经典的01背包问题，用 bitset 优化一下即可。\n总时间复杂度可以做到 O(\\frac{n^2k}{\\omega} + n + m)。\n超现实树本题的思考角度稍显刁钻。\n本题要判断树的集合是否完备，为此我们从【什么树无法被替换】入手。\n但实际上任何树都可以用单个结点的树替换得到，这就变得没啥可分析的了。这说明我们思考问题的角度不够本质。\n树的集合完备，本质上等价于：存在一个数 x，使得深度 \\ge x 的所有二叉树都能被替换得到。\n因此判断集合是否完备，与树的深度有关。因此我们需要研究【哪些树无法被与它深度相同的树替换得到】，我们将这些树称作作基树。\n深度为 n 的基树构成的集合记作 B_n。\n这样我们会发现一些有趣的事情。\n一棵树 T 是基树，当且仅当对于其中的任意结点 u 满足下列条件之一： u 是叶子结点\nu 只有单个儿子\nu 儿子中至少一个是叶子结点 基树的性质体现在 发现深度为 n 的非基树均可由 B_n 中的某个树替换得到。\nB_{n - 1} 可以替换得出 B_n 且仅 B_{n - 1} 可替换得出 B_n。换言之任意的深度为 n - 1 构成的树的集合如果不完全包含 B_{n - 1}，那么它就无法替换得出 B_n。证明显然。 因此树的集合完备，本质上等价于：存在一个数 x，使得 B_x 中的树都可以被替换得到。\n由基树的性质，我们发现非基树是无用的。所以给出的 m 个树中我们只保留基树。\n因此问题转化为：给出的基树能否替换出一个 B_x。\n基树的形态酷似一条链，它的分布呈树形结构。基树的非叶子结点有 4 类： 没有左儿子\n没有右儿子\n左儿子是叶子\n幼儿子是叶子 这样可以用一棵四叉树表示不同深度的基树构成的集合！\n（注意：基树在四叉树上不一定是一条链。例如条件 3 和 4 可以同时满足）\n稍微思考可以发现，我们可以在四叉树上定义类似的完备与否，通过简单的 DFS 来判断整个四叉树是否完备。","title":"NOI2020 补题记录","updated":"2025-04-23T04:07:19.274Z"},{"categories":[],"path":"Math/Subset-Transform/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"},{"name":"FWT","slug":"FWT","permalink":"https://notes.sshwy.name/tags/FWT/"},{"name":"FMT","slug":"FMT","permalink":"https://notes.sshwy.name/tags/FMT/"}],"text":"总结一下有关子集变换的笔记。\n约定： 接下来我们讨论的序列一般指长度为 2^n，下标从 0 开始的序列。例如 a_0, a_1, \\ldots, a_{2^n-1}。\n集合幂级数其实可以理解为以集合为下标的序列。本质上就是普通的序列，只不过是用集合的运算表示位运算。本文中的序列可能指集合幂级数，也可能指普通序列，具体见上下文或者使用的记号。\n集合占位多项式可以理解为是一个序列，序列中的每个元素都是一个多项式。 快速莫比乌斯变换子集与考虑形式化的问题：对于两个序列 a,b，我们希望求序列 c： c_i=\\sum_{j\\& k=i} a_j b_k用集合幂级数的语言，我们想求的是 c_S=\\sum_{S=P\\cap Q} a_P b_Q其中 S 是集合。接下来的问题与过程形式都使用集合来展现。\n考虑做一个高维后缀和的变换。对于集合幂级数 f 定义 f'： f'_S=\\sum_{S\\subseteq T}f_T那么我们对 a 和 b 同时做高维后缀和变换得到： \\begin{aligned}\nc'_S&=\\sum_{S\\subseteq T}c_T=\\sum_{S\\subseteq P\\cap Q}a_P b_Q\\\\\n&=\\sum_{S\\subseteq P}a_P\\sum_{S\\subseteq Q}b_Q\\\\\n&=a'_Sb'_S\n\\end{aligned}也就是说如果我们能快速计算 a 和 b 的高维后缀和，就可以快速得到 c 的高维后缀和 c'。\n在求出了 c' 后，我们希望还原成 c，可以用容斥得到 c(T)=\\sum_{T\\subseteq S}(-1)^{|T|-|S|}c'(S)但其实没必要这么麻烦。我们可以直接倒着写高维后缀和，就可以逆变换回去。\n高维后缀和可以写成\nfor(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;(1&lt;&lt;n);j++) if((j&amp;(1&lt;&lt;i))==0) s[j]+=s[j+(1&lt;&lt;i)];\n&#125;\n高维后缀差分（逆变换）：\nfor(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;(1&lt;&lt;n);j++) if((j&amp;(1&lt;&lt;i))==0) s[j]-=s[j+(1&lt;&lt;i)];\n&#125;\n时间复杂度 O(n2^n)，空间复杂度 O(2^n)。\n子集或对于序列 a,b，我们想求 c_S=\\sum_{S=P\\cup Q}a_Pb_Q类似的，我们这次定义一个高维前缀和： f'_S=\\sum_{T\\subseteq S}f_S则可以推出 \\begin{aligned}\nc'_S&=\\sum_{T\\subseteq S}c_T=\\sum_{P\\cup Q\\subseteq S}a_Pb_Q\\\\\n&=\\sum_{P\\subseteq S}a_P\\sum_{Q\\subseteq S}b_Q\\\\\n&=a'_Sb'_S\n\\end{aligned}于是类似地使用高维前缀和与高维前缀差分即可。\n扩域情况对于集合幂级数而言，每一个元素只有选或者不选两种情况。换言之，二进制数的每个位只有 0 或者 1 两种值。而对于可重集，即 k 进制数来说，也是可以定义集合幂级数以及高维前（后）缀变换的。\n以子集与为例，高维后缀和变换可以一般地表示为 c(\\min(a_1,b_1),\\min(a_2,b_2),\\cdots,\\min(a_n,b_n))\n=\\sum a(a_1,a_2,\\cdots,a_n)b(b_1,b_2,\\cdots,b_n)\\\\\nc'(p_1,p_2,\\cdots,p_n)=\\sum_{p_i\\le q_i}c(q_1,q_2,\\cdots,q_n)取 \\min 相当于与运算；p_i\\le q_i 相当于后缀和操作。\n分治多项式乘法为了理解 FWT 的 xor 变换在干啥，我们先引入分治多项式乘法。\n我们有两个定义在加法乘法环下的 n-1 次多项式 A,B，我们想求 A(x)B(x)。设 \\begin{aligned}\nA(x) &= P_1(x)x^{n/2}+P_2(x)\\\\\nB(x) &= Q_1(x)x^{n/2}+Q_2(x)\n\\end{aligned}假定 n 是 2 的幂。则我们有 \\begin{aligned}\nA(x)B(x) &= (P_1(x)x^{n/2}+P_2(x))(Q_1(x)x^{n/2}+Q_2(x))\\\\\n&= (P_1Q_1)x^n+(P_1Q_2+P_2Q_1)x^{n/2}+P_2Q_2\\\\\n\\end{aligned}而我们知道 P_1Q_2+P_2Q_1=(P_1+Q_1)(P_2+Q_2)-P_1Q_1-P_2Q_2\\\\因此可以只算 P_1Q_1,P_2Q_2,(P_1+Q_1)(P_2+Q_2) 的乘法，递归下去。时间复杂度 T(n)=3T(n/2)+O(n)=O(n^{\\log_23})\\\\异或卷积异或卷积问题：对于序列 a,b，我们要求 c_i=\\sum_{j\\oplus k=i}a_jb_k\\oplus 表示位异或运算。\n我们首先介绍分治异或卷积算法，然后介绍广泛使用的快速沃尔什变换。了解分治异或卷积算法有利于理解快速沃尔什变换。\n分治异或卷积由于异或具有结合律、交换律，对加法的分配律，则我们定义一个指数通过异或运算合并的多项式来表示该序列： C(x)=\\sum_{i = 0}^{2^n-1} c_ix^i可以理解为是“异或生成函数”。类似地我们定义出 A(x) = \\sum_i a_i x^i 以及 B(x) = \\sum_i b_i x^i，那么有 C(x) = A(x) B(x)。这里的乘法定义为 A(x) B(x) = \\sum_{i = 0} ^ {2^n-1} \\sum_{j = 0} ^ {2^n-1}a_i b_j x^{i\\oplus j}为了计算上述异或乘法，我们将多项式前后拆成两半。设 \\begin{aligned}\nA(x) &= P_1x^{2^{n-1} }+ P_2\\\\\nB(x) &= Q_1x^{2^{n-1} }+ Q_2\n\\end{aligned}则使用分治可以得到 \\begin{aligned}\nC(x) &= A(x) B(x)\\\\\n&= (P_1x^{2^{n-1} }+ P_2) (Q_1x^{2^{n-1} }+ Q_2)\\\\\n&= P_1Q_1 + (P_2Q_1 + P_1Q_2)x^{2^{n-1} } + P_2Q_2 x^{2^{n-1} \\oplus 2^{n-1} } \\\\\n&= P_1Q_1 + (P_2Q_1 + P_1Q_2)x^{2^{n-1} } + P_2Q_2 \\\\\n&= (P_1Q_1 + P_2Q_2) + (P_2Q_1 + P_1Q_2)x^{2^{n-1} } \\end{aligned}这里有个特殊之处：由于下标的异或运算使得 P_2 Q_2 项的指数被消掉了，因此我们实际上只用递归算两次多项式乘法。我们设 X=(P_1+P_2)(Q_1+Q_2)\\\\\nY=(P_1-P_2)(Q_1-Q_2)于是可以得到 \\begin{aligned}\nP_1Q_1+P_2Q_2 &= \\frac{X+Y}{2} \\\\\nP_2Q_1+P_1Q_2 &= \\frac{X-Y}{2}\n\\end{aligned}那么 C(x) = \\frac{X + Y}{2} + \\frac{X - Y}{2}x^{2^{n-1} }。\n时间复杂度就是 T(2^{n-1} )=2T(2^{n-1} )+O(2^n)=O(n2^n)\\\\事实上，与卷积和或卷积也可以使用分治多项式乘法去理解。\n快速沃尔什变换快速沃尔什变换（Fast Walsh–Hadamard transform，FWT or FWHT）1是用于快速计算一个序列的沃尔什变换的算法。在算法竞赛领域中，大多数时候 FWT 的作用是快速计算异或卷积。\nFWT 的本质是把 a 变成了 \\text{FWT}(a)_i=\\sum_j a_j (-1)^{\\operatorname{popcount}(i\\& j)}写成集合幂级数的形式就是 \\text{FWT}(a)(S)=\\sum_{T}a(T) (-1)^{|S\\cap T|}不过直接抛出 FWT 的定义并不能帮助我们理解为什么 FWT 可以加速异或卷积的计算。\n通过分治异或卷积理解为此我们沿用上文中分治异或卷积的描述。\n首先我们要更改分治异或卷积的执行顺序，更准确地说是拆分。\n分治异或卷积的优化用一句话概括就是：将计算 (P_1x^{2^{n-1} }+ P_2)(Q_1x^{2^{n-1} }+ Q_2) 归约到计算 (P_1+P_2)(Q_1+Q_2) 和 (P_1-P_2)(Q_1-Q_2) 两个长度减半的异或卷积。\n在实现的时候设 \\text{Solve}(l, r) 表示将 \\sum_{i = l} ^ r a_i x^i 与 \\sum_{i = l} ^ r b_i x^i 做异或卷积。\n我们不妨考虑将 A(x) = (P_1x^{2^{n-1} }+ P_2) 变成 A'(x) = ((P_1 - P_2)x^{2^{n-1} } + (P_1 + P_2))，将 B(x) = (Q_1x^{2^{n-1} }+ Q_2) 变成 B'(x) = ((Q_1 - Q_2)x^{2^{n-1} } + (Q_1 + Q_2))。对于这两个新的多项式： 首先我们将其前半部分做卷积，后半部分做卷积，即递归调用 \\text{Solve}(l, mid) 和 \\text{Solve}(mid+1, r)。\n经过上一步我们计算出了 X 和 Y，然后再根据 C(x) = \\frac{X + Y}{2} + \\frac{X - Y}{2}x^{2^{n-1} }，还原出 C 的系数表示即可。 考虑第一步和第二步本质上做了什么事情。他们其实执行的计算是差不多的，只不过第二步需要除以 2 而第一步不需要。且第一步我们需要同时变换 A 和 B，而在第二步里 X 和 Y 其实表示的是同一个多项式的高低位。\n因此我们有一个想法：我们将第一步的过程和第二步的过程拆开，再将第一步中对 A 和 B 的变换过程拆开！\n换言之我们的操作过程变成： 先分别递归变换 A 和 B 得到 \\mathcal{T}(A) 和 \\mathcal{T}(B)。\n这时 \\mathcal{T}(A) 和 \\mathcal{T}(B) 里存的分别是 2^n 个单项式（只有常数项的多项式）。因此我们直接将两者点乘得到 \\mathcal{T}(C)。\n然后递归地自底向上执行第二步的过程，将 \\mathcal{T}(C) 转化为最后的 C。 由于这三个过程彼此不相关，只要顺序不要乱就行，因此拆开的正确性有保证。\n接下来我们要理解对 A 的变换是 FWT 变换。\n以 A 为例，我们分析对 A 的变换：将 A(x) = (P_1x^{2^{n-1} }+ P_2) 变成 A'(x) = ((P_1 - P_2)x^{2^{n-1} } + (P_1 + P_2))，然后前后两半递归变换。\n设 \\mathcal{T}(A) = \\sum_{i = 0} ^ {2^n-1} t_i x^i，那么我们对于 i 分析 t_i 的值是如何得到的。\n以 n=3, 2^n=8 的情况为例，我们用绿色线表示系数为正，红色线表示系数为负，画出从 A 变换为 \\mathcal{T}(A) 的示意图： 考虑 a_j 对 t_i 的贡献。那么我们只需要考虑 a_j 对 t_i 贡献的系数是 1 还是 -1 即可，这显然由从 a_j 到 t_i 路径上的红色箭头数量的奇偶性决定。为此我们枚举考虑 i 和 j 二进制下第 k 位： 如果两者第 k 位是相同的，那么走的就是水平方向的，这时是否为红色箭头取决于这一位是否为 1；\n如果两者第 k 位不同，那么 j 得走斜着的箭头，而斜着的箭头是不存在红色的。 综上所述，系数即为 (-1)^{\\text{popcount}(i\\&j)}。因此 t_i = \\sum_{j = 0} ^ {2^n - 1} a_j (-1)^{\\text{popcount}(i\\&j)}，这恰好就是 FWT 变换的定义。\n代码实现FWT 和 IFWT 的递归过程为 \\begin{array}{r|l|r|l}\n\\hline\n1 & \\textbf{function }\\text{FWT}(a,l,r)&\n1 & \\textbf{function }\\text{IFWT}(a,l,r)\\\\\n2 & \\qquad m \\gets \\frac{r-l}{2}&\n2 & \\qquad \\text{IFWT}(a,l,l+m)\\\\\n3 & \\qquad \\textbf{for }i=l\\textbf{ to }l+m-1&\n3 & \\qquad \\text{IFWT}(a,l+m,r)\\\\\n4 & \\qquad \\qquad x \\gets a_i&\n4 & \\qquad m \\gets \\frac{r-l}{2}\\\\\n5 & \\qquad \\qquad y \\gets a_{i+m}&\n5 & \\qquad \\textbf{for }i=l\\textbf{ to }l+m-1\\\\\n6 & \\qquad \\qquad a_i \\gets x+y&\n6 & \\qquad \\qquad x \\gets a_i\\\\\n7 & \\qquad \\qquad a_{i+m} \\gets x-y&\n7 & \\qquad \\qquad y \\gets a_{i+m}\\\\\n8 & \\qquad \\textbf{end for} &\n8 & \\qquad \\qquad a_i \\gets \\frac{x+y}{2}\\\\\n9 & \\qquad \\text{FWT}(a,l,l+m)&\n9 & \\qquad \\qquad a_{i+m} \\gets \\frac{x-y}{2}\\\\\n10 & \\qquad \\text{FWT}(a,l+m,r)&\n10 & \\qquad \\textbf{end for} \\\\\n11 & \\textbf{end function} &\n11 & \\textbf{end function} \\\\ \\hline\n\\end{array}异或卷积则是 FWT 后直接做乘法：\\operatorname{IFWT}( \\operatorname{FWT}(a) \\times \\operatorname{FWT}(b) )。\n事实上， \\operatorname{IFWT}(a) = \\operatorname{FWT}(a)\\cdot 2^{-n}。因此非递归版本的 IFWT 也可以直接在最后除掉一个 2^n。\n模板代码\nTrick有一个小 Trick 就是，如果我们修改 \\operatorname{FWT}(a)(0)，那么等 \\operatorname{IFWT} 变换回去后，所有项都被增加一个常量（这个常量不一定等于我们修改的差量）。原因如上所述，a_0 的贡献永远是正的。\n这个性质可以用来解一些要求 a_0=0 的题，那么我们给 \\operatorname{FWT}(a)(0) 随机一个值，变换回去后把所有项都减掉 a_0 即可。 子集卷积我们考虑这样一个问题：求不相交的或卷积： c_S=\\sum_{P\\cup Q=S,P\\cap Q=\\varnothing}a_P b_Q这个不好求。我们设一个集合占位多项式： \\begin{aligned}\nA_{S}(x) &= \\sum_{T\\subseteq S} a_Tx^{|T|} = \\sum_{i} x^i \\sum_{T\\subseteq S,|T|=i} a_T \\\\\nB_{S}(x) &= \\sum_{T\\subseteq S} b_Tx^{|T|} = \\sum_{i} x^i \\sum_{T\\subseteq S,|T|=i} b_T\n\\end{aligned}左右两个定义是等价的。\n令 C_S(x) = A_S(x) B_S(x) 则可以得到 \\begin{aligned}\nC_S(x) &= \\sum_{P\\subseteq S} a_P x^{|P|} \\sum_{Q\\subseteq S}b_Q x^{|Q|} \\\\\n&= \\sum_{P\\subseteq S} \\sum_{Q\\subseteq S} a_P b_Q x^{|P|+|Q|} \\\\\n&= \\sum_{P \\cup Q \\subseteq S} a_P b_Q x^{|P|+|Q|} \\\\\n\\end{aligned}把这个逆变换得到 c_S = \\sum _{P\\cup Q = S}a_P b_Q x^{|P|+|Q|}这时你会发现，当 |P| + |Q| = |S| 时有 P\\cup Q=S,P\\cap Q=\\varnothing。因此我们取 [x^{|S|}] c_S 就是答案。\n时间复杂度为 2O(n2^n)+O(n^22^n)+O(n2^n)=O(n^22^n)在实现的时候有一个技巧，就是在暴力卷积的时候要稍微调整循环顺序，不要一列一列访问内存，不然常数极大。\n代码\nHDU 5823首先显然色数是 \\le n 的，因为你每个点染不同颜色一定是成立的。\n而显然每种颜色可以染一个独立集。设 f(S) 表示点集 S 是否是一个独立集，g(S,x) 表示 S 点集能否使用 x 种颜色染。则 g(S,1)=f(S)\\\\\ng(S,i)=\\left[\\sum_{T\\subseteq S}g(T,i-1)f(S\\setminus T)\\right]\\\\\ng(P\\cup Q,i)=\\left[\\sum_{P\\cap Q=\\varnothing}g(P,i-1)f(Q)\\right]但事实上 P\\cap Q=\\varnothing 不是必要条件，它不会影响最优解。因此这就是一个子集或卷积，需要做 n 次，每次卷完要回来转成艾弗森括号运算值。总复杂度 O(n^22^n)。\n代码\nCF1034 E\n求 c_S=\\sum_{P\\cup Q=S,P\\cap Q=\\varnothing}a_Pb_Q\\bmod 4。n\\le 21。 可以使用上述子集卷积做法，复杂度 O(n^22^n)，在这道题中是不能通过的。\n设 \\begin{aligned}\nA_S(p) &= \\sum_{T\\subseteq S}a_Tp^{|T|}\\\\\nB_S(p) &= \\sum_{T\\subseteq S}b_Tp^{|T|}\n\\end{aligned}设 F_S(p) = A_S(p)B_S(p)，还原一下有 f_S(p) = \\sum_{P\\cup Q = S}a_P b_Q p^{|P| + |Q|}。\n注意到 f_S(p) 这个多项式的最低次项的指数是 |S|。而我们要的就是所有 [p^{|S|}]f_S 的和（即 |P| + |Q| = |S|）。\n设 p=4，这题要求对 4 取模。\n那么我们可以直接把 p=4 代入 \\frac{f_S(p)}{p^{|S|}} 这个多项式，因为是对 4 取模，因此除了常数项之外的其他项的贡献都是 0。实现的时候开 LL 暴力右移即可。\n代码\nHDU 5330这道题虽然名称上是状圧 DP，但在 DP 的过程中是按维度考虑，其实是在做一个高维前缀和的过程。这样就更容易理解它 DP 的含义了。\n具体的 DP 方法可以见注释。\n代码\nAGC034 F设 E(x) 表示从 0 变到 x 的期望： E(x)=1+\\sum_{i=0}^{2^n-1}E(i)p_{x\\oplus i}\\\\\n=1+\\sum_{i=0}^{2^n-1}E(x\\oplus i)p_i \\\\且 p_x=\\dfrac{A_x}{S},E(0)=0。注意到这是一个异或卷积的形式（x\\oplus i\\oplus i=x），则这个等式可以被表示为 \\left\\langle E(0),E(1),\\cdots,E(2^n-1) \\right\\rangle \\oplus \\left\\langle p_0,p_1,\\cdots,p_{2^n-1} \\right\\rangle=\\left\\langle ?,E(1)-1,E(2)-1,\\cdots,E(2^n-1)-1 \\right\\rangleE(0)=0，不满足和式，因此表示为 ? 状态。\n由于 \\sum_{i=0}^{2^n-1}p_i=1，而在上述异或卷积中每个 E(i) 都和所有的 p_i,i\\in[0,2^n-1] 乘起来贡献了一次。因此 E(0)+E(1)+\\cdots+E(2^n-1)=?+(E(1)-1)+(E(2)-1)+\\cdots +(E(2^n-1)-1)\\\\\n?=E(0)+2^n-1于是得到 \\left\\langle E(0),E(1),\\cdots,E(2^n-1) \\right\\rangle \\oplus \\left\\langle p_0,p_1,\\cdots,p_{2^n-1} \\right\\rangle\\\\\n=\\left\\langle E(0)+2^n-1,E(1)-1,E(2)-1,\\cdots,E(2^n-1)-1 \\right\\rangle我们想办法把所有 E(x) 消掉： \\left\\langle E(0),E(1),\\cdots,E(2^n-1) \\right\\rangle \\oplus \\left\\langle p_0-1,p_1,\\cdots,p_{2^n-1} \\right\\rangle=A=\\left\\langle 2^n-1,-1,-1,\\cdots,-1 \\right\\rangle于是我们 FWT 之后计算 \\operatorname{FWT}(A)(i)/\\operatorname{FWT}(p)(i)，然后再转回来即可。因为最后的答案是强制 E(0)=0，所以在做的时候可以直接乘上逆元。最后使用 FWT 本质的 Trick 即可。\n时间复杂度 O(2^nn)。\n代码 1. https://en.wikipedia.org/wiki/Fast_Walsh%E2%80%93Hadamard_transform &#8617;","title":"集合变换学习笔记","updated":"2025-04-23T04:07:19.271Z"},{"categories":[],"path":"19-CSP-Sum/","tags":[],"text":"挂分原因首先总结一下挂分原因。直接原因是没有对拍，因为没有意识到大样例太弱，而且写了一个容错率不高的东西，细节没有考虑到，也只手模了一次小的数据，因此算法实现错误导致挂分。\n总结一下整场考试的发挥。Day1 除了 T2，以及在 T3 上花费太长时间以至于没有巩固 T2，其他都发挥正常。Day2 开场 1 个半小时写了 T1 的 84 分，耗时有点长。其实思路是半个小时就想好的，但一直在想搞正解所以磨蹭了很久。开 T2 的时候才发现是一道贪心题，15 分钟写了 64 分做法。开 T3，发现和徐州站 ACM 的一题很像，因此按当时的做法写了一个换根 DP。Day2 的算法除了 T2 的贪心之外，T1 计数、T3 轻度数据结构，容错率较高，并且大样例相对较强，因此没有挂分。\n整场的问题是由心态导致的。考场策略在考前是定下来的，但是考场上的心态让我总是想杠正解，于是浪费了一些时间，也因此挂分。不稳。\n虽然我可能失去了宝贵的机会，但失落之余，我认为这不全是坏事。它激发我拼命训练的斗志。\n学习总结心态总结完，接下来总结一下算法知识的情况。\n目前，大部分省选算法都有所涉猎，有些算法没有实现但有所耳闻。接下来需要进行算法专题的讲解并配套训练，然后就是在模拟赛中积累更多套路。\n按照之前的大纲，具体的学习情况如下： 平衡树已经掌握，但遇到的有难度的题目较少，做的题大多是不动脑子的码题；\nLCT 学过，但不熟悉，做题较少；\n树剖的套路见得少；\n可持久化数据结构之前掌握过，现在有点生疏；\nAC 自动机，后缀数组，SAM，PAM 生疏；\n不平等博弈目前一窍不通；\n计算几何一窍不通；\n网络流建模讨论见得少；\n长链剖分、斯特林数、仙人掌、单位根反演未学习\n模拟退火等骗分算法没学 计划其中部分内容，可以通过 Scape 哥哥的视频课学习。其他内容，在正睿的课件中也多有讲述。我认为这不要紧，最应该考虑的是制定一个可执行的高效计划，来学习省选算法。\n我认为当前的学习日志方法有一定的缺陷。最直观的感受就是，每次打开文档的速度越来越慢（虽然这不可避免）当然，另一方面就是逐渐出现不更新日志的情况。\n学习日志主要是记录我们学习的内容，但是没有对将要学的内容做规划，因此容易让人逐渐产生惰性。\n我想再维护一个日程表（共享 Excel 文档），用于给未来的日程做规划。最常用的场合就是给接下来的一周做规划。这样整个团队预先知道自己的任务，心态上就会做好准备，效率会更高。如果总结的内容不多，可以把学习日志直接合并到这个 Excel 里。\n然后就是任务分配的计划。之前的训练缺乏计划性，每天早上才开始想今天该学啥，导致进度较慢。但如果用力过猛，计划就无法长久坚持。\n因此思考下来，我觉得可以将一周分成三种日程： 轻量级任务，通常安排在周一，周三，周五；\n重量级任务，安排在周二，周四，周六；\n全天休息，周日 轻量级任务：学视频课、按列表刷题、打 CFvp、学文化课等。还有一个就是，可以把上周拖欠的任务放到下周的轻量级日程中。\n重量级任务：省选模拟赛、大码量题的训练、学习数论知识等。\n每天的总结在当日完成，不拖到星期天。计划是可变的，但宗旨是劳逸结合。\n总结「把一件好事变成更好的事，不是一个人的本事；把一件坏事变成更坏的事，也不是一个人的过失；但能把一件坏事变成好事，那对这个人而言是善莫大焉。」我依稀记得初中班主任的语录，放在这里再适合不过。\n有一个小插曲，就是学校的教练得知我的训练情况后，建议我找比我大一届的水平比我高的学长来一起训练。但是我回复她说，这样训练没有问题。虽然没有水平高我一大截（高爸）的 OIer 长时间带我，但是我有一群志同道合的伙伴。尽管我在团队中年龄最大，机会最少。但在经历了这两个月的训练与这次教训，我更清楚地认识到这个团队的可贵。做大佬的舔狗真的没意思，OI 界能找到的真心朋友少之有少。说到底，带领这个团队一起向前是我想做的。不论走多远，结果怎样。好歹我还是旷了几个月文化课，不亏不亏。\n这几天一个人在家里，发生了这样那样的事情，又不得不接收，其实蛮自闭的。真的就应了我说的那句，「OI 的世界，只允许我们笑里藏泪」。调整好状态，以前所未有的信念迎接接下来的训练。我的目标说起来很简单，虽然也很中二，就是成为一个稳的黄队。\n迷迷糊糊写完了。因为还在调整状态可能观感不佳，谅解 悲愤的故事仍继续着。成绩出来了，279。 D2T2，MLE。\n4e7，4 个 LL 就爆了。考场上没注意。关键是那个评测机是一开始就直接开满内存。所以直接 MLE。\n真 TM 悲愤\n把这次耻辱记在这里了。\n然后就是，感谢网易云的日推，很治愈。 感谢关心。\n让往事随风去吧。这样才能凤凰涅磐。","title":"2019 CSP-S 考挂总结","updated":"2025-04-23T04:07:19.260Z"},{"categories":[],"path":"AFO/","tags":[{"name":"Original","slug":"Original","permalink":"https://notes.sshwy.name/tags/Original/"},{"name":"OI","slug":"OI","permalink":"https://notes.sshwy.name/tags/OI/"}],"text":"退役啦！\n我大概想了一下，决定把 NOI2021 的游记咕了。\n退役其实只是一瞬间的事，等我反应过来的时候，也只是感叹时光飞逝。我试想了一下，即使我 NOI 是金牌，也许仍不会有别的感受。接下来一年终究充满了变数。即使保送，也一定会在将来某个时间点受挫，不可能一路高歌猛进。这么一想，其实我打银牌也蛮不错的了，至少给我找了很多事做，能让我处于有目标且能够朝着目标奋斗的状态。\n重温我的 OI 生涯，有几处关键节点值得纪念。\n初识 OI：首先是于初一时自学语言，彼时我从家里翻出一本《C程序设计》的旧书，然后对着它抄了一遍。当时我甚至不知道有 OI 这一门竞赛，只是单纯想要学习编程。在此我非常感谢当年徐老师对我的引导，帮助我的竞赛入门建立在对 OI 的兴趣之上。初二时参加了生涯第一次正式比赛——NOIP 普及组，拿了个一等奖。话说 NOIP 普及组已经是时代的眼泪来着。同年暑假，我参加了正睿组织的暑假集训，由此认识了蔡老板以及昊爸，徐队，高爸，丁爸，吴队等等，建立了我个人的 OI 交际圈。当时的我未必想到，自己即将经历怎样五彩斑斓的竞赛生活。\n入门 OI：初三时拿了提高组一等奖和普及组满分，以后就可以吹：我也是拿过全国第一的人了，宣告我正式入门 OI。然后继续参加了暑假的正睿集训，认识了各路神仙，鉴于大多是“我认识Ta而Ta不认识我”的神仙，就不举例了，显得很尴尬……同年 9 月，我被蔡老板忽悠着来了金华一中，开始了真正的竞赛生活。这里不得不提金华一中的食堂，虽然没有我熟悉的川菜特色，但是真的好吃，对于我这种山里人1算得上是享受了。平时训练是在一个会议室，大家围绕长桌，有说有笑，共同进步。\n19年赛季，我直接缺席了，详见 2019 CSP-S 考挂总结，由于新冠疫情，我直接没有打省选的资格，就寄了。\n20年的赛季打得中规中矩，转折点见 2021 CCF 冬令营 游记，由此进入省队，开始了真正意义上的 NOI 训练。\n然后是 PKUSC 2021 游记，跌宕起伏之后还是有了不错的结果。\n之后就是 NOI2021 了。\n看起来我的 OI 生涯有够简略，似乎啥都没干，也就花两年时间拿了个银牌，回来卷高考。这也是我接下来想谈的。\n不论刻意还是无意，大多数人对竞赛的印象局限于“有助于升学”，而忽略了竞赛带来的其他所有。即使你自认为在学习竞赛的过程中培养了独立思考的能力，交到了很多朋友，开拓了视野，学到许多，但你的老师，家人，同学们有意无意，或直白或委婉的说辞，总是表达对此的忽视。我并非说他们真的对竞赛抱有肤浅的理解，但是他们毕竟不是圈内人，没有真正经历竞赛生活，他们的安慰、鼓励、祝贺是难以被你认同的。听起来稍显极端，但类似的情况我想多数竞赛生常有面对。\n问题自然出现：我们该以怎样的态度对待 OI？\n有关这些内容可以见 无病呻吟、无病呻吟 续，密码是我 ID（不会有人不知道我 ID 吧不会吧不会吧）\n姑且说明，里面的观点很偏激，但这个是当年的我，不是现在的我。从上文的生涯回忆可以看出，我其实记得的东西不是很多（就是记性不太好），所以不要对号入座。\n说来讽刺，我那无病呻吟真的就是无病呻吟吗？OI 人的心态不应该被漠视，其他竞赛人也是如此。\n帮助我摆脱悲观泥潭的，一方面是蔡老板，对此我报以由衷的感谢。另一方面，也是蔡老板对我引导的体现，则是依靠自我认同感，它来自我创造力和想象力的工作成果。\n在学习 OI 的过程中，我于 GavinZheng 的带领下了解了各种各样的互联网技术，包括博客的搭建与墙外的风景。\n2019 年二月，我对 OI Wiki 做了第一次贡献，并持续下去，为 OI 的发展做出微不足道的贡献。我写这篇杂谈才发现，Github 上我已经开过了 159 个 pr 了。比我想象的多很多。\n2020 年 7 月，我和dqa，东哥，徐队和高爸一起承办了 Codeforces Round 644，和东哥搭上了线，此后也参与了一次 EOJ 月赛和几次多校的命题，体会到当出题人的感受，大赚一笔。\n在搭建博客的过程中，我对 Web 技术产生了兴趣，因此自学了 JavaScript 语言，并用 NodeJS 开发了许多小项目，虽然大多数都流产，不过还是留下了一些不错的成果，比如这个博客主题，还有我对 OI Wiki NG 的一些贡献。\n在蔡老板安排下，我也尝试过 OI 教练，给还未入门 OI 的小朋友们上课，还收到了橄榄枝。\n我还帮 dyls 维护着他的恋爱史（哈哈哈没想到吧\n所有这些经历，与升学没有任何关系，甚至与“学 OI”本身也没啥关系。但我相信，它们为我之后的路有所铺垫。创造性的经历能带给我更纯粹的成就感，支撑着我在 OI 的学习路上更乐观地走。从这个角度，OI 本身其实只是钥匙，它打开了这一切，拓宽了我的视野。仔细想了想，这就是初心吧。抛开这些，我学 OI 的目的就变得功利，乐趣也就荡然无存了。\n点到为止。杂谈不是鸡汤，有关如何培养自我认同感的就不说了，仁者见仁智者见智。\nOI 本身复杂，但我们无需把它想得很复杂。以纯粹的热爱、憧憬来学习，享受纯粹的成就感，我想这是对待 OI 最适合的态度了。\n还是得感谢鼓励我激励我前行的朋友们，也包括那些不是 OIer 的同学们。我马上就回归了，和大家一起高三啦。\n最后还是悄悄地祝我自己生日快乐吧。\n欢迎评论！ 1. 根据蔡老板的划分标准，高爸是高贵的上海人，是城里人，上海周围的是乡下人，再外围的就是山里人了。啥？你不认识高爸？快给他磕头谢罪（bushi &#8617;","title":"OI 退役杂谈","updated":"2025-04-23T04:07:19.260Z"},{"categories":[],"path":"K-Greedy/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"本文绝大部分参考 Naitir - 「技巧总结」第k小和贪心问题，是在此基础上的解说。\n符号约定：[n] 表示集合 \\{1, 2, \\ldots, n\\}。\n前言第 k 小（大）的问题定义在全序集合上，相关算法不胜枚举。常用的方法有二分转化为计数问题解决、数据结构直接维护、离线后整体二分等等。\n大部分方法都建立在所求答案结构相对简单，亦或是全序结构比较特殊，容易计数的前提下。然对于一类全序结构无特殊性质，只可知前驱后继，甚至连前驱后继都难以判断，只能断言比之优劣的结构，上述算法将难以有效。这也是本文的算法解决的问题。\n为了方便大家理解，我们以一个例题引入。\n【例题】子集第 K 小问题\n有一个长度为 n 的正整数序列 a_1, \\ldots, a_n。对于一个 [n] 的子集 T，记 f(T) = \\sum_{i \\in T} a_i 表示一个子序列的价值。对于所有 2^n 个子序列的价值，求其中的第 k 小值，并输出方案。\nn, x, k\\le 10^6。 本题的特点是：全序结构规模过大（O(2^n)），并且结构没有特殊性质，难以计算一个方案的前驱后继。\n但是对于子集 T \\subseteq S，我们可以容易地判断某些方案一定是比它大的。例如对于 e \\notin T，一定有 f(T\\cup \\{e\\}) &gt; f(T)。换言之对于一些与 T 相关的方案我们可以断言它们与 T 的大小关系。\n分析出这些信息后，容易想到维护一个小根堆。初始时将空集加入堆。每次取出堆顶的集合，记作 T。并将【一部分与 T 相关的比 T 大】的集合都加入堆中。这样做 k 次操作后得到的就是第 k 小的方案。\n问题转化为：【一部分与 T 相关的比 T 大】的集合究竟是哪些集合？\n为了方便叙述，我们称【一部分与 T 相关的比 T 大】为被 T 拉入堆中。称 T 是它们的引子。它们是 T 的继子。\n方法一对于所有 e\\notin T，将 T\\cup \\{e\\} 加入堆中。\n这个方法显然不具备正确性，因为一个集合具有多个引子，会出现重复加入的情况。\n方法二只在子序列末尾加入，即对于 T 中的最大值 i_{\\max}（对于空集，i_{\\max} = 0），考虑所有 i_{\\max} &lt; e \\le n，将 T\\cup \\{e\\} 加入堆中。\n这个方法具备正确性，因为每个非空集合有且仅有一个引子。\n而这个方法的时间复杂度是 O(nk\\log (nk))，空间复杂度 O(nk)。因为一个集合有 O(n) 个继子。\n详细的正确性说明每个集合有且仅有一个引子，说明每个集合一定会在某个时刻被拉入堆中。\n而根据小根堆的性质，对于一个集合 T，只有比他小的集合都被取出过堆顶后，它才会被取出。\n因此第 k 次取出的堆顶一定是第 k 小的方案。\n换言之，【非初始集合具有唯一引子】的方法都是正确的算法。 方法三方法二的主要缺陷是继子过多，导致时空复杂度过大。换言之我们需要找到一个引子唯一，继子 O(1) 的偏序结构。\n考虑将 a 从小到大排序。\n那么对于集合 T，我们将 T 中某一元素 i 加 1 （前提是 i + 1 不在 T 中）得到的集合 T' 一定是比 T 大的。\n因此我们的方法是对于集合 T，设其中的最大值是 i_{\\max}（对于空集，i_{\\max} = 0）。若 i_{\\max} &lt; n，那么我们就将 T \\cup\\{i_{\\max} + 1\\} 和 T\\cup \\{i_{\\max} + 1\\}\\setminus \\{i_{\\max}\\} 分别加入堆中。通俗地说，要么我们将子序列最后一个下标加一，要么就加一个数到子序列中。\n这个方法显然具备正确性。并且复杂度足够优秀，为 O(k\\log n)。\n小结由于全序结构的不明显，因此传统的全序算法在这个问题上难以适用。\n上述的算法的本质是利用结构中隐藏的偏序性质（一些与 T 相关的方案我们可以断言它们与 T 的大小关系）组合构建出全序结构，通过小根堆维护以优化复杂度。\n简单来说传统的方法是从最小值开始找 k 次后继，找的是一个集合的后继。而堆维护偏序算法干的事情是，找若干个集合的后继，即踢掉最小的，将更多可能的后继加入。\n【例题】 扩域版第 K 小问题\n给出 n 个正整数集合，第 i 个集合记作 A_i，其中的第 j 小的数记作 A_{i, j}。现在要从每个集合里拿出了一个数，方案的价值是拿出的数的和，求第 k 小的代价是多少。\nn, \\sum |A_i|, k \\le 10^6。 延续子集第 K 小的思路，考虑用堆维护偏序。\n考虑一个选数方案 (j_1, \\ldots, j_n) 其中 j_i 表示第 i 个集合选 A_{i, j_i}。可以发现，将其中任意一个（可以增大的）j_t 加一得到的方案都是比它大的。\n那么初始时将 (1, 1, \\ldots, 1) 加入堆中。同时我们将集合按照 A_{i, 2} - A_{i, 1} 从小到大排序。\n为了保证引子唯一，我们找到方案中最大靠后的 &gt;1 的元素对应的下标 t（即最大的 t 使得 j_t &gt; 1，若没有则 t = 0）： 若 t &gt; 0 且 j_t &lt; |A_t|，将 (j_1, \\ldots, j_{t - 1}, j_t + 1, j_{t + 1}, \\ldots, j_n) 加入堆中。\n若 t &lt; n，将 (j_1, \\ldots, j_t, j_{t + 1} + 1, \\ldots, j_n) （等价于 (j_1, \\ldots, j_t, 2, \\ldots, j_n)）加入堆中。排序保证了这一步的正确性。 这样可以保证引子唯一，进而保证算法正确性。时间复杂度 O(k\\log n)。\n传统算法能否给劲对于这类问题，其实传统算法思想并非毫无用武之地。\n利用传统算法思想我们可以获得复杂度稍劣但更为普遍的解法。\n【另解】（扩域）子集第 K 小问题仍然是子集第 K 小问题，这次我们从二分的角度思考。\n二分答案 x 后，问题转化为求权值和小于等于 x 的方案数。\n仍考虑用堆维护答案。我们用堆维护前 i 个元素的方案中权值和小于等于 x 的所有方案。\n考虑加入 a_{i + 1}，那么我们枚举堆中每一个元素 s，如果 a_{i + 1} + s\\le x 就将 a_{i + 1} + s 加入堆中。\n一旦堆的大小超过 k 就停止 check。\n这个算法的复杂度视实现情况为 O(k\\log k\\log V) 或者 O(k\\log V)。\n上述过程甚至可以改成线段树分治后做堆合并。合并也是按上述方式暴力合并。\n对于扩域子集第 K 小问题，按类似的方法做也可以做到 O(k\\log k\\log V)。\n【应用】树上第 K 小连通块\n给出一棵 n 个点带正整数点权的树，求其上点权和第 k 小的连通块。n\\le 10^5。 这个问题则只能用二分思想解决。\n二分答案后问题转化为连通块计数。将连通块按其中深度最浅的点分类，就转化为树上堆合并的过程了。\nQOJ 1548\n【应用】购物计划\n有 n 个商品，具有种类 a_i 和价值 c_i。\n现在要求购物，第 i 种的物品购买个数要在 [l_i, r_i] 之间。\n求价值和第 k 小的代价。\nn, m, k\\le 2\\times 10^5。 本题实际上是两个第 K 小问题的套娃。先在同一种类里做，然后对原问题做。\n子问题现在问题转化为大小在 [l, r] 范围内的子集第 k 小问题。\n不妨将物品按价值排序，假设分别为 b_1, \\ldots, b_t。为了方便转移我们将末尾的连续下标记作一段区间，可以用 (x, y, z) 表示，其含义是我们选择的物品的末尾的极长下标连续段是 [x + 1, \\ldots, x + y - 1]，并且 b_x 是我们选择的第 z 个物品。其他信息可以忽略。初始状态 (1, l, 1)。\n转移有： (x, y, z) \\to (x + 1, y, z)。\n(x, y, z) \\to (x + 1, y - 1, z + 1)。\n若 x = z = 1 且 y &lt; r，则有 (x, y, z) \\to (x, y + 1, z)。 容易证明引子的唯一性。\n可以堆维护。\n原问题原问题即为扩域第 K 小问题。","title":"偏序结构第 K 小问题算法小结","updated":"2025-04-23T04:07:19.266Z"},{"categories":[],"path":"Math/Polynomial/EGF/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"},{"name":"EGF","slug":"EGF","permalink":"https://notes.sshwy.name/tags/EGF/"},{"name":"Generating-Function","slug":"Generating-Function","permalink":"https://notes.sshwy.name/tags/Generating-Function/"}],"text":"指数生成函数指数生成函数（Exponential generating function，EGF）定义为 \\hat{F}(x)=\\sum_{i\\ge 0}a_i\\frac{x^i}{i!}指数生成函数的运算不是简单的卷积： \\begin{aligned}\n\\hat{F}(x)\\hat{G}(x)&=\\sum_{i\\ge 0}\\sum_{j\\ge 0}a_ib_j\\frac{x^{i+j}}{i!j!}\\\\\n&=\\sum_{k\\ge 0}\\sum_{i=0}^ka_ib_{k-i}\\frac{x^k}{i!(k-i)!}\\\\\n&=\\sum_{k\\ge 0}\\sum_{i=0}^k\\binom{k}{i}a_ib_{k-i}\\frac{x^k}{k!}\n\\end{aligned}因此序列 a_i 和 b_i 的指数生成函数的积得到的是 \\sum_{j=0}^i\\dbinom{i}{j} a_ib_{i-j} 的指数生成函数。这在一些有标号的计数中会很有用。\n常用封闭形式首先有 e^x 的泰勒展开式： \\hat{G}(x)=\\sum_{i\\ge 0}\\frac{x^i}{i!}=e^x那么简单拓展为 e^{-x}： \\hat{G}(x)=\\sum_{i\\ge 0}\\frac{(-x)^i}{i!}=\\sum_{i\\ge 0}(-1)^i\\frac{x^i}{i!}这两个可以拓展出奇数和偶数阶乘的封闭形式。\n置换环与圆排列考虑 n 个元素的排列数 p_n=n! 的指数生成函数： \\hat{P}(x)=\\sum_{n\\ge 0}n!\\frac{x^n}{n!}=\\frac{1}{1-x}\\\\另一方面，n 个元素的圆排列排列数 q_n=(n-1)! 的指数生成函数： \\hat{Q}(x)=\\sum_{n\\ge 0}(n-1)!\\frac{x^n}{n!}=-\\ln(1-x)=\\ln\\left(\\frac{1}{1-x}\\right)这两者有什么联系？容易发现，（置换）排列可以理解为是若干个环（置换环）的集合。而这些环之间的顺序我们不考虑。因此 \\exp\\hat{Q} 可以理解为是若干个带标号的圆排列组合在一起的方案数的指数生成函数，即 \\hat{P}。反之，\\ln\\hat{P} 则相当于把构成方案分成若干个具有相同性质的部分，这些部分的生成函数。\n另一方面，这也解释了 \\exp 和 \\ln 的组合意义，这在求一些生成函数的时候会非常有用。\n拓展错排数的生成函数？\n直接用容斥的式子似乎不太好做。考虑其组合意义就是置换环大小大于 1 的置换数量。那么我们把圆排列数的 x 这一项去掉，然后 \\exp 回去即可： \\hat{F}(x)=\\exp(\\hat{Q}(x)-x)=\\exp\\left(\\ln\\left(\\frac{1}{1-x}\\right)-x\\right)=\\frac{e^{-x}}{1-x}有标号简单连通无向图计数题目链接：城市规划。 求出有 n(n\\le 130000) 个点的有标号简单连通无向图的个数。 算法一设 f(n) 表示 n 个点简单无向连通图的个数，g(n) 表示 n 个点的图的个数。那么 g(n)=2^{\\binom{n}{2}}且 g(n)=\\sum_{i=1}^n\\binom{n-1}{i-1}f(i)g(n-i)化简得到 \\frac{g(n)}{(n-1)!}=\\sum_{i=1}^n\\frac{f(i)}{(i-1)!}\\frac{g(n-i)}{(n-i)!}我们定义三个生成函数 \\begin{aligned}\nF(x)&=\\sum_{i\\ge 1}\\frac{f(i)}{(i-1)!}x^i\\\\\nG(x)&=\\sum_{i\\ge 0}\\frac{g(i)}{i!}x^i\\\\\nH(x)&=\\sum_{i\\ge 1}\\frac{g(i)}{(i-1)!}x^i\n\\end{aligned}那么显然可以得到 H=FG\\pmod{x^{n+1}}，那么 F=HG^{-1}\\pmod{x^{n+1}}，多项式求逆即可。\n最后算完了别忘了把阶乘乘回去。\n算法二设 g(i) 表示 i 个点的简单无向图的个数，f(i) 表示 i 个点简单无向连通图的个数。对应的指数生成函数为 \\hat{G}(x)=\\sum_{i\\ge 0}g(i)\\frac{x^i}{i!}\\\\\n\\hat{F}(x)=\\sum_{i\\ge 0}f(i)\\frac{x^i}{i!}其中 g(i)=2^{\\binom{i}{2}}我们尝试用 \\hat{F} 表示 \\hat{G}。考虑 [x^n]\\hat{F}^i(x) 表示的含义。它表示 n 个点分成 i 个连通块的“排列数”。因为在分的过程中我们是钦定了连通块之间的顺序（这是 EGF 乘法运算的组合意义）。因此还需要除以 i! 才能得到 n 个点分成 i 个连通块的图的个数。因此得到 \\hat{G}(x)=\\sum_{i\\ge 0}\\frac{\\hat{F}^i(x)}{i!}因此 \\hat{G}(x)=\\exp \\hat{F}(x)，那么 \\hat{F}(x)=\\ln \\hat{G}(x)。\n有标号二分图计数首先考虑二分染色图计数。所谓二分染色图指区分左右部的二分图。这个比较简单： f_n = \\sum_{i = 0} ^ n \\binom{n}{i} 2^{(n - i) i}设其对应的 EGF 为 F(x)。根据 ab = \\binom{a + b}{2} - \\binom{a}{2} - \\binom{b}{2}，我们可以很容易将 F 表示为卷积的形式。\n然后我们考虑将二分染色图个数转化为二分图个数。若连通块个数为 k 的二分染色图为 t，那么连通块个数为 k 的二分图个数为 \\frac{t}{2^k}。这启发我们利用连通二分图的个数建立关系。\n假设二分图个数的 EGF 为 G(x)，则连通二分图的个数的 EGF 显然为 \\ln G(x)。于是连通的二分染色图个数为 2\\ln G(x)，于是 2\\ln G = \\ln F因此 G = \\sqrt{F}。使用多项式开根即可。\nTJOI2015 概率论设 h(i) 表示 i 个结点的二叉树总数，f(i) 表示 i 个结点的二叉树的叶子结点数的和。\n容易发现 h(i)=\\sum_{j=0}^{i-1}h(j)h(i-j-1) 是卡特兰数。类似地可以得到 f(i)=2\\sum_{j=1}^{i-1}f(j)h(i-j-1) \\quad (i\\ge 2)其中 f(0)=0,f(1)=1。类似地，设 F(x)=\\sum_{i\\ge 0}f(i)x^i，那么得到 \\begin{aligned}\nF(x)&=\\sum_{i\\ge 0}f(i)x^i\\\\\n&=x+2\\sum_{i\\ge 2}\\sum_{j=1}^{i-1}f(j)h(i-j-1)x^jx^{i-j-1}x\\\\\n&=x+2x\\sum_{j\\ge 1}f(j)x^j\\sum_{i\\ge 0}h(i)x^{i}\\\\\n&=x+2xF(x)C(x)\n\\end{aligned}代入 C(x)=\\dfrac{1-\\sqrt{1-4x}}{2x} 解得 F(x)=\\frac{x}{\\sqrt{1-4x}}用牛顿二项式展开得到 (1-4x)^{-\\frac{1}{2}}=\\sum_{i\\ge 0}\\binom{-\\frac{1}{2}}{i}(-4x)^i\\\\\n=\\sum_{i\\ge 0}\\frac{(-1)^i(2i)!}{4^ii!i!}(-4x)^i\\\\\n=\\sum_{i\\ge 0}\\binom{2i}{i}x^i\\\\那么带回原式得到 F(x)=\\sum_{i\\ge 1}\\binom{2i-2}{i-1}x^{i}根据卡特兰数的生成函数 C(x)=\\sum_{i\\ge 0}\\frac{1}{i+1}\\binom{2i}{i}x^i对应项相除可以得到 \\frac{[x^n]F(x)}{[x^n]C(x)}=\\frac{\\binom{2n-2}{n-1}}{\\frac{1}{n+1}\\binom{2n}{n}}=\\frac{n(n+1)}{2(2n-1)}答案即所求。\nPOJ3734 Blocks容易得到生成函数为 e^{2x}\\left(\\frac{e^x+e^{-x}}{2}\\right)^2\\\\\n=\\frac{e^{4x}+2e^{2x}+1}{4}那么展开得到 \\hat{G}(x)=1+\\sum_{i\\ge 1}(4^{i-1}+2^{i-1})\\frac{x^i}{i!}51nod1728 不动点题意：求有多少个映射 f:\\{1,2,\\cdots,n\\}\\to \\{1,2,\\cdots,n\\}，使得 \\bigcirc_{i=1}^k f=\\bigcirc_{i=1}^{k-1}f。（这个大圈表示复合）\nnk\\le 2\\times 10^6,k\\le 3。\n可以发现，我们要求的是 n 个点带标号的深度不超过 k 的有根树森林计数。\n设 \\hat{F}_k(x) 表示答案的指数生成函数。显然 \\hat{F}_1(x)=e^x。\n设 [x^n]\\hat{G}_k(x) 表示 n 个点深度不超过 k 的有根树的方案数。\\hat{G}_k(x) 是指数生成函数。显然 \\hat{G}_1(x)=x。考虑 \\hat{G}_k(x) 的递推式，可以得到 [x^n]\\hat{G}_k(x)=n[x^{n-1}]\\hat{F}_{k-1}(x)。整理一下得到 \\hat{G}_k(x)=x\\hat{F}_{k-1}(x)。\n于是得到 \\hat{F}_k(x)=\\exp \\hat{G}_k(x)=\\exp(x\\hat{F}_{k-1}(x))。\n注意这题卡常，可以根据 nk\\le 2\\times 10^6 合理设置长度来卡常。\nCF891 E设 a_i 减少的值是 b_i，那么题目相当于要求 E(\\prod a_i-\\prod(a_i-b_i))=\\prod a_i-E(\\prod(a_i-b_i))。\n对于后者，乘上一个 n^k 转化为计数问题： E=\\frac{1}{n^k}\\sum_{\\sum b_i=k}\\frac{k!}{\\prod b_i!}\\prod_{i=1}^n(a_i-b_i)\\\\\n=\\frac{k!}{n^k}\\sum_{\\sum b_i=k}\\prod_{i=1}^n\\frac{a_i-b_i}{b_i!}构造生成函数，对于 \\dfrac{a_i-b_i}{b_i!} 可以构造 \\sum_{j\\ge 0}\\dfrac{a_i-j}{j!}，那么就可以构造一个 OGF： F(x)=\\prod_{i=1}^n\\sum_{j\\ge 0}\\frac{a_i-j}{j!}x^j虽然这是一个 OGF，但是我们是可以把它当 EGF 来用的。因此做一下化简： \\begin{aligned}\nF(x)&=\\prod_{i=1}^n\\sum_{j\\ge 0}\\frac{a_i-j}{j!}x^j\\\\\n&=\\prod_{i=1}^n(a_ie^x-xe^x)\\\\\n&=e^{nx}\\prod_{i=1}^n(a_i-x)\\\\\n\\end{aligned}我们直接 O(n^2) 求出 G(x)=\\prod_{i=1}^n(a_i-x) 的系数，记为 c_i。那么可以得到 \\begin{aligned}\nF(x)&=e^{nx}G(x)\\\\\n&=\\sum_{i\\ge 0}\\frac{(nx)^i}{i!}\\sum_{j\\ge 0}c_jx^j\\\\\n&=\\sum_{i\\ge 0}\\frac{n^ix^i}{i!}\\sum_{j\\ge 0}c_jx^j\\\\\n&=\\sum_{k\\ge 0}x^k\\sum_{i=0}^k\\frac{n^i}{i!}c_{k-i}\n\\end{aligned}期望为 \\frac{k!}{n^k}[x^k]F(x)=\\sum_{i=0}^k\\frac{k^{\\underline{i}}}{n^{i}}c_i=\\sum_{i=0}^{\\min(n,k)}\\frac{k^{\\underline{i}}}{n^{i}}c_i答案为 \\prod_{i=1}^na_i-\\sum_{i=0}^{\\min(n,k)}\\frac{k^{\\underline{i}}}{n^{i}}c_i小朋友与二叉树考虑 G(x)=\\sum_{i=1}^nx^{c_i}。设答案的 OGF 为 F(x)。那么可以列出方程 F=F^2G+1解得 F=\\frac{1\\pm \\sqrt{1-4G}}{2G}=\\frac{2}{1\\mp \\sqrt{1-4G}}取 x=0，由于分母常数项不能为 0，因此舍掉负根，得到 F(x)=\\frac{2}{1+\\sqrt{1-4G(x)}}多项式求逆、幂函数即可（[x^0]F(x)=1）。\n分拆数分拆数（拆分数，划分数）的生成函数为 P(x)=\\prod_{i\\ge 1}\\left(\\sum_{j\\ge 0}x^{ij}\\right)算法一利用所学知识，我们来化简一下该生成函数： P(x)=\\prod_{i\\ge 1}\\frac{1}{1-x^i}两边同时 \\ln 得到 \\begin{aligned}\n\\ln P(x)&=\\ln\\prod_{i\\ge 1}\\frac{1}{1-x^i}\\\\\n&=\\sum_{i\\ge 1}\\ln\\frac{1}{1-x^i}\\\\\n&=-\\sum_{i\\ge 1}\\ln(1-x^i)\\\\\n&=\\sum_{i\\ge 1}\\sum_{j\\ge 1}\\frac{x^{ij}}{j}\\\\\n&=\\sum_{i\\ge 1}x^i\\sum_{j|i}\\frac{1}{j}\\\\\n\\end{aligned}那么我们 O(n\\log n) 预处理 \\ln P(x)，再 \\exp 回去即可。时间复杂度 O(n\\log n)。但常数较大。\n算法二首先介绍一下五边形数：p_n=\\dfrac{1}{2}n(3n-1),n\\in\\mathbf{N}。\n对于广义五边形数，n\\in\\mathbf{Z}。容易证明，p_n\\ge 0(n\\in \\mathbf{Z})。\n接下来介绍欧拉函数（复变函数），其定义为 \\phi(x)=\\prod_{i\\ge 1}(1-x^i)与之相关的是五边形定理，它描述了五边形数与欧拉函数的关系： \\phi(x)=\\sum_{n=-\\infty}^\\infty(-1)^nx^{p_n}另外还有一个性质，欧拉函数的倒数是分拆数的生成函数： \\phi^{-1}(x)=\\sum_{n\\ge 0}P(n)x^n于是直接求即可。求 \\phi(x)\\bmod {x^n} 的复杂度是 O(\\sqrt{n}) 的，多项式求逆复杂度 O(n\\log_2n)。总复杂度 O(n\\log_2n)。","title":"指数生成函数学习笔记","updated":"2025-04-23T04:07:19.269Z"},{"categories":[],"path":"Probset/21-NOI-Training/","tags":[],"text":"训练赛可能是有独立的文章的。这里主要是一些杂题。\n离散计数中的迭代思想题型1： 计算最小的 n 使得 1,\\ldots, n 中满足某一条件的数占比大于等于 p。0\\le p &lt; 1。 考虑一个迭代的过程。设 f(n) 表示 n 以内满足该条件的数的个数。\n若当前的 n 不满足 \\frac{f(n)}{n} \\ge p，我们就找到一个最小的 c 使得 \\frac{f(n + c)}{n + c} \\ge p，然后令 n \\gets n + c。这样迭代下去直到 n 满足条件。\n复杂度与满足该条件的数的分布有关。大多数时候是随机的，跑得应该比较快。\n题型2： 有 m 个条件。计算大于等于 n 的同时满足这 m 个条件的数的最小值。 我们设 f(n, i) 表示大于等于 n 的满足第 i 个条件的数的最小值。\n那么每次我们令 n \\gets \\max_i f(n, i)，直到 n 不发生变化。\n复杂度也和数据分布有关。\nBalticOI 小丑双指针 决策单调性\n其实双指针的应用前提就是决策单调性。只不过大多数时候双指针的题目使用迭代足以胜任。 给出 n 个点 m 条边无向图，q 次询问 (l, r)，问删除编号在 [l, r] 的边后图是否是二分图。n, m, q\\le 2\\times 10^5。 首先我们考虑的是一个前缀和一个后缀的边集的并在一起是不是二分图。这个东西显然具有双指针性质。那么记 f(i) 表示最小的 j 使得 [1, i] 和 [j, m] 的边的并集是二分图。\n直接在线维护动态图看起来很不太行。但是直接分治优化决策单调性就可以，思路也很显然，带撤销并查集即可。\n另外，带撤销并查集是不能路径压缩的，虽然不知道为啥能过。应该是只能按秩合并的。\n复杂度 O(n\\log^2n)。\n代码\nBalticOI 病毒AC 自动机 DP 转移优化 最短路\n对抗体建 AC 自动机，把抗体结尾的结点 ban 掉。这样就将问题转化为是否存在一种突变使得不会走到 ban 的点，以及满足要求的最短突变长度。\n一个初步的想法是设 f(i, j, k) 表示将基因 i 突变展开，且恰能够从 AC 自动机上的状态 j 走到状态 k 的最短展开长度。\n这个东西不容易转移。\n容易想到改进的方法。将每个突变的每个前缀建点。设 f(i, j, k) 表示将结点 i 突变展开，且恰能够从 j 走到 k 的最短展开长度。\n这样就可以写出一些像样的转移。初始状态形如 f(i, x, x) = 0。\n但是容易发现这个转移有后效性。因为 AC 自动机不是 DAG。\n那么一个经典的优化是用最短路优化。\n但本题的转移其实更为特殊——会出现形如 f(i, x, y) + f(t, y, z) \\to f(i + 1, x, z) 的转移。也就是说这个式子既可以理解为 f(i, x, y) 松弛 f(i + 1, x, z)，也可以理解为 f(t, y, z) 松弛 f(i + 1, x, z)。\n那么如何实现？其实就是最短路优化 DP 的写法。上述特殊的转移并不会增加代码难度，只是笔者认为有必要告知，以辅助思考 DP 的转移方程。\n代码\nBalticOI 2020 村庄结论题。不太想写代码。\n最小： 方法一：树上最大匹配，每个点的贡献是 1。单点可以找与它相邻的环加进去，贡献是 2。匹配可以看作二元环。\n方法二：树形 DP 也可以，相当于子树要么全部匹配要么只剩它一个。 最大：用每条边被遍历的次数算出上界。找到树的重心，删除重心的邻边后做 \\frac{n}{2} 个匹配，要求不能是相同的连通块。可以证明这样构造恰好能达到上界。\nJulia the snail分块 莫队 线段树 吉老师线段树 势能分析 有 n 个点，m 个形如 (l, r)，其中 l \\le r 且 r 互不相同的传送门，表示你可以从结点 l 跳到 r。\n有 q 个询问 (x, y) 其中 x\\le y，问从 x 出发在不经过编号大于 y 的结点的情况下能走到的编号最大的点。\nn, m, q\\le 10^5。 算法一分块。\n假设已知 (x, y) 的答案，记作 ans(x, y)。\n算法 A：考虑求 (x, y + 1) 的答案。那么我们考虑右端点为 y + 1，左端点大于等于 x 的传送门。如果存在一个这样的传送门其左端点小于等于 ans(x, y)，那么我们就可以通过这个传送门走到 y + 1。也就是说我们可以 O(\\log) 更新答案。\n算法 B：考虑求 (x - 1, y) 的答案。那么我们考虑左端点为 x - 1，右端点小于等于 y 的传送门，找到其中右端点最大的那个，记作 (x - 1, y')。那么显然有 ans(x - 1, y) = \\max_{x\\le z\\le y'} ans(z, y)。因此固定 y 计算询问我们可以倒着枚举 x，单调栈维护最大值。\n将上述两种方法结合。分块后将询问按右端点所在块分类，算法 A 可以简单撤销，所以很容易想到回滚莫队做法。\n实际上在结合两种算法后会发现，算法过程中左端点是单调递减的，因此算法 A 可以优化为 O(1)。\n时间复杂度 O(n\\sqrt{n})。\n算法二考虑上述算法 B，直接对右端点做扫描线，记 c_i 表示在当前扫描线状态下左端点为 i 时的答案。\n当 y \\to y + 1 时，枚举所有以 y + 1 为右端点的传送门，记作 (x', y + 1)。我们会将 c[1, x'] 中所有 \\ge x' 的值都赋值为 y + 1。\n也就是说我们会将一个区间里大于等于某个阈值 t 的数赋值为另一个 \\ge t 的数。\n这个可以用势能分析线段树（吉老师线段树）做。记区间最大值和去重的次大值即可。\n实现过程会稍显细节。但只要把握要点就不会写错：pushup 时儿子结点的信息是【同步且正确】的，pushdown 时 儿子结点的信息在这次操作之前是【同步且正确】的。详见代码中的 pushdown 函数。\n时间复杂度 O((n + m + q) \\log^2 n)。\n代码\n随机点分相关套路将一棵树随机点分的计数问题有这样一些套路。 随机点分方案数。 将两个连通块连在一起，两者对应的点分树变化只与某些点有关。具体地说，设连上的边是 (u, v)，两者的点分树根节点分别是 A 和 B，那么点分方案合并本质上是点分树上 A 到 u 的路径与 B 到 v 的路径合并。因此只需要记 u 和 v 在点分方案中的深度即可完成 DP 转移。时间复杂度 O(n^2)。详见此文。 随机点分的贡献和。 这个问题视具体情况而定，但通常来讲是难以应用方才讲述的套路的。这种时候可以考虑将贡献均摊到点上，枚举每个点分别计算。\n具体来说考虑以下问题： 随机点分，计算点分树上每个结点的子树大小之和的期望。即随机点分期望复杂度。 结点子树大小之和很容易转化为点分树上结点的深度之和，进而将原问题转化为每个结点在点分树上深度的期望之和。\n结点 u 在点分树上的深度的期望等价于：枚举一个点 v，计算 v 是 u 点分树上祖先的概率之和。\n要让 v 是 u 点分树上的祖先，那么就要求 v 比 u 到 v 路径上的点（包括 u）都早删除。\n因此不妨定 u 为树根，则深度期望可以简单表示为 \\sum_{v \\ne u} \\frac{1}{\\text{dep}_v}，其中 \\text{dep} 表示深度。\n时间复杂度 O(n^2)。可能可以优化。","title":"NOI2021 赛前训练日志","updated":"2025-04-23T04:07:19.273Z"},{"categories":[],"path":"Full-Mark-Composition/","tags":[{"name":"Life","slug":"Life","permalink":"https://notes.sshwy.name/tags/Life/"}],"text":"现代 OI 以受宠带师的“垃圾也有自己温暖的家，所以您坐那里啊”为嚆矢。滥觞于混元形意与数学的期望正失去它们的借鉴意义。但面对看似无垠的未来天空，我想循 alfalfa_w“公平公正是竞赛的生命，任何违规行为对竞赛都是极大的伤害。CCF NOI 各相关机构会带头遵守规则，严格保密，同时也承担维护竞赛公平公正良好秩序的重任，对任何违规或作弊的行为均按竞赛条例给予严肃处理。”好过过早地振翮。\n我们怀揣热忱的灵魂天然被赋予对超越性的追求，不屑于古旧坐标的约束，钟情于在别处的芬芳。但当这种期望流于对早上好！主义不假思索的批判，乃至走向女装与膜蛤主义时，便值得警惕了。与秩序的落差、错位向来不能为越矩的行为张本。而纵然我们已有翔实的蓝图，仍不能自持已在浪潮之巅立下了自己的沉锚。\n“不要搞窝里斗”高麟翔之言可谓切中了肯綮。人的大意了没有闪性是不可祓除的，而我们欲上青云也无时无刻不在因风借力。数学与混元形意暂且被我们把握为一个薄脊的符号客体，一定程度上是因为我们尚缺乏体验与阅历去支撑自己的认知。而这种偏见的傲慢更远在知性的傲慢之上。\n在孜孜矻矻以求 OI 意义的道路上，对自己的期望本就是在与数学与混元形意对接中塑型的动态过程。而我们的底料便是对不同高还是高爸高、不同 AK 的觉感与体认。xianglingao 为 taborca 送去 rp++，又维系昏睡红茶（物理）。他的 OI 观念是厚实的，也是实践的。倘若我们在对过往借中国计算机学会之言“祓魅”后，又对不断膨胀的自我进行“赋魅”，那么在丢失外界预期的同时，未尝也不是丢了自我。\n毫无疑问，从混元形意与数学角度一觇的自我有偏狭过时的成分。但我们所应摒弃的不是对此的批判，而是其批判的廉价，其对批判投诚中的反智倾向。在受宠带师的观念中，如果在成为狮子与孩子之前，略去了像骆驼一样背负前人遗产的过程，那其“永远重复”洵不能成立。\n蓝图上的落差终归只是理念上的区分，在实践场域的分野也未必明晰。譬如当我们追寻早上好！时，在途中涉足晚上好！，这究竟是伴随着期望的泯灭还是期望的达成？在我们塑造 OI 的同时，OI 也在浇铸我们。既不可否认原生的不讲武德性与耗子尾汁性，又承认自己的图景有轻狂的失真，不妨让体验走在言语之前。用不被禁锢的头脑去体味 CCF 的大海与风帆，并效高爸，对无法言说之事保持沉默。\n用在 NOIP 上的生活方式体现个体的超越性，保持婞直却又不拘泥于所谓“遗世独立”的单向度形象。这便是中国计算机学会为我们提供的理想期望范式。生活在 OI 上——始终热爱大地——升上天空。\n使用 满分作文生成器 生成。","title":"高爸生活在 OI 上","updated":"2025-04-23T04:07:19.264Z"},{"categories":[],"path":"PKUSC2021-Sum/","tags":[],"text":"UPD：翻到一篇题解博客\nDay 1早晨起来肚子巨痛无比，没吃早饭又拉不出来。早饭恰了点粥，教练整了点奇奇怪怪的药，稍微好转了一点点。\n9 点去报到，拿了个牌和日程表，中途遇见GVZ和YYH，都是老朋友了，然而我肚子实在不太舒服，没法谈笑风生。\n让人意外的是有试机和试机的题，上去机房发现是 Win10 系统（比赛时用的电脑是 Win7），没有虚拟机但是有 Gvim。这也 OK。\n试机题的 T1 挺能做，T2 由于肚子不舒服，还没看就回酒店了。\n回酒店又开始坐马桶，在一顿哼哼啊啊的挣扎（？）之后我的的腹痛奇迹般地好了。\n中午去吃了一家湘菜馆，味道很不错。不过由于肠胃原因不敢多吃。\n然后就到了比赛时间。这回是 IOI 赛制。\n开场走一个 T1，是个傻逼题，写了 1h。然后花 1h 写了 T2 46 分（前 2 个 Subtask）。\nT3 是祖传的扑克牌题，写了 2 个小时各种调试写了第一个 38 分的 Subtask。第二个 Subtask 写完的时候只有 5 分钟了，交上去还 T 了，没时间卡常，丢了 41 分，有点悲。\n旁边那位老哥写了个 100+46+79，是我的目标。我只写了 100+46+38。心有余而力不足。\n晚上去吃了一家据说很有名的面馆，味道很不错。\n差不多就这样，早点睡，准备明天翻车。\n附送 Day1 题面：\nSum Transformation给出 n\\times n 的矩阵 A 和 m, P，定义 f(A) 表示对矩阵的变换，将 A_{ij} 变成 \\sum_x A_{xj} + \\sum_y A_{iy}\\pmod P。求 f^m(A)。\nn\\le 1000, m, P\\le 10^9。\nB （忘记标题了）给一个序列 a_1, \\ldots, a_n 和 m 次操作： 1 l r：对 l\\le i &lt; r 令 a_i \\gets \\max(a_i, a_{i + 1})。\n2 l r：计算 a[l, r] 的前缀唯一最大值的和。前缀唯一最大值指满足 \\forall l\\le j &lt; i, \\; a_j &lt; a_i 的 a_i（a_l 也算，l\\le i\\le r）。 n, m\\le 3\\times 10^5, a_i\\le 10^9。\n德州扑克真的有人想要看这题的题面吗（憨笑色）\nDay 2上午安排参观了 NOI 决赛场地。\n安排参观寝室，结果进的是女寝……这就是余姚吗。\n然后下午就打 Day 2。\nT1 是个简单换根题，T2 我并不会初步转化然而还是骗了 35 分，T3 骗了 5 分，大众分可能是 155，我只有 140。\n感觉进不了面试了，悲。\n老规矩，放一个题面。\nA给一棵 n 个点带标号的树，要删除一条边再加入一条边使得仍是树，问所有的改动方案形成的树上的所有路径的长度和，即 \\sum_{i} \\sum_{j} \\text{dist}(i, j)。\n删的边不同或加的边不同就算不同的改动方案。\nn\\le 3\\times 10^5。\nB有 n 个菜，第 i 道菜价格 a_i。你要依次买菜。\n对于一道菜，你每花费 c 元 RMB 可获得一张价值 1 元的代金券。代金券可以在之后的买菜过程中使用。\n有 m 次单点修改。对于每次修改询问改后你要花费多少钱才能买下所有菜。\nn\\le 3\\times 10^5, c, a_i\\le 10^{12}。\nC有 n 个 [0, m] 内随机的实数变量 x_1, \\ldots, x_n，问满足 x_i + k \\le x_{i + 2} \\;\\;\\forall i的概率，输出模 p 意义下的答案。\nn\\le 50, m, k\\le 150，p 是质数。\nDay 3进面试啦，狂喜。\n面试分两场，每场 5 分钟，实际上就是和两个教授闲聊五分钟。旨在判断你是个正常人。\n下午就颁奖了。拿了个优异。\n当晚就飞回成都了。","title":"PKUSC 2021 游记","updated":"2025-04-23T04:07:19.272Z"},{"categories":[],"path":"Data-Structure/Link-Cut/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"LCT（Link Cut Tree）是一种动态维护树的结构变化以及相关信息的数据结构。\n对 LCT 的理解LCT 本质上是用 Splay 维护树链剖分： Splay 指伸展树，是一种自适应的平衡树；\n树链剖分则是指广义地将树剖分为若干个链，而非狭义的轻重链剖分。 总体来说，LCT 可以解决以下的问题： 连接两个点；\n删除某条边；\n维护可合并的路径信息。 具体来说，Splay 按照树链从深到浅的顺序维护树链的结点。而 LCT 就是一个 Splay 森林。\n在实现过程中，我们一般使用父节点和子节点指针维护 Splay 的结果。\n如果一对父子结点的指针是相互的，那么连接这两个点的边属于 Splay 上的边。\n否则会出现父节点的子节点指针没有指向自己的情况，那么这条边就属于原树上的边。\n简单地说，LCT 的父节点指针在 Splay 内就是 Splay 的父节点指针，在 Splay 外（根节点的父节点指针）表示的就是这条树链的链顶的父节点指针。\nLCT 的实现接下来我们介绍一个函数式的 LCT 的代码实现。\n通用函数为了方便新节点的定义，我们封装一个函数：\nint new_node(int v);\n然后是老生常谈的信息合并与标记下传函数：\nvoid pushup(int u);\nvoid pushdown(int u);\n为了支持原树根节点的变动，我们需要支持给 Splay 打翻转标记，表示这条树链的父子关系翻转。因此需要有一个打标记的函数：\nvoid noderv(int u);\n核心函数接下来是有关 LCT 结构维护的核心函数。\n为了代码的可读性，我们封装一个函数用于判断该结点是否是所在 Splay 的根节点：\nbool isroot(int u);\n同时封装一个函数用于获取这个结点是 Splay 上的左儿子还是右儿子：\nbool get(int u);\n接下来就是 Splay 的核心函数——旋转和伸展。但需要做一些小改动，比如判断当前结点是否是当前 Splay 的根：\nvoid rotate(int u);\nvoid splay(int u);\n接下来是 LCT 的核心函数——贯通。它的作用是将结点 u 到原树的根节点的路径变成一条树链，其他受影响的链会被截断一部分。\nvoid access(int u);\n然后是维护原树根节点变化的函数，它的作用是将结点 u 变成原树的根节点：\nvoid makeroot(int u);\n常用函数接下来是一些常用的函数，基于核心函数。但不是必需。\nbool check_link(int x,int y);\nvoid link(int x,int y);\nbool check_edge(int x,int y);\nvoid cut(int x,int y); 检查 x,y 是否连通；\n在不连通的 x,y 之间连一条边；\n检查 (x,y) 的边是否存在；\n删除 (x,y) 这条边（保证存在） 完整代码实现/******************heading******************/\nconst int SZ=1e6+6;\nint tot,ch[SZ][2],fa[SZ],val[SZ],sz[SZ],rv[SZ]; // 通用函数 int new_node(int v)&#123; ++tot,ch[tot][0]=ch[tot][1]=fa[tot]=rv[tot]=0; sz[tot]=1,val[tot]=v,sxor[tot]=v; return tot;\n&#125;\nvoid pushup(int u)&#123; sz[u]=sz[ch[u][0]]+sz[ch[u][1]]+1;\n&#125;\nvoid noderv(int u)&#123; if(u)rv[u]^=1; &#125;\nvoid pushdown(int u)&#123; if(rv[u])swap(ch[u][0],ch[u][1]),noderv(ch[u][0]),noderv(ch[u][1]),rv[u]=0;\n&#125; // 核心函数 bool isroot(int u)&#123;return ch[fa[u]][0]!=u&amp;&amp;ch[fa[u]][1]!=u;&#125;\nbool get(int u)&#123;return ch[fa[u]][1]==u;&#125;\nvoid rotate(int u)&#123; int p=fa[u],pp=fa[p],k; pushdown(p),pushdown(u),k=get(u);//k 的赋值必须在 pushdown 后！ if(!isroot(p))ch[pp][get(p)]=u;//!!! ch[p][k]=ch[u][!k], fa[ch[u][!k]]=p; ch[u][!k]=p,fa[p]=u, fa[u]=pp; pushup(p),pushup(u);\n&#125;\nvoid splay(int u)&#123; pushdown(u); for(int p;p=fa[u],!isroot(u);rotate(u)) if(!isroot(p))rotate(get(p)==get(u)?p:u);\n&#125;\nvoid access(int u)&#123; for(int p=0;u;p=u,u=fa[u])splay(u),ch[u][1]=p,pushup(u);\n&#125;\nvoid makeroot(int u)&#123; access(u), splay(u), noderv(u); &#125; // 常用函数 bool check_link(int x,int y)&#123; makeroot(x),access(y),splay(x),splay(y); return !(isroot(x)&amp;&amp;isroot(y));\n&#125;\nvoid link(int x,int y)&#123; makeroot(x), fa[x]=y; &#125;\nbool check_edge(int x,int y)&#123; if(!check_link(x,y))return 0; makeroot(x),access(y),splay(y); if(ch[y][0]!=x||ch[x][1])return 0; return 1;\n&#125;\nvoid cut(int x,int y)&#123; makeroot(x),access(y),splay(y),ch[y][0]=fa[x]=0,pushup(y);\n&#125; // 题目相关函数 void nodeassign(int u,int v)&#123; val[u]=v, pushup(u); &#125;\nvoid assign(int x,int y)&#123; splay(x), nodeassign(x,y); &#125;\nint query(int x,int y)&#123; return makeroot(x), access(y),splay(y),sxor[y]; &#125; void print()&#123; puts(\"---------------------------------\"); FOR(u,1,5)printf(\"u=%2d,lc=%2d,rc=%2d,sz=%2d,f=%2d,rv=%2d\\n\", u,ch[u][0],ch[u][1],sz[u],fa[u],rv[u]); puts(\"---------------------------------\");\n&#125;\n/* * 模板：Luogu3690 * new_node: 新建权值为 v 的结点 * pushup: 信息更新 * pushdown: 标记下传，主要是翻转标记 * noderv: 对某一个结点施加标记。 * LCT 的标记不同于线段树，必须在下传的时候再更新当前结点的信息。不然 * get 的时候会出锅 * nodeassign: 模板题需要 * isroot: 是否是所在 Splay 的根 * get: 是 Splay 上左儿子还是右儿子 * print: 调试函数 * rotate: 双旋，注意与 Splay 的双旋不同，要判 fa[u] 是不是 root，不然 fa[fa[u]] 的 * 儿子不能乱赋值 * splay: 把当前结点旋转到当前 Splay 的根结点，要用到 isroot 函数。一开始 * 先 pushdown。 * access: 把当前结点到根的路径连成一个 Splay，注意这个 Splay 只包含当前结点 * 到根这段路径上的点，不包括当前结点子树的那一段（非到叶结点的树链） * access 完之后这个点不一定是所在 splay 的根，需要手动 splay 一下 * makeroot: 把当前结点变成原树的根，这个结点也会顺便变成所在 Splay 的根。 * check_link: 判断两个点是否连通。 * link: 连接两个不连通的点 * check_edge: 判断两个点是否直连通（有没有边） * cut: 删掉 (x,y) 的边。 * assign: 模板题需要 * query: 模板题需要 */\nBZOJ 2631\n维护 Link/Cut，链加 / 乘 / 求和 对于 Tag 的维护，除了翻转 Tag 是在修改的时候打标记，下传的时候更新当前结点状态；其他标记都是在修改的时候打标记顺便更新该结点信息，在下传的时候更新子节点信息（与线段树相同）\n代码\n维护虚儿子信息链上信息可以 Splay 维护。对于虚儿子的信息，我们可以使用 set 维护。那么就只需要在改变实儿子的时候更新这部分信息。也就是在 access，link 和 cut 的时候。","title":"LCT 初步","updated":"2025-04-23T04:07:19.263Z"},{"categories":[],"path":"Probset/21-May/","tags":[],"text":"PKUSC2018 PKUSCPKUSC 计算几何 圆\n暴力。把多边形拆成有向边，问题转化为计算一个线段与圆的交（交集是线段）。这个可以做一个类似区别交的东西（这里的区间长度定义为是端点的辐角差）。\n时间复杂度 O(nm)。\n细节不多。见代码。\n代码\nNOI2019 回家路线NOI 斜率优化 李超树 DAG\n首先，小猫走的路径是没有环的（时间不能倒流）。因此实质上本题的图是一个 DAG。\n更具体地说，我们用二元组 (u, t) 表示「在时刻 t 到达结点 u」。将题面中的模型转化为点集为 (u, t) 的图，就是一个 DAG。问题转化为求 DAG 上从 (0, 0) 到 (n, ?) 的最小代价。\n本题的代价是与等待时间的连续段有关的，难以均摊到每条边上。换句话说，你没法最短路，除非你暴力建 O(n^2) 条边。不过注意到每次等待只会发生在单个结点上。因此我们将视角切换到一个结点 u 上。则在这个结点上按照时间顺序会有两种事件：列车到站和列车出发。\n因此我们考虑在时刻 t_i 到达 u，花费的最小代价设为 c_i，而时刻 t_j 有另一列车从 u 出发（t_i\\le t_j）于 t_k 时刻到达 v。则到达 (v, t_k) 的代价更新为 A(t_j - t_i)^2 + B(t_j - t_i) + C这是一个典型的斜率优化转移。\n在实现的时候我们需要开 n 个队列（数组）。\n时间复杂度 O(m\\log_2m)，如果使用线性的排序方式可以做到 O(m)。\n代码\n注：斜率优化维护下凸壳时，在插入点的时候，对于横坐标相等的情况要特判：\n#define check(X, Y, Z) (Y.x == Z.x ? (Y.y &lt; Z.y) : (det(Vec(X, Y), Vec(Y, Z)) > 0))\nNOI2019 序列NOI 模拟费用流 贪心\n首先容易想到一个费用流做法，建模类似这样 虚线部分表示选择不一定匹配的两个。\n写得好应该可以获得 64 分。\n满分做法是考虑优化计算费用流的过程。也就是说我们不使用常规的费用流算法，而是根据本题中费用流模型的特殊结构，设计算法模拟费用流的过程。\n就本题而言我们模拟増广路算法。増广路算法的特征是每次找费用的最短路，也就是贪心。\n观察发现，每次増广相当于是左边选了一个 a_x 右边选了一个 b_y。中间怎么流我们其实不关心，因为没有费用，只有一个限制：满足 (c,d) 这条边的容量限制。因此我们的问题可以抽象为一个贪心选数的问题。\n如果 (c, d) 这条边没有满流，那么増广过程等价于贪心选择 a 的最大值和 b 的最大值，直到满流。\n如果满流，那么我们有三种増广路（选数）类型： 选择两个相匹配的数 (a_i, b_i)，且这两个数之前没有被选过。\n对于 (a_i, b_i) 其中 a_i 被选，b_i 未选。那么我们选上 b_i，含义是给一个 S\\to a_i\\to b_i\\to T 的流，踢掉原本 a_i \\to c 的流。这时 c 的入流少了 1，那么我们再从未选的 a_i 中贪心拿最大的即可。\n对于 (a_i, b_i) 其中 a_i 未选，b_i 被选的情况同理。 3 种情况取最优即可。\n容易发现上述増广过程可以数据结构简单维护。\n时间复杂度 O(Tn\\log_2n)。\n代码\nNOI2019 弹跳NOI K-D Tree 最短路\n看起来是个单源最短路。由于边权非负，容易想到 Dijkstra 算法。\n但是直接建图边数太多，如果使用二维线段树或者树套树优化建图会使得复杂度达到 O(m\\log^2n) 的量级，而且还容易被卡空间。\n因此我们考虑优化算法过程。基本的 Dijkstra 算法中我们维护一个小根堆，堆中存放形如 (u, d) 的二元组，表示到达 u 的最短距离是 d。\n由于本题中连出的边是一个矩形的范围，因此容易想到将二元组魔改成 (R, d)，表示到达矩阵 R 中还未被访问（入堆）的点的最短距离是 d。因为 Dijkstra 算法中每个点只会被访问一次，因此 R 中已经被访问过的点的最短路距离一定小于等于 d，所以我们可以不考虑这些点。\n因此问题转化为：如何寻找一个矩阵中未被访问过的点。这个可以树套树或者 K-D Tree。K-D Tree 空间更小。每次我们找到一个点后将其入堆，然后把它标记为已访问过。如果 K-D Tree 上某个结点代表的矩阵内的所有结点都被访问过了，就没必要遍历这个子树了。\nK-D Tree 定位单个点的复杂度是 O(\\log n) 的，而每个点最多被定位一次。因此总复杂度 O(n\\log n + m\\log n)。\n代码\nNOI2019 斗主地插值 数学 猜结论\n一句话：一次函数洗牌之后的期望还是一次函数，二次函数洗牌之后的期望还是二次函数。\n这个结论并没有那么好猜。证明的话可以从一次函数的角度，写一个归纳法，发现可以拆成若干个范德蒙德恒等式的和。二次函数可以差分成一个一次函数来理解。\n其实有另外一种更意识流的理解：洗牌本质上是把这个函数分成前后两段，然后均匀地混合在一起。所以一次函数混合后仍是一次函数，二次函数混合后仍是二次函数。\n详细证明没啥营养。\n代码\nPKUSC2018 星际穿越倍增\n首先可以发现，固定 u。从 u 走到 i（i &lt; u） 的最短步数随 i 增大是逐渐减小（不上升）的。\n因此我们可以设 f(u, i) 表示从 u 出发走 i 步走到的最靠左的点。\n容易发现 f(u, 1) = l_u。\n可以发现 f(u, 2) = \\min_{u \\le v} l_v。进而 f(u, 3) = \\min_{f(u, 2) \\le v} l_v。\n也就是说除了第一步比较特殊，之后的转移是类似的。因此我们对之后的部分做一个倍增即可。\n设 f'(u, j) 表示从满足 u\\le v 的 v 出发走 2^j 步到达的最左端的点。设 g(u, j) 表示从满足 u\\le v 的 v 出发，走到 u - 1, u - 2, \\ldots, f'(u, 2^j) 的最短步数的和。\n转移是 trivial 的。\n注意特殊处理第一步。也就是说在回答询问的时候我们是从 l_u 出发。然后再加上 u 到 l_u 的贡献。\n代码","title":"2021 五月训练日志","updated":"2025-04-23T04:07:19.273Z"},{"categories":[],"path":"DP/Optimal-BST-and-QI/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"DP","slug":"DP","permalink":"https://notes.sshwy.name/tags/DP/"},{"name":"Quadrangle-Inequality","slug":"Quadrangle-Inequality","permalink":"https://notes.sshwy.name/tags/Quadrangle-Inequality/"}],"text":"本文介绍四边形不等式的来历以及应用。\n说明：\\arg\\min_i f(i) 表示最小化 f(i) 的 i，如果有多个则取最大的那个 i。\n四边形不等式四边形不等式（Quadrangle Inequality）是 Yao 在 1980 年于他的 论文 中定义的。\n对于二元函数 f(i,j)（1\\le i\\le j\\le n），称其满足四边形不等式，当且仅当 \\forall i\\le i'\\le j\\le j', f(i,j)+f(i',j')\\le f(i,j')+f(i',j)简记为：交叉小于包含。\n四边形不等式的命名四边形不等式的命名，大概是因为 Yao 在其论文中的证明。在 Yao 论文的条件中，f(i,i)=0。则当 i'=j 时，上述等式退化为了 f(i,j) + f(j,j')\\le f(i,j')如果将 f(i,j) 理解为 i 到 j 的距离，那么上述等式就是反过来的三角不等关系（原本的三角不等关系是 a+b&gt;c）。\n类似地，构造一个凸四边形，其顶点顺次标为 i,i',j,j'。那么四边形不等式描述的就是：对角线长度和小于等于对边长度和，相当于把原本的几何关系反过来。 历史问题四边形不等式最早似乎是在研究最优二叉搜索树问题过程中得到的。\n最优二叉搜索树问题最优二叉搜索树问题（Optimal binary search tree），也称带权平衡二叉树问题，指的是对于一些按特定分布的搜索操作，构造最小化（期望）搜索时间的二叉搜索树。\n问题的形式化定义为： 给出一个升序数列 a_1,a_2,\\ldots,a_n，以及 2n+1 个概率，分别用 A_1,A_2,\\ldots,A_n 以及 B_0,B_1,\\cdots,B_n 表示，其中 \\sum A_i + \\sum B_i = 1。\nA_i 表示，执行一个指向 a_i 的搜索的概率。B_i 表示执行一个指向 a_i 和 a_{i+1} 之间的数的搜索的概率。特别地，B_0 表示指向小于 a_1 的数，B_n 表示指向大于 a_n 的数。\n你需要构造一棵二叉树，使得期望搜索代价最小。 狭义地说，我们定义 \\text{Search}(x) 表示一个搜索操作，其返回一个布尔值，判断 x 是否出现在序列 a 中。那么 A_i 就表示我们执行 \\text{Search}(a_i) 的概率。\nB_i 表示我们执行 \\text{Search}(x)，其中 a_i &lt; x &lt; a_{i+1} 的概率。 以上狭义的部分希望能帮助大家理解。\n另外，我们可以将二叉树的一条边的遍历理解为单位 1 的代价。\n就本问题而言，有两种分支 静态：指构建了二叉树后形态不能变化。\n动态：形态可以发生变化。 就动态的问题而言，已经有太多的解决方案，且与四边形不等式不太相关。因此我们讨论的是静态问题的解决方案。\nKnuth’s DP AlgorithmKnuth 主要发现了 SOBST 问题的最优子问题的性质，从而得到了一个 O(n^2) 的 DP 算法。\n朴素算法要最小化期望搜索代价，等价于最小化所有情况的搜索代价之和。而搜索的代价与二叉树的遍历路径长度有关。可以理解为，执行 \\text{Search}(x) 的搜索代价是 BST 上它到根的路径长度乘上搜索它的概率。你可以理解为，a_i 和 a_{i+1} 之间有一个元素 b_i，代表所有 a_i 和 a_{i+1} 之间的数的集合。\n设 f(i,j) 表示对 a_{i-1} 和 a_{j+1} 之间（不含端点）的数建立二叉搜索树的最小代价和。\n另外，设 p(i,j) 表示，搜索操作指向 a_{i-1} 到 a_{j+1} 之间（不含端点）的概率。\n首先，f(i,i-1) = p(i,i-1) = B_{i-1}。\n对于 p(i,j)（1\\le i\\le j\\le n）而言： p(i,j) = p(i,j-1)+ A_j + B_{j-1}对于 f(i,j)（1\\le i\\le j\\le n）而言，转移时枚举分割点 k，把两边的分为左右两棵子树： f(i,j) = \\min_{i\\le k &lt; j}\\{ f(i,k)+f(k+1,j) \\} + p(i,j)该算法直接实现的复杂度是 O(n^3)。但 Knuth 使用了一些优化来将 DP 的计算复杂度降至 O(n^2)。\n优化设 \\arg(i,j) 表示 \\arg \\min_k \\{f(i,k)+f(k+1,j)\\}，也就是上述方程中的最优转移决策。那么有 \\arg(i,j-1) \\le \\arg(i,j)\\le \\arg(i+1,j)Knuth 在他的 论文 中对此有详细的证明，本文不做解释。从直观的角度，这是很容易理解的。[i,j-1] 的区间相对于 [i,j] 要偏左一些，因此最优分割点更靠左一些。对 [i+1,j] 是有同样的道理。\n有了这个推论，我们可以按照 |j-i| 从小到大的顺序进行 DP 转移，对于 |j-i| 相同的那些 DP 值，可以在 O(n) 的总时间内计算。因此总复杂度 O(n^2)。\n四边形不等式与矩阵我们注意到四边形不等式是关于二元函数定义的，对此我们可以用矩阵模型描述。\n单调矩阵（monotone matrix）：对于 n\\times m 的矩阵 A，若 \\forall 1\\le i &lt; j\\le n，\\arg\\min_k(A_i)\\le \\arg\\min_k(A_j)，即第 i 行最小值的位置在第 j 行最小值位置的左边，则称该矩阵为单调矩阵。\n完全单调矩阵（totally monotone matrix）：若矩阵 A 的所有子矩阵均为单调矩阵，则称之为完全单调矩阵。子矩阵指抽出若干行若干列交叉位置上的元素形成的矩阵。\n容易证明若 w 满足四边形不等式，则 w 对应的矩阵 W 以及其转置 W^T 都是完全单调矩阵。\n单调矩阵反映了四边形不等式在矩阵上的体现。\n四边形不等式优化 DP在需要用到四边形不等式的性质优化的问题中，四边形不等式往往表现出次模性。这里的次模性指边际效益递减（不一定变小，而是指变劣）。\n形式 I对于满足四边形不等式的代价函数 w，考虑以下形式的 DP： f(i) = \\min_{j &lt; i} \\{ f(j) + w_{j, i}\\}应用二分栈算法可以在 O(n\\log n) 的时间内完成计算。\n根据四边形不等式的性质，我们发现：对于两个决策点 j_1, j_2（j_1 &lt; j_2），如果 f(j_1) + w_{j_1, i} &gt; f(j_2) + w_{j_2, i}，则随 i 增加 j_1 不可能变优。\n因此对于 j_1 &lt; j_2，j_1 优于 j_2 只占一段时间。\n于是我们可以二分出 j_1 劣于 j_2 的最早时刻 i。\n而且这个 i 是单调的。证明：考虑矩阵 A_{j, i} = f(j) + w_{j, i}。这个矩阵满足四边形不等式。i 在其中扮演一个分界点的角色。然后你可以反证法证明。它是单调的。\n这样我们就只需要支持在序列末位插入/删除元素，在序列上二分。使用栈维护即可。\n形式 II\nf(i, j) = \\min_{k &lt; j} \\{ f(i - 1, k) + w_{k, j}\\}Yao 的论文指出：在 Knuth 算法中，如果 w(i,j) 满足四边形不等式，那么 f(i,j) 也满足四边形不等式。\n同时它也指出，如果 f(i,j) 满足四边形不等式，那么 \\arg(i,j-1) \\le \\arg(i,j)\\le \\arg(i+1,j)始终成立。\n因此就可以使用决策单调性优化 DP。\n应用：背包问题\n你有 n 个物品，大小和权值分别为 w_i 和 v_i。你有一个大小为 m 的背包，求放入背包的物品权值和的最大值。\nn\\le 10^6, m\\le 50000, w_i\\le 300, v_i\\le 10^9。 考虑 DP。由于物品的大小较小，因此考虑分类。设 f(s, i) 表示考虑大小小于等于 s 的所有物品和大小为 i 的背包的最大价值和。设 V_{s, i} 表示选 i 个大小为 s 的物品的权值和的最大值，那么显然 f(s, i) = \\max_j \\{f(s - 1, i - sj) + V_{s, j}\\}类似多重背包的套路，我们将转移按模 s 的余数分类，那么可以将方程转化为类似 g_i = \\max_j \\{ h_j + w_{i , j} \\}的形式，其中 w_{i,j} = V_{s, j - i}。\n显然这是一个满足四边形不等式的 DP 方程，可以应用二分栈算法解决。","title":"四边形不等式复习笔记","updated":"2025-04-23T04:07:19.262Z"},{"categories":[],"path":"LIS-on-Tree/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"这年头，啥都能上树。\n回顾最长上升子序列问题最长上升子序列问题（longest increasing subsequence, LIS）指 给出序列 a_1, \\ldots, a_n，求它的一个最长的子序列 b，使得 b_i&lt;b_{i+1}。 这个问题有一个经典 O(n\\log_2n) 做法。维护一个序列 d_i 表示长度为 i 的上升子序列的最小的末尾权值。每次在 d_i 上二分查找（lower_bound）来更新。如果没有 \\ge 它的就在 d 的末位加入新的元素。最终 LIS 的长度就是 |d|。\n如果要求的是最长不下降子序列（longest non-descending subsequence，LNDS），那么把 lower_bound 改成 upper_bound 即可。\n树上 LIS\n给出一棵点带权有根树，点权为 c_u。要求从中选择一个点集 S，使得 S 中任意一对祖孙关系的点 u,v（u 是 v 的祖先）都有 c_u&lt;c_v。 两棵子树的树上 LIS 是互不影响的！因此我们可以合理安排两个 LIS 的顺序使得两者的 LIS 是他们长度的和。换言之两个的 d 数组可以直接归并。合并的时候使用启发式合并即可，multiset 维护 LIS 对应的 d 数组。合并完子树要加入当前结点，也是 lower_bound。\n时间复杂度 O(n\\log_2^2n)。\n树上 LNDS 则是 upper_bound。\n例题和代码可以看 这里。","title":"「Trick」树上 LIS","updated":"2025-04-23T04:07:19.266Z"},{"categories":[],"path":"Romance-of-Duyi/","tags":[{"name":"dysyn1314","slug":"dysyn1314","permalink":"https://notes.sshwy.name/tags/dysyn1314/"}],"text":"","title":"Duyi 的恋爱史","updated":"2025-04-23T04:07:19.275Z"},{"categories":[],"path":"Probset/21-April/","tags":[],"text":"string本题的关键点在于挖掘好串的性质。容易发现好串实际上是一个离散化的完全 Trie。而我们的修改是区间的，不容易维护。考虑差分。\n一个长度为 2^i 的串差分后就变成了长度为 2^i-1 的串。如果这个串是好串，那么我们可以将其差分后的串理解为一棵完全二叉树的中序遍历。这棵二叉树的同一层的结点上的数是一样的。\n因此我们的问题转化成：每次询问一个长度为形如 2^k-1 的区间，要求单点修改把这个区间的串改成好串的差分串，求最小操作次数。那么我们显然可以将二叉树的每一层结点分开考虑，取 0 和 1 中出现次数少的算入贡献即可。实际实现过程中可以利用二进制数的性质（lowbit）完成。\n对于多组询问，我们可以预处理 c_{i, j} 表示 \\sum_{k}a_{i-k2^j}。这样就支持 O(q\\log_2n) 回答单个询问了。\n总时间复杂度 O((n + q) \\log_2 n)。\nLost Island1思维 推理\n红蓝眼的扩展题。我们先考虑这个经典的红蓝眼睛问题： 一个岛上有 n 个红眼和 m 个蓝眼的人（n &gt; 0, m &gt; 0），但每个人都不知道自己眼睛的颜色。每个人都能看见其他人眼睛的颜色，但他们不会去向别人询问自己的眼睛的颜色。这个岛上有个规矩：如果某个人知道了自己眼睛的颜色，那么他在第二天就需要自杀。\n这天来了个旅行家，他说：这个岛上既有红色眼睛的人也有蓝色眼睛的人，也只有这两种颜色。\n问岛上的人是否会自杀。会以怎样的方式自杀。 首先我们考虑 n &gt; 1, m = 1 的情况。可以发现第二天那个唯一的蓝眼睛的人会自杀。\n原因因为他看不到别的蓝眼睛的人，而旅行家又说有蓝眼睛的人，那么只可能是他自己。 然后考虑 n &gt; 2, m = 2 的情况。到了第二天没有人会自杀。但是到了第三天，两个蓝眼睛的人会同时自杀。\n原因如果你只看到一个蓝眼睛的人，且第二天这个人自杀了，那么你就可以断定蓝眼睛的人只有这一个人。\n但是第二天没有人自杀。说明这个蓝眼睛的人也看到了蓝眼睛的人，也就是说不只一个蓝眼睛的人，而你只看到了一个蓝眼睛的人。所以你也是蓝眼睛的人。 因此归纳得到，若 n &gt; m，那么第 m+1 天所有蓝眼睛的人会同时自杀。\n而对于剩下的 n 个红眼睛的人，他们发现蓝眼睛的人都自杀了，他们就知道自己不是蓝眼睛的人了。因此他们会在第 m+2 天全部自杀。\nn = m, n &lt; m 的情况类似。\n回到原问题。可以推广得到： 若有两个及以上的 b_i = 0，那么答案就是 \\max_{b_i &gt; 0}(a_i - b_i + 1)。\n若有唯一的 b_i = 0，那么答案是 \\max_{b_i &gt; 0}(a_i - b_i + 1) + 1。\n若没有 b_i = 0，那么答案是 \\max(\\sec \\max(a_i - b_i + 1)+1, \\max(a_i - b_i + 1))，其中 \\sec\\max 表示可重集的次大值。 代码\nTwo Pirates - 22DP 期望\n这题有一个很妙的模型转化。我们把这过程倒过来，同时把拿东西改成放东西。\n不妨用黑球表示神仙（没喝醉的）放的，白球表示傻逼放的。\n我们将宝物按从小到大排序。从空的序列开始： 首先神仙放一个黑球。\n然后傻逼放一个白球。傻逼原本的操作是随机选一个宝物，倒过来后就是：随机一个空隙插入一个白球。\n接下来是神仙放球。由于神仙拿最大的，因此他会把球放序列末尾。\n回到步骤 2。 转化后的模型有一个特点：每次放一个白球，只会让其后面的球平移一个位置。\n这样就可以方便地 DP 了。设 p(i, j) 表示当前序列长度为 i，左数第 j 个球是黑球的概率。\n如果轮到神仙放球，那么 p(i+1, i+1) = 1，p(i + 1, j) = p(i, j)\\;(j \\le i)。\n如果轮到傻逼放球，那么 p(i+1, j) = p(i, j-1) \\frac{j-1}{i + 1} + p(i, j)\\frac{i + 1 - j}{i + 1}。\n代码\nChess Tournament3\nn 个队伍的循环赛，只有 k 个战场（一轮比赛最多有 k 场对决），求一种安排的方案使得最小化比赛的轮数。\nn\\le 200, k\\le \\frac{n}{2}。 构造\n本题的构造是：首先取 k = \\lfloor \\frac{n}{2} \\rfloor，构造一个妙妙的比赛日程序列。然后我们取这个序列的区间 [(i-1)k + 1, ik] 作为第 i 轮比赛的内容。\n构造方法是：对于 n 是奇数的情况，我们取 (1, n), (2, n-1), \\ldots, (\\frac{n+1}{2}-1, \\frac{n+1}2{+1}) 一共 \\frac{n-1}{2} 个二元组加入到对决日程末尾。然后我们将每个二元组 (x, y) 循环一位变成 (x\\bmod n + 1, y\\bmod n + 1)，再把这个新的二元组序列加入到对决日程的末尾。重复 n 次我们就得到了一个长度为 \\frac{n(n-1)}{2} 的序列，且每个无序二元组在其中恰好出现一次。\n至于为啥这个序列妙得能够过本题，就不证明了（咕咕）。\n对于 n 是偶数的情况，我们对 1,\\ldots, n-1 构造与上述类似的 \\frac{n-1}{2} 个二元组后，将 (\\frac{n}{2}, n) 加入其中即可。剩余的步骤类似。\n代码\nX Number数位 DP\n先转化为前缀计数，枚举与限制相同的前缀，那么后面可以随便填。直接枚举 d 的出现次数，并求出其他数字的最大出现次数，然后做个背包即可（带一个组合数的系数）。\n我实现的复杂度是 O(T\\log_{10}^4 n 10^2)。不过常数是很小的。数位 DP 的常数一般不大。\n这题写代码的时候遇到了一个问题，静态查错才查出来的。说明对拍不是万能的。详情见我两发提交的不同之处。\n代码\nComplete the MST\n给出一个 n 个点 m 条边的边带权无向图，要求将其补成一个完全图，使得所有边权值的异或和为 0，且这个完全图的最小生成树的权值和最小。\nn, m\\le 2\\times 10^5。 并查集 二合一\n如果这个图的补图存在环，那么这个完全图的 MST 就无法用完补图上所有的边。因此我们可以把补图的边赋权为 0，留一条边赋权为原图的异或和。然后做一个类似 01-MST 的贪心即可。\n否则，我们仍然先做一个 01-MST，然后做一个类似次小生成树的东西，即我要么将答案加上原图的异或和，要么去掉当前的MST上的一条权值为 0 的边（补图上的边），加入一条原图上的边。\n时间复杂度 O(m + n\\log_2n)。\n代码\nSwap Pass如果整个排列是一个环，那么我们可以固定一个点 u，每次把 u 上的点权换到对应的编号上。这样肯定是合法的。\n如果不是一个环，就想办法合并成一个环。\n对着某个点极角排序一下，然后相邻的来合并，这样就避免了相交。\n时间复杂度 O(n\\log_2n)。\n代码\nTree Calendar\n给出一棵 n 个点的以 1 为根的树，初始时每个结点权值是它的 DFS 序（某一个）。接下来进行若干次点权交换： 每次找到一个点权的字典序最小的二元组 (u, v) 且 u 是 v 的父亲，然后交换两者的点权。 现在给出若干次交换后的树，问它原本的 DFS 序是什么样子，以及经过了多少次交换到达这一状态。\n无解输出 NO。\nn\\le 3\\times 10^5。 性质\n本题有三个重要的性质。\n手玩一下，可以发现你的操作步骤大概是，不停把权值 i 往下推直到推不动，然后推 i+1。\n性质 1：当你推 i 到推不动的时候，i 恰好代表它所在结点的后序遍历的次序（post-order）。由于后序遍历不唯一，因此更严谨地说，是初始状态的 DFS 序对应的后序遍历。也就是说当你把 1,2,\\ldots,i 都推到推不动的位置上去后，1, 2, \\ldots, i 所在结点的后序遍历次序恰好是他们目前的点权。\n性质 2：对于任意结点 u，将它的儿子按点权排序。那么在交换过程中，这个顺序不会发生变化。\n性质 3：当把 1,2,\\ldots,i 都推到推不动的位置上去后，根结点的点权恰好为 i+1。换言之每个点权都是从根结点开始被往下推的。\n手玩一下可以证明。\n于是，根据性质 2，我们可以直接利用当前的树构建出它的初始状态的 DFS 序。然后我们就可以求出其对应的后序遍历。\n结合性质 1 和性质 3，我们可以找到当前被推的是哪个权值，假设是 v。由于操作可逆，我们就倒着把它推回根结点。\n思考一下可以发现： 1, 2, \\ldots, v-1 得恰好在后序遍历的位置上。\n对于 i\\ge v，则 i 的位置应该在其初始状态的 DFS 序所在结点 u 的 \\max(0, \\text{dep}(u) - (i - v)) 级祖先上。 另外，在倒推 v 前要先检查 v 原本所在结点是不是后序遍历所在结点的祖先。\n时间复杂度 O(n\\log_2n)。\n代码\nBags and Coins位运算 背包\n容易转化为 01 背包问题，需要位运算优化。记录 b_i 表示最少选择前多少个物品能凑出 i。这样可以构造出方案。\n为了维护 b_i，需要在 DP 转移的过程中找到这一轮变成 1 的位。用 bitset 可以用 _Find_first 方法（虽然看上去很不官方）。手写位运算的话要注意预防 UB。具体来说： 32 位整型的位移值必须在 [0, 31] 范围内\n左移操作不能溢出 具体来说就是这样的：\nunsigned ls(unsigned x, int y) &#123; return ((y) ? (((x) &amp; ((1u &lt;&lt; (32 - (y))) - 1)) &lt;&lt; (y)) : (x));\n&#125;\n代码\n游戏筛法\n（JXOI 2018）\nl = 1 的情况要特判。\n问题可以转化为一个筛法问题，类似求 [l, r] 中的“伪质数”的个数。\n考虑魔改埃氏筛的过程。为了辅助筛法我们需要预处理 [1, l - 1] 里的质数。\n详情见 代码实现 1. Samara Farewell Contest 2020 (XXI Open Cup, GP of Samara) Prob. J &#8617; 2. Samara Farewell Contest 2020 (XXI Open Cup, GP of Samara) Prob. D &#8617; 3. Samara Farewell Contest 2020 (XXI Open Cup, GP of Samara) Prob. I &#8617;","title":"2021 四月训练日志","updated":"2025-04-23T04:07:19.272Z"},{"categories":[],"path":"Probset/DP-and-Subset-1/","tags":[],"text":"Max Correct Set证明 周期\n改成从 0, \\ldots, n-1 中选择数也是等价的。\n本题的难点在于证明：存在一种最优解使得其周期为 x+y。\n有了这个就可以写一个状圧 DP：f(i, S) 表示考虑在 0, 1, \\ldots, i-1 中选一个合法的集合，其中最后的 \\max(x,y) 个数的选择状态是 S 的最优解。\n记 c_i 表示 0, \\ldots, n-1 中 \\bmod {(x+y)} 为 i 的数的个数。用这个辅助 DP 的转移即可。\n代码\nNeko Rules the Catniverse状圧 矩阵乘法\n不妨把条件改成 y\\ge x-m。\n设 f(i, j, S) 表示考虑了 1, \\ldots, i，序列长度为 j，且 i, i-1, \\ldots, i-m+1 的使用状态是 S 的方案数。\n每次转移要么不选 i+1，要么把 i+1 放到序列末尾，要么放到某个数 x 的前面（x \\ge i-m+1）。\n然后使用矩阵乘法优化静态转移即可。\n时间复杂度 O((k2^{m+1})^3\\log_2 n)。\n代码\nThe Celebration of RabbitsFWT\n由于序列长度是奇数，因此对于一个序列最多有 1 个 x 使得其异或和为 0。因此我们可以枚举 x，把值域变成 [x, m+x]。这样问题就转化成 2n+1 个数异或和为 0 的方案数。直接 FWT 即可。\n做这题的时候这 OJ 好像出问题了。不保证代码正确性。\n代码\nBank Security UnificationDP 缩减状态\n我们用 a_i 表示题目中的序列。\n朴素的 DP 是设 f(i) 表示前 i 个数的答案。暴力转移的复杂度是 O(n^2) 的。\n考虑缩减状态。设 H(x) 表示 x 的最高位。那么对于以 a_i 结尾的最优解 a_{j_1}, a_{j_2}, \\ldots, a_{j_k}, a_i，一定不存在 j_k &lt; j^\\prime &lt; i，使得 H(a_{j_k}\\&a_{j^\\prime}) = H(a_{j^\\prime}\\&a_i)。否则我可以把 j^\\prime 加进来使得答案更大。\n根据上述发现，我们可以设 t_i 表示最大的 j 使得 a_j 的第 i 位为 1。那么对于 f(i) 只需要考虑所有的 t_j 作为转移即可。\n时间复杂度 O(n\\log_2w)。 代码\n随机二分图容斥 状态压缩\n如果只有 t = 0 的边，那么容易想到 f(S, T) 表示左右点集的选择情况，直接跑一个状圧 DP。状态空间大小是 O(\\sum_{i} \\binom{n}{i}^2)的（因为限定 |S| = |T|）。不过很多状态是跑不到的，因为 DP 转移时我们会强制边的某个端点处在 lowbit 的位置。\n对于 t = 1 的边，由于无法做类似 2-SAT 计数一样的东西，那么考虑容斥。如果我们直接把它拆成两条 t = 0 的边，那么可以发现原本的概率 \\frac{1}{2} 变成了 \\frac{1}{4}。于是我们要补个 \\frac{1}{4} 上去。方法是加入一条“边”连接了 a_1, b_1, a_2, b_2，出现的概率是 \\frac{1}{4}。\n对于 t = 2 的边同理，只不过概率是 -\\frac{1}{4}。\n代码 守卫区间 DP\n（JXOI 2018）\n本题思路容易受误导。实际上与凸包、单调栈等是没有关系的。\n考虑区间 [l, r]，我们必然会在 r 上放一个守卫。那么设这个守卫看到的位置依次是 p_1, \\ldots, p_k。分析一下 p 满足怎样的性质。\n首先，\\dfrac{h_r - h_{p_i}}{r - p_i}，即两点连线的斜率肯定是单调递增的。\n其次，对于非空区间 [p_i + 1, p_{i + 1} - 1]，只有 p_{i + 1} 可能看到其中的一些亭子。\n简要证明：如果 p_j（j &gt; i + 1）能看到其中的一些亭子，那么 r 又能看到 p_j 和 p_{i+1}，则 r 也能看到其中的数，矛盾。\n换言之 [p_i + 1, p_{i + 1} - 1] 独立了。即我们划分出了一个子问题。\n这样就可以区间 DP 了。设 f(i, j) 表示区间 [i, j] 的答案。\n设 j 在 [i, j] 中能看见的下标最小的亭子是 k。划分出最靠左的区间作为子问题，那么 f(i, j) = \\min(f(i, k), f(i, k -1)) + f(k + 1, j)可以理解为：在 k 或者 k - 1 上放一个守卫，取最小值。\n时间复杂度 O(n^2)。\n代码","title":"DP 与集合幂级数做题记录","updated":"2025-04-23T04:07:19.274Z"},{"categories":[],"path":"Probset/PKUWC2018/","tags":[],"text":"MinimaxDP 线段树合并 动态 DP\n有两个思路。\n算法一枚举 i，设 f_u 表示结点 u 的权值大于等于 V_i 的概率。可以树形 DP。设 x, y 是 u 的两个儿子： f_u = f_xf_y + p_uf_x(1-f_y) + p_uf_y(1-f_x)如果 u 是叶子结点，那么 f_u = [a_u\\ge V_i]。\n由于 i 会变化，因此是个动态 DP。\n由于需要树链剖分和线段树维护区间矩阵乘法，复杂度是 O(n\\log ^2nC) 的，C 是常数。\n算法二设 f_{u, i} 表示 u 的权值为 V_i 的概率。由于 V_i 互不相同，则 f_{x, i} 和 f_{y, i} 不可能同时大于 0。不妨设 f_{x, i} &gt; 0，那么 f_{u, i} = f_{x, i} \\left(\\sum_{j &lt; i}f_{y, j}p_u + \\sum_{j &gt; i}f_{y, j} (1 - p_u)\\right)在线段树合并的过程中维护括号里的和即可。类似缺一背包。\n时间复杂度 O(n\\log^2n)。\n代码\nSlay the SpireDP 计数\n用 a_i，b_i 分别表示强化牌和攻击牌。\n我们肯定会先打出所有的强化牌再打攻击牌。\n把一张攻击牌换成强化牌不会使总伤害变小。\n因此我们枚举随机的 m 张牌中有 i 张强化牌，然后分类讨论： 若 i\\le k - 1，那么强化牌全选，剩下的 m - i 张攻击牌里选出 k - i 张最大的。\n若 i &gt; k - 1，那么强化牌里选 k - 1 张最大的，然后攻击牌里选一张最大的。 考虑强化牌部分的系数。\n将强化牌从大到小排序。我们设 f(i, j) 表示前 i 张强化牌里选 j 张的乘积的和。则 f(i, j) = f(i - 1, j) + f(i - 1, j - 1) a_i。\n第一种情况可以直接用 f 表示。第二种情况可以转化为：选 x 张强化牌，计算其中的前 k - 1 大的乘积的和，可以枚举第 k - 1 大的牌是什么，得到 \\sum_{i = 1}^{n} f(i - 1, k - 2)a_i\\binom{n - i}{x - k + 1}。\n考虑攻击牌部分的系数。\n将攻击牌从小到大排序。对于第一种情况，设 g(i, j, p) 表示前 i 张攻击牌里选出 j 张，这 j 张中前 p 大的数之和的和。那么「 m - i 张攻击牌里选出 k - i 张最大的」可以表示为 g(n, m - i, k - i)。转移如下： g(i, j, p) = g(i - 1, j, p) + g(i - 1, j - 1, p - 1) + \\binom{i - 1}{j - 1} b_i你发现第三维可以扔掉。这样就是个二维 DP 了。\n第二种情况比较 trivial，就不展开了。\n总时间复杂度 O(Tn^2)。\n代码\n随机算法DP 独立集 \\gdef\\adj{\\text{adj}}\n设 \\adj(j) 表示 j 的邻居集合（包括它自己）。\n看到本题容易联想到朴素的最大独立集 DP：设 f(S) 表示 G[S] 的最大独立集。而这个 DP 有个缺陷：它考虑不到那些不在独立集中的点。如果要拓展这个思路，就需要额外加一个状态表示当前还有哪些点没有被放入排列。\n换个思路。\n我们发现 S\\subseteq \\bigcup_{x\\in S}\\adj(x)。因此我们可以把目前已被覆盖的点计入状态，然后在转移的过程中处理放入排列的贡献。\n换言之，设 f(i, S) 表示当前放入排列的数的集合是 S，且 G[S] 的独立集大小为 i 的方案数。转移时枚举 j\\notin S，然后把 \\adj(j)\\setminus S 里的点放入排列，计算系数即可： f(i + 1, S\\cup \\adj(j)) \\gets f(i, S) {(n - |S| - 1)}^{\\underline{|\\adj(j)\\setminus S| - 1}}设 t 是 G 的最大独立集大小，那么 答案就是 \\frac{1}{n!}f(t, [n])。\n时间复杂度 O(n^22^n)，据说卡常能过。\n设 g(S) 表示覆盖 S 的最大独立集大小（注意不是 G[S] 的最大独立集，指的是 \\bigcup_{x\\in I} \\adj(x) = S 的最大的 |I|），答案亦可写成 f(g([n]), [n])。\n容易发现 f(g(S), S) 只会由 f(g(S) - 1, T) 转移而来（最优子结构）。也就是说我去掉覆盖 S 的最大独立集 I 中的一个点以及只被它覆盖的点得到 S' 和独立集 I'，那么 I' 仍是 S' 的最大独立集。\n因此 f 的第一维就不需要了，用 g 辅助 f 转移即可。\n时间复杂度 O(n2^n)。\n代码","title":"PKUWC 2018 做题记录","updated":"2025-04-23T04:07:19.274Z"},{"categories":[],"path":"Math/Linear-Algbra/LP-and-its-Dual/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"},{"name":"LP","slug":"LP","permalink":"https://notes.sshwy.name/tags/LP/"},{"name":"Linear-Programming","slug":"Linear-Programming","permalink":"https://notes.sshwy.name/tags/Linear-Programming/"},{"name":"Network-Flow","slug":"Network-Flow","permalink":"https://notes.sshwy.name/tags/Network-Flow/"}],"text":"线性规划线性规划（Linear Programming，LP），指目标函数与约束条件皆为线性不等式的最优化问题。\n定义 m\\times n 的矩阵 A 和向量 \\textbf{b}=[b_1,\\cdots,b_m]^T，\\textbf{c}=[c_1,\\cdots,c_n]^T。\n线性规划通常可以用矩阵的形式表示为：1 \\begin{array}{l}\n\\text{maximize} & \\textbf{c}^T\\textbf{x}\\\\\n\\text{s.t.} & A\\textbf{x}\\le \\textbf{b},\\textbf{x}\\ge 0\n\\end{array}\\textbf{x} \\ge 0 表示 \\forall i, x_i\\ge 0。\n每个线性规划问题（称为原问题）都可以变换为一个对偶问题。上述问题的对偶问题为： \\begin{array}{l}\n\\text{minimize} & \\textbf{b}^T\\textbf{y} \\\\\n\\text{s.t.} & A^T\\textbf{y}\\ge \\textbf{c}^T,\\textbf{y}\\ge 0\n\\end{array}弱对偶定理：\\sum_{j=1}^nc_jx_j 的任意一组解小于等于 \\sum_{i=1}^mb_iy_i。\n强对偶定理：\\sum_{j=1}^nc_jx_j 的最大值等于 \\sum_{i=1}^mb_iy_i 的最小值（可以取等）。\n理解线性规划与对偶经济学角度2原问题：企业 A 拥有 m 种资源，计划生产 n 种产品（有 n 个变量），目标是最大化总收入，但使用资源的预算不能超过资源总数（有 m 个约束）；\n对偶问题：企业 B 想要收购这些资源，需要确定 m 种资源的报价（有 m 个变量），目标是最小化总成本，但企业 A 只有在卖资源的收益不低于卖产品的时候才会同意卖资源（n 个约束）。\n当然，你事先知道每种产品在单位数量下所耗资源的数量。\n数学角度原问题：给出 m\\times n 的矩阵 A（每一列的向量表示该产品所耗资源的数量），向量 \\mathbf{c}=[c_1,\\cdots,c_n]（产品成本），向量 \\mathbf{b}=[b_1,\\cdots,b_m]^T（每项资源的总量）。求向量 \\mathbf{x}=[x_1,\\cdots,x_n]^T（生产产品的数量），在 A\\mathbf{x}\\le \\mathbf{b}\\\\\n\\mathbf{x}\\ge 0的条件下，求 \\max z=\\mathbf{cx}对于任意一个非负向量 \\textbf{y}=[y_1,\\cdots,y_m]^T 和可行解 \\textbf{x}，有 \\textbf{y}^TA\\textbf{x}\\le \\textbf{y}^T\\textbf{b}而对于任意一个满足 \\textbf{c}\\le \\textbf{y}^TA的非负向量 \\textbf{y}，有 \\textbf{cx}\\le \\textbf{y}^TA\\textbf{x}\\le \\textbf{y}^T\\textbf{b}这意味着，\\textbf{y}^T\\textbf{b} 是原问题的一个上界。而最小的上界就是原问题目标函数的最优值。\n把他们都置换一下，可以得到原问题的对偶问题： A^T\\textbf{y} \\ge \\textbf{c}^T\\\\\n\\textbf{y}\\ge 0求 \\min w=\\textbf{b}^T\\textbf{y}对偶方法推论我们知道 A_i\\textbf{x}\\le b_i 会对偶成 y_i，且 y_i\\ge 0。那么对于 A_i\\textbf{x}\\ge b_i 和 A_i\\textbf{x}= b_i 的条件又如何对偶？\nA_i\\textbf{x}\\ge b_i 可以写成 -A_i\\textbf{x}\\le -b_i，那么就可以照常对偶。\n对于 A_i\\textbf{x}= b_i，我们可以写成两个条件 A_i\\textbf{x}\\le b_i 且 -A_i\\textbf{x}\\le -b_i。这样会对偶出两个变量 y_i' 和 y_i''。而他们的系数是恰好相反的，因此可以合并成 (y_i'-y_i'') 乘系数的形式。而 y_i'-y_i'' 没有 \\ge 0 的限制。因此我们可以将 A_i\\textbf{x}= b_i 当作 A_i\\textbf{x} \\ge b_i 对偶得到变量 y_i，然后消除 y_i \\ge 0 的限制。\n解题技巧接下来介绍一点在 LP 问题转化过程中会用到的技巧。\n引理 1：若 A\\textbf{x}\\ge \\textbf{b} 且 \\sum (A\\textbf{x})_i=\\sum \\textbf{b}_i，那么 A\\textbf{x}=\\textbf{b}。用不等式组的话说，如果左右加起来相等，那么每个等式都取等。反之亦然。\n经典线性规划问题及其对偶最大流最小割定理最大流和最小割问题是一对对偶问题。\n最大流问题变量：f(u,v)\\ge 0:(u,v)\\in E,|f|&gt;0。\n约束： \\begin{aligned}\nf(u,v) &\\le c(u,v) & (u,v)\\in E\\\\\n\\sum_{(v,u)\\in E}f(v,u)-\\sum_{(u,v)\\in E}f(u,v) &\\le 0 &u\\in V\\setminus\\{s,t\\} \\\\\n|f|+\\sum_{(v,s)\\in E}f(v,s)-\\sum_{(s,v)\\in E}f(s,v) &\\le 0 \\\\\n-|f|+\\sum_{(v,t)\\in E}f(v,t) - \\sum_{(t,v)\\in E}f(t,v) &\\le 0\n\\end{aligned}求 \\max |f|。（这里 |f| 只是变量名，没有特别的运算意义）。\n这里要说一点。原本的流量平衡是 \\sum_{(v,u)\\in E}f(v,u)-\\sum_{(u,v)\\in E}f(u,v)=0。在上面的约束中，把 2,3,4 的左边（实际上一共 |V| 个条件）加起来，可以发现每条边被算了两次，和为 0。而一堆小于等于 0 的数加起来是 0，那么这些数全都是 0。于是这个与流量平衡条件是等价的。\n对偶过程转化为对偶问题时，约束条件会对偶成变量，而条件的上界（右边）是变量的系数。\n对于对偶变量系数向量，则是一个变量在每个约束中的系数顺次组成的向量。对偶变量乘上系数向量就构成了对偶约束条件（有变量个）的左部，而右部由原问题的变量系数（最大化中的系数）构成。\n设条件 1 的对偶变量为 \\{d_{u,v}\\}。条件 2,3,4 的对偶变量分别为 \\{h_u\\},h_s,h_t。 对于变量 f(u^{\\prime},v^{\\prime}):u{^\\prime},v^{\\prime}\\in V\\setminus\\{s,t\\}，它对偶出来的约束条件是 d_{u^{\\prime},v^{\\prime}}-h_{u^{\\prime}}+h_{v^{\\prime}}\\ge 0。\n对于变量 f(v^{\\prime},s)，它对偶出来的约束条件是 d(v',s)-h_{v'}+h_s\\ge 0。\n对于变量 f(s,v^{\\prime})，它对偶出来的约束条件是 d(s,v')-h_{s}+h_{v'}\\ge 0。\n对于变量 f(v^{\\prime},t)，它对偶出来的约束条件是 d(v',t)-h_{v'}+h_t\\ge 0。\n对于变量 f(t,v^{\\prime})，它对偶出来的约束条件是 d(t,v')-h_{t}+h_{v'}\\ge 0。 上述都可以总结为，变量 f(u,v)，它对偶出来的约束条件是 d_{u,v}-h_{u}+h_{v}\\ge 0。\n然后是变量 |f|，它对偶出来的约束条件是 h_s-h_t\\ge 1。\n于是我们就得到了对偶形式的问题。 变量：d_{u,v}\\ge 0:(u,v)\\in E，h_u\\ge 0:u\\in V。\n约束： \\begin{aligned}\nd_{u,v}-h_u+h_v &\\ge 0 & (u,v)\\in E\\\\\nh_s-h_t & \\ge 1\n\\end{aligned}求 \\min \\sum_{(u,v)\\in E} c(u,v)d_{u,v}。\n转化为最小割问题首先结合 1,4 可以得到 d_{u,v}\\ge \\max(h_u-h_v,0)。而 h_s-h_t\\ge 1，为了最小化答案，不妨设 h_s=1,h_t=0。并且 h_u 只会取整数（可以证明存在这样的最优解）。那么我们定义 S=\\{u|h_u=1\\},T=\\{u|h_u=0\\}，显然 (S,T) 是原图的割。\n而 \\forall (u,v)\\in E，若 u\\in S,v\\in T，则有 d_{u,v}=1；其他情况 d_{u,v}=0，这说明割边的贡献是 1，则 \\min \\sum_{(u,v)\\in E} c(u,v)d_{u,v} 就是最小割的定义。因此对偶问题等价于最小割问题。\n二分图最大权匹配给出一个二分图 (V=L\\cup R(L\\cap R=\\varnothing),E:u\\in L,v\\in R\\;\\forall (u,v)\\in E)，边权为 w，求最大权匹配。\n原问题变量：x(u,v)\\ge 0:(u,v)\\in E。\n约束： \\begin{aligned}\nx(u,v) &\\le 1 & (u,v)\\in E\\\\\n\\sum_{(u,v)\\in E}x(u,v) & \\le 1 & u\\in L\\\\\n\\sum_{(v,u)\\in E}x(v,u) &\\le 1 & u\\in R\n\\end{aligned}求 \\max \\sum_{(u,v)\\in E}x(u,v)w(u,v)。\n容易证明 x(u,v) 只会取整数。因为 x(u,v)w(u,v) 是线性函数且始终过整点。因此最大值也一定是一个整点。另一个理解方式是，假设 |L|=1,|R|=3，连了一个爪，那么我们一定可以找到一条边使得其边权大于等于总边权和的 \\frac{1}{3}，那么我们选这条边作为匹配即可。\n因此上述 LP 形式与最大权匹配问题等价。\n对偶问题变量：h_u\\ge 0:u\\in V,d_{u,v}\\ge 0:(u,v)\\in E。\n约束： \\begin{aligned}\nd_{u,v} + h_u + h_v &\\ge w(u,v) & (u,v)\\in E\n\\end{aligned}求 \\min \\sum_{(u,v)\\in E} d_{u,v} + \\sum_{u\\in V}h_u。\n容易证明一定存在 d_{uv}=0\\;\\forall (u,v)\\in E 的解。证明简单，对于所有 d_{u,v}，设 x+y=d_{u,v}，那么把 h_u 加 x，把 h_v 加 y，答案不变。\n因此上述对偶问题可以简化。\n简化对偶问题变量：h_u\\ge 0:u\\in V。\n约束： \\begin{aligned}\nh_u + h_v &\\ge w(u,v) & (u,v)\\in E\n\\end{aligned}求 \\min \\sum_{u\\in V}h_u。\n这就是我们熟悉的 KM 算法的形式了。\n费用流模型接下来我们将介绍对偶算法里常用的网络流模型。\n给出一个无源汇网络图 G=(V,E)，每条边的容量是 c，费用是 w，同时每个结点有一个流量差度 e_i，表示流入结点 i 的流量与流出结点 i 的流量的差。\n考虑计算最大费用最大流。\n原问题变量：f(u,v)\\ge 0:(u,v)\\in E。\n约束： \\begin{aligned}\nf(u,v) &\\le c(u,v) & (u,v)\\in E\\\\\n\\sum_{(v,u)\\in E}f(v,u)-\\sum_{(u,v)\\in E}f(u,v) &= e_u & u\\in V \\\\\n\\end{aligned}求 \\max \\sum_{(u,v) \\in E}f(u,v)w(u,v)。\n对偶问题变量：y_{u,v}\\ge 0:(u,v)\\in E, h_u:u\\in V。\n约束： \\begin{aligned}\ny_{u,v}-h_u+h_v &\\ge w(u,v) & (u,v)\\in E\n\\end{aligned}求 \\min \\sum_{(u,v)\\in E} c(u,v)y_{u,v} + \\sum_{u\\in V}h_ue_u。\n事实上，上述不等式等价于 y_{u,v}\\ge \\max (w(u,v)+h_u-h_v,0)。由于我们要求最小值，因此我们可以不要 y_{u,v} 的变量了。\n简化对偶问题变量：h_u:u\\in V。\n求 \\min \\sum_{(u,v)\\in E} c(u,v)\\max(w(u,v)+h_u-h_v,0) + \\sum_{u\\in V}h_ue_u。\n换言之任何能够描述成上述形式的问题都可以使用线性规划和网络流解决。\n网络流算法如何具体地求出最大费用循环流？我们分析对偶问题的目的是，将题目转化为 y_{u,v}-h_u+h_v\\ge w(u,v) 的 LP 形式，然后对偶成最大费用循环流。因此接下来介绍如何求出最大费用循环流。\n首先我们是有直接求最小（大）费用循环流的算法的，参见 最大费用循环流的论文 or 这道题。速度甚至比普通的有源汇费用流算法更快。\n接下来我们讨论把循环流转化为有源汇的费用流的算法。\n我们的大致思路是，先把所有正权边满流。这样可以发现一定是最大费用，但不一定满足流量差度。那么我们把多于的流给退回去，求出最小费用的退流，就得到了最大费用循环流。\n具体地，设 e'_u=\\sum_{(v,u)\\in E}f(v,u)-\\sum_{(u,v)\\in E}f(u,v)。 如果 e'_u = e_u，则点 u 满足流量差度。 如果 e'_u &lt; e_u，那么点 u 就多流出了 e_u - e'_u 的流量。 如果 e'_u &gt; e_u，那么点 u 就多流入了 e'_u - e_u 的流量。 考虑建立新的图，新建源点 s 和汇点 t。我们跑一次最小费用最大流来把不合法的因素消除。 对于 e'_u &lt; e_u 的点，建立 (s,u),c(s,u)=e_u - e'_u,w(s,u)=0 的边。表示强行让你把多流的部分流出来。\n对于 e'_u &gt; e_u 的点，建立 (u,t),c(u,t)=e'_u - e_u,w(u,t)=0 的边。\n对于原图上的边 (u,v)：\n如果 w(u,v) &gt; 0，那么就直接在新图上建立它，表示我可以退这么多流。\n否则 w(u,v) \\le 0，这条就在新图上建立它的反向边，容量不变，费用变成相反数。因为它只能加流。也可以理解为，在新图上建立它，然后让它满流。 然后在新图上求出最小费用最大流，再用满流的方案减去它就是答案。\n例题Freelancer’s Dreams\n有 n 种物品，第 i 个物品买 1 份有收益 (a_i,b_i)（可以买实数份）。问最少买多少份物品使得 A 属性的和超过 p,B 属性的和超过 q。\nn\\le 10^5,1\\le p,q,a_i,b_i\\le 10^6. 先写出原问题的 LP 形式：\n变量：x_i\\ge 0:i\\in[1,n]。\n约束： \\begin{aligned}\n\\sum_{i=1}^na_ix_i &\\ge p \\\\\n\\sum_{i=1}^nb_ix_i &\\ge q\n\\end{aligned}求 \\min \\sum_{i=1}^nx_i。\n对偶一下得到：\n变量：A\\ge 0,B\\ge 0。\n约束： \\begin{aligned}\nAa_i+Bb_i &\\le 1\n\\end{aligned}求 \\max Ap + Bq。\n容易发现，约束就是半平面交，因此 B 是 A 的凸函数，则 Ap+Bq 也是凸的。则三分即可。\n代码\nZJOI2013 防守战线\n战线可以看作一个长度为 n 的序列，在序列第 i 号位置上建一座塔有 c_i 的花费，且一个位置可以建任意多的塔，费用累加计算。有 m 个区间 [l_i, r_i]，要求在第 i 个区间的范围内要建至少 d_i 座塔。求最少花费。\nn\\le 1000,m,d_i\\le 10000。 设 v_i 表示前 i 个位置上放了多少塔。则原问题可以描述为 \\min\\left( \\sum_{i}\\infty \\max(d_i + v_{l_i - 1} - v_{r_i}, 0)\n+ \\sum_{i}\\infty \\max(v_{i - 1} - v_{i}, 0)\n+ \\sum_{i\\ge 1} (v_i - v_{i - 1})c_i \\right)跑一个最大费用循环流即可。\n代码\nCow and Exercise\n给定 n 个点的带权有向简单图，q 次询问（独立），每次给定 x，可以把每条边增加一定的长度，但总共至多增加 x，问点 1 到点 n 的最短路最大能是多少。\nn≤50,m\\le n(n-1),q≤10^5。 单组询问首先写出原问题的 LP 形式。对于 x=X 的询问： \\begin{aligned}\n& \\text{mininize} & & d_n-d_1 \\\\\n& \\text{s.t.} & & d_v \\le d_u+w(u,v)+x_{u,v} \\\\\n& & & \\sum_{(u,v)\\in E} x_{u,v} \\le X \\\\\n\\end{aligned}发现这个形式不太容易转化为最大费用循环流的模型。因为第二个条件比较烦。\n则考虑二分，即求出最小代价使得最短路长度 \\ge L： \\begin{aligned}\n& \\text{mininize} & & \\sum_{(u,v)\\in E} x_{u,v} \\\\\n& \\text{s.t.} & & d_v \\le d_u+w(u,v)+x_{u,v} \\\\\n& & & d_n-d_1 \\ge L \\\\\n\\end{aligned}那么显然 x_{u,v} 可以不要了，我们要求的就是 \\min \\left(\\max(L+d_1-d_n,0)\\infty + \\sum_{(u,v)\\in E}\\max(d_v-d_u-w(u,v),0)\\right)这个可以用最大费用循环流解决。\n多组询问考虑到増广路算法中最大流对应最大费用的函数是凸的，因此我们把这个函数求出来。\n具体地，我们发现上述模型在去掉了 n 连到 1 容量为 \\infty 的边后，实际上就是一个最大费用最大流的问题。可以使用増广路算法。\n而最大流显然不会超过 n。因此设 f_i 表示最大流为 i 时的最大费用。这样很容易求。在増广的时侯每次只增加一个单位的流就可以求出 f_k。那么原图的最大流就是 \\max_{k} \\{f_k+kL\\}因此我们的问题就变成了，二分 L，判断 \\max_{k} f_k+kL\\ge x 是否成立。由于这个函数也是凸的，无脑 O(\\log_2^2n) 是可以的。\n更高明的做法是把上式化为 \\forall k, L\\le \\frac{x-f_k}{k}。这时相当于 L =\\min_k \\frac{x-f_k}{k}，于是做一次三分（导数上二分）即可。时间复杂度 O(n^2m+q\\log_2n)。\n代码\n小结在解决线性规划的问题中，要灵活运用对偶问题以及经典模型求解。 1. https://zh.wikipedia.org/zh/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92 &#8617; 2. https://www.zhihu.com/question/26658861/answer/631753103 &#8617;","title":"线性规划与对偶问题入门","updated":"2025-04-23T04:07:19.269Z"},{"categories":[],"path":"Euclideanoid/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"以前学的一直是推式子版的类欧，难记又难写。现在学会了几何意义版本，就写个总结。\n问题引入对于正整数参数 a, b, c 和非负整数 n，我们想要计算 f(a, b, c, n) = \\sum_{i=0}^n \\lfloor \\frac{ai+b}{c} \\rfloor。\n考虑其几何意义，设 l: y=\\frac{ax+b}{c}。我们要求的实际上是二维平面上 l，x 轴，y 轴和 x=n 这 4 条直线围成的梯形中整点的数量。细节地说，对于边界上的点，x 轴上的点不能取，其他三条线上的点都能取。 接下来我们做一些分类讨论，目的是减小问题规模，划分出子问题。\n当 b\\ge c 时，我们可以截一个矩形出来： 然后问题转化为求上面那个梯形里的整点数。因此有 f(a, b, c, n) = \\left\\lfloor\\frac{b}{c}\\right\\rfloor (n+1) + f(a, b\\bmod c, c, n)当 a\\ge c 时，我们引一条过原点斜率为整数的直线 l_2: y = kx，其中 k = \\left\\lfloor\\frac{a}{c}\\right\\rfloor。那么我们先考虑求 l_2 下方的整点数，然后求 l 与 l_2 之间的整点数。 前者可以用等差数列公式求得 \\frac{1}{2}\\left\\lfloor\\frac{a}{c}\\right\\rfloor n(n+1)。对于后者，考虑将整个平面上的点做一个映射：(x, y) \\to (x, y-kx)。容易发现这个映射的实质是把上面的那个梯形变成紧靠 x 轴的直角梯形。而 l 经过映射后得到的直线变成了 y=\\frac{ax+b}{c} - kx = \\frac{(a\\bmod c)x+b}{c}。因此 f(a, b, c, n) = f(a\\bmod c, b, c, n) + \\frac{1}{2}\\left\\lfloor\\frac{a}{c}\\right\\rfloor n(n+1)最后考虑 a&lt;c 且 b&lt;c 的情况。 注意到在这种情况下，l 与 y 轴的交点位于 [0, 1) 中。而直线的斜率小于 1。这时我们考虑将平面沿 y=x 翻转： 考虑用矩形的整点数减去三角形的整点数。不过这里引入了两个问题： 求三角形的面积不属于我们定义的类欧问题，需要转化。\n求三角形的整点数时直线上的点是不能算的。 对于第一个问题很简单：把 y 轴向右平移一个单位即可。这样直线的解析式就变成 y = \\frac{cx+c-b}{a}。问题转化为矩形内整点数减去梯形内整点数。\n对于第二个问题，我们将直线向下平移一点点即可。所谓的一点点指 \\frac{1}{a}。因此直线变成 y = \\frac{cx+c-b-1}{a}。\n在翻转之后，x 的上限取 \\lfloor\\frac{an+b}{c}\\rfloor。由于 y 轴向右平移了一个单位，因此实际上是 \\lfloor\\frac{an+b}{c}\\rfloor-1。\n于是我们得到 f(a, b, c, n) = \\lfloor\\frac{an+b}{c}\\rfloor n - f(c, c-b-1, a, \\lfloor\\frac{an+b}{c}\\rfloor-1)。\n把三个转移合到一起就得到类欧几里德的完整算法了。\n边界条件是 a=0，此时 f(a, b, c, n) = \\lfloor\\frac{b}{c}\\rfloor (n+1)。\nint f(int a, int b, int c, int n) &#123; if(a == 0) &#123; return (b/c)*(n+1); &#125; if(a &lt; c &amp;&amp; b &lt; c) &#123; int m = (a*n+b)/c; return m*n - f(c, c-b-1, a, m-1); &#125; return f(a%c, b%c, c, n) + (b/c)*(n+1) + (a/c)*(n*(n+1)/2);\n&#125;\n问题扩展考虑求 g(a, b, c, n) = \\sum_{i=0}^n \\lfloor \\frac{ai+b}{c} \\rfloor^2，h(a, b, c, n) = \\sum_{i=0}^n i \\lfloor \\frac{ai+b}{c} \\rfloor。\n对于 g，可以理解为是给二维平面上的整点 (x,y) 定一个权值 w_g(x, y) = 2y-1。那么我们要求的就是梯形里所有整点的点权和。\n截矩形和截三角形的两种转移都可以容易地推出。问题在于沿 y=x 翻转后，此时的点权变成了 2x-1，不太能用 g 描述子问题。\n不妨看 h。要求 h，我们可以定点权 w_h(x, y) = x。这时我们可以认为沿 y=x 翻转后，点权变成了 2w_h(x, y)-1。也就是说我们可以用 h 和 f 描述 g 的转移。\n同样的，对于 h 而言，前两种转移也是 trivial 的，而对于第三种转移，沿 y=x 翻转后点权变成了 y，可以理解为是 \\frac{1}{2}(w_h(x, y) + 1)。因此我们同样可以用 g 和 f 描述 h 的转移。","title":"类欧几里德算法小结","updated":"2025-04-23T04:07:19.264Z"},{"categories":[],"path":"Interactive-Prob-Judger/","tags":[{"name":"Original","slug":"Original","permalink":"https://notes.sshwy.name/tags/Original/"},{"name":"Interactive","slug":"Interactive","permalink":"https://notes.sshwy.name/tags/Interactive/"}],"text":"为什么会有这篇文章交互题是 OI 中一种新颖的题型。它可以同时恶心出题人和做题的人。\n出题人写交互器要调试半天，做题的人写代码不方便本地评测。\n在花费一些时间后，我实现了一个简单的交互器运行模块，可以帮助你进行交互题的本机评测。\n如果你并不知道交互题是什么，建议你先去做一道交互题。\n如果你还不了解交互题的造题过程，请在 Polygon 上注册一个帐号，观摩一下它默认提供的 example-interactive-binary-search。\n用途交互题包含几个部分： 交互器（交互库）：这个是出题人实现的，用于和你提交的程序进行交互。如果要本地评测你代码的正确性，那么显然你得自己写一个交互器。不过大多数题目的交互器是不难实现的。\n数据生成器：交互题仍然是有数据的。交互器大部分读入数据之后才会给你的程序提供输入，监听你程序的输出。这个也是自己写的。\n评测器：这是本文实现的内容。如果没有评测器，那么你本地测试就只能开两个终端窗口，每次把交互器的窗口输出的内容复制到你程序的窗口，再把你程序的输出复制到交互器的窗口，无法实现自动化。更别提对拍了。 形象地说，评测器是交互器和你程序的桥梁。\n代码实现/** * judger.cpp: Judger for Interactive Problem * * @author Sshwy * @copyright 2021 Sshwy (Weiyao Huang) * @license MIT * @date 2021.4.26 * * Usage: judger [command1] [command2] */\n#include &lt;stdio.h>\n#include &lt;unistd.h>\nusing namespace std; int main(int argc, char ** argv)&#123; if(argc != 3) &#123; fprintf(stderr, \"Usage: %s [command1] [command2]\\n\", argv[0]); return 0; &#125; int p1[2], p2[2]; if(pipe(p1) == -1 || pipe(p2) == -1) return fprintf(stderr, \"fail to create pipe\\n\"), 1; pid_t id = fork(); if(id &lt; 0) return fprintf(stderr, \"error fork\\n\"), 1; if(id == 0)&#123; // child : a if (dup2(p2[0], fileno(stdin)) == -1) return fprintf(stderr,\"Error 1\"), 1; if (dup2(p1[1], fileno(stdout)) == -1) return fprintf(stderr,\"Error 2\"), 1; execve(argv[1], nullptr, nullptr); &#125; else &#123; if (dup2(p1[0], fileno(stdin)) == -1) return fprintf(stderr,\"Error 3\"), 1; if (dup2(p2[1], fileno(stdout)) == -1) return fprintf(stderr,\"Error 4\"), 1; execve(argv[2], nullptr, nullptr); &#125; return 0;\n&#125;\n样例目前仅在 Linux 环境下测试过。\n选手程序// a.cpp\n#include &lt;bits/stdc++.h>\nusing namespace std; bool check(int x) &#123; printf(\"? %d\\n\", x); // check if ? >= x fflush(stdout); fprintf(stderr, \"? %d\\n\", x); // check if ? >= x scanf(\"%d\", &amp;x); return x == 1;\n&#125;\nint main() &#123; int n; scanf(\"%d\", &amp;n); fprintf(stderr, \"a.cpp: n %d\\n\", n); int l = 1, r = n, mid; while (l &lt; r) mid = (l + r + 1) >> 1, check(mid) ? l = mid : r = mid - 1; printf(\"! %d\\n\", l); return 0;\n&#125;\n交互器// interactor.cpp\n#include &lt;bits/stdc++.h>\nusing namespace std;\n#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i) int a, b;\nint main() &#123; FILE *inf = fopen(\"in.txt\", \"r\"); fscanf(inf, \"%d%d\", &amp;a, &amp;b); fclose(inf); assert(a &lt;= b); printf(\"%d\\n\", b); fflush(stdout); FOR(_, 1, 30) &#123; char x[5]; int y; scanf(\"%s%d\", x, &amp;y); fprintf(stderr, \"b.cpp: x:[%s], y:[%d]\\n\", x, y); if (x[0] == '?') &#123; printf(\"%d\\n\", a >= y); fflush(stdout); &#125; else &#123; assert(x[0] == '!'); if (y == a) &#123; fprintf(stderr, \"AC\\n\"); &#125; else &#123; fprintf(stderr, \"WA\\n\"); &#125; return 0; &#125; &#125; fprintf(stderr, \"WA\\n\"); return 0;\n&#125;\n执行结果$ g++ a.cpp -o a\n$ g++ interactor.cpp -o interactor\n$ g++ judger.cpp -o judger\n$ echo 5 10 > in.txt\n$ ./judger ./a ./interactor\na.cpp: n 10\n? 6\nb.cpp: x:[?], y:[6]\n? 3\nb.cpp: x:[?], y:[3]\n? 4\nb.cpp: x:[?], y:[4]\n? 5\nb.cpp: x:[?], y:[5]\nb.cpp: x:[!], y:[5]\nAC","title":"交互题本机评测器","updated":"2025-04-23T04:07:19.265Z"},{"categories":[],"path":"Probset/21-United-Provincial/","tags":[],"text":"宝石\n有一个长度为 c 的元素互不相同的序列 a，一棵 n 个点带点权的无根树。q 次询问 (u, v)，求最大的 i，使得 a_1, \\ldots, a_i 在 u 到 v 的简单路径的点权构成的序列中作为子序列出现过。\nn, q \\le 2\\times 10^5, c\\le 5\\times 10^4。 倍增 二分\n有一个高妙的单 log 做法\n我的做法是，首先把 a 序列变成 1, 2, \\ldots, c 的样子，点权跟着改。把路径按照 lca 分成前后两段。\n前半段可以倍增。然后我们在 v 上打一个形如 (\\text{lca}(u, v), x, i) 的标记，表示从 \\text{lca}(u, v) 到 v 的路径以权值 x 开始，且这是第 i 个询问。\n对于后半段，我们二分一下路径结尾的权值，然后倒着往上走到 lca 的位置（倍增）。\n因此总复杂度 O(n\\log n + q\\log ^2n)。\n代码\n滚榜状圧 DP 费用提前\n容易想到状圧 DP。\n设 a_i，b_i 表示第 i 个被公布的队伍的封榜前过题数和封榜后过题数。我们借此分析本题的状态空间与相关优化。\n那么可以用于描述一个局面的朴素状态有： 已经公布结果的队伍集合。\n已公布队伍的 b_i 的和。\n当前的榜首过的题数。\n当前榜首的 b_i。 考虑压缩状态。\n实际上我们不需要记榜首过的题数，只需要记榜首的编号和 b_i 即可计算出它的过题数。\n这样的状态数就是 O(2^nnm^2)，难以通过。\n分析一下状态空间，我们发现状态的第四维仅用于维护 b_i 的偏序。换言之，它维护的是「b_i 不降」的条件。考虑修改 DP 的方式，把这一条件消除。\n「b_i 不降」等价于「\\Delta b_i\\ge 0」（\\Delta b_i 表示其差分），后者显然是一个不需要计入状态空间的条件。那么我们能否用 \\Delta b_i 完成 DP？\n原题的滚榜过程是：每次 a_i \\to a_i + b_i，同时它会变成榜首。 第一个被公布的队伍需要超越 a_{\\max} 才能成为榜首。\n除此之外，第 i 个被公布的队伍（i &gt; 1）需要超过 a_{i - 1} + b_{i - 1} 才能成为榜首。 注意到第二个过程等价于： 第 i 个被公布的队伍（i &gt; 1）只要能超过 a_{i - 1} + b_{i - 1} 就能成为榜首。 于是 「a_i + b_i \\ge a_{i - 1} + b_{i - 1}」等价于「\\Delta b_i \\ge a_{i - 1} - a_i」。\n而 \\sum b_i = m 等价于 \\sum \\Delta b_i (n - i + 1) = m。\n因此我们完全可以用 \\Delta b_i 完成 DP，而且可以把第四维消除。其组合意义就是费用提前计算。\n于是设 f(S, i, j) 表示已公布的队伍集合，最后一个被公布的队伍编号，已经被公布的队伍的 \\sum \\Delta b_i (n - i + 1) 的和，对应的方案数。\n状态数 O(2^nnm)，时间复杂度 O(2^nn^2m)。\n代码\n卡牌游戏有一个高妙的线性做法。\n本题的算法趋向不明显，需要静下心来分析。\n假设 a_i 是最小值。那么 1, \\ldots, i - 1 就必须翻面，且我们要求 \\min_{1\\le j &lt; i} \\{ b_j \\} &gt; a_i。那么我们还剩 m - (i - 1) 次翻牌机会。显然我们会从 a_n 开始倒着翻，使最大值最小。但是如果我们遇到了 a_x &lt; b_x 或者 b_x &lt; a_i 的牌就不用翻了。综上，这部分时间复杂度 O(n)。\n假设 b_i 是最小值。那么不妨从小到大枚举 b_i。那么与上述过程是类似的，只不过多了一步寻找最大的 x 使得 a_x &lt; b_i 的过程。\n各种指针前缀后缀最小最大值扫一下就行。\n瓶颈是排序。\n总时间复杂度 O(n\\log_2 n)。\n代码\n矩阵游戏差分约束\n先考虑构造一组解，满足 b_{i, j} = a_{i, j} + a_{i + 1, j} + a_{i, j + 1} + a_{i + 1, j +1}的限制。\n然后考虑调整 a_{i, j} 满足值域限制。\n容易想到对于第 i 行，我们令 a_{i, j} \\gets a_{i, j} + (-1) ^ jx，仍然是满足等式限制的。列同理。\n盲猜一下，任意局面都可以通过行调整和列调整得到。而矩阵的每个元素恰好受一个行调整和列调整的影响。因此问题转化为若干个二元不等式的问题，容易想到差分约束。\n为了构造差分约束，我们定义变量 r_1, \\ldots, r_n 和 c_1, \\ldots, c_m 分别表示行调整和列调整的系数。然后令 a_{i, j} \\gets a_{i, j} + (r_i - c_j)(-1)^{i+j}。容易证明这个构造满足等式性质。\n然后使用 Bellman-Ford 寻找一组解即可。若有负环则无解。\n注意：和约束是不能做的。\n注意：判负环是判断入队次数 \\ge n，而非松弛次数。\n代码\n图函数Floyd 最短路\nFloyd 可能不是个复杂度正确的算法，但是想要让 Floyd 过还是需要一些技巧的。\n首先我们发现原题很复杂。需要转化。分析可以发现，在计算 f(u, G) 的过程中，当第二步枚举到 v （v &lt; u）的时候，u 和 v 互相可达当且仅当存在一个包含 u, v 的环，使得环上的结点编号都 \\ge v。\n证明对于结点 x（x &lt; v），若 x 在之前被删掉了，那么显然不在此环上。\n若没被删掉，那么必不可能在此环上，否则它就会在之前被删掉，矛盾。 因此我们设 g(u, v) （u &gt; v） 表示是否存在一个包含 u, v 的环，使得环上的结点编号都 \\ge v。那么有 h(G) = \\sum_{v\\le u}g(u, v)。这样就转化为了一个纯计数问题。\n计算 g(u, v) 可以有很多做法。但本题还要求计算在删除前 i 条边后的 h(G_i)。不难想到计算每个 g(u, v) 的贡献。因此我们设 t(u, v) 表示使得 g(u, v) = 1 的最大的 i。考虑 Floyd 算法，我们从大到小枚举中间点来保证环上的结点编号 \\ge v。而一条路径的权值就是这条路径上最早的被删除的边的时间。\n这样我们就得到了一个 \\Theta(n^3 + m) 的算法。它可以获得 44 分。\nFloyd 转移的部分大概长这样：\nROF(k, n, 1) &#123; FOR(i, 1, n) FOR(j, 1, n) &#123; if(w[i][j] &lt; min(w[i][k], w[k][j])) w[i][j] = min(w[i][k], w[k][j]); &#125; FOR(i, k, n) &#123; int x = min(w[i][k], w[k][i]); x = min(m + 1, x); if(x > 0) ans[x - 1] ++; // 答案的差分数组 &#125;\n&#125;\n考虑优化。分析发现 w(i, k) = 0 的转移其实是无效的。把这种情况判掉可以得到 80 分（因为 80 分的边数较少）。\n仔细思考，实际上 i &gt; k &lt; j 的转移也是无用的。因为满足 i &gt; k &lt; j 的 w(i, j) 不会对 w(i, k) 和 w(k, i) 的值造成影响。也不会对后续点对的最短路有影响。所以当 i &gt; k 时我们只枚举 j &lt; k 的部分做转移。\n这样可以获得 100 分。\n代码\n支配支配树\n性质 1：支配关系构成树的结构。\n证明：如果 u,v 都支配 z，且 u, v 互不支配，那么我可以找到一条从 1 到 z 经过 v 但不经过 u 的路。矛盾。\n性质 2：若 u 的受支配集改变，那么 u 在支配树上的子树里的结点的受支配集也跟着改变。\n证明：u 的受支配集显然是它在支配树上的祖先结点。得证。\n性质 3：u 受支配集的改变只会是删除其中的元素。\n一个朴素的想法是：对每个结点 u 判断它的受支配集是否变化，如果变化就给它的子树都打上标记。最后统计标记的个数。\n将祖先转化为父亲。也就是说对每个结点 u 判断它的受支配集中 u 的父亲是否被删除。如果有就给子树打上标记。容易证明这样是可以覆盖到所有的受支配集发生变化的结点的。\n上述问题等价于：是否存在一条 1\\to (s_i, t_i)\\to u 的路径不经过 u 在支配树上的父亲。\n等价于：u 的父亲不是 1\\to s_i 的必经点，且 t_i 能不经过 u 的父亲到达 u。\n预处理 h(u, v) 表示 v 不经过 u 的父亲能否到达 u。这样可以在 O(n) 的时间内回答询问。\n在 O(nm) 的时间内建立支配树即可。建支配树相当于是给支配关系做拓扑排序。\n时间复杂度 O(nm + nq)。\n代码","title":"2021 省选联考 A 卷解题报告","updated":"2025-04-23T04:07:19.273Z"},{"categories":[],"path":"Graph/DMST/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Directed-MST","slug":"Directed-MST","permalink":"https://notes.sshwy.name/tags/Directed-MST/"}],"text":"对于 n 个点 m 条边的边带权有向图（无自环，允许重边）G = (V, E)，并给定一个结点 r 作为根结点，朱-刘算法（Chu–Liu/Edmonds’ algorithm）可在 O(nm) 的时间内求出以 r 为根的最小权外向生成树，即最小树形图，或判断无解。\nTarjan 算法是对其的进一步优化。本文仅介绍朱-刘算法有关内容。\n朱-刘算法朱-刘算法的基本思想是将有向图的环缩点，转化为有向无环图（DAG）的最小树形图问题。\n对于每个非 r 的结点 u，设 e_{\\min}(u) 表示权值最小的 u 的入边（到达 u 的边）。若不存在，直接判定为无解。\n如果这些边构造的子图，即 G' = (V, E' = \\{e_{\\min}(u) : u\\in V, u\\ne r\\})，无环，那么容易证明 E' 是最小树形图的方案之一。\n证明最小权是显然的。\n考虑从任意非 r 的结点 u 开始沿着 e_{\\min} (u) 反向走。由于无环，那么最后一定会停在 r 上。因此 r 可以沿着 E' 中的边到达任意结点。因此这构成了一棵外向生成树。 如果有环，那么可以证明：存在一种最小树形图的方案，使得环上只有一条边没有被选，其他边都被选。\n不妨设这个环上的点的点集为 C，那么我们可以把这个环缩点成 u_C。且我们先把环上的边都选了。\n且对于 (u, v) \\in E（v\\in C, u\\notin C），我们将 w(u, v) 变成 w(u, v) - w(e_{\\min}(v))，含义为：如果我选择了 (u, v) 这条边，我就要放弃 e_{\\min}(v) 这条边。\n由于根结点必然不在环中（因为我们只对非 r 的结点 u 求 e_{\\min}(u)），因此 u_C 必然有恰好一条入边被选，这样环上的某一条边就会被放弃，破环为链，这就保证了缩点算法得到的结果一定是树形图。\n我们不停地按照上述过程缩点，直到没有环。这样就转化为了 DAG 的最小树形图问题。\n时间复杂度 O(nm)。\n代码实现在实现的时候我们可以类似并查集一样记录每个点被缩点到了哪个点里。如果一条边的两个端点被缩到同一个点里，那么这条边相当于被删除了。\n记录方案的时候只需要记每条边被选后需要放弃的边的集合，再记录每条边被选的时间，然后按照时间从后往前更新被选的状态即可（因为有的边被选了可能会在之后的缩点过程中被放弃）。\n#include&lt;bits/stdc++.h>\n#define FOR(a, b, c) for(int a = (int)(b); a &lt;= (int)(c); a++)\n#define ROF(a, b, c) for(int a = (int)(b); a >= (int)(c); a--)\nusing namespace std; struct Edge &#123; int u, v, w, ow; Edge(int _u, int _v, int _w) &#123; u = _u, v = _v, w = ow = _w; &#125; void reset () &#123; w = ow; &#125;\n&#125;; /** * Chu-Liu/Edmonds' algorithm * 计算有向图（允许重边、不允许自环）给定根的最小权外向生成树（最小树形图） * vector&lt;Edge> buildFrom(n, r, ve): n 个点，边集是 ve，根是 r 的最小权外向生成树 * 若无解则返回一个空的 vector * 要求 ve 非空 */\ntemplate&lt;const int N, const int M>\nstruct DirectedMST &#123; int nd[N], tnd[N], fa[N], pre[N], In[N], Time[M], totTime, onCir[N], totCir; vector&lt;int> toggle[M]; int get(int u) &#123; return fa[u] == u ? u : fa[u] = get(fa[u]); &#125; int getNode(int u) &#123; return nd[u] == u ? u : nd[u] = getNode(nd[u]); &#125; bool work(const int n, const int root, vector&lt;Edge> &amp; ve) &#123; bool flag = false; fill(In, In + n + 1, -1); fill(onCir, onCir + n + 1, 0); totCir = 0; for(unsigned i = 0; i &lt; ve.size(); i++)&#123; // calculate e_min(v) int u = getNode(ve[i].u), v = getNode(ve[i].v); if(u == v) continue; if(In[v] == -1 || ve[In[v]].w > ve[i].w) In[v] = i; &#125; FOR(i, 1, n) fa[i] = i; FOR(i, 1, n) if(i != root &amp;&amp; getNode(i) == i) &#123; if(In[i] == -1) return false; Edge e = ve[In[i]]; int u = getNode(e.u), v = getNode(e.v); if(u == v) continue; if(get(u) == get(v)) &#123; // find a circle ++totCir; for(int z = u; z != -1; z = z == v ? -1 : getNode(ve[In[z]].u)) onCir[z] = totCir, tnd[z] = v, Time[In[z]] = ++totTime; // assert(z); flag = true; &#125; else &#123; fa[get(u)] = get(v); &#125; &#125; for(unsigned i = 0; i &lt; ve.size(); i++)&#123; // shrink auto &amp; e = ve[i]; int u = getNode(e.u), v = getNode(e.v); if(u == v) continue; if(onCir[v] &amp;&amp; onCir[v] == onCir[u]) continue; if(onCir[v]) toggle[i].push_back(In[v]), e.w -= ve[In[v]].w; &#125; FOR(i, 1, n) if(onCir[i]) nd[i] = tnd[i]; // assert(getNode(i) == i); return flag; &#125; vector&lt;Edge> buildFrom(int n, int root, vector&lt;Edge> ve) &#123; assert(!ve.empty()); vector&lt;Edge> vt; FOR(i, 1, n) nd[i] = i; fill(Time, Time + ve.size() + 1, 0); totTime = 0; while(work(n, root, ve)); FOR(i, 1, n) if(getNode(i) == i &amp;&amp; i != root) &#123; if(In[i] == -1) return vt; // empty Time[In[i]] = ++totTime; &#125; vector&lt;int> SortByTime(totTime + 1, -1); for(unsigned i = 0; i &lt; ve.size(); i ++) if(Time[i]) SortByTime[Time[i]] = i; ROF(i, totTime, 1) &#123; int x = SortByTime[i]; if(Time[x]) for(int y: toggle[x]) Time[y] = 0; &#125; for(unsigned i = 0; i &lt; ve.size(); i ++) &#123; ve[i].reset(); // set w to ow (namely original weight) if(Time[i]) vt.push_back(ve[i]); &#125; assert(vt.size() == n - 1); return vt; &#125;\n&#125;;\n「例题」Dictionary1\n有 n 个字符串 s_1, \\ldots, s_n，要求构造一棵字典树使得每个字符串 s_i 都在字典树中以「从祖先到儿子的路径」的形式出现过（不一定是从根结点出发）。\n最小化字典树的结点数，并输出构造的方案。\nn \\le 50, |s_i| \\le 10。 容易发现我们可以维护一棵字典树 T，每次将一个字符串的前缀与 T 中的一个「从祖先到儿子的路径」构成的字符串“贴”到一起，这样可以合并 n 个字符串来得到一棵字典树。\n因此我们预处理 f(i, j) 表示第 i 个串的子串与第 j 个串的前缀匹配的最长长度。那么构造一个完全有向图，使得 (i,j) 的权值为 f(i, j)，则原问题就转化为：枚举根结点，求出这个图的最大树形图。\n在求出了最大树形图的方案后，就容易构造字典树的方案了。\n时间复杂度 O(n^4)。\n当然，由于本题的字符串长度较小，可以直接按照题解的算法建字典图求最小树形图。\n代码 1. ACM ICPC 2013–2014, Northeastern European Regional Contest (NEERC) Prob. D &#8617;","title":"最小树形图相关算法入门","updated":"2025-04-23T04:07:19.265Z"},{"categories":[],"path":"DSU-on-tree/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"DSU","slug":"DSU","permalink":"https://notes.sshwy.name/tags/DSU/"}],"text":"树上启发式合并（DSU on tree），可以概括为小的合并到大的上去（small to large1）。\n具体地说，设 F(u) 表示我们要求的结点 u 的信息，而 a_u 代表结点本身的数据。F(u) 依赖于 u 子树内结点的数据，但这种数据并不能简单合并，需要挨个遍历以更新信息。不过这种数据具备可减性。\n这时我们就可以考虑利用启发式合并来离线地计算每个结点 u 的 F(u)。\n考虑 DFS，我们先计算子结点的信息，在计算完后我们根据这个结点的身份决定是否让其父亲继承它的信息以及其子树的数据。如果继承，那么就保留其数据，否则就删除。\n而身份判断的标准就是该结点是重儿子。所谓的重儿子指子树大小最大的儿子。\n考虑将树重链剖分，那么可以发现结点 u 的数据会被遍历当且仅当我们正在计算 v 的信息，且 v 是 u 的祖先\nu 在 v 的轻儿子的子树里 这等价于：v 是 u 到根链上的重链的底端。\n因此这样的 v 的个数是 O(\\log n) 的。于是启发式合并的复杂度是 O(n\\log n) 的。\nCF600E\n求子树众数和 如果只考虑一棵树，可以 O(n) 求解。而本题信息是可以合并的，因此每次我们保留重儿子的信息（如果当前这棵树的根是一个重儿子就不清空）。这样每个结点的信息最多贡献 O(\\log_2n) 次，总复杂度 O(n\\log_2n)。\n代码\nCF741D\n求子树路径上字母任意顺序存在构成回文串的最长路径 由于是回文串，因此我们只关心出现次数的奇偶性。则设 c[mask] 表示出现状态为 mask 的结点的最大的深度。求经过当前根结点的最长路径，可以枚举子树结点，枚举某一位的出现次数为奇数或者出现次数都为偶数，然后更新当前答案。删除的话直接设为 -INF。显然可以保留重儿子信息。复杂度 O(n\\log_2n)。\n代码 1. https://codeforces.com/blog/entry/44351 &#8617;","title":"树上启发式合并小结","updated":"2025-04-23T04:07:19.262Z"},{"categories":[],"path":"Math/Polynomial/Semi-Online-Convolution/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"本文原标题「分治 FFT/NTT 学习笔记」，不过这容易与分治 + NTT 混淆，因此在接触到半在线卷积的概念后果断更名。\n半在线卷积 I\n考虑计算序列 f_0, \\ldots, f_n，其中 f 由卷积得到： f_i=\\sum_{j=0}^{i-1}f_jg_{i-j-1} \\qquad (i &gt; 0)g_0, \\ldots, g_n 是个已知序列，f_0 值已知。 求逆首先要说，上述问题可以直接通过多项式求逆解决。设两者的生成函数 F(x) = \\sum _i f_i x^i, G(x) = \\sum_i g_i x^i。那么 FGx + f_0 = F因此得到 F = \\frac {f_0}{1-Gx}。\n多项式求逆的复杂度为 O(n\\log n)。\n分治卷积分治卷积，也称分治 FFT/NTT，指将贡献通过分治转化为离线卷积，通过多项式卷积的方式计算贡献。\n我们定义记号 F[l, r] 表示多项式 \\sum_{i = l} ^ r f_i x^i，也就是 f 序列的区间 [l, r] 对应的生成函数。\n另外我们定义 F \\to G[l, r] 表示多项式 F 的每一项系数有对 G[l, r] 的对应项系数的贡献。简而言之，这描述的是对于任意 l\\le i \\le r，令 g_i \\gets g_i + f_i。\n这样我们就可以较为严谨地描述分治卷积的算法过程。定义 \\text{Solve}(l, r) 表示 F[l, r]Gx \\to F[l, r] 的操作。换言之 \\text{Solve}(l, r) 计算区间 [l, r] 的半在线卷积的贡献。\n考虑分治。那么对于区间中点 mid： 先递归地调用 \\text{Solve}(l, mid) 来计算出 F[l, mid] 的全部系数。\n累加 F[l, mid] 对 F[mid+1, r] 的贡献。\n再调用 \\text{Solve}(mid+1, r) 来计算 F[mid+1, r] 的全部系数。 第二步可以形式化地描述为操作 F[l, mid] Gx \\to F[mid+1, r]。\nO(n^2) 暴力执行这一操作复杂度过高。为了降低复杂度，我们首先考虑限定 G 的区间，因为 G 中并不是每个系数都能贡献到 [mid+1, r]。简单计算一下可以发现该操作等价于 F[l, mid] G[0, r - l - 1]x \\to F[mid+1, r]。\n区间范围计算过程考虑 [l, mid] 和 [mid+1, r] 的区间端点。那么设 Gx 对应的区间是 [L, R]。则有 \\begin{cases}\nL \\le mid + 1 - mid \\le R\\\\\nL\\le r - l \\le R\n\\end{cases}这样可以得到 L = 1, R = r-l（一些小的边界情况就不考虑了）。\n因此 G 对应的区间就是 [L-1, R-1]， 也就是 [0, r-l-1]。 由于 F[l, mid] 的系数已经通过第一步的递归计算得到，那么我们可以计算 \\frac{F[l, mid]}{x^l} 与 G[0, r-l-1] 的多项式卷积来得到对 F[mid+1, r] 的贡献。\n计算这个卷积的复杂度是 O((r-l)\\log n)。因此整个分治卷积的总时间复杂度为 O(n\\log^2n)。\n半在线卷积 II1\n已知 f_0, g_0，设 g_i = \\bigoplus_{j = 0} ^ i f_j。且 f_i = \\sum_{j = 0} ^ {i-1} f_j g_{i-j-1} \\qquad (i &gt; 0)求 f_0, \\ldots, f_n 序列。 与上一个半在线卷积不同的是，g 也是半在线的。这时我们可能会想到在分治卷积的过程中同时计算 f 和 g。\n假设我们已经计算好 F[l, mid] 和 G[l, mid]，接下来考虑 [l, mid] 对 [mid+1, r] 的贡献。\n错误策略如果仍然采用 F[l, mid] G[0, r-l-1]x \\to F[mid+1, r] 的分治卷积方式。\n那么当 l=0 时就有 F[0, mid]G[0, r-1]x\\to F[mid+1, r]。\n但是 G[mid+1, r-1] 还没有被正确地计算出来，因此这样计算是不对的。 这时我们需要利用分治卷积的一个性质：若令 mid = \\lfloor\\frac{l + r}{2}\\rfloor，那么在分治过程中若 l&gt;0，那么一定有 l \\ge r-l+1。\n证明考虑 [0, r] 递归到 \\big[\\lfloor\\frac{r}{2}\\rfloor+1, r\\big] 的过程。则显然有 \\lfloor\\frac{r}{2}\\rfloor + 1 \\ge r - \\lfloor\\frac{r}{2}\\rfloor。 也就是说原策略在 l &gt; 0 的情况是对的。所以我们得特殊处理 l = 0 的情况。我们将原策略修改一下：\n当 l = 0 时： 执行 F[0, mid] G[0, mid] x \\to F[mid+1, r]。此时其他部分少掉的贡献是 F[0, mid] G[mid+1, r-1]x \\to F[mid+1, r]。 当 l &gt; 0 时： 首先执行原策略 F[l, mid] G[0, r-l-1]x \\to F[mid+1, r]。\n然后我们补上 l=0 时缺失的贡献，也就是 F[0, r-l-1] G[l, mid] x \\to F[mid+1, r]。 这样就可以使用分治卷积来计算了。总时间复杂度仍为 O(n\\log^2n)。\n半在线卷积 III1\n对于多项式 F=\\sum_{i} f_i x^i 和已知的多项式 G，有 F = GF^2x + f_0其中 f_0 已知。求 F \\bmod {x^{n+1}}。 仍然是考虑分治卷积。假设我们已经算出 F[l, mid]，则 [l, mid] 对 [mid+1, r] 的贡献，有两种描述方式！\n方法一我们将贡献描述为 G[0, r-l-1]F^2[l, mid]x \\to F[mid+1, r]。\n请注意 F^2[l, r] 和 (F[l, r])^2 代表的含义是不一样的。\n如果要利用 F 暴力地计算 F^2[l, mid]，那么可以执行 (F[0, mid])^2 \\to F^2[l, mid]。复杂度是 O(mid\\log n)，显然不能接受。\n这时我们仍然考虑分治卷积的区间性质。\n当 l = 0 时我们直接执行上述操作，复杂度是 O((r-l)\\log n) 的。\n否则 l &gt; 0，由于 l \\ge r-l+1，因此 2l \\ge r+1，换言之 (F[l, mid])^2 对 F^2[l, mid] 没有任何贡献。于是上述操作可以拆成 2F[0, l-1]F[l, mid] \\to F^2[l, mid]。\n(F[0, l-1])^2 \\to F^2[l, mid]。 后者其实就是 [0, l-1] 对 [l, mid] 的贡献，是个半在线卷积的形式。因此我们设多项式 H=F^2，然后同时分治卷积地计算 F 和 H 即可。\n方法二若 l = 0，那么贡献仍描述为 G[0, r-l-1]F^2[l, mid]x \\to F[mid+1, r]。\n若 l &gt; 0，那么我们将贡献描述为 2G[0, r-l-1]F[l, mid]F[0, l-1]x \\to F[mid+1, r]。\n原因是 l\\ge r-l+1，因此 2l \\ge r+1，所以我们可以将 \\sum_{i, j}f_i f_j[\\max(i, j)\\ge l] 拆分为 \\sum_{i\\ge l, j &lt; l} f_j f_j + \\sum_{i &lt; l, j\\ge l}f_i f_j。写成生成函数的形式就得到了上式。\n进一步约束范围可以得到 2G[0, r-l-1]F[l, mid]F[0, r - l-1]x \\to F[mid+1, r]。这样就可以 O((r-l)\\log n) 计算贡献了。\n总时间复杂度 O(n\\log ^2 n)。\n方法二的应用参考 UOJ50 链式反应。\n不等关系\n给定一个字符串 s_1,s_2,\\cdots,s_n，仅包含&lt;和&gt;两种字符。\n计算有多少长度为 n+1 的排列满足 p_i 和 p_{i+1} 的关系是 s_i。答案对 998244353 取模。 考虑容斥，大于 = 无限制 - 小于。考虑我们将长度为 x 的排列分成 k 段，每一段的长度为 a_i，段内的关系都是小于，段与段之间的关系是无限制。则这样的排列的方案数是 \\binom{x}{a_1,a_2,\\cdots,a_k}=\\frac{x!}{\\prod_{i=1}^ka_i!}把容斥系数放在 DP 的式子里即可。设 f(i) 表示排列的前 i 个数的方案数除以 i! 的结果。答案即为 f(n+1)(n+1)!。设 a_i = [s_i = '&gt;']。特别地，我们定义 s_0='&gt;'。 f(i)=\\sum_{j=0}^{i-1}a_jf(j)\\frac{1}{(i-j)!}(-1)^{C(i-1)-C(j)}\\\\\nf(0)=0其中 C(x)=\\sum_{i=1}^xa_i。\n直接 DP，复杂度 O(n^2)。我们稍微变换一下式子 f(i)=(-1)^{C(i-1)}\\sum_{j=0}^{i-1}a_jf(j)\\frac{1}{(i-j)!}(-1)^{C(j)}设 F(j)=a_jf(j)(-1)^{C(j)},G(i-j)=\\dfrac{1}{(i-j)!}。这样就可以分治卷积了。\n代码 1. https://www.luogu.com.cn/blog/command-block/ban-zai-xian-juan-ji-xiao-ji &#8617;","title":"半在线卷积入门","updated":"2025-04-23T04:07:19.270Z"},{"categories":[],"path":"Graph/Kuhn-Munkres/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Graph","slug":"Graph","permalink":"https://notes.sshwy.name/tags/Graph/"},{"name":"KM","slug":"KM","permalink":"https://notes.sshwy.name/tags/KM/"}],"text":"之前做一道 KM 题，被卡 DFS 了。现在来填坑，学一个 BFS 版。\nKM 算法通过维护结点的顶标来求出二分图的最大权完美匹配，其正确性可以由对偶定理证明。\n对于 2n 个点左右两边点数相同的二分图 G=(V:(L,R),E)，KM 算法的复杂度是 O(n^3) 的。\n完美匹配：每个点都是某个匹配边的端点的匹配。\n最大权匹配转化为最大权完美匹配：对于左右点集大小不相同的二分图，我们可以把点集小的补满，新增一些权值为 0 的边，这不会影响答案。\n对于结点 u，记其顶标为 h_u，可以理解为点权。记边权为 w。\nKM 算法将在始终保证 h_u + h_v \\ge w(u,v) 的情况下最小化 \\sum_{u\\in L\\cup R}h_u，并给出匹配的方案。根据对偶定理，最小化的 \\sum_{u\\in L\\cup R}h_u 记为最大匹配的权值。\n相等子图KM 算法执行过程中会维护一个子图 G'=(V=(L,R), E'=\\{(u,v) \\in E| w(u,v) = h_u + h_v\\} )，其中 E' 维护的是满足 h_u + h_v = w(u,v) 的边。\n为什么维护相等子图根据对偶定理，保证 h_u + h_v \\ge w(u,v) 的情况下最小化 \\sum_{u\\in L\\cup R}h_u 得到的是最大权匹配。不妨设这个匹配是 P，那么对于 (u,v) \\in P 一定有 h_u + h_v \\ge w(u,v)。两边对 (u,v)\\in P 求和，发现是相等的，因此一定有 h_u + h_v = w(u,v)。\n换言之，只要存在 h 使得相等子图有完美匹配，那么我们就找到了最大权匹配。\n注意，完美匹配是与权值无关的。这个概念是基于不带权二分图的。在理解 KM 算法的过程中不要与带权匹配混淆。 因此我们有了一个 KM 算法的雏形： 在相等子图里増广。\n如果増广不了，就改一改顶标。 重复上述步骤直到找到完美匹配。当然，因为 |L| = |R|，所以完美匹配是一定存在的。\nKM 算法直接给出 KM 算法的框架。\n初始化： 对于 u\\in L，让 h_u = \\max_{v\\in R} w(u,v)。\n对于 u\\in R，让 h_u = 0。 DFS 版的比较好懂，但是难写而且跑得慢，这里我们讲 BFS 版。\n我们依次枚举右部的点 u 来作为増广结束的位置。\n然后 BFS： 对于右部的点，我们枚举相等子图中与它相邻的点继续搜索；\n对于左部的点，我们直接跳到与它匹配的点上去。如果没有与它匹配的点，那么我们就找到了増广路。 在 BFS 的过程中记录前驱指针。増广的时候倒着増广。也就是说是从左部的未匹配的点増广到右部的未匹配点（u）。\n如果増广失败，就考虑调整顶标值。\n顶标的调整方式与増广的方向有关。如果是从左到右増广，那么就以左加右减的方式；反之亦然。\n左加右减：将左部 BFS 树上的点的顶标统一增加 d，将右部 BFS 树上的点的顶标统一减少 d。\n设 BFS 树的点集是 T。\n在这样操作之后： 相等子图里的边依然满足 h_u + h_v = w(u,v)。\n对于 (u,v) : u\\in T, v\\notin T 的边仍不属于相等子图。\n对于 (u,v) : u\\notin T, v\\in T 的边，它原来不属于相等子图，现在可能进入了相等子图，因而使相等子图得到了扩大。 根本原因我们的増广路实际上是从 BFS 树的叶子走到根（u）。我们应当扩展 BFS 的叶子而不是给 BFS 树的根结点加一个父节点。前者对应 (u,v) : u\\notin T, v\\in T 的边，后者对应 (u,v) : u\\in T, v\\notin T 的边。 那么考虑 d 的值。为了保证 h_u + h_v \\ge w(u,v) 对每条边成立，则有 d = \\min_{(u,v) : u\\notin T, v\\in T} h_u + h_v -w(u,v)实际上我们可以对左部点 u 维护一个松弛变量 \\text{slack}(u) = \\min_{v\\in T} h_u + h_v - w(u,v)，这样就有 d = \\min_{u\\notin T}\\text{slack}(u)。而 \\text{slack}(u) 可以在 BFS 的过程中维护。\n在做完了左加右减之后，至少有一条 (u,v) : u\\notin T, v\\in T 的边会加入相等子图，即一定会有増广路。因此我们再进行一轮増广即可。\n代码","title":"Kuhn Munkres 算法入门","updated":"2025-04-23T04:07:19.265Z"},{"categories":[],"path":"Math/Min_25/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"},{"name":"Sieve","slug":"Sieve","permalink":"https://notes.sshwy.name/tags/Sieve/"}],"text":"min_25 筛适用于求积性函数前缀和，并且能够找到一个完全积性函数使得两个函数质数处的取值相同。 \\gdef\\Prime{\\mathcal{P}}记号说明\n\\Prime 表示质数集合。 设 p_i 表示从小到大第 i 个质数（p_1=2）。 \\Prime_i 表示小于等于 i 的质数构成的集合，即 \\Prime_i=\\{x\\le i|x\\in \\Prime\\}。\nQ(n) 表示 n 的最小质因子。 前提条件定义 f(n) 是一个积性函数。f'(n) 是完全积性函数，且 f' 与 f 在质数处的取值相同，即 \\forall x\\in \\Prime,f'(x)=f(x)，且 f' 要能快速计算前缀和。\n算法摘要简单描述一下筛法的步骤： 我们的目标是求 F(n)=\\sum_{i=1}^nf(i)。\n由于 f(i) 是积性函数，因此 f(1)=1。于是转化为 F(n)=1+\\sum_{i=2}^nf(i)。\n我们先求出 G(n)=\\sum_{i\\in \\Prime_n}f'(i)，表示所有质数处的取值。\n然后统计所有合数的贡献，再加上 G(n) 和 1 就是 F(n)。 第一部分定义 g(i,n)=\\sum_{x\\in \\Prime_n\\cup\\{x\\le n|Q(x)&gt; p_i \\}} f'(x)表示满足 x 是 n 以内的质数或者最小质因子大于 p_i 的 f'(x) 的和。我们可以用埃氏筛来理解这个定义，相当于目前筛到了质数 p_i，最小质因子大于 p_i 的数则没有被筛到。\n显然 G(n)=g(n,n)。并且 g(i,1)=0。边界情况 g(0, i) = \\sum_{j=2}^i f'(j)。因此为了计算 g(0, i)，f' 需要支持快速计算前缀和。\n接下来考虑递归计算 g(i,n)。讨论 p_i 与 n 的关系。\n如果 p_i^2&gt;n，意味着 n 以内不存在最小质因子大于等于 p_i 的合数。即 \\{x\\le n|Q(x)&gt; p_{i-1} \\}=\\{p_i\\}。因此得到 g(i,n)=g(i-1,n)\\quad (p_i^2&gt;n)如果 p_i^2\\le n，那么相当于我们只需要在 g(i-1,n) 里减掉多余的部分就可以得到 g(i,n)。具体地，我们减掉 Q(x)=p_i 的合数就可以了。这部分的和可以表示为（这里用到了 f' 的完全积性） \\sum_{p_i|x,x\\le n} f'(p_i)f'\\left(\\frac{x}{p_i}\\right)\\left[Q\\left(\\frac{x}{p_i}\\right)\\ge p_i\\right]另一方面，后者可以用 g 表示： \\begin{aligned}\n&\\sum_{p_i|x,x\\le n} f'\\left(\\frac{x}{p_i}\\right)\\left[Q\\left(\\frac{x}{p_i}\\right)\\ge p_i\\right]\\\\\n=&\\sum_{x\\le \\frac{n}{p_i}} f'(x)[Q(x)\\ge p_i]\\\\\n=&g\\left(i-1,\\left\\lfloor\\frac{n}{p_i}\\right\\rfloor\\right)-\\sum_{j=1}^{i-1}f'(p_j)\n\\end{aligned}于是得到 g(i,n)=g(i-1,n)-f'(p_i)\\left(g\\left(i-1,\\left\\lfloor\\frac{n}{p_i}\\right\\rfloor\\right)-\\sum_{j=1}^{i-1}f'(p_j)\\right)\\quad (p_i^2\\le n)记 h(i)=\\sum_{j=1}^if(p_j)=\\sum_{j=1}^if'(p_j)，则汇总两个转移得到 g(i,n)=\\begin{cases}\ng(i-1,n)& (p_i^2&gt;n)\\\\\ng(i-1,n)-f'(p_i)\\left(g\\big(i-1,\\lfloor\\frac{n}{p_i}\\rfloor\\big)-h(i-1)\\right)& (p_i^2\\le n)\n\\end{cases}容易发现，我们并不需要求出 g(n,n)。设 k 满足 p_{k+1}^2&gt;n,p_{k}^2\\le n。那么显然 G(n)=g(n,n)=g(k,n)。\n因此我们线性筛预处理出 p_1,p_2,\\cdots,p_k，然后预处理出 h(x),x\\in[1,k]，这样就可以计算 g(k,n) 了。实现可以使用滚动数组。\n这部分的时间复杂度约为是 O\\Big( \\frac{n^{\\frac{3}{4}}}{\\ln n} \\Big)。\n第二部分定义 S(i,n)=\\sum_{x\\le n,Q(x)\\ge p_i}f(x)即所有最小质因子大于等于 p_i 的 f(x) 的和。那么可以得到 F(n)=f(1)+S(1,n)=1+S(1,n)。\n同样考虑求出 S(i,n) 的递归式。我们把质数和合数的贡献分开考虑。\n质数部分的贡献显然是 G(n)-h(i-1)。\n对于合数部分，我们枚举它的最小质因子，假设是 p_j(j\\ge i)。然后枚举 p_j 在合数中出现的次数，假设为 e。那么剩下的部分如果大于 1，就表示为 S\\left(i+1,\\left\\lfloor\\frac{n}{p_j^e}\\right\\rfloor\\right)。如果一个合数只含有质因子 p_j，那么表示为 p_j^{e+1} 就行了。这时的贡献就是 f(p_j^{e+1})。\n综上得到 S(i,n)=G(n)-h(i-1)+\\sum_{i\\le j,p_j^2\\le n}\\sum_{e\\ge 1,p_j^{e+1}\\le n}f(p_j^e)S\\left(i+1,\\left\\lfloor\\frac{n}{p_j^e}\\right\\rfloor\\right)+f(p_j^{e+1})在实现的时候直接递归即可。\n这个部分的复杂度是 O(n^{1-\\epsilon}) 的。\n小结第一部分的 g 本质上用于处理完全积性函数在质数处取值的前缀和问题。换言之对于 f 在质数处的表达式 f(p)，只要能将其分解为若干个完全积性函数的和的形式，那么就可以分别使用这一过程处理。\n第二部分的核心部分是递归，这要求我们能快速计算 f 在质数幂处的取值 f(p^e)，这样利用第一个过程里预处理的部分就可以筛出来。\n当 n\\le 10^{13} 时，Min_25 筛的总时间复杂度是 O\\Big( \\frac{n^{\\frac{3}{4}}}{\\ln n} \\Big) 的。\n模板代码","title":"Min_25 筛入门","updated":"2025-04-23T04:07:19.269Z"},{"categories":[],"path":"Math/Subset-Power-Series/","tags":[{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"在阅读本文之前，如果你对 FMT，FWT，子集卷积等操作不熟悉，可以先阅读集合变换学习笔记。\n记号\n[n] 表示 \\{1,2,\\cdots,n\\}。\nf_S（S\\subseteq [n]）表示一个以集合为下标的一一映射（或者说序列）。 集合幂级数我们定义 f_S（S\\subseteq [n]）的集合幂级数为 F(x)=\\sum_{S\\subseteq [n]}f_Sx^S当然，我们并没有定义 x 的 S 次方的运算。因此你不需要考虑它的具体含义，把 x 当作一个符号即可。\n集合幂级数的基础运算对于两个 [n] 上的集合幂级数 F,G，他们的加法运算为 H(x)=F(x)+G(x)=\\sum_{s\\subseteq [n]}(f_S+g_S)x^S也就是对应项系数相加。\n要定义乘法运算，我们就首先要定义 x 的指数的运算律。我们定义一个集合之间的运算 \\otimes，要求 交换律：S\\otimes T=T\\otimes S。\n结合律：(A\\otimes B)\\otimes C=A\\otimes (B\\otimes C)。\n单位元：A\\otimes \\varnothing=A。 那么定义集合幂级数的乘法运算为 \\begin{aligned}\nH(x)&=F(x)G(x)\\\\\n&=\\left(\\sum_{S\\subseteq [n]}f_Sx^S\\right)\\left(\\sum_{T\\subseteq [n]}g_Tx^T\\right)\\\\\n&=\\sum_{S\\subseteq[n]}\\sum_{T\\subseteq[n]}(f_Sg_T)x^{S\\otimes T}\n\\end{aligned}接下来我们列举一些典型的集合运算的例子。\n集合并考虑集合并 \\cup 运算。那么容易发现这是集合并卷积。\n为了计算集合并卷积，我们先定义 F(x)=\\sum_{S\\in[n]}f_Sx^S 的子集和为 \\check{F}(x)=\\sum_{S\\subseteq [n]}x^S\\sum_{T\\subseteq S}f_T子集和可以使用 FMT 或者 FWT 先实现。然后再点值相乘，再做逆变换，即可计算集合并卷积。\n时间复杂度 O(n2^n)。\n那么我们定义了乘法，是否可以定义乘法的逆运算——除法？\n显然，只要在进行子集和变换后，每一项都有逆元，则除法也是有意义的。\n集合交取补集就是集合并，因此不赘述。\n集合异或考虑集合异或 \\oplus 运算，容易发现这是集合异或卷积。\n考虑分治多项式乘法。我们把集合分为含 n 和不含 n 的集合。那么可以得到 FG\n=\\left(\\sum_{S\\subseteq[n-1]}f_Sx^S+\\sum_{n\\in S\\subseteq[n]}f_{S}x^{S}\\right)\\left(\\sum_{S\\subseteq[n-1]}g_Sx^S+\\sum_{n\\in S\\subseteq[n]}g_{S}x^{S}\\right)可以发现这是 4 个 [n-1] 上的集合幂级数，因此可以得到 \\begin{aligned}\nFG &=(F_1+x^{ \\{n\\} }F_2)(G_1+x^{ \\{n\\} }G_2)\\\\ &=(F_1G_1+F_2G_2)+x^{\\{n\\}}(F_1G_2+F_2G_1)\n\\end{aligned}那么我们可以计算 (F_1+F_2)(G_1+G_2) 以及 (F_1-F_2)(G_1-G_2) 的值，那么两式相加除以 2 得到 F_1G_1+F_2G_2，相减除以 2 得到 F_1G_2+F_2G_1。这样我们就把 [n] 的集合异或卷积分解为两个 [n-1] 的集合异或卷积。该算法时间复杂度 T(n)=2T(n-1)+O(2^n)=O(n2^n)。\n实现的时候，我们会做 FWT 变换，然后再点值相乘，再逆变换回去。\n除法也是可以定义的。\n子集卷积考虑不相交的并。对于集合 S,T，如果 S\\cap T=\\varnothing 那么 S\\otimes T=S\\cup T。否则没有定义（严谨地说，若 S\\cap T\\ne \\varnothing，那么 S\\otimes T=0）。为了计算子集卷积，之前的方法是不适用的。我们定义 F(x) 关于 z 的集合占位幂级数F_z(x) 为 F_z(x)=\\sum_{S\\subseteq[n]}f_Sx^Sz^{|S|}在这里我们仍不考虑 z 的含义，只当它是占位符。\n而 [S\\cap T=\\varnothing][S\\cup T=A] 等价于 [|S|+|T|=|A|][S\\cup T=A]。因此我们对 F 和 G 的集合占位幂级数做集合并卷积得到 \\begin{aligned}\nF_zG_z&=\\left( \\sum_{S\\subseteq[n]}f_Sx^Sz^{|S|} \\right) \\left( \\sum_{T\\subseteq[n]}g_Tx^Tz^{|T|} \\right)\\\\\n&=\\sum_{S\\subseteq[n]}\\sum_{T\\subseteq[n]}f_Sg_Tx^{S\\cup T}z^{|S|+|T|}\n\\end{aligned}那么容易发现 FG=\\sum_{S\\subseteq[n]} [x^Sz^{|S|}](F_zG_z)。\n在实现的过程中，我们认为 x^S 的系数是一个长度 O(n) 的关于 z 的形式幂级数。FMT 可以对应项系数相加，复杂度 O(n^22^n)。然后对应项系数相乘，也就是对应项形式幂级数相乘，时间复杂度 O(n^22^n)。逆变换也是 O(n^22^n)。\n因此子集卷积的时间复杂度是 O(n^22^n)。\n那么子集卷积有除法吗？只要形式幂级数能够求逆即可。形式幂级数能求逆的条件是常数项非 0。因此除法是可以定义的。\n稍微解释一下 O(n^2) 形式幂级数求逆的算法。假设我们要对 F(x)=\\sum_{i=0}^nf_ix^i 求逆，那么设其逆元为 G(x)。于是有 \\forall 0\\le j\\le n, \\sum_{i=0}^jf_ig_{j-i}=[j=0]因此 g_j=\\begin{cases}\n0 & j=0\\\\\n-\\frac{1}{f_0}\\sum_{i=1}^jf_ig_{j-i} & j&gt;0\n\\end{cases}递推即可。\n集合幂级数的高级运算接下来我们介绍集合幂级数基于基础运算的高级运算。也基本不会讨论每种集合运算的情况。\n集合幂级数求导定义集合幂级数的导数： cx^S=\\sum_{v\\in S}cx^{S\\setminus\\{v\\} }因此对于 [n] 上的集合幂级数有 F'(x)=\\sum_{S\\subseteq [n]}x^S\\sum_{v\\notin S}f_{S\\cup\\{v\\} }集合幂级数 exp形式幂级数的 exp 通常定义在模 x^n 意义下。而集合运算是在全集的范围内进行的，系数不会收敛。另一方面，子集卷积在每个多项式非空的情况下最多卷 n 次就会收敛，因此我们只考虑 [x^{\\varnothing}]F(x)=0 的子集卷积的 exp。\ne^{F(x)} 定义为 e^{F(x)}=\\sum_{i\\ge 0} \\frac{F^i(x)}{i!}如何计算 e^{F(x)}？对集合占位幂级数两边同时 FMT 得到 \\begin{aligned}\n\\text{FMT}\\left(e^{F_z(x)}\\right)\n&=\\sum_{i\\ge 0}\\sum_{S\\subseteq[n]}\\frac{([x^S]\\text{FMT}(F_z))^ix^S}{i!}\\\\\n&=\\sum_{S\\subseteq[n]}x^S\\sum_{i\\ge 0}e^{[x^S]\\text{FMT}(F_z)}\n\\end{aligned}而 [x^S]\\text{FMT}(F_z) 是长度为 O(n) 的形式幂级数，因此我们只需要考虑模 x^{n+1} 意义下形式幂级数 exp 即可。\n接下来介绍 O(n^2) 形式幂级数 exp 的算法。首先考虑求导： {(e^{A(x)})}'=\\frac{\\text{d}e^{A(x)}}{\\text{d}x}=\\frac{\\text{d}e^{A(x)}}{\\text{d}A(x)}\\frac{\\text{d}A(x)}{\\text{d}}=e^{A(x)}A'(x)设 e^{A(x)}=\\sum b_ix^i，A(x)=\\sum a_ix^i，那么考虑 x^i 的系数，容易得到 b_{i+1}=\\frac{1}{i+1}\\sum_{j=0}^ib_ja_{i-j+1}(i-j+1)这样就可以递推了，时间复杂度 O(n^2)。\n集合幂级数 ln同样是子集卷积的 ln，我们定义 \\ln(1-F(x))=-\\sum_{i\\ge 1}\\frac{F^i(x)}{i}这里 1 是指 x^{\\varnothing} 的项的系数。仍然是使用集合占位幂级数，容易转化为求模 x^{n+1} 意义下 \\ln ([x^S]\\text{FMT}(F_z))。那么我们继续考虑 O(n^2) 算法。设 [x^S]\\text{FMT}(F_z)=1+A(x)，A(x)=\\sum_{i\\ne 0}a_ix^i。那么求导有 \\begin{aligned}\n\\ln'(1+A(x))&=\\frac{A'(x)}{1+A(x)}\\\\\n\\ln'(1+A(x))(1+A(x))&=A'(x)\n\\end{aligned}设 \\ln(1+A(x))=\\sum b_ix^i，仍然是考虑 x^i 的系数： b_{i+1}=a_{i+1}-\\frac{1}{i+1}\\sum_{j=1}^ia_jb_{i-j+1}(i-j+1)递推即可。\n集合幂级数开根可以使用同样的递推方式，不赘述。\n分治卷积 1已知 [n] 上的集合幂级数 G(x)=\\sum_{S\\subseteq[n]}g_Sx^S，求集合幂级数 F(x)=\\sum_{S\\subseteq[n]}f_Sx^S，其中 f_S=\\sum_{T\\subseteq S}f_Tg_{S\\setminus T}这个看着就像一个分治 FFT 的式子，只不过这次的对象换成了集合幂级数。先使用他们的集合占位幂级数表示，得到 \\begin{aligned}\n\\sum_{S\\subseteq[n]}f_Sx^Sz^{|S|}\n&=\\sum_{S\\subseteq[n]}x^Sz^{|S|}\\sum_{T\\subseteq S}f_Tg_{S\\setminus T}\\\\\n\\sum_{S\\cap T=\\varnothing} f_{S\\cup T}z^{|S\\cup T|}\n&=\\sum_{S\\cap T=\\varnothing}(f_Sx^{S}z^{|S|})(g_{T}x^{T}z^{|T|})\n\\end{aligned}由于我们只关心 |S|+|T|=|S\\cup T| 的系数，因此可以转化为 \\sum (f_Sx^{S}z^{|S|})(g_{T}x^{T}z^{|T|})=\\sum f_{S\\cup T}x^{S\\cup T}z^{|S| + |T|}那么考虑分治。假设我们求出了 S\\subseteq[n-1] 的 f_S 的值。那么 S\\subseteq[n-1] 对 \\{n\\}\\subseteq S\\subseteq[n] 的贡献是 \\sum_{S\\subseteq[n-1]} (f_Sx^{S}z^{|S|})\\sum_{\\{n\\}\\subseteq T\\subseteq[n]}(g_{T}x^{T}z^{|T|})=\\sum f_{S\\cup T}x^{S\\cup T}z^{|S| + |T|}容易发现这是一个 [n-1] 上的集合或卷积，可以 O((n-1)2^{n-1}) 计算（也就是令 g'_T=g_{T\\setminus\\{n\\} } 然后对 f,g' 做集合或卷积）。贡献完之后再递归考虑 \\{n\\}\\subseteq S\\subseteq[n] 的 f_S 即可。\n总时间复杂度 T(n)=2T(n-1)+O((n-1)2^{n-1})=O(n^22^n)。\n分治卷积 2考虑递推式 f_S=\\sum_{\\varnothing \\subset T\\subseteq S}f_Tf_{S\\setminus T}虽然感觉可以直接求通项公式。但还是介绍一下这个方法。我们仍然有 O(n^22^n) 的求法。仍然是考虑集合占位多项式。但这次我们先枚举 z 的次数。也就是说 (f_Sz^{|S|}x^S)(f_Tz^{|T|}x^T)\\to f_{S\\cup T}z^{|S| + |T|}x^{S\\cup T}。因此我们从小到大枚举 |S| 和 |T|，那么这就是集合或卷积的运算。由于对于每个 |S| 我们会做一次 FMT/IFMT，而我们会做 O(n^2) 次对应项系数相乘的乘法，因此复杂度仍是 O(n^22^n)。\n这个方法似乎也可以用于求解上一个分治卷积问题。\n参考文献吕凯风，集合幂级数的性质与应用及其快速算法，2015 年信息学奥林匹克中国国家队候选队员论文集\n子集卷积及其高级运算","title":"集合幂级数学习笔记","updated":"2025-04-23T04:07:19.271Z"},{"categories":[],"path":"Math/Polynomial/DGF/","tags":[],"text":"本文探讨狄利克雷生成函数以及其相关应用。 \\gdef\\dgf#1{\\tilde{ #1 }}\n\\gdef\\Prime{\\mathcal{P}}另外，使用 \\Prime 表示素数集合。\n狄利克雷生成函数对于无穷序列 f_1, f_2, \\ldots，定义其狄利克雷生成函数（Dirichlet series generating function，DGF）1： \\dgf{F}(x) = \\sum_{i\\ge 1}\\frac{f_i}{i^x}如果序列 f 满足积性（积性函数2）：\\forall i\\perp j, \\; f_{ij} = f_i f_j，那么其 DGF 可以由质数幂处的取值表示： \\dgf{F}(x) = \\prod_{p\\in \\Prime} \\left(1 + \\frac{f_p}{p^x} + \\frac{f_{p^2}}{p^{2x}} + \\frac{f_{p^3}}{p^{3x}} + \\cdots \\right)对于两个序列 f, g，其 DGF 之积对应的是两者的狄利克雷卷积序列： \\dgf{F}(x)\\dgf{G}(x) = \\sum_{i} \\sum_{j}\\frac{f_i g_j}{(ij)^x} = \\sum_{i} \\frac{1}{i^x}\\sum_{d | i} f_d g_{\\frac{i}{d}}常见积性函数的 DGFDGF 最适合用于研究与积性函数的狄利克雷卷积相关的问题。因此首先我们要了解常见积性函数的 DGF。\n黎曼函数序列 1, 1, 1, \\ldots 的 DGF 是 \\sum_{i\\ge 1}\\frac{1}{i^x} = \\zeta(x)。\\zeta 是黎曼函数。\n由于其满足积性，因此我们可以得到 1, 1, 1, \\ldots 的 DGF 的另一种形式： \\zeta(x) = \\prod_{p\\in\\Prime} \\left(1 + \\frac{1}{p^x} + \\frac{1}{p^{2x}} + \\ldots \\right) = \\prod_{p\\in \\Prime} \\frac{1}{1-p^{-x}}莫比乌斯函数对于莫比乌斯函数 \\mu，它的 DGF 定义为 \\dgf{M} (x) = \\prod_{p\\in \\Prime}\\left(1 - \\frac{1}{p^x}\\right) = \\prod_{p\\in \\Prime}(1-p^{-x})容易发现 \\zeta(x) \\dgf{M}(x) = 1，也就是说 \\dgf{M}(x) = \\frac{1}{\\zeta(x)}。\n欧拉函数对于欧拉函数 \\varphi，它的 DGF 定义为 \\dgf{\\Phi}(x) = \\prod_{p\\in\\Prime} \\left(1 + \\frac{p-1}{p^x} + \\frac{p(p-1)}{p^{2x}} + \\frac{p^2(p-1)}{p^{3x}} + \\ldots \\right) = \\prod_{p\\in \\Prime}\\frac{1-p^{-x}}{1-p^{1-x}}因此有 \\dgf{\\Phi}(x) = \\frac{\\zeta(x-1)}{\\zeta(x)}。\n幂函数对于函数 I_k (n) = n^k，它的 DGF 定义为 \\dgf{I_k} (x) = \\prod_{p\\in\\Prime} \\left(1 + \\frac{p^k}{p^x} + \\frac{p^{2k}}{p^{2x}} + \\ldots \\right) = \\prod_{p\\in \\Prime} \\frac{1}{1-p^{k-x}} = \\zeta(x-k)根据这些定义，我们可以轻松地证明 \\varphi \\ast 1 = I，因为 \\dgf{\\Phi}(x)\\zeta(x) = \\zeta(x-1)。\n其他函数对于约数幂函数 \\sigma_k(n) = \\sum_{d|n}d^k，它的 DGF 可以表示为狄利克雷卷积的形式：\\dgf S(x) = \\zeta(x-k)\\zeta(x)。\n对于 u(n) = |\\mu(n)|（无平方因子数），它的 DGF 为 \\dgf{U}(x) = \\prod_{p\\in \\Prime} (1+p^{-x}) = \\frac{\\zeta(x)}{\\zeta(2x)}。\n相关应用DGF 的应用主要体现在构造积性序列的狄利克雷卷积序列。研究方向通常是质数处的取值。\n例如在杜教筛的过程中，要计算积性序列 f 的前缀和，我们需要找到一个积性序列 g 使得 f\\ast g 和 g 都可以快速求前缀和。那么我们可以利用 DGF 推导这一过程。\n以洛谷 3768 简单的数学题3为例，我们要对 f_i = i^2\\varphi(i) 构造一个 g。由于 f 是积性的，考虑其 DGF \\dgf{F}(x) = \\prod_{p \\in \\Prime} \\left(1 + \\sum_{k\\ge 1} \\frac{p^{3k-1}(p-1)}{p^{kx}} \\right) = \\prod_{p\\in \\Prime} \\frac{1-p^{2-x}}{1-p^{3-x}} = \\frac{\\zeta(x-3)}{\\zeta(x-2)}因此 \\dgf{F}(x)\\zeta(x-2) = \\zeta(x-3)。所以令 g = I_2 即可。这样有 f\\ast g = I_3，两者都是可以快速计算前缀和的。 1. https://en.wikipedia.org/wiki/Generating_function#Dirichlet_series_generating_functions_(DGFs) &#8617; 2. https://en.wikipedia.org/wiki/Multiplicative_function &#8617; 3. https://oi-wiki.org/math/du/#_7 &#8617;","title":"狄利克雷生成函数入门","updated":"2025-04-23T04:07:19.269Z"},{"categories":[],"path":"Math/Polynomial/Polynomial/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"},{"name":"Polynomial","slug":"Polynomial","permalink":"https://notes.sshwy.name/tags/Polynomial/"}],"text":"常见导数首先铺垫一些基本函数的导数3： \\begin{aligned}\n(x^n)' &= nx^{n-1}\\\\\n|x|' &= \\operatorname{sgn}x\\\\\n(e^x)' &= e^x\\\\\n(a^x)' &= e^{x\\ln a}\\ln a\\\\\n(\\ln x)' &= \\frac{1}{x}\\\\\n(f^n(x))' &= nf'(x)(f^{n-1}(x))\n\\end{aligned}多项式积分\n\\int F(x)\\text{d}x=\\int\\sum_{i\\ge 0}a_ix^i\\text{d}x=\\sum_{i\\ge 1}\\frac{a_{i-1}}{i}x^i泰勒展开泰勒展开可以将一个函数表示为无穷级数，也称为泰勒级数（Taylor Series）1： f(x)=\\sum_{n\\ge 0}\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n其中比较常用的是 f(x) 在 x_0=0 处的展开，也称麦克劳林展开： f(x)=\\sum_{n\\ge 0}\\frac{f^{(n)}(0)}{n!}x^n多项式牛顿迭代牛顿迭代法本用于逼近方程的根，而多项式牛顿迭代2则指在多项式环上求出模 x^n 意义下的根。实际上 n 越大那么求出的根越接近真实的根，这与牛顿迭代法是类似的。\n已知函数 G，求多项式 F，使得 G(F(x))=0\\pmod{x^n}考虑倍增。假设我们求出了 F_0 使得 G(F_0(x))=0\\pmod{x^{\\left\\lceil\\frac{n}{2}\\right\\rceil}}。\n首先注意到 G(F(x))=0\\pmod{x^{\\left\\lceil\\frac{n}{2}\\right\\rceil}}，因此 F\\bmod x^{\\left\\lceil\\frac{n}{2}\\right\\rceil}=F_0，即他们的低位是一样的。\n考虑将 G(F(x)) 在 F_0(x) 处泰勒展开： G(F(x))=\\sum_{i\\ge 0}\\frac{G^{(i)}(F_0(x))}{i!}(F(x)-F_0(x))^i\\pmod{x^n}注意到 F(x)-F_0(x) 把低位都减没了。(F(x)-F_0(x))^2 的最低次数项的次数都是 x^n，因此可以直接忽略了。即 G(F(x))=G(F_0(x)) + G^{'}(F_0(x))(F(x)-F_0(x))\\pmod{x^n}因为 G(F(x))=0，化简得到 F(x)=F_0(x)-\\frac{G(F_0(x))}{G^{'}(F_0(x))} \\pmod{x^n}也可以简记为 F=F_0-\\frac{G\\circ F_0}{G'\\circ F_0}\\pmod{x^n}牛迭与多项式牛迭接触过牛顿迭代的读者会知道，对于一个连续且单调的函数 f(x)，我们要求 f(x)=0 的近似解，则迭代的公式为 x_i=x_{i-1}-\\frac{f(x_{i-1})}{f'(x_{i-1})}牛顿迭代可以直观理解：如果当前位置的点值和导数点值同号，说明在根的右边；否则说明在根的左边。\n那么多项式牛顿迭代又怎么直观理解呢？\n多项式环是没有数轴的说法的。不过我们可以把它看作是向一个多项式逼近的过程，就像泰勒展开一样。F_0 变成 F，代入 0&lt;x&lt;1，它的增量是不断变小（收敛）的。如果 x&gt;1 的话是发散的，这不在我们讨论的范围中。也就是说在 0&lt;x&lt;1 的时候，多项式的高次项对点值的影响就越小。因此倍增牛迭可以理解为是添加高次项来逼近多项式。\n接下来我们来看一下多项式牛顿迭代的应用。\n多项式求逆求模意义下多项式的逆。形式化地说：对于多项式 H(x)，求出 F(x) 使得 F(x) H(x) = 1 \\pmod {x^n}。\n首先介绍 O(n^2) 求逆的算法。\n设 H(x) = \\sum_{i\\ge 0} h_ix^i，F(x) = \\sum_{i\\ge 0}f_i x^i。\n那么 f_0 = \\frac{1}{h_0}。对于 i&gt;0，有 \\sum_{j=0}^i h_j f_{i-j} = 0。即 f_i = -\\frac{1}{h_0}\\sum_{j=1}^i h_j f_{i-j}。这样就可以递推求出 F(x)。\n使用牛顿迭代法可以更快。\n设 G(F(x)) = \\frac{1}{F(x)}-H(x)。\n那么问题转化为了求满足 G(F(x))=0\\pmod{x^n} 的解。应用牛顿迭代得到 \\begin{aligned}\nF(x)&=F_0(x)-\\frac{G(F_0(x))}{G'(F_0(x))}\\\\\n&=F_0(x)-\\frac{F_0^{-1}(x)-H(x)}{-F_0^{-2}(x)}\\\\\n&=2F_0(x)-H(x)F_0^2(x)\n\\end{aligned}那么使用 FFT/NTT 即可在 O(n\\log_2n) 的时间内计算。\n多项式开方求 h(x) 的平方根。即求一个多项式 F(x) 使得 F^2(x) = h(x) \\pmod {x^n}。\n与求逆类似，我们仍然可以递推地在 O(n^2) 时间内求出 F(x)。\n仍然考虑多项式牛迭。\n设 G(F(x))=F^2(x)-h(x)。应用牛顿迭代得到 \\begin{aligned}\nF(x)&=F_0(x)-\\frac{G(F_0(x))}{G'(F_0(x))}\\\\\n&=F_0(x)-\\frac{F_0^2(x)-h(x)}{2F_0(x)}\\\\\n&=\\frac{F_0^2(x)+h(x)}{2F_0(x)}\n\\end{aligned}时间复杂度 O(n\\log_2n)。\n多项式对数考虑计算一个多项式的对数函数（ln），记作 \\ln F(x)。首先我们要了解 \\ln F(x) 的级数形式。\n考虑 \\ln (1-x) 在原点的泰勒展开： \\ln(1-x)=-\\sum_{i\\ge 1}\\frac{x^i}{i}这样一来，我们就可以定义 \\ln (1-F(x)) ： \\ln(1-F(x))=-\\sum_{i\\ge 1}\\frac{F(x)^i}{i}换句话说对于 F(0)=1 的多项式，我们把它理解为 1-F_1(x) 的形式，就可以理解为上述定义。\n之所以要求常数项是 1，是因为 \\ln 1 = 0，不用考虑离散对数等等的问题。同时方便我们计算。\n接下来考虑计算求出 \\ln F(x)\\pmod{x^n}。首先做复合函数求导： (\\ln F(x))'=\\frac{\\text{d}\\ln F(x)}{\\text{d}x}=\\frac{\\text{d}\\ln F(x)}{\\text{d}F(x)}\\frac{\\text{d}F(x)}{\\text{d}x}=\\frac{F'(x)}{F(x)}两边同时积分得到 \\ln F(x)=\\int\\frac{F'(x)}{F(x)}\\text{d}x这样就可以用多项式求逆来计算了。这样计算的一个问题是，求导再积分后，常数项就没了。如果 F(0)=1 就会比较好办，此时 \\ln F(x) 的常数项为 0。\n除此之外，我们仍然可以递推求解 \\ln F(x)。设 \\ln F(x) = \\sum_{i\\ge 1} g_i x^i，F(x) = \\sum_{i\\ge 0}f_i x^i（f_0 = 1）。\n根据 (\\ln F(x))' F(x) = F'(x)，对于 i &gt; 0 有 \\sum_{j=0}^i g_{j+1}(j+1) f_{i-j} = f_{i+1}(i+1)。\n整理一下得到 g_i = f_i - \\frac{1}{i} \\sum_{j = 1} ^ {i-1} j\\cdot g_j\\cdot f_{i-j}。这样就可以 O(n^2) 递推了。\n注： \\ln x=\\sum_{i\\ge 1}\\frac{1}{i}\\left( \\frac{x-1}{x} \\right)^i\\qquad \\forall Re(x)\\ge \\frac{1}{2}.多项式指数考虑计算一个多项式的指数函数4（exp），记作 \\exp F(x) 或者 e^{F(x)}。\n仿照 \\ln F(x) 的定义，我们将 \\exp x=e^x 在原点泰勒展开得到 \\exp x=\\sum_{i\\ge 0}\\frac{e^0}{i!}x^i=\\sum_{i\\ge 0}\\frac{x^i}{i!}因此可以得到 \\exp F(x)=\\sum_{i\\ge 0}\\frac{F^i(x)}{i!}考虑求 \\exp H(x)\\pmod {x^n}。设 G(F(x))=\\ln F(x)-H(x)\\pmod{x^n}。应用牛顿迭代得到 \\begin{aligned}\nF(x)&=F_0(x)-\\frac{G(F_0(x))}{G'(f_0(x))}\\\\\n&=F_0(x)-\\frac{\\ln F_0(x)-H(x)}{\\frac{1}{F_0(x)}}\\\\\n&=F_0(x)(1-\\ln F_0(x)+H(x))\n\\end{aligned}容易发现在 H(x) 常数项为 0 时上式是容易计算的。\n时间复杂度 O(n\\log_2n)。\n再考虑递推求解 e^{F(x)}。考虑求导：(e^{F(x)})' = e^{F(x)} F'(x)。\n设 e^{F(x)} = \\sum_{i \\ge 0} g_i x^i，F(x) = \\sum_{i \\ge 0} f_i x^i，那么 g_{i+1}(i+1) = \\sum_{j=0}^i f_{j+1}(j+1) g_{i-j}。\n整理一下有 g_i = \\frac{1}{i} \\sum_{j=0}^{i-1} f_{j+1}(j+1)g_{i-j-1}（i&gt;0），当f_0 = 0 时有 g_0 = 1。\n模板代码 1. https://en.wikipedia.org/wiki/Taylor_series &#8617; 2. http://blog.miskcoo.com/2015/06/polynomial-with-newton-method#i-4 &#8617; 3. https://zh.wikipedia.org/wiki/%E5%AF%BC%E6%95%B0%E5%88%97%E8%A1%A8 &#8617; 4. https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0 &#8617;","title":"多项式入门","updated":"2025-04-23T04:07:19.270Z"},{"categories":[],"path":"LCSE-rev-prog/","tags":[{"name":"Original","slug":"Original","permalink":"https://notes.sshwy.name/tags/Original/"}],"text":"咳。鉴于我不想我的博客被 GFW 屏蔽，我会稍微注意一下措辞。\n背景大名鼎鼎的 Liquid 社，不知道的请自行了解。他们家的 Galgame（似乎）都是用 LC-Script Engine 做的（就我目前接触到的他们社的游戏而言）。\n前阵子搞到了一 L 社生肉资源，用了一整天研究了一下 VNR。但是它这个翻译延迟实在太高了，大概 2s 吧。这严重影响我推 gal 的效率。于是我有了一个主意：提取游戏的文本，然后机翻完之后再放回去！原因是在用 VNR 之后，发现如今的机器翻译其实做得不错（据说以前不太行），勉强能冲。\n但是网上的 GalGame 汉化基本就没有教程。一个原因是 Galgame 比较小众，Galgame 汉化更是小众中的小众。而且据说这几年来 Galgame 行业也不景气。不过，毕竟我都写出这博客来了，结果就不用说了。\n初期工作篇首先，当然是直接找这个游戏的汉化版，然而没有找到。\n那么就要想办法了解汉化的方法。于是我对着这个游戏的可执行文件lcsebody.exe搜了一通，发现这个游戏是 LC-Script Engine 制作的游戏的标志。但这个 Engine 显然是不开源的。\n不过 Github 的神通广大我是妹想到的，真的有一个 LCSELocalizationTools 的项目。这个项目得用 java 运行，作用是解密，并从 LC-Script Engine 打包的文件里解包出一个一个的小文件，比如游戏的脚本，CG 之类的。它也支持打包，也就是说你用这个工具解包后，对解包出来的文件做修改，然后再打包，它就会用你修改过的替换掉原本的，也就实现了你对游戏数据的修改。\n然而事情没有这么简单。它不 work。于是我提了个 Issue，然后就联系到了大佬 Charlie。这个大佬似乎做过 LC-Script Engine 的开发，这是我妹想到的。不错，找对人了。\n解析文本篇Charlie 告诉我，LC-Script Engine 主要是异或加密，而我这个游戏的 key 似乎和他测试的那个游戏的 key 不一样。因此改一改项目中的 key 就行了。\n就行了……\n然后我花了半天的时间，配好了 Kotlin 的开发环境。因为这个项目是 Kotlin 写的。是的，我还得学一波 Kotlin 操作。\n不过好在 Kotlin 与 Typescript 很像，除了那个闭包的特性，其他的都挺容易上手。最后，当然是成功了。这样，我就拿到了解包后的数据。鉴于目前的 DeepCreamPy 的去码效果 8 太行，反而容易降低冲的兴致，因此我没有对游戏 CG 做修改，将主要目标转为游戏脚本。\n所谓游戏脚本，是指包含了字幕以及选择题逻辑的文本文件。LC-Script Engine 的游戏脚本后缀为 SNX。不过这个 SNX 你用记事本打开，还是乱码。好在 Charlie 说，它的那个项目里有解析 SNX 的模块，但是没有写命令行接口。意思就是说我得自己写一个接口。\n为了这波，我只能，真的，去学 Kotlin 了……之前的学，你只需要知道 Kotlin 怎么定义变量，怎么注释，差不多就行了。这次……\n一波猛如虎的 Coding 之后，我终于理解了 Charlie 写的代码在干啥，然后写了一个接口，顺利地把 SNX 文件转换为 PO 文件。而 PO 文件，就是可以用记事本编辑的文件了。\n有一说一，这个 vscode 真香。当然得配个 vim 插件，不然还是差评。Kotlin 的闭包其实写得蛮爽的，甚至比 js 的箭头函数还简洁。\n之后我稍微操作了一下，去百度整了一个 API。别问我为什么百度。国内我只找到百度有免费的翻译。不是指网页版的，网页版的得写爬虫，网上也没有现成的。写了一个 Python 脚本，翻译 PO 文件的内容。然后在稍微润色一下。\n在做了一两个句子的翻译后，我把它打包回去，测试了一下，结果发现游戏的对应的这个场景里，没有显示任何文本！乱码都没有……\n鉴于 Charlie 是高三学长，时间比较紧张，所以我就，对着他写的模块 debug 了一下，真就发现了一个 bug。修复了一下，果然，有乱码了。\n其实很不错了，毕竟有总比没有好。\n逆向编程篇前面的，说实话都是小菜。没怎么卡进度。但是对于一个 OI 人 /Web 开发人，你要我做逆向编程，就比较离谱。\n乱码的问题，是因为游戏引擎的问题。我们之前修改的都是游戏的数据文件，游戏引擎（lcsebody.exe）是一根手指都没动的。Charlie 说，乱码问题的解决分两步： 因为 Galgame 默认你是用日本的系统运行的，因此游戏引擎的编码通常的日文的编码（比如 Shift_JIS）。你得把这个编码改成中文的编码（比如 GB2312）。\n光改编码还不过。游戏引擎通常还会干一件事情：检查你的字符值是否合法。因为对于一种编码方案而言，其字符编码的值域是一个区间。而 Shift_JIS 与 GB2312 的区间显然是不同的。所以你得找到这部分的逻辑判断代码，把它改成 GB2312 的逻辑判断代码。 于是我按照大佬的建议下载了 Ollydbg（OD）用于调试。我熟悉了一下这个软件的操作，然后就操作了一番。但这遇到了一个问题：我这个 Galgame 必须用转区工具打开。也就是说你得用另一个 exe 来启动lcsebody.exe。Ollydbg 支持两种调试方式： 用 Ollydbg 打开某个 exe。但这个方法我们行不通，因为 Ollydbg 不支持转区。\n用 Ollydbg 去附加在某个正在运行的进程上。这个方法似乎可行。但我只有在第一次附加的时候成功了。其他时候都会导致 Galgame 的进程莫名其妙就结束了。这我怎么调？ 我就卡这了。还好还好，只卡了我一天。\n在调试的过程中我发现，在看不懂汇编语言的情况下，你根本就不是在 Debug，你是在抽奖，跟买彩票一样，按照网上的博客去操作，但根本操作不了，因为两者的情况大不相同。\n因此我决定，先学汇编。\n学汇编我花了一些时间学了汇编的基础操作，再结合搜索引擎，终于是看懂了那些常见的指令的含义。\n你别看完一句话就说完了。你也可以试试。在不知道有没有用的情况下，去学一门语言。\n结果发现，还是有点用的。在学汇编的过程中我也在熟悉 OD 的操作。并一直在搜索“OD 无法附加”之类的词条。功夫不负有心人，在一位知乎大佬的点拨后，我死马当活马医，尝试了一些他的方法，没想到成功了！\n直到现在，我才是真正地，能开始做那两个步骤了。\n至于后面的步骤，在我熟悉了 OD 的操作后，就几乎比较顺利了。通过暴力查询的方式找到了两个地方，并且多亏我学了会儿汇编。不用反编译就能看懂汇编指令的逻辑，因此顺利完成了这部分的修改。\n来一个截图吧 虽然这个字体粗细有点怪，但总比日文可读多了。\n之后大佬也算好人帮到底，讲解了一下字体的修改，帮忙 Debug 了免 LE 启动的方法。最终效果如下： 有关技术部分的内容在下方，也给出了参考文章。仍有问题的可以评论交流。\n总结这次逆向编程的经历，算是给我打开了一个方向吧。对很多计算机系统方面的知识有了了解。逆向编程整东西，破其一点，就能领悟很多了。当然，其实最大的好处还是，冲！\n技术篇\n使用 LCSELocalizationTools，在咨询大佬后得知 LCSE 是异或加密。因此修改异或参数后能够解包 / 封包。\n使用其中配套的模块，实现 SNX 文件解析为 PO 文件。\nPython 调用百度翻译 API，然后 Poedit 手动校对翻译。\n翻译好后，封包回去，发现打开是乱码。得知需要修改 LCSE 引擎。\n如何附加lcsebody.exe：用 OD 把入口处的指令修改为 EB FE（死循环），然后转区启动。这时不会有游戏窗口出现（因为卡在入口了），但应该能找到lcsebody.exe的进程。然后用命令行启动 OD，带一个-p的参数，用 pid 来附加就行了（附加进去后记得先改回入口的指令再进行调试1）。\n要找到CreateFontIndirectA调用前的字符编码参数，方法是寻找0x80（Shift_JIS）的常量，将其改成0x86（GB2312）2。\nGalGame 一般回检验字符的编码是否在范围内。而不同的编码的范围是不同的，因此要修改这部分的逻辑。方法是寻找0xE0的常量，并对这部分的逻辑做修改。在了解汇编指令的含义后，其实不用反编译就可以理解这部分逻辑，并作出对应的修改3 4 5。\n将INIT.snx用 winHex 的 Shift JIS 编码打开，可以找到 MS ゴシック，把 MS 写成黑体即可。注意，你找 MS 的时候用 JIS 编码，编辑黑体的时候要改成 GBK 来写。虽然这样我似乎搞出了宋体？但至少字体不是那种一会儿粗一会儿细的了。\n似乎这是 2djgame 的资源，带了点私货。在游戏根目录加一个 2djgame.txt 的空文件，就可以免 LE 启动了。 附 汇编语言 学习日志mov 指令将某个地址（寄存器）的数据用用另一个（地址的）数据覆盖。\nMOV ax, 8\nMOV ax, bx\nMOV ax, [0]\nMOV [0], ax\nMOV ds, ax 其中 ds 是段寄存器。\n[x]是指向 ds:x 的内存单元，其对应的内存地址为 ds 左移 4 位加上 x。更准确地说，它表示一个偏移地址为 x 的内存单元。\n段寄存器不能直接用数据 MOV，这是 8086CPU 的硬件问题。\n在汇编源代码中，如果[]内是常量，就需要用ds:[]显示地表示指向的内存单元。 ADD（SUB） 指令将某个寄存器或者地址的值加上另一个数值。类似 C++ 中的+=。\nADD ax, 8\nADD ax, bx\nADD ax, [0]\nADD [0], ax ADD 不能直接操作段寄存器。\n加法溢出的进位会被舍弃。\nSUB 的用法和 ADD 是类似的。 JMP 指令CS:IP 指向的地址是 CPU 读取指令的地址。\n要修改 CS:IP，需要使用 JMP 指令。\nJMP 2AE3:3\n执行后 CS=2AE3H，IP=0003H。CPU 将从 2AE33H 处读取指令。\nJMP ax\n其含义等同 MOV IP, ax。\nPUSH &amp; POP 指令CPU 提供栈的机制。8086CPU 中有段寄存器 SS 和寄存器 SP，任意时刻，SS:SP 指向栈顶元素。\nPUSH ax SP = SP-2，然后将 ax 的内容写入 SS:SP。 POP ax 将 SS:SP 的内容写入 ax，然后 SP = SP+2。 有关段寄存器和寄存器的操作，在之前已经有所介绍，因此不再多说。\n[BX] &amp; [BX+idata] 指令[BX] 指代的是 ds:bx 的地址。相当于吧偏移量存到寄存器 bx 中。\n[BX+idata] 的偏移地址为 (BX)+idata。\n也可以写作 idata[BX]。可以理解为，idata 是一个静态偏移量，相当于静态数组头指针。而 BX 就是迭代器。\nLOOP 指令LOOP 指令与一个特定寄存器 cx 有关。\nLOOP sign\nCPU 执行到 LOOP 时有两部操作： cx = cx-1\n判断 cx 存储的值是否为 0，不为 0 就转到 sign 处执行程序（相当于执行JMP sign），否则继续向下执行。 sign代指一个内存单元的地址。\nDW &amp; DB 指令dw 指令可以定义一段数据，以字为单位（16 位）。\n相对地，db 则表示以字节为单位的数据（8 位）。\nDB &#39;unIX&#39;\n相当于\nDB 75H, 6EH, 49H, 58H\nAND &amp; OR 指令与 ADD 指令用法类似。含义就是对应的位运算。\nINC 指令INC ax\n把 ax 寄存器里的值 +1。\n[BX+SI] &amp; [BX+DI] &amp; [BX+SI+idata] &amp; [BX+DI+idata]SI 和 DI 是两个，不能当作 8 位寄存器的，16 位寄存器。\nMOV ax,[bx+si]\n等价于\nMOV ax,[bx][si]\n类似地，以下命令的效果是一样的\nMOV ax,[bx+200+si]\nMOV ax,[200+bx+si]\nMOV ax,200[bx][si]\nMOV ax,[bx].200[si]\nMOV ax,[bx][si].200\n寻址寄存器\n只有 BX、SI、DI 和 BP 可以用来寻址（放[]里）。\n在[]中，它们可以单独出现，或者以四种组合出现：BX+SI、BX+DI、BP+SI、BP+DI。其中可以加常量。\n在[]中使用 BP，且指令没有显式给出段地址，那么段地址默认取 SS。 1. http://blog.sina.com.cn/s/blog_41299a970102wjf2.html &#8617; 2. https://blog.csdn.net/madonghyu/article/details/90029001 &#8617; 3. https://blog.csdn.net/madonghyu/article/details/103572482 &#8617; 4. https://zh.wikipedia.org/wiki/GB_2312 &#8617; 5. https://zh.wikipedia.org/wiki/Shift_JIS &#8617;","title":"记一次 L 社 GalGame 汉化经历","updated":"2025-04-23T04:07:19.266Z"},{"categories":[],"path":"Math/Polynomial/Think-via-GF/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"},{"name":"EGF","slug":"EGF","permalink":"https://notes.sshwy.name/tags/EGF/"},{"name":"Generating-Function","slug":"Generating-Function","permalink":"https://notes.sshwy.name/tags/Generating-Function/"},{"name":"OGF","slug":"OGF","permalink":"https://notes.sshwy.name/tags/OGF/"},{"name":"Polynomial","slug":"Polynomial","permalink":"https://notes.sshwy.name/tags/Polynomial/"},{"name":"Combinatorial","slug":"Combinatorial","permalink":"https://notes.sshwy.name/tags/Combinatorial/"}],"text":"本文目前是笔记的形式，可能观点比较散。\n初衷是把生成函数的部分复习一下。\n首先要理解一件事：生成函数是理解问题的方式，而多项式则是计算的方法。因此即使经常有“生成函数与多项式”之类的博客标题，但不能把生成函数和多项式混为一谈。\n事实上，在把问题转化为生成函数后，剩下的式子转化与代码实现都属于多项式的范畴。\n强烈建议在做生成函数题的时候，推完式子时，先手算一下样例看对不对，对了再写代码。\n另外，本文的所有例题均带有 生成函数 多项式 EGF 标签。\nEGF 与 OGFOGF 的定义：F(x)=\\sum a_ix^i，表示序列 a_i 的生成函数。\nEGF 的定义：\\hat{F}(x)=\\sum a_i\\frac{x^i}{i!}，表示序列 a_i 的指数生成函数。\n再次强调，生成函数只是理解问题的方式。因此你可能发现，EGF 的实现和 OGF 的实现是差不多的——只不过多乘一个阶乘而已。你甚至可以认为，EGF 是 \\frac{a_i}{i!} 的 OGF。这是理解方式的转变。然而实际上，生成函数也就只是一种理解问题的技巧。\nOGF 和 EGF 的加法，都是对应项系数相加。\nOGF 的乘法：a_ix^i\\times b_jx^j=a_ib_jx^{i+j}。表达的是卷积的运算。\nEGF 的乘法：a_i\\frac{x_i}{i!}\\times b_j\\frac{x^j}{j!}=a_ib_j\\binom{i+j}{i}\\frac{x^{i+j}}{(i+j)!}。表达的是带组合系数的卷积运算。\nOGF 的多个函数的乘法，表达的是类似多个背包合并的运算。而 EGF 的多个函数的乘法，表达的是类似多个序列合并（同一个序列里的相对顺序不计贡献）的运算（多重组合数）。两者的区别是，背包中的物品是不考虑顺序的，而序列则是要考虑顺序的。\n因此在理解问题的时候，可以先转化为序列问题或者背包问题，再用生成函数来理解。\nPKUWC2018 猎人杀\n有 n 猎人。每个猎人只有一个固定的技能：死亡后必须开一枪，且被射中的人也会死亡。\n假设当前活着的人有 [i_1,\\cdots,i_m]，那么有 \\frac{w_{i_k}}{\\sum_{j=1}^m w_{i_j}} 的概率向猎人 i_k 开枪。\n第一枪由你打，目标选择方法和猎人一样。由于开枪导致的连锁反应，所有猎人最终都会死亡。求 1 号猎人最后一个死的概率。\nw_i&gt;0,1\\le \\sum w_i\\le 10^5。 分治 NTT\n生成函数部分按照原题意，每杀一个人，概率空间会发生变化。这样就没法做了。\n如果我们允许向死人开枪呢？\n向死人开枪，相当于浪费一回合。但这无关紧要。因为我们要求的答案和回合数无关。我们只关心一号猎人最后一个死的概率。\n这样的话概率空间就一样了。那么我们的问题就可以转化为一个序列问题： 每次有 p_i=\\frac{w_i}{\\sum_{j=1}^n w_j} 的概率在序列的末位加入 i。求： 最后一个数是 1，且 1 只出现了这一次，\n2,\\cdots,n 都在序列中出现过 的序列出现的概率。 （这个序列的长度是不固定的，可能无限长）\n如果我们按照一个一个在序列末尾加数的方式理解问题，那么要求 2,\\cdots,n 都在序列中出现过就比较难处理。因此我们考虑另一个理解方式——n 个序列的合并。 假设你有 n 个序列，第 i 个序列是 c_i 个 i（c_i&gt;0）。特殊地，c_1=1。你要把他们合并成一个序列，使得 1 出现在最后一个位置，求方案数？ 容易发现这个问题和上面的问题是等价的。我们知道概率乘方案数等于这些方案的概率。因此我们求出每个序列的出现概率——即，选出 c_i 个 i 的概率，那么乘起来再乘上方案数，就是这些方案的概率。而方案数就是一个简单的多重组合数。\n这是从序列合并的角度理解，那么接下来我们将其转化为生成函数的理解。\n对于 2\\le j\\le n，由于我们可以选择任意个数的 i，因此他们的生成函数应该是无穷级数的 EGF。不妨设 \\hat{f_j}(x)=\\sum_{i\\ge 1}\\frac{(p_jx)^i}{i!}含义是，选择 i 个 j 的概率是 p_j^i，由于我们至少选一个，因此 i\\ge 1。\n对于 i=1，我们只要求 1 出现一次且在末尾，因此它不会影响方案数，只需要乘一次 p_1 的概率即可。因此我们可以不用求它的生成函数。也可以理解为，i=1 的生成函数是一个常数 p_1。\n那么序列的生成函数（EGF）就是 \\hat{F}(x)=p_1\\prod_{j=2}^n\\hat{f_j}(x)其中 [x^i]\\hat{F}(x) 表示长度为 i 的序列出现的概率。那么我们要求的就是 \\hat{F}(x) 的EGF 系数的和。\n注意，对于 EGF \\hat{F}(x)=\\sum a_i\\frac{x^i}{i!}=\\sum b_ix^i，我们说的EGF 系数是指 a_i，即 b_i\\cdot i!，系数才是指 b_i。\n多项式部分接下来就是多项式转化的部分了。\n首先 \\hat{f_j}=e^{p_jx}-1，因此 \\hat{F}(x)=p_1 \\prod_{j=2}^n(e^{p_jx}-1)首先我们知道，e^{px} 的 EGF 系数和就是等比数列求和，可以化为封闭形式 \\frac{1}{1-p}。可惜 e^{px} 与 e^{qx} 的乘积的 EGF 系数和并不是 \\frac{1}{1-p}\\cdot \\frac{1}{1-q}，因此我们只能想办法求出对与每个 t，e^{tx} 的系数值（出现次数）。因此接下来的问题就是一个类似背包的计算。然而这不能直接容斥 \\frac{1}{1-\\sum p}。注意到 \\sum p_i\\le 10^5，因此不妨设 g_i 表示 \\frac{1}{1-i} 出现的次数（带容斥系数），容易发现 g_i 的 OGF 是 \\prod_{j=2}^n(x^{p_j}-1)那么直接使用分治 + 多项式乘法计算即可。\n可以先把 p_j 当作 w_j 来算，最后再全部除以 \\prod w_i 即可。\n时间复杂度 O(n\\log_2^2n)。\n代码\nUNR3 百鸽笼\n有 n 个数 a_i。设 \\sum_{i=1}^na_i=m。\n接下来进行 m-1 次操作：每次在 &gt;0 的数中等概率随机选择一个数 a_x，然后把 a_x 减 1。\n最后一定会剩下一个 1。现在问对于 1\\le i\\le n，在操作后 a_i=1 的概率。\n1\\le a_i\\le 30,n\\le 30。 插板法 无穷级数转封闭形式\n生成函数部分不妨考虑 i=1 时 a_i=1 的概率。\n不妨加一次操作。因为选择最后一个空的笼子的概率是 1。\n仍然考虑使用生成函数的方式理解。首先，根据类似的思路，我们可以把操作变成，每次在所有数中等概率选择。这样的话序列的长度就可能是无限长的，它需要满足的条件是： 对于 2\\le i\\le n，i 的出现次数 \\ge a_i。\n1 在序列中出现了恰好 a_1 次，且最后一个数是 1。 这里可能会有一个小疑问：为什么是出现 a_1 次而不是 a_1-1 次？其实如果是出现 a_1-1 次的话，那么就没有最后一个数是 1 的限制。我们相当于删掉了第 1 列里的一个格子，那么这和原问题就是不等价的。\n仍然是考虑每个数的生成函数。对于 2\\le j\\le n： \\hat{f_j}(x)=\\sum_{i\\ge a_j}\\frac{(\\frac{1}{n}x)^i}{i!}特殊地，对于 i=1，我们考虑除了最后一个 1 之外的 1： \\hat{f_1}(x)= \\frac{(\\frac{1}{n}x)^{a_1-1}}{(a_1-1)!}那么整个序列的生成函数就是 \\hat{F}(x)=\\frac{1}{n}\\prod_{i=1}^n\\hat{f_i}(x)我们要求的仍是系数和。\n多项式部分首先，对于 2\\le j\\le n： \\hat{f_j}(x)=\\sum_{i\\ge a_j}\\frac{(\\frac{1}{n}x)^i}{i!}=e^{\\frac{1}{n}x}-\\sum_{i=0}^{a_j-1}\\frac{(\\frac{1}{n}x)^i}{i!}为了方便表示，设 \\hat{S}(j)=\\sum_{i=0}^j\\frac{(\\frac{1}{n}x)^i}{i!}，那么就可以得到 \\hat{f_j}(x)=e^{\\frac{1}{n}x}-\\hat{S}(a_j-1)。因此整个序列的生成函数可以化为 \\hat{F}(x)=\\frac{1}{n} \\frac{(\\frac{1}{n}x)^{a_1-1}}{(a_1-1)!}\n\\prod_{j=2}^n(e^{\\frac{1}{n}x}-\\hat{S}(a_j-1))如果我们把除了 e 之外的部分展开，那么可以得到形如 \\sum_{m,t} e^{\\frac{m}{n}x}c_{m,t}\\frac{x^t}{t!} 的一个多项式（二维数组）。要计算它的 EGF 系数和，我们可以对每一项 e^{\\frac{m}{n}x}c_{m,t}\\frac{x^t}{t!} 分别计算 EGF 系数和再相加。那么对这个单项式展开 e 会得到 c_{m,t}\\sum_{i\\ge 0}\\left(\\frac{m}{n}\\right)^i\\binom{i+t}{i}\\frac{x^{i+t}}{(i+t)!}它的 EGF 系数和就是 c_{m,t}\\sum_{i\\ge 0}\\left(\\frac{m}{n}\\right)^i\\binom{i+t}{i}这里要补充一个知识。我们知道等比数列的封闭形式是 \\sum_{i\\ge0} x^i=\\frac{1}{1-x}。那么考虑 \\frac{1}{(1-x)^t}。它的展开形式是 (\\sum_{i\\ge 0}x^i)^t，第 [x^i] 项的系数实际上是把 i 分成 t 个非负变量的方案数，也就是插板法 \\binom{i+t-1}{i}。因此 \\frac{1}{(1-x)^t}=\\sum_{i\\ge 0}x^i\\binom{i+t-1}{i}。\n应用这个补充的知识，我们可以得到上式的封闭形式为 c_{m,t}\\frac{1}{(1-\\frac{m}{n})^{t+1}}=c_{m,t}\\left(\\frac{n}{n-m}\\right)^{t+1}。注意，UOJ 的官方题解中得到的系数是带了一个 t! 的，因为它算的是 OGF 系数，不是 EGF 系数。还是那句话，两者只是理解方式的不同，代码实现是相似的。\n得出封闭形式那么就容易计算了。\n最后，考虑到我们要计算每个 i 的概率，那么我们可以先把所有的 (e^{\\frac{1}{n}x}-\\hat{S}(a_j-1)) 乘起来。然后每次除掉 i 对应的 EGF，再求答案即可。\n时间复杂度 O(n^6)（a_i 和 n 同阶）。\n事实上，生成函数做法和容斥的做法，代码几乎一样。\n代码\n附 UNR#3 的题解链接：\nUNR #3 day1\nUNR #3 day2\nUR19 通用测评号\n有 n 个变量 x_i，初值为 0。给出两个数 a,b（a&gt;b）。每次会在 &lt;a 的变量中等概率随机选一个加 1，直到所有变量都 \\ge b。问操作完后 =a 的变量的个数的期望。\n1\\le n\\le 250,1\\le b&lt;a\\le 250。 递推 微分方程\n生成函数部分n 个变量之间是等价的。因此我们可以计算操作完之后 x_1=a 的概率，然后乘 n 就是答案。\n仍然考虑把 &lt;a 的条件去掉。每次在所有变量中选一个加 1，直到所有变量 \\ge b。那么我们要求的就是 x_1\\ge a 的概率，不过我们还要求 x_2,\\cdots,x_n 中至少出现一个 b（因为你最后一次操作一定是把某个变量从 b-1 变成 b），而如果有多个 b 的话，你最后一次操作在什么位置，也要计入方案中。这就比较难计数。\n不妨考虑另一种理解方式。仍然要把 &lt;a 的条件去掉。但我们可以理解为：让 x_1=a 的这次操作会产生 1 的贡献。其他时候都没有贡献。问贡献的期望。\n在什么时候会产生贡献？首先你要选出 a 个 x_1，且当前选的这一次（操作序列的最后一个变量）是 x_1。其次 x_2,\\cdots,x_n 中至少有一个变量 &lt;b。这样理解的好处是，我们不用考虑最后一次操作的方案数（因为操作仍没有结束），只用考虑生成这类序列的方案数。那么就可以使用生成函数了。\n那么 x_1 的 EGF 是 \\frac{1}{n}\\frac{(\\frac{1}{n}x)^{a-1}}{(a-1)!}。对于 x_j（2\\le j\\le n）的 EGF，我们可以把至少一个变量 &lt;b 容斥为 1 减去所有变量 \\ge b 的概率。那么 x_j\\ge b 的概率的 EGF 是 \\hat{f}(x)=\\sum_{i\\ge b}\\frac{(\\frac{1}{n}x)^i}{i!}。因此我们得到了整个序列的生成函数： \\hat{F}(x)=\\frac{1}{n}\\frac{(\\frac{1}{n}x)^{a-1}}{(a-1)!}\\left(\n\\left(e^{\\frac{1}{n}x}\\right)^{n-1}-\\hat{f}(x)^{n-1}\\right)多项式部分考虑转化： \\hat{F}(x)=\\frac{1}{n}\\frac{(\\frac{1}{n}x)^{a-1}}{(a-1)!}\\left(\ne^{\\frac{n-1}{n}x}-\n\\left(e^{\\frac{1}{n}x}-\\sum_{i=0}^{b-1}\\frac{(\\frac{1}{n}x)^i}{i!}\\right)^{n-1}\n\\right)我们要计算的仍是 \\hat{F}(x) 的 EGF 系数和。仍然考虑求出类似 \\sum e^{\\frac{m}{n}x}c_{m,t}\\frac{x^t}{t!} 的形式。\n为了方便表示，设 v=\\frac{1}{n}x,u=e^{v}。我们先求出关于 v 的生成函数，就可以快速转化为关于 x 的生成函数。\n那么换元之后，我们得到 \\hat{F}(v)=\\frac{1}{n}\\frac{v^{a-1}}{(a-1)!}\\left(\nu^{n-1}-\\left(u-\\sum_{i=0}^{b-1}\\frac{v^i}{i!}\\right)^{n-1}\\right)不妨设 \\hat{S}=\\sum_{i=0}^{b-1}\\frac{v^i}{i!}，然后把后面的式子二项式展开： \\begin{aligned}\n\\hat{F}(v) &=\\frac{1}{n}\\frac{v^{a-1}}{(a-1)!}\\left(u^{n-1}-\n\\sum_{j=0}^{n-1}\\binom{n-1}{j}(-1)^j\\hat{S}^ju^{n-1-j}\n\\right)\\\\ &=-\\frac{1}{n}\\frac{v^{a-1}}{(a-1)!}\n\\sum_{j=1}^{n-1}\\binom{n-1}{j}(-1)^j\\hat{S}^ju^{n-1-j}\n\\end{aligned}到这里我们已经可以直接计算了。我们可以 O(n^2b\\log_2(nb)) 计算 \\hat{S}^1,\\cdots,\\hat{S}^{n-1}。然后把他们加起来就能得到 c_{m,t} 了。但我们仍然可以继续优化。\n首先，可以发现 \\hat{S}'=\\hat{S}-\\frac{v^{b-1}}{(b-1)!}。因此 \\begin{aligned}\n(\\hat{S}^j)'\n&=j\\hat{S}'\\hat{S}^{j-1} \\\\\n&=j\\left( \\hat{S}-\\frac{v^{b-1}}{(b-1)!}\\right)\\hat{S}^{j-1} \\\\\n&=j\\left(\\hat{S}^j-\\frac{v^{b-1}}{(b-1)!}\\hat{S}^{j-1}\\right) \\\\\n\\end{aligned}不妨设 \\hat{S}^j=\\sum p_i\\frac{v^i}{i!}，\\frac{v^{b-1}}{(b-1)!}\\hat{S}^{j-1}=\\sum q_i\\frac{v^i}{i!}。那么上式就可以表示为 p_{i+1}\\frac{v^{i}}{i!}=j\\left(p_i\\frac{v^i}{i!}-q_{i}\\frac{v^i}{i!}\\right)即 p_{i+1}=j(p_i-q_i)。\n转 OGF 系数就是 p'_{i+1}(i+1)!=j(p'_ii!-q'_ii!)，即 p'_{i+1}=\\frac{j(p'_i-q'_i)}{i+1}。\n这样就可以递推求 \\hat{S}^j 了，时间复杂度 O(n^2b)。\n代码\nEGF 转 OGF考虑 \\hat{F}(x)=\\sum_{i\\ge 0}a_i\\frac{x^i}{i!}，我们要将其转为 F(x)=\\sum_{i\\ge 0}a_i。\n对于长度有限的生成函数，我们可以直接乘阶乘。\n对于一些无穷级数，则需要做代数变换。例如 \\hat{F}(x)=e^{ax}。它的展开形式为 \\hat{F}(x)=\\sum_{i\\ge 0}\\frac{(ax)^i}{i!}。我们要将它转为 F(x)=\\sum_{i\\ge 0}(ax)^i=\\frac{1}{1-ax}，因此我们说 e^{ax} 的EGF 转 OGF为 \\frac{1}{1-ax}。\n接下来的部分题目会用到这一技巧。\n还是那句话。这只是一种理解方式的转变。上文的 EGF 系数和，也可以使用 EGF 转 OGF 理解为，\\hat{F} 转为 F 后求 F(1)。\nZJOI2019 开关\n你有 n 个开关，初始时全为 0。每次你会以 \\frac{p_i}{\\sum_{j=1}^n p_j} 的概率按动第 i 个开关。给出一个状态 s（01 串），问期望按多少次才能第一次按到这个状态。\nn\\le 100,\\sum p_i\\le 5\\times 10^4。 EGF 转 OGF 导数 概率生成函数 期望\n生成函数部分为了避免歧义，我们用 a_i 来表示题目中的 \\frac{p_i}{\\sum_{j=1}^n p_j}。相信在做过之前的若干题目后，大家对 EGF 都有了一定的理解。因此接下来的描述就不会像之前那么详细了。\n我们要求的是第一次按出 s 的期望次数，这里有一个经典的套路。我们求出按 i 次后第一次到达 s 的概率，记为 h_i。那么它的 OGF 就是 H(x)=\\sum_{i\\ge 0}h_i x^i。则期望就是 \\sum_{i\\ge 0}h_i\\cdot i=H'(1)。\n那么如何求出 H？“第一次到达 s”这个条件比较烦。考虑构造生成函数方程：到达 s 的概率 = 第一次到达 s 后，经过若干次操作（可能是 0 次）又到达 s 的概率。\n到达 s 的概率可以用 EGF 表示。要到达 s，则某些开关要按奇数次，有些要按偶数次。那么这两种的 EGF 分别是 \\frac{e^x-e^{-x}}{2} 和 \\frac{e^x+e^{-x}}{2}。因此容易得到 \\hat{F}(x)=\\prod_{i=1}^n \\frac{e^{a_ix}+(-1)^{s_i}e^{-a_ix}}{2}第一次到达 s 后又到达 s，相当于我先到达 s。然后经过若干次操作后回到 s。因此我们再考虑求出一个 EGF 表示，回到原状态的概率（即，所有开关都按偶数次）： \\hat{G}(x)=\\prod_{i=1}^n\\frac{e^{a_ix}+e^{-a_ix}}{2}那么我们 EGF 转 OGF，设 \\hat{F} 和 \\hat{G} 的 OGF 分别为 F,G。那么我们可以得到 HG=F。即 H=\\frac{F}{G}。\n多项式部分根据简单的函数求导法则可以得知 H'=\\frac{F'G-FG'}{G^2}。那么 H'(1)=\\frac{F'(1)G(1)-F(1)G'(1)}{G^2(1)}。于是我们想办法计算 F,F',G,G' 的系数和即可。\n我们仍从 EGF 入手。以 F,F' 为例。\n首先，\\hat{F}(x) 可以表示为 \\sum_{j}f_je^{\\frac{j}{m}x} 的形式（注意，这里是没有 \\frac{x^i}{i!} 的），其中 m=\\sum_{i=1}^n p_i。那么使用 EGF 转 OGF 就可以得到 F(x)=\\sum_j f_j \\cdot \\frac{m}{m-jx} 那么它的系数和就是 F(1)。不过有一个小问题，如果 j=m，那么 m -mx 做分母的项当 x=1 时就没有意义了。\n这也好办。我们有两种思路： 在 H=\\frac{F}{G} 的分子分母同乘 (1-x)；\n在 H'=\\frac{F'G-FG'}{G^2} 的分子分母同乘 (1-x)^2（把 F,F',G,G' 都乘一个 (1-x)）。 第二种思路不大可行。因为 F'(x) =\\sum_j f_j \\cdot\n\\frac{m^2}{\\left(m-jx\\right)^2}\n\\cdot \\frac{j}{m}只乘一个 (1-x) 不足以解决问题。因此我们考虑第一种思路。\n设 \\dot F(x)=F(x)(1-x)，\\dot G(x)=G(x)(1-x)。那么首先 \\dot F(x)=F(x)=\\sum_j f_j \\cdot \\frac{m(1-x)}{m-jx}，且 \\dot F(1)=f_m。然后使用简单的求导法则得到 \\dot F'(x)=\\sum_j f_j \\frac{m(j-m)}{(m-jx)^2}那么 \\dot F'(1)=\\sum_{j\\ne m}f_j\\frac{m}{j-m}。\n\\dot G 和 \\dot G' 同理。\n综上所述，我们只需要求出 \\hat{F} 的 \\sum_{j}f_je^{\\frac{j}{m}x} 形式即可，这个可以 O(nm) 背包计算。\\hat{G} 同理。时间复杂度 O(nm)。当然可以分治 +NTT 优化。\n事实上，在实现的时候，连最开头的 \\frac{1}{2} 那个部分都可以不用除了（分子分母同乘 2^n）。\n代码\n喂鸽子\n有 n 个变量 x_i，初值为 0。每次等概率随机选择一个变量加 1，直到所有变量都 \\ge k。问期望的操作次数。\nn\\le 50,k\\le 1000。 EGF 转 OGF\n由于这题和通用评测号相似，因此也不会详细讲述。\n生成函数部分不妨钦定 1 是最后一个变成 k 的，最后把答案乘 n 即可。那么可以得到关于操作次数（减 1）的概率的 EGF： \\hat{F}(x)=\\frac{1}{n}\\frac{(\\frac{1}{n}x)^{k-1}}{(k-1)!}\\prod_{j=2}^n\\left(\\sum_{i\\ge k}\\frac{(\\frac{1}{n}x)^i}{i!} \\right)设 F 是 \\hat{F} EGF 转 OGF 后的生成函数。\n那么关于操作次数的概率的 OGF 是 \\dot F=F(x)\\cdot x。因此我们要求的就是 \\dot F'(1)。\n多项式部分众所周知 \\dot F'(x)=F'(x)\\cdot x+F(x)。因此 \\dot F'(1)=F'(1)+F(1)。\n接下来考虑变换 EGF。首先 \\hat{F}(x)=\\frac{1}{n}\\frac{(\\frac{1}{n}x)^{k-1}}{(k-1)!}\n\\left(e^{\\frac{1}{n}x}-\\sum_{i=0}^{k-1}\\frac{(\\frac{1}{n}x)^i}{i!} \\right)^{n-1}不妨设 \\hat{S}=\\sum_{i=0}^{k-1}\\frac{(\\frac{1}{n}x)^i}{i!}，那么 \\begin{aligned}\n\\hat{F}(x) &=\\frac{1}{n}\\frac{(\\frac{1}{n}x)^{k-1}}{(k-1)!}\n\\left(e^{\\frac{1}{n}x}-\\hat{S} \\right)^{n-1}\\\\ &=\\frac{1}{n}\\frac{(\\frac{1}{n}x)^{k-1}}{(k-1)!}\n\\sum_{j=0}^{n-1}\\binom{n-1}{j}(-1)^j\\hat{S}^je^{\\frac{n-1-j}{n}x}\n\\end{aligned}可以利用相同的方式 O(n^2k) 递推求出 \\hat{S}^j。然后我们可以把 \\hat{F}(x) 表示为 \\sum e^{\\frac{m}{n}x}c_{m,t}\\frac{x^t}{t!} 的形式（0\\le m&lt;n）。我们要求 F(x)，那么我们把每一项 e^{\\frac{m}{n}x}c_{m,t}\\frac{x^t}{t!} 分别 EGF 转 OGF，然后相加即可。\n把 e^{\\frac{m}{n}x}c_{m,t}\\frac{x^t}{t!} 展开得到 c_{m,t}\\sum_{i\\ge 0}\\binom{i+t}{i}(\\frac{m}{n})^i\\frac{x^{i+t}}{(i+t)!}。\nEGF 转 OGF 得到 c_{m,t}\\sum_{i\\ge 0}\\binom{i+t}{i}(\\frac{m}{n})^ix^{i+t}，转化为封闭形式是 c_{m,t}x^t(\\frac{n}{n-mx})^{t+1}。\n因此 F(x)=\\sum c_{m,t}x^t(\\frac{n}{n-mx})^{t+1}。则通过简单的导数法则再加一些代数变换得知 F'(x)=\\sum c_{m,t}n^{t+1}\n\\frac{ntx^{t-1}+mx^t}{(n-mx)^{t+2}}由于 m&lt;n，所以不会出现分母为 0 的情况。直接计算 F'(1) 和 F(1) 即可。\n代码","title":"生成函数回炉重造","updated":"2025-04-23T04:07:19.270Z"},{"categories":[],"path":"Data-Structure/Long-Path-Decomposition/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"重链剖分重链剖分（heavy path decomposition）1时，每个内部结点都会选择一个儿子做为自己链上的儿子，我们称为继承儿子（重儿子）。如果一个结点没有被继承，那么它就是一个链顶结点。一棵树剖分过后链的个数是 \\Theta(Leaf) 的，其中 Leaf 表示叶子结点的个数。\n按照树剖后的顺序先遍历继承儿子，然后遍历其他儿子，那么每条链上的结点的 DFS 序（DFS order）是连续的。这样可以用一个指针数组来模拟二维数组，于是就可以方便地进行一些 DP 转移。\n高度设 h(u) 表示 u 的高度，则 h(u)=\\max_{v\\in Son(u)}h(v)+1关于高度的性质：u 所在的链长度至少为 h(u)。\n注意区分深度：dep(u)=dep(F_u)+1。\n长链剖分（long path decomposition）指将高度最高的儿子结点作为继承儿子的一种剖分。\n形式化地，长链剖分中每个内部结点选择的是其儿子中高度最大的点作为继承结点，设其为 R_u。\n对于子树合并类的信息，在 DFS 的过程中对于每个结点 u，如果 结点 u 维护的信息量是 O(h(u)) 的。\nu 可 O(1) 继承 R_u 的信息。\n合并两个大小分别为 x, y 的信息的复杂度可以做到 \\min(x, y)。 那么我们可以利用长链剖分做 O(n) 离线计算每个结点的信息。具体方法是 u 继承 R_u 的信息，然后合并其他儿子的信息。复杂度可表示为 \\sum_{u\\in T} \\sum_{v\\in \\text{son}(u), v\\ne R_u} h(v)h(v) 可以理解为是 v 的长链之一。由于 v\\ne R_u，因此 v 本身是轻儿子，也就是说 v 是链顶。因此上述和式本质上就是所有树链的长度和，显然是 O(n) 的。\nk 级祖先\n给一棵 n 度有根树，q 次询问点 x 的 k 级祖先。 这题可以容易地 O(n)-O(n)、O(n\\log_2n)-O(\\log_2n)、O(n\\sqrt{n})-O(\\sqrt{n}) 来做。考虑长链剖分。\n首先我们倍增求出 f(u,j) 表示 u 的 2^j 级祖先。另外，对于每个链顶结点u，我们预处理出 u 的前 h(u) 级祖先和 u 这条链上的结点序列。\n则我们先求出一个最大的 j 使得 2^j\\le k。设 u'=f(u,j),k'=k-2^j，那么我们要求的就是 u' 的 k' 级祖先。\n由于 h(u')\\ge 2^j&gt;k'，因此 u' 的 k' 级祖先要么在 u' 所在的链上，要么在 u' 所在链的链顶结点的祖先序列上。两者都可以 O(1) 查询。因此分类讨论一下即可 O(1) 查询 k 级祖先。\n时间复杂度 O(n\\log_2n)-O(1)。\n代码\nCookies\n有根树。设 d(u) 表示一个序列，d(u,j) 表示在 u 的子树中与 u 距离为 j 的点的个数。对于每个 u 询问 d(u) 中最大值出现第一次的下标。 这题显然可以启发式合并。我们考虑长链剖分。\n容易发现 d(u) 的长度为 h(u)。考虑 d(u) 继承自 d(R_u)。则显然有 d(u,i+1)\\gets d(R_u,i)\\\\\nd(u,0)\\gets 1然后我们遍历 u 的非继承儿子 v，把这些儿子的序列贡献到 d(u) 上： d(u,i+1)\\gets d(v,i)这样就求出了 d(u)。然后在贡献和继承的时候顺便更新最大值即可，这样复杂度就是遍历非 R_u 之外的结点的复杂度，因此总复杂度 O(n)。使用 deque 实现，支持在前端插入一个数和随机访问内存，实现起来方便。（只要不遍历长链，复杂度就是对的）\n模板，放出核心代码\ndeque&lt;int> *d[N];\nlong long ans; int dep[N],hgh[N];\nint a[N],b[N];\nvoid dfs1(int u,int p)&#123; dep[u]=dep[p]+1; hgh[u]=1; FORe(i,u,v)if(v!=p)dfs1(v,u),hgh[u]=max(hgh[u],hgh[v]+1);\n&#125;\nvoid dfs2(int u,int p)&#123; int mx=0,son=-1; FORe(i,u,v)if(v!=p&amp;&amp;hgh[v]>mx)mx=hgh[v],son=v; if(son==-1)&#123; d[u]=new deque&lt;int>; d[u]->pb(1); a[u]=0,b[u]=1; return; &#125; dfs2(son,u); FORe(i,u,v)if(v!=p&amp;&amp;v!=son)dfs2(v,u); // 继承 son d[u]=d[son]; d[u]->push_front(1); a[u]=0,b[u]=1; if(b[son]>b[u])b[u]=b[son],a[u]=a[son]+1; else if(b[son]==b[u])a[u]=min(a[u],a[son]+1); // 合并其他儿子的答案 FORe(i,u,v)&#123; if(v==p||v==son)continue; int lim=(int)d[v]->size()-1; int mx2=0,ans=-1; FOR(i,0,lim)&#123; (*d[u])[i+1]+=(*d[v])[i]; if((*d[u])[i+1]>mx2)mx2=(*d[u])[i+1],ans=i+1; &#125; if(mx2>b[u])b[u]=mx2,a[u]=ans; else if(mx2==b[u])a[u]=min(a[u],ans); delete(d[v]); &#125;\n&#125;\n完整代码\n谈笑风生考虑长链剖分。设 f(u,i) 表示子树 u 内与 u 距离为 i 的结点的子树大小减 1 的和： f(u,i)=\\sum_{v\\in T_u,dep(u)+i=dep(v)}S(v)-1则分两种情况讨论： b 是 a 的祖先，则方案数为 \\min(dep(a)-1,k)(S(a)-1)；\na 是 b 的祖先，则方案数为 \\sum_{i=1}^{\\min(k,h(a)-1)}f(u,i)。 在继承的时候 f(u,i+1)\\gets f(R_u,i)\\\\\nf(u,0)\\gets S(u)-1在贡献的时候 f(u,i+1)\\gets f(v,i)考虑到我们询问的时候是一个区间和的形式，因此把 f(u) 做后缀和处理即可。这样可以 O(1) 计算询问，也可以 O(1) 转移，复杂度 O(n)。\n这是指针版的写法，感觉更好用：\nlong long BIN[N],lb;\nlong long *f[N]; long long ans[N];\nint hgh[N],dep[N],sz[N];\nvector&lt; pair&lt;int,int> > qry[N]; void dfs1(int u,int p)&#123; hgh[u]=1,dep[u]=dep[p]+1,sz[u]=1; FORe(i,u,v)if(v!=p)dfs1(v,u),sz[u]+=sz[v],hgh[u]=max(hgh[u],hgh[v]+1);\n&#125;\nvoid dfs2(int u,int p)&#123; ++lb; int mx=0,son=-1; FORe(i,u,v)if(v!=p&amp;&amp;hgh[v]>mx)mx=hgh[v],son=v; if(son==-1)&#123; f[u]=BIN+lb;// 指针赋值 f[u][0]=sz[u]-1; return; &#125; dfs2(son,u); FORe(i,u,v)if(v!=p&amp;&amp;v!=son)dfs2(v,u); f[u]=f[son]-1; f[u][0]=sz[u]-1+f[u][1];// 后缀和 FORe(i,u,v)&#123; if(v==p||v==son)continue; FOR(i,0,hgh[v]-1)f[u][i+1]+=f[v][i]; f[u][0]+=f[v][0];// 后缀和 &#125; // 处理询问 for(pii p:qry[u])&#123; int id=p.fi,k=p.se; ans[id]+=1ll*min(dep[u]-1,k)*(sz[u]-1); ans[id]+=f[u][1]-(k+1>=hgh[u]?0:f[u][k+1]); &#125;\n&#125;\n完整代码\n攻略把一个点拆成其权值长度的链。\n然后在新的树上长链剖分后选前 k 大的链即可。\n代码\nHOTEL 加强版\n一棵树，求三个互不相同的点并且两两距离相等的方案数。 记 f(u,i) 表示子树 u 中与 u 距离 i 的点的个数，g(u,i) 表示子树 u 中的二元组 (x,y) 的个数，满足 x,y 到其 LCA 的距离都为 d 且这个 LCA 到 u 的距离为 d-i。即距离差为 i 的二元组的个数。\n考虑继承 f(u,i)\\gets f(R_u,i-1)\\\\\nf(u,0)\\gets 1\\\\\ng(u,i)\\gets g(R_u,i+1)考虑贡献 f(u,i+1)\\gets f(v,i)\\\\\ng(u,i)\\gets g(v,i+1)\\\\\ng(u,i)\\gets f(u,i)f(v,i-1)这里的 f(u),g(u) 是指在合并完了 v 之前的子节点的 DP 值。\n考虑统计答案，我们可以在上述贡献的过程中统计： Ans\\gets f(u,i-1)g(u,i)\\\\\nAns\\gets f(v,i)g(u,i+1)\\\\在计算完 f(u),g(u) 之后，还有 Ans\\gets g(u,0)。\n注意这些转移的边界，以及他们的转移顺序。\n代码\n重建计划首先二分答案，则边权变成 w-mid，问题转化为是否存在一条长度在 [L,U] 的路径权值非负。\n如法炮制，设 f(u,i) 表示 u 的子树内以 u 为端点的长度为 i 的路径的权值最大值。\n继承 f(u,i)\\gets f(R_u,i)+w(R_u)-mid\\\\\nf(u,1)\\gets w(R_u)-mid贡献 f(u,i+1)\\gets f(v,i)+w(v)-mid\\\\\nf(u,1)\\gets w(v)-mid这里的转移是取 \\max。在合并的时候顺便检查是否存在 x,y 使得 f(u,x)+f(v,y)+w(v)-mid&gt;0，则我们枚举 y 的时候查询区间最大值即可。因此使用线段树维护上述转移，需要支持区间加、单点对某个数取 \\max、询问区间 \\max。\n时间复杂度 O(n\\log_2n)。\n代码 1. https://en.wikipedia.org/wiki/Heavy_path_decomposition &#8617;","title":"长链剖分学习笔记","updated":"2025-04-23T04:07:19.263Z"},{"categories":[],"path":"Math/Faulhaber/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"},{"name":"Stirling-Number","slug":"Stirling-Number","permalink":"https://notes.sshwy.name/tags/Stirling-Number/"}],"text":"开个小坑，介绍自然数幂和（等幂求和）问题以及相关算法。\n等幂求和问题等幂求和问题（Faulhaber’s formula）1 指计算多项式 f_k(n) = \\sum_{i=0}^n i^k = 0^k+1^k+2^k+\\cdots +n^k的值。\n对于 k 较小的情况： 当 k=1 时有 f_1(n) = \\frac{n(n+1)}{2}。\n当 k=2 时有 f_2(n) = \\frac{n(n+1)(2n+1)}{6}。 插值法使用插值法计算的主要方式是，先利用多项式的 O(k) 个点值得出该多项式的表示，然后用此表示来计算点值。\n拉格朗日插值法如果只是单点求值，那么可以直接利用拉格朗日多项式 \\sum_{i}y_i\\prod_{j\\ne i}\\frac{x-x_j}{x_i-x_j}来计算。单次求值的时间复杂度是 O(k^2)。\n如果取 x_i=i，那么在模意义下可以使用阶乘及其逆元来进一步优化，做到 O(k) 的时间计算点值。\n如果要得到 F_k 的系数表示，那么暴力模拟多项式展开的过程是 O(k^3) 的。\n使用缺一背包的方式分治计算可以做到 O(k^2\\log_2k)。\n差分法取 x_i = i （0\\le i\\le k+1）共 k+2 个点，然后将其差分。\n具体地，设 d_j(i) = d_{j-1}(i)-d_{j-1}(i-1)，j 表示差分的次数，d_0(i) = i。那么有 F_k(n) = \\sum_{i=0}^{k+1} \\binom{n}{i} d_i(i)这实际上是求出了 F_k(n) 的下降幂表示。利用斯特林数的变换： n^{\\underline{k}} = \\sum_{i = 0}^ks(k, i)(-1)^{k-i}n^i我们也可以在 O(k^2) 的时间内将其转化为常幂系数表示。\n代码\n二项式定理利用二项式定理也可以计算等幂求和，其主要思想是通过差分、裂项等方法构造等式，推导递推式。首先 (x+1)^k = \\sum_{i =0}^k\\binom{k}{i}x^i通过移项构造一个差分形式： (x+1)^k-x^k = \\sum_{i=0}^{k-1}\\binom{k}{i}x^i这样就能得到 \\begin{aligned}\nn^k &= \\sum_{i=0}^{n-1}(i+1)^k-i^k\\\\\n&= \\sum_{i=0}^{n-1}\\sum_{j=0}^{k-1}\\binom{k}{j}i^j\\\\\n&= \\sum_{j=0}^{k-1}\\binom{k}{j}F_j(n-1)\n\\end{aligned}然后我们再次移项得到 F_{k-1} 的递推式： F_{k-1}(n-1) = \\frac{n^k-\\sum_{j=0}^{k-2}\\binom{k}{j}F_j(n-1)}{k}所以整理一下得到 F_{k}(n) = \\frac{n^{k+1}-\\sum_{j=0}^{k-1}\\binom{k+1}{j}F_j(n)}{k+1}斯特林数使用斯特林数计算等幂求和的要点在于构造递归式。由下降幂转通常幂的公式： n^{\\underline{m}}=\\sum_{i=0}^m(-1)^{m-i}s(m,i)n^i移项得到 n^m=n^{\\underline{m}}-\\sum_{i=0}^{m-1}(-1)^{m-i}s(m,i)n^i所以我们把这个公式代入等幂求和公式得到 \\begin{aligned}\nF_k(n)&=\\sum_{i=1}^n\\left(i^{\\underline{k}} -\\sum_{j=0}^{k-1}(-1)^{k-j}s(k,j)i^j \\right)\\\\\n&=k!\\sum_{i=1}^n\\binom{i}{k}-\\sum_{j=0}^{k-1}(-1)^{k-j}s(k,j)F_j(n)\\\\\n&=k!\\binom{n+1}{k+1}-\\sum_{j=0}^{k-1}(-1)^{k-j}s(k,j)F_j(n)\n\\end{aligned}这样我们就可以递归求解了。\n伯努利数等幂求和也可以借助伯努利数2相关的知识计算。伯努利数序列并不具有直观含义，但其指数生成函数（EGF）为 \\hat{B}(x) = \\frac{x}{e^x-1} = \\sum_{i\\ge 0}B_i \\frac{x^i}{i!}为了推导等幂求和的系数表示，我们先介绍伯努利多项式的定义： \\beta_n(z)= \\sum_{i=0}^n\\binom{n}{i}B_iz^{n-i}伯努利多项式实际上是一个序列 \\beta_0(z), \\beta_1(z), \\cdots，这个序列的每一个元素都是个多项式。\n因此我们可以求出这个序列的指数生成函数（多项式序列的生成函数）： \\hat{\\mathbf{B}}_z(x) = \\sum_{i\\ge 0}\\beta_i(z) \\frac{x^i}{i!}把 z 写成下标是因为这个生成函数中 x 作为主要的占位符。接下来我们推导其封闭形式： \\begin{aligned}\n\\hat{\\mathbf{B}}_z(x) = & \\sum_{i\\ge 0}\\beta_i(z) \\frac{x^i}{i!}\\\\\n= & \\sum_{i\\ge 0} \\frac{x^i}{i!} \\sum_{j=0}^i\\binom{i}{j}B_jz^{i-j} \\\\\n= & \\sum_{i\\ge 0} \\sum_{j=0}^i \\frac{B_jx^j}{j!} \\frac{z^{i-j}x^{i-j}}{(i-j)!} \\\\\n= & \\frac{x}{e^x-1}e^{zx}\n\\end{aligned}接下来我们将其差分： \\hat{\\mathbf{B}}_{z+1}(x) - \\hat{\\mathbf{B}}_z(x) = \\frac{x}{e^x-1}e^{(z+1)x} - \\frac{x}{e^x-1}e^{zx} = xe^{zx}这对应的是序列 \\beta_i(z+1)-\\beta_i(z) 的 EGF。将其展开得到 xe^{zx} = \\sum_{i\\ge 0} \\frac{z^ix^{i+1}}{i!} = \\sum_{i\\ge 0} z^i(i+1) \\frac{x^{i+1}}{(i+1)!}因此我们得到 \\beta_{i+1}(z+1)-\\beta_{i+1}(z) = z^i(i+1)，即 z^i = \\frac{\\beta_{i+1}(z+1)-\\beta_{i+1}(z)}{i+1}我们将 z^i 表示为了差分的形式，因此我们可以裂项相消： \\begin{aligned}\n\\sum_{i=0}^n i^k &= \\frac{1}{k+1}\\sum_{i=0}^n \\beta_{k+1}(i+1)-\\beta_{k+1}(i)\\\\\n&= \\frac{\\beta_{k+1}(n+1) - \\beta_{k+1}(0)}{k+1} \\\\\n&= \\sum_{i=0}^{k+1}\\binom{k+1}{i}B_i(n+1)^{k+1-i} - B_{k+1} \\\\\n&= \\sum_{i=0}^{k}\\binom{k+1}{i}B_i(n+1)^{k+1-i}\n\\end{aligned}这样我们就直接得到了 F_k(n) 的系数表示。 1. https://en.wikipedia.org/wiki/Faulhaber%27s_formula &#8617; 2. https://zh.wikipedia.org/zh-cn/%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%95%B0 &#8617;","title":"自然数幂和小结","updated":"2025-04-23T04:07:19.268Z"},{"categories":[],"path":"Math/Counting-Pro/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"常见数列贝尔数：n 个数分成若干个非空集合的方案数 B_n=\\sum_{k=0}^nS(n,k)。\n递推：B_n=\\sum_{k=0}^{n-1}\\binom{n-1}{k}B_k。 调和级数：H_n=\\sum_{i=1}^n\\frac{1}{i}=\\ln n+\\varepsilon_n+\\gamma，其中 \\gamma 是欧拉常数，\\varepsilon_n\\approx \\frac{1}{2n}。\n容斥原理ARC 102 E\n有 n 个不可取分的 k 面骰子，对于每个 i=2,3,\\cdots,2K，求有多少种方案使得：任意两个骰子朝上的面要么相同，要么和不为 i。答案对 998244353 取模。\n2\\le n\\le 2000,1\\le k\\le 2000。 先枚举 i。也就是说 1,i-1，2,i-2，……不能同时出现。那么就出现 0 次或者一次。直接枚举有多少组里出现了一个。假设有 j 组。设这 j 个有 2^j 种选择（左边或者右边）。然后考虑出现了多少次：x_1+x_2+\\cdots +x_j，其中 x_i&gt; 0。然后枚举 y_i 表示比 i 大的数字出现的次数。把 x,y 放在一起插版即可。\n集训队作业 2018 小 z 的礼物设 t_x 表示 x 这个礼物第一次得到的时间。要求 E(\\max t_x)。考虑容斥。 \\sum_{T\\in S}(-1)^{|T|+1}E(\\min_{x\\in T}t_x)T 定下来：直接算随到一个的概率。假设有 X 个 pair 满足，一共有 Y 个 pair。那么期望就是 E(\\min T)=\\frac{Y}{X}。\n考虑 DP。f(i,j,S,x) 表示现在考虑第 i 行第 j 个格子，S 表示每行最后一个元素选不选。考虑 x 是否在子集中。\nARC 96 E Everything on It题意：求有多少个子集族满足： 其中任意一个子集都是 [n] 的子集；\n任意两个子集不同；\n1,2,\\cdots,n 都在其中出现至少两次。 考虑容斥。枚举 i 表示 1,2,\\cdots,i 出现次数小于等于 1。那么答案为 \\sum_i \\binom{n}{i}(-1)^iF(i)其中 F(i) 表示 1,\\cdots i 出现次数小于等于 1 的方案数。\n考虑枚举有 k 个集合含有 [1,i] 中至少一个，其他集合则不含有 [1,i]。\n显然不含有 [1,i] 的子集族数为 2^{2^{n-i}}。\n对于这个 k 个集合，我们考虑把 1,\\cdots,i 分入 k 个集合，有的数字可以不放，每个数字最多出现一次。相当于再拿一个集合出来装垃圾。我们给垃圾堆强制加入数字 0 来保证每个集合非空。同时我们认为 0 所在的集合指向垃圾堆。这样就相当于是 i+1 个数分成 k+1 个非空集合，那么方案数就是 S(i+1,k+1)。\n至于这 k 个集合的其他数字则可以任意填，并且由于 k 个集合各种含有不同的 1,\\cdots,i 的数字，因此其他部分就不需要考虑重复的问题了，那么方案数就是 (2^{n-i})^k。\n因此得到 F(i)=2^{2^{n-i}}\\sum_k (2^{n-i})^kS(i+1,k+1)ARC 101 E Ribbons on Tree题意：给你一个 n 个点的数，其中 n 是偶数。问有多少种将 n 个点配成 n/2 对的方式，使得每对点的路径并覆盖了整棵树。n\\le 5000。\n不合法的情况就是某条边不被经过，相当于这条边被割掉。因此考虑容斥。暴力的做法是枚举被割掉的边集，然后每个连通块内无限制连边的方案数，复杂度 O(2^n)。\n首先考虑无限制连边的方案数。对于一个大小为 x 的连通块，它的配对方案数是 g(x)=\\begin{cases}\n(x-1)(x-3)\\cdots1 & x\\equiv0\\bmod 2\\\\\n0 & x\\equiv 1\\bmod 2\n\\end{cases}那么考虑 DP 计算容斥贡献。设 f(i,j,0/1) 表示 i 的子树中，i 所在连通块大小为 j，被割的边数的奇偶性为 x 的配对方案数。注意，我们只统计被割掉的连通块的配对方案数，i 所在的连通块暂不统计配对方案数。\n假设 1 是根，我们要求的答案显然是 \\sum_{i=1}^ng(i)(f(1,i,0)-f(1,i,1))考虑转移，对于 (u\\to v) 的边： 不割。相当于把 v 所在的连通块接在 u 所在的连通块上。则 f(u,i) 和 f(v,j) 可以贡献到 f'(u,i+j) 上。\n割。则 f(u,i) 和 f(v,j)g(j) 贡献到 f'(u,i) 上。 对子树大小取 min，时间复杂度 O(n^2)。\nARC 93 F枚举 \\{G_1,G_2,\\cdots,g_n\\} 的子集。要求 S 中的所有集合都满足最小值在 A 中，问方案数。记作 f(S)。答案就是 \\sum_S(-1)^{|S|}f(S)。\n从大到小考虑 A 中的元素。dp(T) 表示 T 的最小值属于 A。\n斯特林反演下降幂：n^{\\underline{m}}=\\prod _{i=0}^{m-1}(n-i)。\n通常幂转下降幂：x^n=\\sum_{k=0}^nS(n,k)x^{\\underline{k}}。\n上升幂：n^{\\overline{m}}=\\prod_{i=0}^{m-1}(n+i)。\n上升幂转通常幂：x^{\\overline{n}}=\\sum_{k=0}^ns(n,k)x^k。\n反演公式斯特林反演： f(n)=\\sum_{k=0}^nS(n,k)g(k)\\\\\ng(n)=\\sum_{k=0}^n(-1)^{n-k}s(n,k)f(k)反转公式\n\\sum_{k=m}^n(-1)^{n-k}s(n,k)S(k,m)=[m=n]\\\\\n\\sum_{k=m}^n(-1)^{n-k}S(n,k)s(k,m)=[m=n]引理： x^{\\underline{n}}=(-1)^n(-x)^{\\overline{n}}\\\\\nx^{\\overline{n}}=(-1)^{n}(-x)^{\\underline{n}}证明显然。\n证明反转公式： \\begin{aligned}\nn^m&=\\sum_{k=0}^mS(m,k)n^{\\underline{k}}\\\\\n&=\\sum_{k=0}^mS(m,k)(-1)^k(-n)^{\\underline{k}}\\\\\n&=\\sum_{k=0}^mS(m,k)(-1)^k\\sum_{j=0}^ks(k,j)(-n)^{j}\\\\\n&=\\sum_{j=0}^mn^j\\sum_{k=j}^mS(m,k)s(k,j)(-1)^{k-j}\n\\end{aligned}反之亦然。\n证明反演公式： \\begin{aligned}\nf(n)&=\\sum_{i=0}^n[i=n]f(i)\\\\\n&=\\sum_{i=0}^nf(i)\\sum_{j=i}^nS(n,j)s(j,i)(-1)^{j-i}\\\\\n&=\\sum_{k=0}^nS(n,k)\\sum_{i=0}^k(-1)^{k-i}s(k,i)f(i)\n\\end{aligned}也就是说如果 g 的定义式成立，那么 f 成立。\n用另一个反转公式，那么如果 f 的定义式成立，那么 g 成立。这样就证完了。\n2018 雅礼集训 方阵\n给定 n\\times m 的矩阵，每个格子填上 [1,c] 中的数字，求任意两行、两列均不同的方案数。\nn,m\\le 5000。 不同：对应位置不同。\n考虑只要求行不相同。\n设 g(m) 表示 m 列的矩阵，行互不相同的方案数。有 c^m 种可能的行。则 g(m)=(c^m)^{\\underline{n}}f(m)：m 列的答案。枚举 g(m) 中列被分成多少类。 g(m)=\\sum_{i=0}^mS(m,i)f(i)\\\\\nf(m)=\\sum_{i=0}^m(-1)^{m-i}s(m,i)g(i)注：f(0)=0。\n一道例题\n给定 n 个结点的树，从某个点出发开始随机游走：在点 u 时，有 p_u 的概率留在原地，否则等概率向相邻结点移动，直到移动到 1 号点停下。求从每个结点出发直指停下，所花费的时间的 k 次方的期望。\nn\\le 10^5,k\\le 10^5,nk\\le 10^6。 设 u 到根结点的期望时间是 t_u。我们要求 E(t_u^k)。 \\begin{aligned}\nE(t_u^k)&=E\\left(\\sum_{i=0}^kS(k,i)t_u^{\\underline{i}}\\right)\\\\\n&=\\sum_{i=0}^kS(k,i)i!E\\left(\\binom{t_u}{i}\\right)\\\\\nE\\left(\\binom{t_u}{i}\\right)&=P_uE\\left(\\binom{t_u+1}{i}\\right)+\\frac{1-P_u}{d_u}\\sum_{(u,v)}E\\left(\\binom{t_v+1}{i}\\right)\\\\\nE\\left(\\binom{t_u}{i}\\right)&=P_uE\\left(\\binom{t_u}{i}+\\binom{t_u}{i-1}\\right)+\\frac{1-P_u}{d_u}\\sum_{(u,v)}E\\left(\\binom{t_v}{i}+\\binom{t_v+1}{i-1}\\right)\\\\\n(1-P_u)E\\left(\\binom{t_u}{i}\\right)&=P_uE\\left(\\binom{t_u}{i-1}\\right)+\\frac{1-P_u}{d_u}\\sum_{(u,v)}E\\left(\\binom{t_v}{i}+\\binom{t_v+1}{i-1}\\right)\n\\end{aligned}考虑按照 i 从小到大的顺序做。设 E\\left(\\binom{t_u}{i}\\right)=dp(u),E\\left(\\binom{t_u}{i-1}\\right)=a_u： dp_u=P_u(dp_u+a_u)+\\frac{1-P_u}{d_u}\\sum_{(u,v)}(dp_v+a_v)\\\\\ndp_u=\\frac{P_ua_u}{1-P_u}+\\frac{1}{d_u}\\sum_{(u,v)}(dp_v+a_v)可以按树上高消的套路做了。要记得 O(k\\log_2k) 预处理斯特林数。\n另一道例题设连通块数为 T：T^k=\\sum_{i=0}^kS(k,i)i!\\binom{T}{i}。问题转化为求出 \\sum_{T}\\binom{T}{i}，它表示选出了 i 个连通块。\n设 dp_t(n) 表示 n 个点 t 个连通块的图的个数。 \\sum_{T}\\binom{T}{i}=\\sum_{j=1}^n\\binom{n}{j}dp_i(j)2^{\\binom{n-j}{2}}\\\\\nAns=\\sum_{i=0}^kS(k,i)i!n!\\sum_{j=1}^ndp_i(n-j)\\frac{1}{(n-j)!j!}2^{\\binom{j}{2}}问题转化为如何求 \\frac{dp_i(j)}{j!}。 dp_t(n)=\\sum_{i=1}^n\\binom{n-1}{i-1}dp_1(i)dp_{t-1}(n-i)\\\\\n\\frac{dp_t(n)}{(n-1)!}=\\sum_{i=1}^n\\frac{dp_1(i)}{(i-1)!}\\frac{dp_{t-1}(n-i)}{(n-i)!}那么 \\hat{G}_t=\\sum_{n\\ge 0}dp_t(n)\\frac{x^n}{n!}\\\\\n\\hat{F}=\\sum_{n\\ge 1}dp_1(n)\\frac{x^n}{(n-1)!}容易得到 n\\hat{G}_t=\\hat{F}\\hat{G}_{t-1}+1dp_1(n) 就是 \\ln G(n)。\n清华集训 2017 生成树计数\n在一个 s 个点的图中，存在 s-n 条边，使图中形成了 n 个连通块，第 i 个连通块中有 a_i 个点。\n现在我们需要再连接 n-1 条边，使得该图变成一棵树。对于一种连边方案，设原图中第 i 个连通块连出了 d_i 条边，那么这棵树 T 的价值为： val(T)=\\left( \\prod_{i=1}^nd_i^m \\right)\\left( \\sum_{i=1}^nd_i^m \\right)求出所有可能的生成树的价值之和，对 998244353 取模。\nn\\le 3\\times 10^4,m\\le 30。 转化为 n 个点的生成树 T： \\begin{aligned}\n&\\left( \\prod_{i=1}^nd_i^m \\right)\\left( \\sum_{i=1}^nd_i^m \\right)\\left( \\prod_{i=1}^na_i^{d_i} \\right)\\\\\n=&\\sum_T\\sum_{i=1}^na_i^{d_i} d_i^{2m}\\prod_{j\\ne i}(a_j^{d_j}d_j^{m})\\\\\n=&\\sum_{\\sum k_i=n-2}\\binom{n-2}{k_1,k_2,\\cdots,k_n}\\sum_{i=1}^na_i^{k_i+1}(k_i+1)^{2m}\\prod_{j\\ne i}\\left(a_j^{k_j+1}(k_j+1)^{m}\\right)\n\\end{aligned}交换 (n-2)!\\sum_{i=1}^n\\sum_{\\sum k_i=n-2}\\frac{1}{\\prod k_i!}a_i^{k_i+1}(k_i+1)^{2m}\\prod_{j\\ne i}a_j^{k_j+1}(k_j+1)^{m}\\\\\n(n-2)!\\sum_{i=1}^n\\sum_{\\sum k_i=n-2}\\frac{a_i^{k_i+1}(k_i+1)^{2m}}{k_i!}\\prod_{j\\ne i}\\frac{a_j^{k_j+1}(k_j+1)^{m}}{k_j!}EGF B_i(x)=\\sum_{k\\ge 0}a_i^{k+1}(k+1)^{2m}\\frac{x^k}{k!}\\\\\nA_i(x)=\\sum_{k\\ge 0}a_i^{k+1}(k+1)^{m}\\frac{x^k}{k!}带回 [x^{n-2}](n-2)!\\sum_{i=1}^n B_i(x)\\prod _{i\\ne j}A_j(x)定义 T(x)： \\begin{aligned}\nT(x)&=\\int A_i(x)\\text{d}x=\\sum_{k\\ge 1}a_i^kk^m\\frac{x^k}{k!}\\\\\n&=\\sum_{k\\ge 1}a_i^k\\frac{x^k}{k!}\\sum_{j=0}^mS(m,k)k^{\\underline{j}}\\\\\n&=\\sum_{j=0}^mS(m,j)a_i^jx^je^{a_ix}\\\\\n\\end{aligned}那么复合函数求导得到（sum 里是个复合函数） \\begin{aligned}\nA_i(x)&=\\frac{\\text{d}T(x)}{\\text{d}x}=\\sum_{j=0}^mS(m,j)a_i^jjx^{j-1}e^{a_ix}+\\sum_{j=0}^mS(m,j)a_i^{j+1}x^je^{a_ix}\\\\\n&=e^{a_ix}\\sum_{j=0}^mS(m,j+1)(j+1)a_i^{j+1}+S(m,j)a_i^{j+1}\\\\\n&=e^{a_ix}\\sum_{j=0}^mS(m+1,j+1)a_i^{j+1}x^j\n\\end{aligned}复杂度 O(nm\\log_2^2n)。\nBurnside 引理ARC 62 F Painting Graphs with AtCoDeer题意：给出无向图 G，对边染 K 种颜色之一。一个环上面的边旋转后得到的染色方案视为相同，求不同的染色方案数。\n求出所有的点双（每个点双是独立的）： 单独的边：方案数为 K。\n单环：\\frac{1}{n}\\sum_{d=0}^{n-1}k^{\\gcd(n,d)}。\n复合环：可以交换两条边的颜色。只用统计不同颜色出现次数的方案数。插板 \\binom{n+k-1}{k-1}。 乘起来即可。","title":"「草稿」组合计数综合练习","updated":"2025-04-23T04:07:19.267Z"},{"categories":[],"path":"Codeforces/part-3/","tags":[],"text":"Minimum Euler Cycle\n给你一个有向图 K_n=(V,E)。|V|=n。|E|=\\{ (u,v) \\mid u,v\\in E,u\\ne v \\}（有向边）。你要求出字典序最小的欧拉回路的端点序列。例如 n=3 时为 \\{1,2,1,3,2,3,1\\}。\n由于输出太大，你只需要输出一个区间 [L,R]。\nn\\le 10^5,R-L\\le 10^5。 构造 贪心\n这序列一定是 \\{ \\{1,i&gt;1\\},\\{2,i&gt;2\\},\\{3,i&gt;3\\},...,\\{n,i&gt;n\\},1\\}。\\{1,i&gt;1\\} 表示 \\{1,2,1,3,1,4,\\cdots,1,n\\}。\n于是可以简单地求出了。\n代码\nDivisor Paths\n给你一个整数 D，要构建一个无向图 G=(V,E)：V=\\{x\\mid x|d\\}，E=\\{(x,y)\\mid x&gt;y,y|x,\\frac{x}{y}\\text{ is prime}\\}。设 (x,y)（x&gt;y）的边权为 w(x,y)=\\sum_{d|x}[d\\nmid y]。\n现在 q 次询问 u,v 两点的最短路径数。\nD\\le 10^{15},q\\le 3\\times 10^5,u,v\\in V。 数学 数论 盲猜\n一条边 (x,y) 相当于 y 乘一个质数走到 x。\n直觉告诉我们 u,v 的最短路是 u \\to \\gcd(u,v)\\to v 的权值。相当于你可以从 u 开始，除掉一些 u 比 v 多的质数，再乘上一些 v 比 u 多的质数。也可以发现最短路一定经过 \\gcd(u,v)。也就是说最短路径数是 f\\left(\\frac{u}{\\gcd(u,v)}\\right)f\\left(\\frac{v}{\\gcd(u,v)}\\right)（两边的路径数只和商有关，因此是一个一元函数）。\n那么最短路的数量，相当于就是你乘（除）质数的顺序。那么我们只关心不同质数间的顺序。这就是个多重组合数。那么 f(x) 就可以容易地计算了。\n最后，由于 u,v 是 D 的约数。因此分解质因数的时候枚举 D 的质因数即可。\n时间复杂度 O(\\sqrt{D}+q\\log D)。\n代码\nStrange Function\n对于整数序列 a，设 f(a) 表示 a 的前缀最大值序列。如 f(\\{3,1,2,7,7,3,6,7,8\\})=\\{3,7,8\\}。\n给出长度为 n 的序列 a,p 和长度为 m 的序列 b。你可以以 p_i 的代价删掉 a_i（代价可能是负的），要求用最小的代价删掉一些数，使得 f(a')=b。\nn\\le 5\\times 10^5,1\\le a_i\\le n,|p_i|\\le 10^9, 1\\le m\\le n, 1\\le b_{i-1}&lt;b_i\\le n。 DP 线段树\n设 f(i,j) 表示前 i 个数的最小代价使得 f(a[1,i])=b[1,j]。考虑 a_{i+1}： 若 a_{i+1}&lt;b_j。则 a_{i+1} 可以删也可以不删。因此它的代价贡献是 \\min(p_{i+1},0)。\n若 a_{i+1}=b_j，则 a_{i+1} 可以删。也可以不删。如果不删的话，会多一种转移：f(i,j-1)\\to f(i+1,j)。\n若 a_{i+1}&gt;b_j。如果选，那么必须 a_{i+1}=b_{j+1}，不然不合法；如果不选（删掉），则代价就是 p_{i+1}。 对第二维建线段树维护 DP 即可。\n时间复杂度 O((n+m)\\log_2m)。\n代码\nSubstring Search\n给出一个小写字母的一一映射（长度为 26 的排列）p。规定字符串 s 和 t 匹配当且仅当： |s|=|t|；\n\\forall 1\\le i\\le |s|，s_i=t_i 或 p_{s_i}=t_i。 现在给出两个串 s,t（|s|\\le |t|），求出 s 在 t 的每个位置是否匹配。输出长度为 |t|-|s|+1 的 01 串。\n|s|\\le |t|\\le 2\\times 10^5。 多项式 随机\ns_i=t_i 或者 p_{s_i}=t_i，等价于 (s_i-t_i)^2(p_{s_i}-t_i)^2=0。因此 s 在 i 处匹配的条件是 f(i)=\\sum_{j=1}^{|s|}(s_j-t_{i+j})^2(p_{s_j}-t_{i+j})^2=0那么我们求出 f(0),\\cdots,f(|t|-|s|) 即可。\n如果 f 是 \\sum a_ib_{i+j} 的形式，我们可以简单地使用 O(n\\log_2n) 多项式乘法计算。而上式实际上可以拆开分成 5 项，分别对应 t_{i+j} 的 0 到 4 次方项。因此我们对每一项都做多项式乘法最后加起来即可。\n时间复杂度 O(n\\log_2n)。但这样有一个问题。就是可能被卡 NTT 模数。因此我们给每个字母分配一个随机权值。这样就行了。\n代码\nEdge Weight Assignment\n给出一棵 n 个点树。你可以给每条边一个边权。要求赋权使得任意两个叶子的路径异或和为 0。\n问不同权值个数的最大值和最小值。\n3\\le n\\le 10^5。 分类讨论 构造 手玩 DP\n题目中的条件可以转化为，选择一个根结点。则任意叶子结点到根的异或和相等。不妨选一个非叶子结点作为根。\n考虑最小值。那么容易发现同一个结点 u 的所有叶子儿子的父边是权值相同的，可以直合并成一个结点。手玩发现，答案是 1 或者 3。3 的构造如下（设 a\\oplus b\\oplus c=0）： 也可以简单描述一下。考虑从根结点往下构造。设 \\text{C}(u,a) 表示构造 u 的子树的边权，使得 u 子树里所有叶子点到 u 的异或和为 a。那么对于 C(u,a)，我们给 u 的叶子儿子的父边赋权为 a，然后给 u 的非叶儿子 v 的父边赋权为 b 并递归构造 C(v,c)。\n1 的情况很平凡。\n考虑最大值。经过刚才的思考过程，可以发现，两个子树是独立的，可以任意赋权。因此把叶子儿子合并后做一个简单的树形 DP 即可。\n代码\nNested Rubber Bands\n你有一棵 n 个点树 T=(V,E)。要求你构造平面上 n 个封闭图形 a_i。若 a_u 和 a_v 相交（边界相交），当且仅当 (u,v)\\in E。问这 n 个封闭图形中至多有多少个互相嵌套的图形。即找一个最大子集 S，使得 \\forall x,y\\in S，a_x 和 a_y 是包含关系。输出 |S|。\n3\\le n\\le 10^5。 DP 手玩\n考虑这样一个问题：若 (x,y)\\in E 且 a_x\\subset a_z，那么 a_y 和 a_z 是什么关系？\n容易发现，a_y\\subset a_z、a_y,a_z 相交这两个条件有且仅有一个满足。\n我们断言：一个合法的相互嵌套方案是集合 S 使得： S 中任意两个点不相邻。\n存在树上的一条简单路径 P 使得 S 中的点到 P 的距离小于等于 1（毛毛虫）。 证明：反证法。不妨考虑下图的情况。其他情况可以类比： 在这里 5,6,7 是不分顺序的。不妨设 a_7\\subset a_6\\subset a_5。\n那么根据刚才的小发现，4 一定在被 6 包含；于是 1 也一定被 6 包含，2 也一定被 6 包含。\n那么 a_2\\subset a_6\\subset a_5，而 a_2,a_5 是相交的，矛盾。\n而如果不存在上图的方案，可以证明一定是毛毛虫的形式。或者说我们还可以证明，毛毛虫为什么一定合法？\n这个也不难。枚举在末尾加一个子树，看子树的根结点选或者不选。然后都可以构造使得新构造的把之前的都包含了。\n证完后就可以求答案了。可以直接树形 DP 或者换根。\n复杂度 O(n)。\n代码\nSergey’s problem\n给你一个 n 个点 m 条边的有向图（无自环，可能有重边）。要求你求出一个点集 Q 使得对于任意不在 Q 中的点 u，都存在一个点 v\\in Q 使得 v 走不超过 2 步可以到 u。可以证明一定有解。\nn,m\\le 10^6。 归纳法 构造\n如果我选了点 u，那么 u 走一步能到的点就不能选。另一方面，如果走一步能到 u 的某个点 v 被选了，那么意味着 u 和 u 走一步能到的点都被 v 覆盖了。因此我们可以把 u 和它走一步能到的点删了，对剩下的图构造。构造完了我们再看是否有走一步能到 u 的点被选。如果有，就不用选 u 了。否则就选 u。\n写一个 DFS 即可。\n时间复杂度 O(n+m)。\n代码\nLarge Triangle\n给你二维平面上 n 个点，问你是否存在三个点使得三角形面积恰好为 S。\n3\\le n\\le 2000,1\\le S\\le 2\\times 10^{18}。 微调\n如果确定了两个点，那么把它当作一个向量，与其他点算叉积，则可以排序后二分判定。\n但问题是，你选择不同的向量，顺序也不一样。每次排序的话，就是 O(n^3\\log_2n) 的。\n不过考虑一下，如果我只是轻微旋转一下这个向量，那么只有这个向量的两个端点的顺序发生变化，两者交换一下即可。只要我们别旋转到超过下一个向量，则其他的点的顺序也是不变的。\n因此把 O(n^2) 个向量按斜率排序，然后按序交换并二分即可。时间复杂度 O(n^2\\log_2n)。\n代码\nRaining season\n给一棵 n 个点的树，每条边的权值是一个一次函数 a_ix+b_i。给你 m，问你在 x=0,1,\\cdots,m-1 时树的直径是多少。输出 m 个数。\nn\\le 10^5,m\\le 10^6,0\\le a_i\\le 10^5,0\\le b_i\\le 10^9。 边分治 闵可夫斯基和 凸包 计算几何\n一条路径的权值是一次函数。\n则直径的函数是半平面交的形式。\n考虑边分治。首先多叉树转二叉树。\n假设当前的连通块的大小是 n，考虑经过当前分治边的直径。显然可以看作是两边各选一个点的一次函数加起来，对这 O(n^2) 个一次函数求半平面交。但这东西复杂度太大。\n将半平面交对偶成凸包（一次函数对偶成点）。容易发现，两个一次函数的加法，就是两个点（向量）的加法。则两边的一次函数加起来的半平面交，相当于对偶后两边的点加起来的凸包。也就是两边的凸包的闵可夫斯基和。这个可以 O(n) 做，而且得到的凸包的大小也是 O(n) 的。\n对于每个连通块我们都做一次，这样会得到总大小为 O(n\\log_2n) 的凸包集合。把这些点全丢一起再求一次凸包（注意是凸包合并，不是闵可夫斯基和），再对偶回去就得到直径的函数了。\n然后求一下 0,\\cdots,m-1 的点值即可。\n时间复杂度 O(n\\log_2^2n+m)。\n由于一般的闵可夫斯基和太容易出锅，因此代码里写的是两个上凸壳的闵可夫斯基和。这样的好处是不用极角排序，按 x 轴排序也能做。\n代码\nChiori and Doll Picking (hard version)\n给出一个非负整数集合 A，设 p_i=\\sum_{S\\subseteq A}\\left[ \\text{popcount}(\\oplus_{x\\in S}x)=i \\right]求 p_0,p_1,\\cdots,p_m。\nn\\le 2\\times 10^5,m\\le 53。 线性基 meet in middle FWT 组合数学\n先求出线性基 B，设 B 能表出的数的集合为 S(B)。那么答案显然就是线性基的数的答案乘 2^{n-|B|}。\n若 |B|\\le 26，则我们可以暴力枚举 S(B) 的数并统计答案。\n若 |B|&gt;26，构造序列 A，A_i=[i\\in S(B)]。那么 A 有一些性质。不妨设 A 的 FWT 变换为 \\hat{A}。\n性质 1：\\hat{A}_i 的取值只能为 0 或 2^{|B|}。\n我们知道 \\hat{A}_i=\\sum_{j}A_j(-1)^{|i\\& j|}。而 A 中值为 1 的数只有 2^{|B|} 个，因此若 \\hat{A}_i=2^{|B|}，则必然满足：\\forall j\\in S(B)，|i\\& j| 是偶数。\n那么这样的 i 一共有多少个？假设满足该条件的 i 的集合为 G。那么容易发现，\\forall x,y\\in G，x\\oplus y\\in G，也就是说 G 有关于异或运算的封闭性。因此可以求出 G 的一个线性基 C。容易发现 C 的大小是小于等于 m-|B| 的！因为你确定了 B 中自由元的值后，根据“偶数条件”，其他主元的值也确定了。\n我们可以使用一些技巧做到 2^{m-|B|} 枚举 G 中的数。\n那么我们再考虑 FWT 回去求答案，则 \\begin{aligned}\np_x\n&=\\sum_{i=0}^{2^m-1}[|i|=x]A_i\\\\\n&=\\sum_{i=0}^{2^m-1}[|i|=x]\\frac{1}{2^m}\\sum_{j\\in G}\\hat{A}_j(-1)^{|i\\& j|}\\\\\n&=\\frac{1}{2^{m-|B|}}\\sum_{j\\in G}\\sum_{i=0}^{2^m-1}[|i|=x](-1)^{|i\\& j|}\n\\end{aligned}容易发现。后面的那个式子只和 |j| 有关，即 \\sum_{i}[|i|=x](-1)^{|i\\& j|}=g(x,|j|)。那么我们想办法预处理 g(x,y) 即可。 g(x,y)=\\sum_{i=0}^{2^m-1}[|i|=x](-1)^{|i\\& (2^y-1)|}=\\sum_{z=0}^{\\min(x,y)}\\binom{y}{z}\\binom{m-y}{x-z}(-1)^z不妨设 f(x)=\\sum_{j\\in G}[|j|=x]，那么原式可以化为 p_x=\\frac{1}{2^{m-|B|}}\\sum_{y=0}^{m}f(y)g(x,y)代码\nMake Symmetrical\n二维平面上，要求支持 q 次操作： 插入一个整点 (x,y)（1\\le x,y\\le 10^5），保证这个点之前没有插入过。\n删除一个点（之前插入过）。\n给出 (x,y)（1\\le x,y\\le 10^5），求至少再加入多少个点可以使整个点集关于直线 ((0,0),(x,y)) 轴对称。 1\\le q\\le 2\\times 10^5。 暴力\n关于 ((0,0),(x,y)) 轴对称的点，到原点的距离是相等的。而实际上满足 x^2+y^2=C 在固定 C 的情况下的点 (x,y) 的数量是不多的。在本题中至多有 144 个点。\n不妨考虑，每次加入一个点的时候，我们 O(144) 地更新答案。然后查询的时候直接查表即可。\n值得一提的是，在计算两个点的对称轴的时候由于这两个点到原点的距离相等，因此可以直接向量加法求出（菱形）。\n用 map 维护。时间复杂度 O(q\\log_2n\\cdot 144))，使用 unordered_map 可以更快。\n代码\nMake Square\n如果序列 b_1,\\cdots,b_m 中存在两个数 b_i,b_j（i&lt;j）使得 b_ib_j 是完全平方数，则 b 是好的。\n对于一个序列 b，每次操作，你可以选择一个元素并乘上一个质数，或者选择一个元素并除掉一个质数。f(b) 表示最少的操作次数使得 b 变成好的。\n给你一个序列 a，每次询问区间的 f(a[l,r])。\nn\\le 2\\times 10^5,q\\le 10^6,a_i\\le 5\\times 10^6。 DP 二进制表示 异或 扫描\n首先想到把平凡因子去掉，这样每个数就最多有 7 个互不相同的质因子，即最多有 128 个约数。\n现在，要让 ab 是完全平方数（即 a 到 b 的最短距离），则相当于 a 要先走到 a 的某个约数 x，再从 x 走到 b。\n考虑扫描线 DP。考虑 a_1,\\cdots,a_i，设 f(x,d) 表示最大的 j（j\\le i）使得 x\\mid a_j 且 \\frac{a_j}{x} 有 d 个质因子（即 x 走 d 步到 a_j）。再设 g_x 表示最大（靠右）的 j 使得 [j,i] 的答案 \\le x。\n考虑如何从 i-1 更新到 i。加入一个 a_i，则我们可以先枚举 x\\mid a_i，用 a_i 走到 x 再走 d 步来更新对应的 g（即使 a_i 到 x 和 x 走的 d 步中有相同的质因数也没关系。因为我们求的是 \\le）。更新完 g 再用 x 走到 a_i 来更新 f。\n然后我们就可以求出以 i 为右端点的询问的答案了。\n时间复杂度 O(n(\\sqrt{a_i}+128\\cdot 7)+q\\cdot 14)。\n代码","title":"Codeforces 题目选讲 3","updated":"2025-04-23T04:07:19.261Z"},{"categories":[],"path":"Probset/21-March-1/","tags":[],"text":"所谓跟训日志，就是说我是不打省选第三轮的（因为四川没有第三轮）。\n矩阵\n有一个 n\\times n 的矩阵，初始时为全 0。每次你可以选一个行的子集 R 和列的子集 C，把所有 (r,c)（r\\in R, c\\in C）变成 1。\n要求在不超过 26 次操作内让 (i,j)（j\\le i\\le j+1）是 0，其他全部变成 1。\n输出步骤。\nn\\le 3000。 二进制划分 分治\n这题的部分分可以分治，每次将左下和右上的矩阵干掉，这样就变成了两个互不相关的子问题，可以同步解决。\n先考虑一个相关的问题 A： 让 i=j 的 (i,j) 是 0，其他都变成 1。也就是说我们要选中所有 i\\ne j 的二元组。 考虑按位划分。对于行号和列号（即 1,2,\\cdots, n）枚举二进制下第 i 位，将第 i 位为 0 的放入集合 A，其他的放入集合 B。那么我们让 R\\gets A, C\\gets B 做一次操作，再让 R\\gets B, C\\gets A 做一次操作。这样的操作次数是 2\\log_2n 的。容易证明它可以选中所有 i\\ne j 的二元组 (i,j)。\n那么回到原问题。我们能否将原问题转化为上述问题？\n考虑将列（或者行）奇偶分组。这时你会发现原问题被分解为了两个规模是 \\frac{n}{2} 的问题 A。不过这两个不一定能同步做，因此操作次数上界是 4\\log_2n 的。还是太多。\n我们考虑做一个优化，使得只需要 R\\gets A, C\\gets B 这一次操作，不需要 R\\gets B, C\\gets A。\n容易发现行号和列号不一定是 1,2,\\ldots, n，只需要保证互不相同，且对角线上的元素的行号和列号相同即可。\n那么我们找一组数，使得其中的任意两个数 a,b 满足： 存在 i 使得 a 的二进制第 i 位为 0，b 的二进制第 i 位为 1；\n存在 j 使得 a 的二进制第 i 位为 1，b 的二进制第 i 位为 0。 这样就意味着，当我们枚举到 i 时，(a,b) 会被选中，当枚举到 j 时，(b,a) 会被选中。因此就不需要 R\\gets B, C\\gets A 这一步操作了。\n不妨考虑所有 13 位，有 6 个 1 的二进制数。由于 \\binom{13}{6} &gt; 1500，可以胜任。将这些数作为行号和列号，可以在 2\\log_2n 次操作内完成任务。\n有一些细节问题：在奇偶分组后，可能要求某一行全部变 1。这时不需要新加一次操作，直接在每次操作的时候加上这一行的行号即可。\n网格游走问题\n要求你从 (a_1,b_1) 走到 (a_2,b_2)，使得不碰到 y=0 和 y=t 的直线（0&lt;b_1, b_2&lt;t）。\n从 (x,y) 出发，你可以走到 (x+1, y-1) 或者 (x+1, y+1)。\n求方案数。\na_1, a_2\\le 10^7。 容斥 组合意义 翻折\n如果只要求不碰到 y=0，那么这就是个经典的翻折问题。而由于本题难以不重不漏的计数，因此考虑容斥。\n从 (a_1, b_1) 走到 (a_2, b_2) 的方案数是一个组合数。然后我们要减掉不合法的方案数。\n我们想办法将每个路线赋权，使得合法的路线权值是 0，不合法的路线权值是 -1。那么我们求出权值和即可得到不合法的方案数。\n对于一个路线 P，考虑这样两个累加过程： 当 P 第一次经过 y=t 时减 1，接下来当它经过 y=0 时加 1，接下来当它经过 y=t 时又减 1，经过 y=0 时又加一，以此类推。\n当 P 第一次经过 y=0 时减 1，接下来当它经过 y=t 时加 1，接下来当它经过 y=0 时又减 1，以此类推。 你发现这两个过程得到的累加和的和，对于不合法的路径总是 -1，对于合法的路径总是 0。\n接下来我们就来算两类累加和。由于是对称的，我们只描述第一种累加和的计算过程。\n考虑算所有路线的累加和的和。 对于第一次经过 y=t 的情况，我们将 (a_2, b_2) 关于 y=t 对称得到 (a_2, 2t-b_2)，然后求 (a_1, b_1) 到 (a_2, 2t-b_2) 的方案数即可（系数是 -1）。\n接下来经过 y=0，这时我们将 (a_2, 2t-b_2) 关于 y=0 对称得到 (a_2, b_2-2t)，然后求 (a_1, b_1) 到 (a_2, b_2-2t) 的方案数即可（系数是 1）。 以此类推，第 i 次翻折的系数是 (-1)^i。\n然后就做完了。\n树\n完全二叉树：指内部结点的儿子数都为 2 的二叉树。\n左 m 链树：有 m 个叶子点，且所有内部结点的右儿子都是叶子结点的完全二叉树。\n定义两种操作： 删除某个子树；\n对于边 (x,y)（x 是 y 的父亲），将 x 替换为 y（x 的其他儿子全部被删除）。 现在问有多少个 n 个叶子结点的完全二叉树，使得无法通过若干次操作变成左 m 链树。\nn, m\\le 10^7。 生成函数 组合意义\n这道题有两个思路方向，其中只有组合意义是可以走到最后的（目前）。\n算法一考场上想到的生成函数做法。\n显然我们可以去掉所有的叶子结点。因此问题转化为求 n-1 个结点，且往左走的最大次数不超过 m-2 的二叉树的个数。\n设 f_{i,j} 表示有 i 个内部结点，且左链（往左走的最大次数加 1）长度小于等于 j 的二叉树是个数。\n设 F_j(x) = \\sum_{i}f_{i,j}x^i。根据 f 的DP方程容易得到 F_j = \\frac{1}{1-xF_{j-1}}其中 F_0 = 1。\n然后你算前几个 F 就会发现分子和分母的多项式的系数有规律。\n这样你可以求出分子和分母的多项式，然后做一个 O(n^2) 求逆（这题没给 O(n\\log_2n) 部分分）。\n算法二这是个组合意义的做法。为此我们直接DP。\n设 f_{i,j} 表示有 i 个结点且走到当前这个点的左链（走到当前这个点，往左走的最大次数加 1）长度小于等于 j 的完全二叉树是个数。按照 DFS 序DP。\n有 f_{i,j} = f_{i-1, j-1} + f_{i-1, j+1}（0&lt;j&lt;m）。\n容易发现这就是上文的网格游走问题。因此容斥即可。\n那么答案是 f_{2n-1, 1}，因为根结点的右链末端点是DFS序最大的点。\n时间复杂度 O(n)。\n代码\nGlow, Little Pixel, Glow\n你有一个网格，沿着横竖交叉的网格线会有脉冲经过。有两类脉冲： 横向的脉冲一定是从左往右移动\n纵向的脉冲一定是从上到下移动 脉冲可以记为 (t, m, a)，分别表示这个脉冲的出发时间、脉冲长度、脉冲所在的行号（列号）： 出发时间指这个脉冲到达第 1 列（行）的时间。\n脉冲的移动速度是一个单位网格边长每单位时间。\nm 可理解为，脉冲是个长度为 m-1 单位边长的线段，即它同时覆盖了 m 个格点。 被脉冲覆盖的格点处于激活状态。\n每个格点上有一个灯泡。如果某个格点的横向和纵向在某个时刻同时被激活，那么这个点上的灯就会亮。\n现在给出 n 个脉冲，保证每一行最多一个脉冲，每一列最多一个脉冲，问最后被点亮的灯的个数。\nn\\le 2\\times 10^5, t, m, a\\le 10^5。 建模\n这题的条件比较繁琐，细节颇多，难点在于形式化的建模。\n首先我们可以离散化，只考虑存在脉冲的行和列（这里的离散化是指思维过程中离散化，不一定体现在代码上）。\n如果某个灯它不亮，那么要么它所在的行脉冲比列脉冲来得早，要么列脉冲比行脉冲来得早。因此我们可以对这两种情况分别统计，就可以得到不亮的灯数，进而得到点亮的灯数。\n而这两种情况是对称的，只用考虑其中一种情况，然后将行列交换再做一次即可。\n设 f_i(x) 表示第 i 行的脉冲第一次到达第 x 列的时间。假设这一行的脉冲是 (t_i, m_i, i)，那么显然 f_i(x) = t_i + x - 1。\n设 g_x(i) 表示第 x 列的脉冲恰好离开第 i 行的时间。设这一列的脉冲是 (t_x, m_x, x)，那么有 g_x(i) = t_x + i + m_x-1。\n那么当且仅当 f_i(x)\\ge g_x(i)，第 i 行第 x 列的灯不亮（只统计列脉冲比行脉冲来得早的情况）。\n于是问题转化为求满足 f_i(x)\\ge g_x(i) 的格点 (i, x) 的个数。\n简单变换一下不等式得到 t_i -i\\ge t_x -x + m_x，不等式的左边只和 i 有关，右边只和 x 有关。可以 O(n\\log_2n) 计数。\n总时间复杂度 O(n\\log_2n)。\n代码\nCarny Magician\n求字典序第 k 小的含有 m 个不动点的长度为 n 的排列。不动点指满足 p_i = i 的下标 i。不存在则输出 -1。\nm\\le n\\le 50, k\\le 10^{18}。 贪心 溢出处理\n这题是没有取模的。因此如果你的算法涉及了减法（容斥），那么就难以处理溢出的情况。\n因此我们考虑不重不漏的计数。首先外壳是个贪心，将问题转化为：设 g(a,b) 表示：将 a 个不同的数排成排列，且其中有 b 个数无法构成不动点（可以理解为，这 b 个数的值大于 a）的错排方案数。错排指没有不动点的排列。 g(a, b) = \\begin{cases}\ng(a-1, b-1)b + g(a-1, b)(a-b) & b&gt;0 \\\\\ng(a-1, 1)(a-1) & b=0\n\\end{cases}有了这个我们就可以在贪心的过程中计算方案数了。举个例子，有 m 个不动点的长度为 n 的排列总数是 \\binom{n}{m}g(n, m)。\n然后我们写一个简单的防溢出即可：\nlong long add(long long x, long long y) &#123; return min(INF, x+y);\n&#125;\nlong long mul(long long x, long long y) &#123; if(!x || !y) return 0; if(INF/x &lt; y) return INF; return x*y;\n&#125;\n时间复杂度 O(n^3)。\n代码\nPivoting Points\n二维平面上有 n 个点 p_i(x_i, y_i)，不存在三点共线。你可以选择一个点做为起始点，然后任意画一条只经过这个起始点的直线。\n接下来以该直线过的点 u 为轴，逆时针旋转直线，每当碰到另一个点 v（即两个点同时出现在该直线上）时，把轴点更换为 v，并且在 v 上打个标记，然后继续旋转。\n令这次旋转的价值为，旋转了 360^\\circ 后标记数量最多的点上的标记数量。\n任意选择起点，求最大价值。\nn\\le 2000。 模拟\n容易证明，旋转 360^\\circ 后会回到起始点。因此我们设 \\text{nex}(i, j) 表示以 i 为轴，过 p_i 和 p_j 的直线逆时针旋转下一个碰到的点的编号。这个可以 O(n^2\\log n) 预处理。\n然后模拟一下即可。每个环只会被访问一次，因此时间复杂度有保证。\n不过在某些情况下一个环可能只代表 180^\\circ 的旋转，比如 n=3 时就存在这样的情况。\n一个简单粗暴的方法是记录一下旋转的角度，看加起来是不是约等于 2\\pi。\n代码\n尺树寸泓\n给出一棵 n 个点的带点权的二叉树，你可以 把一个点左旋。\n把一个点右旋。\n设一个点的价值是子树点权和。求子树里结点的价值的积。 n\\le 2\\times 10^5, q\\le 2\\times 10^5。 DFS序\n这题的要点是：左旋和右旋都不会影响树的中序遍历。\n而中序遍历中子树对应区间。\n同时分析可得，旋转带来的修改是 O(1) 的。\n写个树状数组维护即可。\n时间复杂度 O(n\\log_2n)。\n凫趋雀跃\n要求从 (0,0) 走到 (T_x, T_y)，每一步可以走一个非零向量 (x,y)，其中 0\\le x\\le M_x, 0\\le y\\le M_y，且其中有 k 个形如 (a_i, a_i) 的向量不能选。保证 a_i 是 10 的倍数。\n问恰好走 R 步到达的方案数。\nT_x, T_y, M_x, M_y\\le 800, R\\le 1600, k\\le 50。 容斥\n本题的条件约束复杂，较为繁琐，要点是勇气。只要敢想就可以过。\n如果 k=0，并且允许走零向量，那么我们发现可以把向量正交分解，即把横竖分开做，转化为一维的问题。总方案数就是两个一维问题方案数的乘积。转化后的一维问题形如：有 n 个非负变量，要求总和为 m，且每个变量小于 M，求方案数。这可以容斥后插板。\n如果不允许走零向量，那就对此套个容斥上去。\n如果 k&gt;0，那么就对此再套个容斥上去。形式化地，设 g(i, j) 表示走了 i 次不能选的向量，走到了 (10j, 10j) 这个位置的方案数。然后再配合组合数就可以容斥了。\n仔细算一下复杂度，发现能过。可能需要记忆化以优化。\n代码\n保镖\n给出一个左部 n 个点右部 m 个点的带点权二分图 G=(V, E)，求集合 S 的个数，使得 S\\subseteq V 且存在一个匹配把 S 中的点都覆盖，且 S 中的点权和 \\ge t。\nn, m\\le 20, t\\le 4\\times 10^8。 霍尔定理霍尔定理指出一个二分图存在完美匹配的条件。定义 N(u) 表示 u 的邻居集合。那么对于二分图 G=(V_l, V_r, E)，不妨设 |V_l| \\le |V_r|。那么 G 存在大小为 |V_l| 的匹配当且仅当 \\forall S \\subseteq V_l,\\; |S| \\le |\\cup_{u\\in S}N(u)|证明如果 G 存在大小为 |V_l| 的匹配，那么此条件显然成立。\n如果此条件成立，那么可以通过一个构造性的算法得到大小为 |V_l| 的匹配： 初始时令匹配集合 M \\gets \\varnothing。\n若 M 的左部点集等于 V_l 就终止算法。\n否则找到一个左部点 u\\notin M，然后尝试寻找増广路。\n如果找到増广路，就増广。然后返回步骤 2。\n否则，对于任意从 u 出发，以左部点结束的路径 P，设 P 上的左部点集合为 S，那么 S 必然不满足上述条件（hall violator）。 简而言之，要点在于：如果找不到増广路，就会出现 hall violator，因此必然有増广路，因此有完美匹配。 题解如果只选择左部点的子集，那么我们可以使用霍尔定理判断。\n而如果选择了两边的点且满足题目给的条件，那么左右两边选择的点集一定分别满足霍尔定理（必要性）。\n我们尝试证明：左右两边选择的点集分别满足霍尔定理的充分性。\n假设左右两边分别满足霍尔定理。\n那么我们先给左边的点集找一个完美匹配。\n然后依次考虑右边点集里的点： 如果这个点已经被覆盖，就不管它。\n否则我们就増广。由于右边满足霍尔定理且右边的点集没满，因此一定有増广路。而且増广的过程只会覆盖更多的点。 这样就证明了充分性。\nTwo Buildings\n给出长度为 n 的序列 h_1, \\ldots, h_n，求 \\max_{1\\le i&lt;j\\le n}(h_i + h_j)(j-i)。\nn\\le 10^6。 分治 决策单调性\n考虑分治。那么我们在左边选一个 i，右边选一个 j。不妨令 g_i = -h_i，将问题转化为：左边选一个 (i, g_i)，右边选一个 (j, h_j)，求 (h_j-g_i)(j-i) 的最大值——即二维平面上的矩形面积。\n这个问题目前看不到什么性质。不过由于是最优化问题，因此我们考虑添加一些限制来导出我们需要的性质。\n如果存在 j_1, j_2 使得 j_1 &lt; j_2，h_{j_1} &lt; h_{j_2}，那么 (j_1, h_{j_1}) 就是无用的。于是我们可以把右边的点筛选一下，剩下的点满足横坐标单增的同时纵坐标递减。\n左边同理，也可以这么筛一下。\n这时就出现了可供利用的性质：决策单调性。 如图。假设 u 对应的最优决策是 y。那么设浅灰色面积为 s_1，深灰色面积为 s_2，则有 s_1 \\le s_2。\n因此对于 u 右边的 v 来说，如果 v 选择 y 左边的 x，那么显然是劣于选择 y 的。\n这就证明了决策单调性。然后就可以再分治了。\n时间复杂度 O(n\\log^2n)。\n代码","title":"2021 省选三轮跟训日志 1","updated":"2025-04-23T04:07:19.272Z"},{"categories":[],"path":"Probset/20-CSP-Training/","tags":[{"name":"WC2021","slug":"WC2021","permalink":"https://notes.sshwy.name/tags/WC2021/"},{"name":"DP","slug":"DP","permalink":"https://notes.sshwy.name/tags/DP/"},{"name":"数据结构","slug":"数据结构","permalink":"https://notes.sshwy.name/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"圆方树","slug":"圆方树","permalink":"https://notes.sshwy.name/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"},{"name":"CSP2020","slug":"CSP2020","permalink":"https://notes.sshwy.name/tags/CSP2020/"}],"text":"Yet Another DAG Problem\n给出一个 n 个点 m 条边边带权 DAG，构造序列 a_1,\\ldots,a_n 使得 a_i&gt; 0。\n\\forall (u,v,w) \\in E, a_u&gt;a_v。 并最小化 \\sum_{(u,v,w)\\in E}(a_u-a_v)w。\nn\\le 18,m\\le \\frac{n(n-1)}{2}。 状压\n首先这题可以 LP，但鉴于 n 较小，有点大材小用。考虑状压。\n由于是 DAG，我们将它整理为分层图的形式，相邻层的距离为 1。把代价拆分到相邻层上即可。\n设 f(S) 表示，G[S]（S 的导出子图）的最小代价。转移时我们枚举下一层的点集 T，使得 S,T 不相交且 \\forall u\\in T，要么 u 是一个入度为 0 的点，要么 \\exists\\,v\\in S,\\,(v,u)\\in E。 新增的代价就是跨过 S,T 的边权的和： f(S\\cup T) \\gets f(S) + \\sum_{u\\in S,v\\in T,(u,v,w)\\in E}w在 DP 的过程中构造方案即可。\n复杂度 O(3^n+2^nn^2)，有一些预处理。\n代码\nRoads and Ramen\n给出一棵 n 个点的无根树，边有黑白两种颜色。有 m 次操作，每次操作选择一条边反转它的颜色。每次操作后求黑边个数为偶数的最长简单路径的长度。\nn\\le 5\\times 10^5,m\\le 5\\times 10^5。 直径\n有两个做法。一个是性质做法，一个是套路做法。\n算法一\n假设树的直径是 AB。\n那么若 AC 和 BC 奇偶性相同，则答案就是 AB。\n否则假设最优解是 EF。那么有 CE 和 CF 的奇偶性相同。因为 AC 和 BC 奇偶性不同，不妨假设 AC 和 CE 奇偶性相同。因为 AB 是直径，所以 FC\\le AC，所以 FD\\le AD，所以 EF\\le AE。因此选 AE 不劣。\n另一种 A-C_1-C_2-B，然后 E-C_1，F-C_2 的情况也可以类似地证明。证明的关键点是 A-C_1 和 B - C_2 奇偶性相同，而 E-C_1，F-C_2 奇偶性不同。\n这样我们就证明了，存在端点是直径端点的最优解。那么维护两棵树的到根路径最优解即可。这个很容易维护。\n时间复杂度 O((m+n)\\log_2n)。\n算法二如何求直径？设 d_u 表示深度。那么我们要求的就是 \\max_{u,v}\\{ d_u+d_v-2d_{\\text{lca}(u,v)} \\}。但是 \\text{lca} 不是一个容易求的东西。考虑欧拉序。那么 \\text{lca}(u,v) 一定在 u 到 v 的欧拉序中出现过。因此直径就转化为了 \\max_{X_u\\le w\\le X_v}\\{ d_u+d_v-2d_w \\}。\n考虑线段树。对区间维护 \\max d_u，\\max_{X_u\\le w}\\{ d_u - 2d_w \\} 和 \\max_{w\\le X_u}\\{ d_u - 2d_w \\}。然后两个区间合并一下即可。\n对于本题，加一个奇偶性讨论上去即可。\n时间复杂度 O((m+n)\\log_2n)。\n防御工事\n给出一个 n 个点 m 条边的连通图。q 次询问： 第 i 次询问给出 k_i 个点。要求你在图上选择一个点 u 使得：等概率随机选择不是 u 的 n-1 个点中的一个点 v，这 k_i 个点中存在不经过 v 到达 u 的路径的点的个数的期望最大。 输出这个最大的期望乘上 n-1 的值。 n\\le 2\\times 10^5, m\\le 5\\times 10^5, q\\le 5\\times 10^5,\\sum k_i\\le 5\\times 10^5。 圆方树 虚树 换根 DP\n建出圆方树。x 能不经过 v 到达 y 等价于圆方树上 x 能不经过 v 到达 y。\n以 u 为根。称询问的点是关键点。则不能（不经过 v）到达 u 的点有且仅有 v 子树中的点。\n因此圆方树上建虚树，虚树上换根即可。\n时间复杂度 O(\\sum k_i + n+m)。\n代码\n微信步数\n考虑 k 维空间里的一个超立方体空间 [1,w_1]\\times [1,w_2]\\times\\cdots \\times [1,w_k]（以下简称空间）。给出一个长度为 n 的二元组序列 (c_i,d_i) 满足 1\\le c_i\\le k，称为行动序列。\n对于一次从 (x_1,\\ldots,x_k) 出发的行动，我们会循环执行行动序列，第 i+nk 步我们会执行二元组 (c_i, d_i) 代表的行动，即 x_{c_i} \\gets x_{c_i} + d_i，直到走出了空间就停止。\n求以空间中的每个点为起点行动的步数的和。\nn\\le 5\\times 10^5, k\\le 10, w_i\\le 10^9, d_i\\in \\{1,-1\\}。 rounding box 高维空间 差分 自然数幂\n对于一个行动序列，定义它的 rounding box 是每一维坐标在变化过程中的极差区间构成的超立方体空间，定义它的行动向量是每一步行动的向量和。感性理解一下。\n用两个向量 (l_1,\\ldots,l_k) （减向量）和 (r_1,\\ldots,r_k) （增向量）表示整个行动序列的 rounding box，其中 l_i 表示第 i 维坐标的最大减量，r_i 表示最大增量。同时用 \\textbf{v} 表示它的行动向量。\n为了方便叙述和实现，我们先对行动序列处理一下，使得 \\mathbf{v} 的每一维都非负。直观的说，让 \\mathbf{v} 的方向指向“右上角”。这样的变换不影响答案。\n考虑走不超过 n 步就走出场地的点。可以枚举 i，计算走恰好 i 步走出空间的点数，也就是【前 i-1 步的 rounding box 在空间内】的点数减去【前 i 步的 rounding box 在空间内】的点数。\n接下来考虑不属于上述类的点。\n行动的过程可以概括为：从起点 x 出发，先走若干次（可能为 0）行动向量到达一个点 y，然后走 n+j 步（1\\le j\\le n）走出空间。\n为什么要这么分类如果我们将行动过程概况为：从起点 x 出发，先走 t 次（可能为 0）行动向量到达一个点 y，然后走 j 步（1\\le j\\le n）走出空间。\n那么就会发现：当 t=0 和 t=1 对应的 y 的点集之间的关系不能简单地用 \\mathbf{v} 的信息表示，因此难以合并计算。 接下来考虑 y 的分布。固定 j。\n要求从 y 点恰好在 n+j 步走出空间，合法的 y 的个数相当于【前 n+j-1 步的 rounding box 在空间内】的点数减去【前 n+j 步的 rounding box 在空间内】的点数。差分 y 的分布，将问题转化为：y 分布在一个超立方体内，求所有 y 的贡献和。\n考虑分布在【走 n+j 步的 rounding box】的 y 的贡献。一个 y 的贡献可拆分为： 从 y+\\mathbf{v} 走 j 步走出边界的贡献和。\n从 x 走到 y+\\mathbf{v} 的贡献和。 容易发现，【走 n+j 步的 rounding box】的减向量与原行动序列的减向量相同，仍是 (l_1,\\ldots,l_k)。用 (r'_1,\\ldots,r'_k) 表示其增向量。\n则 y 的限制是 l_i&lt; y_i \\le w_i - r'_i。\n第一部分为了计算从 y+\\mathbf{v} 走 j 步走出边界的贡献和，我们要先考虑有多少个 x 能走到 y。\n考虑固定 y，计算有多少个可以到达 y 的起点 x。那么 x 的限制是 x_i &gt; l_i（1\\le i\\le k），此外 x+t\\mathbf{v} = y（t\\ge 0）。这样的 x 的个数是 f(y) = \\min_{1\\le i\\le k}\\left\\lfloor \\frac{y_i-l_i-1}{\\mathbf{v}_i}\\right\\rfloor+1考虑从 y+\\mathbf{v} 走 j 步走出边界的贡献和，即： j\\times\n\\sum_{y_1=l_1+1}^{w_1-r'_1}\n\\sum_{y_2=l_2+1}^{w_2-r'_2}\\cdots\n\\sum_{y_k=l_k+1}^{w_k-r'_k} f(y)记 p_i = w_i-r'_i-l_i-1。上式可以化简为 j\\times \\sum_{t\\ge 0} \\prod_{i=1}^k\\max(0,p_i-t\\mathbf{v}_i+1)。\n化简过程\n\\begin{aligned}\n&\\sum_{y_1=l_1+1}^{w_1-r'_1}\n\\sum_{y_2=l_2+1}^{w_2-r'_2}\\cdots\n\\sum_{y_k=l_k+1}^{w_k-r'_k}\n\\min_{1\\le i\\le k}\\left\\lfloor \\frac{y_i-l_i-1}{\\mathbf{v}_i}\\right\\rfloor+1\\\\\n=& \\sum_{y_1=0}^{p_1}\n\\sum_{y_2=0}^{p_2}\\cdots\n\\sum_{y_k=0}^{p_k}\n\\min_{1\\le i\\le k}\\left\\lfloor \\frac{y_i}{\\mathbf{v}_i}\\right\\rfloor+1 \\\\\n=& \\sum_{t\\ge 1} \\sum_{y_1=0}^{p_1}\n\\sum_{y_2=0}^{p_2}\\cdots\n\\sum_{y_k=0}^{p_k}\n\\left[\\min_{1\\le i\\le k}\\left\\lfloor \\frac{y_i}{\\mathbf{v}_i}\\right\\rfloor+1\\ge t \\right] \\\\\n=& \\sum_{t\\ge 0} \\sum_{y_1=0}^{p_1}\n\\sum_{y_2=0}^{p_2}\\cdots\n\\sum_{y_k=0}^{p_k}\n\\left[\\min_{1\\le i\\le k}\\left\\lfloor \\frac{y_i}{\\mathbf{v}_i}\\right\\rfloor \\ge t \\right] \\\\\n=& \\sum_{t\\ge 0} \\sum_{y_1=0}^{p_1} [y_1 \\ge t\\mathbf{v}_1]\n\\sum_{y_2=0}^{p_2} [y_2 \\ge t\\mathbf{v}_2]\\cdots\n\\sum_{y_k=0}^{p_k} [y_k \\ge t\\mathbf{v}_k] \\\\\n=& \\sum_{t\\ge 0} \\prod_{i=1}^k\\max(0,p_i-t\\mathbf{v}_i+1)\n\\end{aligned}\n考虑如何计算上式。容易发现当存在 p_i-t\\mathbf{v_i} &lt; 0 时整个式子的值就是 0。因此可以把 \\max 去掉。\n设 q = \\min_{1\\le i\\le k}\\lfloor\\frac{p_i+1}{\\mathbf{v}_i}\\rfloor，则上式可以化简为 j \\sum_{t = 0}^q \\prod_{i=1}^k(p_i-t\\mathbf{v}_i+1)。\n连乘积可以看作一个关于 t 的 k 次多项式 F(x) = \\sum_{i}f_ix^i，则可以化简为 j\\sum_{i=0}^kf_i\\sum_{t = 0}^qt^i。\n后者是个 k 次前缀和的式子。可以 O(k^2) 预处理 O(k) 计算。\n计算过程设 f(n,k) = \\sum_{i=0}^n i^k。考虑差分，定义 f_0(n,k) = f(n,k), f_i(n,k) = f_{i-1}(n,k) - f_{i-1}(n-1,k)（i&gt;0）。差分 k+1 次，就会变成常数序列。\n那么用 f_i(i,k) 计算对 f(n,k) 的贡献即可。容易发现这是个格路计数问题。\n因此可以 O(k^2) 预处理 O(k) 计算。 第二部分考虑从 x 走到 y+\\mathbf{v} 的贡献和。枚举走了 t 轮行动序列到 y（即 x+t\\mathbf{v} = y）。同时我们要求 l_i&lt;x_i，因此贡献和为 n\\times \\sum_{t\\ge 0}(t+1)\\sum_{y_1=l_1+1}^{w_1-r'_1}\n\\sum_{y_2=l_2+1}^{w_2-r'_2}\\cdots\n\\sum_{y_k=l_k+1}^{w_k-r'_k} \\prod_{i=1}^k [y_i - t\\mathbf{v}_i&gt; l_i]化简得到 n\\sum_{t\\ge 0}(t+1) \\prod_{i=1}^k(p_i - t\\mathbf{v}_i + 1)。\n化简过程\n\\begin{aligned}\n&\\sum_{t\\ge 0}(t+1)\\sum_{y_1=l_1+1}^{w_1-r'_1}\n\\sum_{y_2=l_2+1}^{w_2-r'_2}\\cdots\n\\sum_{y_k=l_k+1}^{w_k-r'_k} \\prod_{i=1}^k [y_i - t\\mathbf{v}_i&gt; l_i] \\\\\n=& \\sum_{t\\ge 0}(t+1)\\sum_{y_1=0}^{p_1}\n\\sum_{y_2=0}^{p_2}\\cdots\n\\sum_{y_k=0}^{p_k} \\prod_{i=1}^k [y_i \\ge t\\mathbf{v}_i] \\\\\n=& \\sum_{t\\ge 0}(t+1) \\prod_{i=1}^k(p_i - t\\mathbf{v}_i + 1)\n\\end{aligned}\n可以用与第一部分类似的方法处理。\n算上枚举 j 的复杂度，总复杂度 O(nk^2)。\n代码\n烟花表演\n给出一棵 n 个点边带权的有根树。要求改变边的长度使得所有叶子结点的深度相同。将一条长度为 w 的边改成 w' 的代价是 |w-w'|（w'\\ge 0）。\nn\\le 6\\times 10^5, w_i\\le 10^9。 凸函数 拐点 可并堆 DP\n设 f_u(x) 表示将结点 u 子树的叶子到 u 的距离调整为 x 的最小代价。用 s(u) 表示 u 的儿子结点集合，那么我们可以将转移过程分成两个部分： 把 u 连一条长度为 w 的边到它的父亲。即设 g_u(x) 表示把 u 的儿子调整到 u 的父亲距离为 x 的最小代价，那么 g_u(x) = \\min_{0\\le i \\le x}\\{ f_u(i) + |w-x+i| \\}。\n将 u 的儿子的贡献合并：f_u(x) = \\sum_{v\\in s(v)}g_v(x)。 为了高效维护这两种操作，我们需要重点分析第一个转移的性质。\n感性理解一下，f_u 其实是 O(n+m) 个绝对值函数的“和”，可以认为 f_u 具有凸性（下凸壳）。算法的过程会证明这一点，因此我们先认为它是对的。\n同样显然的是，f_u 是个直线围成的凸壳，直线的斜率是整数。\n分析 g_u 的转移。为了方便叙述，省略下标 u。\n固定 x，则 |w-x+i| 取到最小值当且仅当 i=x-w。另一方面，不妨设 f 的最小值区间是 [L,R]。\n注意到绝对值函数顶点两边的斜率是 -1 和 1，而 f 函数 L 左边的斜率 \\le -1，R 右边的斜率 \\ge 1。换言之我们应当优先满足 f 的最优性再考虑绝对值函数的最优性。\n对于转移式 g(x) = \\min_{0\\le i \\le x}\\{ f(i) + |w-x+i| \\}\n当 x &lt; L 时，f(i) 为最小值的条件是 i=x。因此有 g(x) = f(x) + w。\n当 L\\le x &lt; L+w 时，f(i) 为最小值的条件是 L\\le i &lt; \\min(L+w,R+1)。而注意到 x-w&lt;L，因此当 i=L 时 f 取到最小值，绝对值函数取到极小值，即 g(x) = f(L) + w-x+L。\n当 L+w \\le x\\le R+w 时，让 i=x-w 可以使 f 和绝对值函数同时取到最小值，则 g(x) = f(x-w) = f(L)。\n当 R+w &lt; x 时，让 i=R 可以使 f 取到最小值，此时绝对值函数取到极小值，则 g(x) = f(R) + |w-x+R| = f(L) + x-w-R。 接下来考虑怎么维护 f。\n上述过程的实质是平移、加一段斜率为 -1 的直线、将凸壳的右边替换为斜率为 1 的直线。\n考虑用可重集维护拐点的横坐标。一个拐点会导致其右边的斜率加 1。再维护一下最后一个拐点右边的斜率 k，就可以表示整个凸包了。 对于第一种转移，我们只需要找到一个 L 和 R（L 不唯一，R 唯一），然后将 R 右边的拐点删掉，将 L 和 R 分别变成 L+w,R+w 即可，然后把 k 改成 1。将一个 L 变成 L+w 相当于加一段斜率为 -1 的直线。 对于第二种转移，相当于点值相加，那么合并可重集，k 相加即可。 为了维护上述可重集，我们还需要支持：找到 L 和 R。这个并不难。由于一个拐点会导致其右边的斜率加 1，而我们知道最后一个拐点右边的斜率，那么我们可以删除横坐标最大的 k-1 个拐点就可以找到 R，然后再删 R 就可以找到 L。\n一个拐点右边的斜率恰好等于 u 的儿子数，因此复杂度有保证。\n最后考虑如何计算答案。我们知道 f(0) 等于边长之和，这样就可以计算出 f(L) 处的点值了。\n不妨用可并堆维护可重集。时间复杂度 O(n\\log_2n)。\n代码\n硬件包管理器\n有 n 个三元组 (t_i,a_i,b_i) 和 m 个限制，第 j 个限制形如 (l_j,r_j)，表示要求将区间 [l_j,r_j) 的三元组的 t 调整为 \\ge t_{r_j}。将 t_i 调整为 t'_i 的代价是 a_i\\max(t_i-t'_i,0) + b_i\\max(t'_i-t_i,0)。\n求满足所有限制的最小调整代价。\nn\\le 3\\times 10^5, m\\le 3\\times 10^5。 凸函数 拐点 可并堆 DP\n限制可以处理成树形结构。接下来就和烟花表演的思路类似了。\n设 f_u(x) 表示让子树 u 的 t 都 \\ge x 的最小代价。有 g_u(x) = \\sum_{v\\in s(u)} f_v(x)。\nf_u(x) = \\min( \\min_{x\\le i\\le t_u}g_u(i)+(t_u-i)a_u, \\min_{i\\ge t_u,i\\ge x} g_u(i) + (i-t_u)b_u )。 第二个转移可以理解为，给 g_u 加上一个类绝对值函数，然后把斜率小于 0 的部分改成水平直线。\n相当于加一个横坐标为 t_u 的拐点。\n这次我们用二元组 (x,y) 表示拐点的横坐标以及这个拐点对斜率的增量。就可以用可并堆维护了。\n这题的可并堆是小根堆。求答案的时候用 f(10^5) 减掉差值。\n代码\n寿司早餐\n给出 n 个 d 位线性基 B_1,\\ldots,B_n，问他们的张成空间的并（去重）的第 k 大。\nn\\le 12, d\\le 50, k\\le 10^{18}。 线性基 线性基合并 容斥\n数理题。\n记线性基 B 张成的线性空间为 V=\\text{span}(B)。\n我们要求的是 U = \\text{span}(B_1)\\cup \\cdots \\cup \\text{span}(B_n) 中的第 k 大。\n可以转化为，枚举 i，固定前缀 \\overline{u_1\\ldots u_i}，求 U 中以 \\overline{u_1\\ldots u_i1} 为前缀的向量的个数。\n计数问题可以容斥，则枚举 [n] 的子集 S，求 \\bigcap_{j\\in S}\\text{span}(B_j) 中以 \\overline{u_1\\ldots u_i1} 为前缀的向量的个数。\n引理 1：两个线性空间的交仍是线性空间。\n证明对于两个线性空间 V_1,V_2，如果向量 a,b 满足 a,b\\in V_1\\cap V_2，则有 a\\oplus b\\in V_1，a\\oplus b\\in V_2，则 a\\oplus b \\in V_1 \\cap V_2。 因此问题转化为如何求两个线性空间交的线性基。\n引理 2：对于两个线性基 B_1,B_2，设 W=\\{v \\in B_2 | v\\in \\text{span}(B_1)\\}，即 B_2 中能被 B_1 表示的向量基。若 \\text{span}(B_1)\\cap \\text{span}(B_2\\setminus W) = \\varnothing，即 B_1 与 B_2\\setminus W 线性无关，则 W 是 \\text{span}(B_1)\\cap \\text{span}(B_2) 的一组线性基。\n设 B_1 = \\{a_1,\\ldots,a_x\\}，B_2=\\{b_1,\\ldots,b_y\\}。\n证明不妨设 W = \\{b_1,\\ldots,b_z\\}（z\\le y）。\n对于任意向量 v\\in \\text{span}(B_1)\\cap\\text{span}(B_2)，v 能被 a_i 和 b_i 分别表示。\n假设 v = \\sum A_ia_i = \\sum B_ib_i，那么 \\sum A_ia_i - \\sum_{i\\le z}B_ib_i = \\sum_{z&lt;i\\le y}B_ib_i。\n式子的左边是用 B_1 和 W 表示的，式子的右边是用 B_2\\setminus W 表示的。\n由于 W 可以被 B_1 表示，因此左边可以只用 B_1 表示。\n因为 B_1 与 B_2\\setminus W 线性无关，因此等式右边必须为 0，否则等式不可能成立。\n注意到这个等式是对任意 v\\in \\text{span}(B_1)\\cap\\text{span}(B_2) 成立的。换言之对任意 v\\in \\text{span}(B_1)\\cap\\text{span}(B_2) 都有等式的右边为 0。\n因此 B_i = 0（z&lt;i\\le y），因此 v=\\sum_{i\\le z}B_ib_i，即 v 可以被 W 表示，即 v\\in\\text{span}(W)。\n因此 \\text{span}(B_1)\\cap\\text{span}(B_2) = \\text{span}(W)。 但问题在于，对于两个线性基 B_1,B_2，并非总是存在 W=\\{v \\in B_2 | v\\in \\text{span}(B_1)\\} 使得 B_1 与 B_2\\setminus W 线性无关。因此我们需要构造一个线性基 B_2'，使得 \\text{span}(B_2) = \\text{span}(B_2') 且对于 W'=\\{v \\in B'_2 | v\\in \\text{span}(B_1)\\}，有 B_1 与 B_2'\\setminus W' 线性无关。\n设 B_2' = \\{c_1,\\ldots,c_y\\}。对于 b_i： 如果它能被 a_1\\ldots,a_x, b_1\\ldots,b_{i-1} 线性表出，那么随便取一种表出方案，设 b_i = p_1a_1+\\cdots + p_xa_x+q_1b_1+\\cdots + q_{i-1}b_{i-1}，那么令 c_i = p_1a_1+\\cdots + p_xa_x。\n否则，令 c_i = b_i。 构造的正确性首先证明 B_1 与 B_2'\\setminus W' 线性无关。\n这是显然的。因为 B_2'\\setminus W' = \\{c_i | c_i = b_i\\}，因此这些基与 B_1 可以合并成一个线性基。而一个线性基的划分显然是互相线性无关的。\n接下来证明 B_2 能被 B_2' 表示（相当于证明 B_2' 是合法的线性基）。容易发现 b_i 可以用 c_i 和 b_1, \\ldots, b_{i-1} 表示。当 i=1 时始终有 b_1 = c_1，使用归纳法可以证明 b_i 能被 c_1,\\ldots,c_i 表示。 实现上述构造算法的时候，我们维护 a_1\\ldots,a_x, b_1\\ldots,b_{i-1} 构成的线性基 T，并维护 T 中的每个向量是 a_1\\ldots,a_x, b_1\\ldots,b_{i-1} 中哪些向量的和（一种方案即可），用二进制数表示。\n已知线性基求张成空间中前缀为 \\overline{u_1\\ldots u_i1} 的向量个数可以 O(d) 计算。\n直接枚举 [n] 的子集容斥的复杂度是 O(n2^nd^2)。从去掉最后一个数的基转移可以优化到 O(2^nd^2)。预处理出线性基后容斥的复杂度是 O(2^nd\\log_2k)，因此总复杂度 O(2^n(d^2+d\\log_2k))。\n代码","title":"WC 赛前训练日志 1","updated":"2025-04-23T04:07:19.272Z"},{"categories":[],"path":"Probset/Summery-for-practice/","tags":[],"text":"构造题Atcoder5093题面\n考虑增量。对于一个大小为 k 的图，我们加一个点进去。那么我们求出原本这个图的哈密尔顿回路的最大值 M，则我们新连的边只要大于 M，就不会和以前的路径冲突。现在我们考虑新连的路径互不冲突。考虑构造一个序列 a=\\left\\langle 1,2,4,7,12,20,29,38,52,73 \\right\\rangle 这个序列满足所有的 a_i 和 a_i+a_j 是互不相同的。因此我们第 k+1 个点连向第 i 个点的边权设为 (M+1)\\times a_i。这样就行了。\n代码\nAtCoder 5167题面\n考虑分治，每次把当前点集分成两个点集，连二分图，然后左右递归做。\n由于左右两边点集不相交，因此两边递归下去连出来的二分图也是不相交的。\nlevel 就是当前递归的层数。\n标算是一个鬼畜的 lowbit 构造法，不太可扩展。\n代码\n字符串CF 427D题面\n一个串建 SAM，另一个串在上面跑就行了。跑的时候要记一下另一个串的当前长度和状态数。\n代码\nCF 316G3题面\n把所有串（包括第一个串）连起来，加一个分隔符（&#123;）建一个 SAM，统计状态数的时候分串统计。然后统计每个状态的贡献就行。\n代码\nCF 204E题面\n建一个广义 SAM，然后用 Map 统计一下各个串是否经过这个状态以及经过次数，统计的时候和状态数乘一乘就行。\n代码\nZJOI2015 诸神眷顾的幻想乡题面\n最多只有 20 个叶结点，所以以每个叶结点为根分别建 Trie，然后合并成一个 Trie，然后在 Trie 上 BFS，每次从父节点的 Last 扩展为当前的结点建 SAM。然后统计本质不同状态数就行。\n代码\n数据结构ZR 1037C题面\n长度相同的一起处理，本质不同的长度是根号级别的。复杂度 O(\\sqrt{n})。\nCF 438D题面\n线段树，均摊\n代码\nUOJ 228题面\n对于区间 \\max-\\min\\le 1 的情况开根，有两种情况： 开根后差仍为 1，相当于一个区间减；\n开根后变成相同的数，相当于区间覆盖； 对于这两个标记，在区间覆盖的时候清空区间加的标记；在下传的时候先覆盖再加。均摊 O(n\\log_2n\\log_2\\log_2n)。\n代码\nLOJ 121每条边存在的时间是一个区间，那么我们按时间建线段树，然后每个区间被分成 log 个标记。于是我们在线段树上 DFS，使用可撤消并查集维护连通性即可。\n代码\nBZOJ1568 JSOI2008李超线段树，标记永久化一下，即查询的时候查询路径上的标记。复杂度 O(n\\log_2n)。\n代码\nBZOJ2038典型的莫队。注意 Luogu 的数据可能区间长度为 1。在提交的时候要删调试的文件（吃一发 WA）\n代码\nCF1221F显然可以把所有点都放到 y=x 上方，这样转化之后有 \\forall(x,y),x&lt;y。\n考虑将所有点按照纵坐标从小到大排序。则我们做一个横着向上的扫描线，每次加入一些点后，我们相当于要合理画出一条竖线，使得横线，竖线，y=x 围成的三角形内的点权和减掉三角形直角边边长最大。这本质就是线段树上最大右边缘区间和，可以直接维护。在扫描线向上延伸的时候要在对应结点减去前后位置的差，这样就可以顺便减掉边长（可以理解为边长差分）。\n离散化一下，显然正确性不会变。\n代码\nZJOI2019 线段树\n题面较长。 容易想到，转化为概率问题。每次我们的操作有 \\frac{1}{2} 的可能被执行。不妨设 f(u) 表示线段树的结点 u 的 tag 值为 1 的概率。那么我们执行一次操作，结点的 f(u) 会怎么变化？\n我们将一次操作中的结点分类： 黑点代表被完全覆盖，红点表示被部分覆盖，灰点表示它有可能接受父节点的 pushdown。\n若进行一次操作： 黑点的 f(u) 是 1；\n红点的 f(u) 是 0；\n灰点的 f(u)，取决于其祖先的点上是否有 tag。 因此光定义 f(u) 并不能很好地处理灰点的情况。我们还定义 g(u) 表示，u 及其祖先中出现 tag 值为 1 的概率。\n对于 g(u)，若进行一次操作： 黑点的 g(u) 为 1（它自己有 tag）；黑点的儿子（子树）的 g(u) 也是 1；\n红点的 g(u) 为 0；\n灰点的 f(u) 为 g(u)，而 g(u) 则不变。 因此我们得到了转移的式子： 黑点：f(u)=\\frac{1}{2}(f(u)+1)，g(v)=\\frac{1}{2}(g(v)+1)(v\\in T_u)；\n红点：f(u)=\\frac{1}{2}f(u)，g(u)=\\frac{1}{2}g(u)；\n灰点：f(u)=\\frac{1}{2}(f(u)+g(u))。 使用线段树维护即可。\n时间复杂度 O(n\\log_2n)。\n代码\n子异和\n设 f(S)=\\bigoplus_{x\\in S}x，设 F(S)=\\sum_{T\\subseteq S} f(T)。\n给出一棵 n 个点带点权树。要求支持 m 次操作： 路径的权值都异或 x；\n求路径的权值集合的 F 值。 n,m\\le 2\\times 10^5,a_i\\le 10^9。 位运算 按位考虑 线段树 树链剖分\n首先考虑 F 怎么算。先按位考虑。那么问题转化为 01 集合的 F 值。设该集合有 x 个 0，y 个 1。那么可以得到 F(S)=2^{x+y-1}[y&gt;0]。于是我们发现这只和集合大小有关。\n考虑树上的问题，那么我们的问题就转化为 01 点权树的操作。然而树链剖分维护的复杂度是 O(n\\log_2^2n) 的，再加上按位考虑就是 O(n\\log_2^3n) 的。\n不妨把所有位合在一起考虑。因为我们只需要查询当前路径的第 k 位上是否有 1。那么也就是查询路路径 or。要支持路径 or，路径 xor，我们可以维护 a_u,b_u,c_u 分别表示当前区间的数哪些位都是 1，哪些位都是 0，哪些位是 01 都出现了的。那么在区间异或的时候对 a_u,b_u 做一些位运算即可。在向上合并信息的时候可以用 a,b 更新 c。\n总时间复杂度 O(n\\log_2^2n)。\n代码\n图论AtCoder 5168题面\n每行，每列建点，那么在 (x,y) 放一个权值为 w 的卡相当于连一条 (x,y,w) 的边。我们选的方案则一定是一个基环树森林。基环树点数等于边数，则每一条边可以不重不漏地选择一个端点，相当于在这一行（列）被选。于是像找 MST 一样贪心找最大权基环树森林就行。\n代码\nBZOJ1001 狼抓兔子最小割的题，Get 到了一个给无向边建流的 Trick。似乎更好的做法是平面图最小割转对偶图最短路，但我懒所以直接 Dinic 过了。\n代码\nZR 308动态加点求桥。\n可以离线并查集维护。首先读下来所有边并建出一个桥的生成树（即加入并查集的边构成的树）。然后再扫一遍边集，如果遇到桥就加 1，否则就删除两点路径上的边的桥标记。使用并查集树上的合并技巧即可。\n时间复杂度 O(n\\log_2n)。\n代码\nCF1243 0-1MST求的是 0 连通块的个数。每次加入一个点，看这个点可以和当前的哪些连通块合并，于是遍历所有与这个点有关的边，统计到每个连通块的边数，就可以判断是否存在 0 的边。\n时间复杂度 O(n\\log_2n+m)。O(n\\log_2n) 是并查集。\n计数AtCoder 5169题面\n一个计数题。首先我们要知道，给 n 个人分不超过 r 个球的方案数是 \\dbinom{n+r}{r} 的。相当于给 n+1 个人分 r 个球，第 n+1 个人是一个工具人。\n题意要求从大到小排序后 a_m=a_{m+1}，则我们转化为求 a_m&gt;a_{m+1} 的方案数，然后用总方案数减。\n我们枚举 x，则转化为求出 a_m=x,a_{m+1} \\le x-1,\\sum_{i=1}^na_i\\le S，的方案数。用差分的方法转化为求 a_m\\ge x,a_{m+1}\\le x-1,\\sum_{i=1}^na_i\\le S 的方案数。然后对 a_{m+1\\sim n}\\le x-1 容斥一下，这样相当于球的上限是 S-mx-ix，i 是枚举的 a_k&gt;x 的个数。\n代码\nCF1221G定义 f(S) 表示边权属于集合 S 的方案数。这样容斥一下： Ans=f(0,1,2)-f(0,1)-f(1,2)-f(0,2)+f(0)+f(1)+f(2)-f(\\varnothing)接下来挨个分析： 显然，f(0,1,2)=2^n。\nf(0,2) 相当于每个连通块染一种颜色，则设连通块数量为 C，那么 f(0,2)=2^C。\nf(0) 相当于每个点权值为 0，但孤立点则权值任意。设孤立点个数为 I，则 f(0)=2^I。\nf(2)=f(0)。\nf(1) 即二分图染色。如果存在非二分图连通块则 f(1)=0；否则 f(1)=2^C。\nf(\\varnothing) 与边数有关，如果边数为 0 则 f(\\varnothing)=2^n，否则 f(\\varnothing)=0。\nf(1,2)=f(0,1)。 最后考虑 f(0,1)，它相当于是图的独立集个数。则设 f(S) 表示 G 的导出子图 G[S] 的独立集数。那么显然可以枚举当前点是否属于独立集来计数。而合法的状态数不多。采用记忆化搜索，事实上最多枚举 2^{\\frac{n}{2}} 次，然后剩下的就根据记忆化的结果直接返回，复杂度是 O(2^{\\frac{n}{2}}) 的。\n总复杂度 O(2^{\\frac{n}{2}})。\n代码\nLG4980Polya 模板题 Ans=\\frac{1}{n}\\sum_{i=1}^nn^{\\gcd(n,i)}\\\\\n=\\frac{1}{n}\\sum_{d|n}n^d\\varphi\\left(\\frac{n}{d}\\right)代码\nBZOJ1002 轮状病毒正解是基尔霍夫矩阵树定理，但递推式很简单，f_i=3f_{i-1}-f_{i-2}+2。\n高精度即可。\n代码\nBZOJ3202 SDOI2013 项链题解 1\n题解 2\n总结一下这题的细节与技巧： 不能费马小定理求逆元，因为模数有时不是质数。\nLL 乘快速幂的时候要先取模，不然可能溢出。\n注意掌握莫比乌斯反演与容斥的小技巧。 代码\nBZOJ1547 周末晚会通过 Burnside 定理转化为求 01 链的相邻 1 个数不超过 k 的方案数，并且要求首尾的 1 连起来个数不超过 k。\n如果 n\\le k 那么可以随便染。如果 n&gt;k,d\\le k 则环数不超过 k，只要不全染 1 就没事。否则考虑 DP。\nf[i,j] 表示 i 个数末位 k 个为 1 的方案数（不考虑首位和的情况）。最后减掉不合法的方案即可。\n代码\nZR996 空具体就看题解了。记两个 Trick。\n首先是字符串子序列匹配方案数和具体的字符是没有关系的，因此枚举最后一段的长度可以转化为组合计数问题。\n然后就是组合数化简的技巧：对于 f(n,k)=\\sum_{i=0}^n\\binom{i+k}{k}p^i，可以写成递推的形式： \\begin{aligned}\nf(n,k)&=\\sum_{i=0}^n\\binom{i+k-1}{k-1}p^i+\\sum_{i=0}^n\\binom{i+k-1}{k}p^i\\\\\n&=f(n,k-1)+\\sum_{i=0}^n\\binom{i+k-1}{i-1}p^i\\\\\n&=f(n,k-1)+\\sum_{i=0}^{n-1}\\binom{i+k}{i}p^{i+1}\\\\\n&=f(n,k-1)+p\\sum_{i=0}^{n}\\binom{i+k}{i}p^i-\\binom{n+k}{n}p^{n+1}\\\\\n&=f(n,k-1)+p\\cdot f(n,k)-\\binom{n+k}{n}p^{n+1}\n\\end{aligned}于是移项得到 f(n,k)=\\frac{f(n,k-1)-\\binom{n+k}{k}p^{n+1}}{1-p}Exercise\n定义一个置换 P 的幂周期为最小 k 使得 P^k=I。\n求长度为 n 的所有置换的幂周期乘积 \\bmod M。\n1\\le n\\le 7500。 min-max 容斥 DP 组合数学\n容易发现，幂周期是环长的 LCM。由于求的是乘积，不妨对每个质因子 p 考虑指数的和。因此我们要求的就是所有幂周期中 p 的指数的和 \\bmod (M-1)。\n设 E(p,x) 表示 p 在 x 中的指数。\n假设环长是 l_1,l_2,\\cdots,l_m。那么 p 的指数就是 \\max E(p,l_i)。 \\begin{aligned}\n\\sum_{l}\\max_{i=1}^m E(p,l_i)\n&=\\sum_{l}\\sum_{\\varnothing\\subset S\\subseteq [m]} (-1)^{|S|-1} \\min_{i\\in S}E(p,l_i)\\\\\n&=\\sum_{l}\\sum_{\\varnothing\\subset S\\subseteq [m]} (-1)^{|S|-1}\\sum_{x\\ge 1}\\prod_{i\\in S}[E(p,l_i)\\ge x] \\\\\n\\end{aligned}不妨设 f(x,p)=\\sum_{l}\\sum_{\\varnothing\\subset S\\subseteq [m]} (-1)^{|S|-1}\\prod_{i\\in S}[E(p,l_i)\\ge x]则原式化为 \\sum_{x\\ge 1}f(x,p)。\n考虑如何计算 f(x,p)。容易发现，它相当于强制要求子集里的环长都是 p^x 的倍数。考虑 DP。设 s=p^x，设 g_i 表示 is 个数的贡献和。那么枚举第一个数所在环的长度，得到 g_i=-\\sum_{j= 1}^i(sj-1)!\\binom{si-1}{sj-1}g_{i-j}前面的负号是容斥系数。那么 f(x,p) 就相当于 n 个数中选择 si 个数（剩下的 n-si 个数随便排），然后统计这 si 个数的贡献： f(x,p)=f'(s)=\\sum_{i= 1}^{\\lfloor\\frac{n}{s}\\rfloor} \\binom{n}{si}(n-si)!g_i那么计算 f(x,p) 的复杂度就是 O(\\frac{n^2}{s^2})。则总复杂度就是 O(\\sum_{i=1}^n\\frac{n^2}{i^2})=O(\\frac{n^2\\pi^2}{6})，能过。\n注意，枚举的时候只枚举 p^x，不要枚举非质因子幂的合数。\n代码\n博弈CF1221E一道不平等博弈的题。由于 a&gt;b，我们考虑 Bob 先手的情况，对于一段连续的.的长度有 4 种情况： x&lt;b；\nb\\le x&lt;a；\na\\le x&lt;2b；\nx\\ge 2b。 如果存在第 2 种情况，那么 Bob 必胜。因为 Alice 能走的 Bob 一定能走，而 Bob 能走的 Alice 不一定能走。\n如果存在第 4 种局面，那么 Bob 可以走一发构造出 2，这样他也赢了。\n第一种局面没用。第三种局面对于 Alice 和 Bob 都是一次性的。\n因此再来考虑 Alice 先手，如果存在 2 那么他就输了；如果存在 2 个及以上的 4 那他也输了。否则可以枚举他走了一步之后的局面，根据局面 3 个数的奇偶性判胜负。\n代码\n期望ABC144 F注意到这是一个拓扑序为 1 到 n 的 DAG，因此我们可以按拓扑序逆序计算每个点到 n 的期望，记为 E(i)。 E(i)=\\frac{1}{deg_i}\\sum_{(i,j)\\in E}E(j)+1现在要求我们删掉一条边，则一个直观的想法是我们计算到达点 i 的概率 P(i)： P(i)=\\sum_{(j,i)\\in E}\\frac{1}{deg_j}P(j)假设我们删掉了 (i,x) 这条边，则 i 这个点的期望就变成了 E'(i)=\\frac{1}{deg_i-1}\\sum_{(i,j)\\in E,(i,j)\\ne (i,x)}E(j)+1于是删掉这条边，期望就变成了 E(1)-P(i)(E(i)-E'(i))。这样就枚举删边更新答案，做完了。\n离线HNOI2016 网格如果所有路径都包括这个点，那么他们的路径交也包括这个点。因此权值线段树上维护路径交，查询的时候在线段树上二分。要先离散化一下变成不同的权值方便删除。\n路径交：边的路径交可以直接取两两 LCA 中最深的两个。点的路径交需要先判是否相交再这么做。\n代码\n贪心CF893 D一个显然的贪心是，只在 a_i=0 的时候充钱。这样不会变劣。\n先检查一下最低限度的充钱会不会爆 d。如果不会爆 d 就在每次 a_i=0 且钱为负数的时候直接充满到 d。如果在某个时刻钱数大于 d，就说明之前有一次充多了，直接把钱数变成 d 即可。因为我们检查了最低限度充钱是有解的，因此正确性保证。\n复杂度 O(n)。\n数论 / 数学ZR1090 A+B Problem算法一：注意到 f(n)=\\sum_{i=0}^na^ib^{n-i}=\\frac{a^{n+1}-b^{n+1}}{a-b}于是直接计算分子，对 (a-b)p 取模，然后除掉 a-b 即可。然而 int128 的精度过不去；\n算法二：注意到 f(2x+1)=(a^{x+1}+b^{x+1})f(x), f(2x)=(a^x+b^x)f(x)-a^xb^x。于是类似快速幂地做就行。复杂度 O(\\log_2n)。\nCF1255 E2设 s_i=\\sum_{j=1}^i a_i。那么原操作可以转化为，将 s_i 加一或减一。这样就是只针对一个数的操作了。\n由于 s_i 是单增的，因此对于一个固定的 k，要把所有 s_i 变成 k 的倍数，我们贪心地把 s_i 变成离它最近的 k 的倍数即可。容易证明这是合法的。代价就是 \\sum\\min(s_i\\bmod k,k-s_i\\bmod k)。\n至于 k，我们只需要选择 s_n 的质因子作为 k 即可。容易证明 k 的约数一定不比 k 劣。这样复杂度为 O(n\\log_2n)。","title":"做题总结","updated":"2025-04-23T04:07:19.274Z"},{"categories":[],"path":"Math/Expectation/Prob/","tags":[{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"},{"name":"Expectation","slug":"Expectation","permalink":"https://notes.sshwy.name/tags/Expectation/"}],"text":"Topcoder12984 TorusSailing考虑矩阵的最后一行和最右一列，我们把所有方格的期望表示为这 n+m-1 个变量的方程。\n然后考虑矩阵的第一行和最左一列，发现可以联立这些方程与最后一行、最右一列的方程。\n这样就可以高斯消元了。消完了再带回去即可求出期望。\n时间复杂度 O((n+m)^3)。\n代码\nHDU4035 Maze设 f(u) 表示结点 u 的期望，那么 f(u)=k_uf(1)+\\frac{1-k_u-e_u}{d_u}\\sum_{(u,v)}(f(v)+1)\\\\我们尝试将 f(u) 表示成 a_uf(p)+b_u+c_uf(1) 的形式，其中 p 是 u 的父节点。首先设 A_u=\\sum_{v\\in Son(u)}a_v\\\\\nB_u=\\sum_{v\\in Son(u)}b_v\\\\\nC_u=\\sum_{v\\in Son(u)}c_v\\\\\nD_u=\\frac{d_u}{1-k_u-e_u}\\\\那么把上式化简可以得到 f(u)=\\frac{f(p)}{D_u-A_u}+\\frac{B_u+d_u}{D_u-A_u}+\\frac{D_uk_u+C_u}{D_u-A_u}f(1)\\\\对于根结点的情况： f(1)=\\frac{B_1+d_1}{D_1-k_1D_1-A_1-C_1}实现的时候注意判无解即可。注意，本题精度要开到 10^{-9}。\n代码\nSHOI2017 分手是祝愿考虑按灯泡的最优策略。我们显然是先找到最大的 1 把它变成 0，然后再找最大的 1 变成 0……\n因此设 f(i) 表示把一个最优按 i 次能全 0 的局面变成按 i-1 次能全 0 的局面的期望步数。显然，当 i\\le k 时你会选最优，即 f(i)=1；否则，你有 \\dfrac{i}{n} 的概率按到一个应该按的灯，剩余的概率则会转移到 f(i+1)。因此得到 f(i)=\\frac{i}{n} + \\frac{n-i}{n}(f(i)+f(i+1)+1)边界情况 f(n)=1,f(0)=0。f(n)=1 是因为你不论按哪个，都能按到你应该按的那个灯。\n于是我们先求出初始局面在最优情况下需要按的次数，假设为 x。那么答案为 n!\\sum_{i=1}^x f(i)时间复杂度 O(n\\log_2n) 或 O(n\\sqrt{n})。\n代码\n歌唱王国\n有 t 个字符集是 \\{1,\\ldots,n\\} 的长度分明为 m_i 的字符串 s_i（模式串）。有 t 次询问，第 i 次询问为：生成一个字符串 T，每次随机在 T 末尾添加一个字符，一旦 T 中出现了 s_i 就停止生成。求 T 长度的期望。\nt\\le 50, n\\le 10^{18}, m_i\\le 10^5。 概率生成函数\n固定 S = s_i。\n第一部分设 f_i 表示长度为 i 时恰好结束的概率，g_i 表示长度为 i 时没有结束的概率。\n显然，对于 i&lt;|S|，有 f_i = 0。\n严谨定义补充严谨地说，f_i 表示随机生成长度为 i 的串，S 仅做为 f_i 后缀出现且仅出现一次的概率。\n而 g_i 表示随机生成长度为 i 的串，S 未出现的概率。 首先根据定义有 f_i+g_i=g_{i-1}。即在 i-1 的长度还没有结束，那么可能会在 i 或者大于 i 的长度结束。\n特殊地，当 i=0 时，f_0=0, g_0=1。\n对于串 S，我们记录 a_i 表示 S[1,i] 与 S[|S|-i+1,|S|] 是否匹配（即是否是 border）。那么我在长度为 i 的状态下直接加入这个串，显然一定会结束。但是，我们还可能会在长度小于 i+|S| 的时候结束（即当我补完一个 border 的时候就结束了）。那么可以得到 \\frac{g_i}{n^{|S|}}=\\sum_{j=1}^{|S|}a_jf_{i+j}\\frac{1}{n^{|S|-j}}解释一下上式的含义： 左边：随机生成长度为 i+|S| 的串 T 满足 T[1,i] 中没有 S 且 T[i+1，i+|S|] = S 的概率。 右边：对 j 求概率和：随机生成长度为 i+j 的串 T 满足 T[1,i+j] 恰好以 S 结尾且 T[i+j+1,i+|S|] = S[j+1,|S|] 的概率。 两者都等价于：在长度属于 [i+1,i+|S|] 这个区间结束的概率。\n整理一下得到 g_i=\\sum_{j=1}^{|S|}a_jn^jf_{i+j}。\n第二部分接下来我们用概率生成函数来改写上式。\n概率生成函数离散随机变量 X 的概率生成函数为 F_X(x)=\\sum_{i=0}^\\infty P(X=i)x^i该函数有两个重要的性质： F_X(1)=\\sum_{i=0}^\\infty P(X=i)=1；\nF_X'(1)=\\sum_{i=0}^\\infty P(X=i)\\cdot i=E(X)。 概率生成函数是普通生成函数的一种特殊情况（被赋予特殊的意义）。 设 F(x)=\\sum_{i\\ge 0}f_ix^i，G(x)=\\sum_{i\\ge 0} g_ix^i。我们要求的就是 F'(1)。\n于是我们可以把定义式改写为 F(x)+G(x)=G(x)\\cdot x+1对两边求导得到 F'(x)+G'(x)=G'(x)x+G(x)\\\\\nF'(x)=G(x)+G'(x)(x-1)因此 F'(1)=G(1)。\n另一种理解方式对于离散变量 x，我们知道 E(x) = \\sum_i P(x = i)\\cdot i = \\sum_{i\\ge 1}P(x\\ge i)。\n而 g_i 可以理解为长度 &gt;i 的概率。因此要求的期望等价于 G(1)。 把 g_i=\\sum_{j=1}^{|S|}a_jn^jf_{i+j} 改写为 G(x) = \\sum_{j=1}^{|S|}a_jn^jF(x)x^{-j}注意，对于 i&lt;|S| 有 f_i=0，因此不会出现负指数项。令 x=1 可以得到 G(1) = \\sum_{j=1}^{|S|}a_jn^jF(1)因为 F(1)=1，因此得到 G(1)=\\sum_{j=1}^{|S|}a_jn^j这样就做完了。\n代码\n硬币游戏\n给出 n 个长度为 m 的互不相同的 01 串 s_i。现在生成一个字符串 T，每次在 T 末尾随机加入一个字符。一旦 T 中出现某个 s_i 就停止。对每个 s_i 求以 s_i 结尾的概率。\nn,m\\le 300。 概率生成函数 高斯消元 SDOI\n设 F_i(x)=\\sum_{j=0}^\\infty f(i,j)x^j，其中 f(i,j) 表示长度为 j 以 S_i 结尾结束的概率。\n设 G(x)=\\sum_{j=0}^\\infty g(j)x^j，其中 g(j) 表示长度为 j 仍未结束的概率。\n我们要求的是 F_i(1),i\\in[1,n]。\n类似地，首先有一个显然的等式： G(x)+\\sum_{i=1}^nF_i(x)=G(x)x+1类似地，设 a_{i,j,k} 表示 S_i[1,k] 与 S_j[m-k+1,m] 是否匹配。那么我们强行在当前状态下插入 S_i，可以得到 G(x)\\left(\\frac{x}{2}\\right)^{|S_i|}=\\sum_{j=1}^n F_j(x)\\sum_{k=1}^m a_{i,j,k} \\left(\\frac{x}{2}\\right)^{|S_i|-k}相当于你在插入的过程中，可能在中途就以 S_j 结尾结束了。\n根据第一个等式，取 x=1 得到 \\sum_{i=1}^nF_i(1)=1第二个等式取 x=1 得到 G(1)=\\sum_{j=1}^nF_j(1) \\sum_{k=1}^m 2^k a_{i,j,k}那么对于 i\\in[1,n] 再加上上面那个式子，我们可以 O(n^3) 高斯消元求出答案了。\n注：eps 要开到 10^{-100}。\n代码\n随机游走\n给定一棵 n 个结点的树，你从点 x 出发，每次等概率随机选择一条与所在点相邻的边走过去。\n有 Q 次询问，每次询问给定一个集合 S，求如果从 x 出发一直随机游走，直到点集 S 中所有点都至少经过一次，期望游走几步。\n特别地，点 x（即起点）视为一开始就被经过了一次。\n答案对 998244353 取模。 FMT 容斥 min-max 容斥 PKUWC\n首先考虑 min-max 容斥。\nmin-max 容斥对于全序集合 S，有 \\max S = \\sum_{T\\subseteq S}(-1) ^{|T|-1}\\min T\n设 x_i 表示走到 i 的时间的期望。那么我们要求的是 \\max x_i，转化为求 \\min x_i，即到达任意一个点的时间的期望。\n这个可以用树上消元在 O(n) 的复杂度计算，答案就是根结点的期望。\n最后容斥的时候可以使用 FMT，把容斥系数带进去即可。\n总时间复杂度 O(2^nn)。\n代码\nCircles of Waiting主元法：对于一类消元问题，可以先将变量用一组主元表示，然后将这些变量的方程与主元联立求解，以降低复杂度。\n对于这道题，我们可以把圆上左边界的点作为主元，具体来说是圆内每行 x 坐标最小的点。那么根据期望方程 F_{x,y}=p_1F_{x-1,y}+p_2F_{x,y-1}+p_3F_{x+1,y}+p_4F_{x,y+1}+1我们可以得到 F_{x+1,y} 的方程式。这样就可以从左边推到右边界。由于右边界之外的点期望是 0，就可以列出 2R+1 个方程。于是高斯消元即可。时间复杂度 O(R^3)。\nGraph Game考虑一棵树的情况。如果在某个时刻我们删掉 A 的时候 B 仍与 A 连通，那么 (A,B) 就会产生 1 的贡献。我们考虑这件事发生的概率。容易发现概率是 A,B 路径长度的倒数（确切地说，这里的长度是指点数）。因此把所有有向路径长度的倒数求和就是答案。\n如果是基环树，那么从 A 到 B 就可能会出现两条路径（即中间夹一个环）。那么有两条路径，如果我们直接把贡献算成两条路径长度倒数和的话，会多算贡献。那么减掉路径并的长度倒数即可。\n证明见官题。\nBingo权值是 2 的幂，相当于子集枚举，可以理解其组合意义为每行每列被选择包含的概率的和。因此得到 \\frac{1}{m^{\\underline{n^2}}\\binom{m}{k}}\\sum_{i=1}^n\\sum_{j=1}^n \\binom{n}{i}\\binom{n}{j}\\binom{m}{k}k^{\\underline{n^2-(n-i)(n-j)}}(m-(n^2-(n-i)(n-j)))^{\\underline{(n-i)(n-j)}}\\\\\n=\\frac{1}{m^{\\underline{n^2}}}\\sum_{i=1}^n\\sum_{j=1}^n \\binom{n}{i}\\binom{n}{j}k^{\\underline{n^2-(n-i)(n-j)}}(m-(n^2-(n-i)(n-j)))^{\\underline{(n-i)(n-j)}}Slime and Biscuits\n给出一个长度为 n 的序列 a，设 s=\\sum_{i=1}^n a_i。每次有 \\frac{a_i}{s} 的概率选择 i，然后等概率选择 1,\\cdots,n 中一个不等于 i 的数 j，然后令 a_i 减一，a_j 加一。当存在某个 a_i=s 时停止操作。问期望时间。\nn\\le 10^5,s\\le 3\\times 10^5。 概率 期望 消元\n容易想到，设 E(x) 表示，在 a_x=s 时结束的期望。答案就是 \\sum_{i=1}^n E(i)。但是要注意，这不是普通意义上的期望。\n普通意义的期望例如丢骰子，丢到 1 的期望时间。那么你丢无限次，丢到 1 的概率是无限趋近于 1 的。也就是说不论哪个局面都可以通过继续丢骰子来丢出 1。\n但是在题目中的游戏的条件下，一旦有某个 y(y\\ne x) 使得 a_y=s，那么游戏就结束了。这种情况对 E(x) 的贡献显然是 0（因为不是在 x 处结束的）。但是它的时间（随机变量）却不一定是 0。是在这个条件下我们强制它的贡献是 0，这个规则是不符合普通期望的定义的。\n换言之，E(x) 其实是一个不完全期望——它只包含所有合法情况的概率乘随机变量值（时间）的和（对于普通的期望，所有的情况最后一定可以导出合法情况）。\n理解了这个，我们再重新审视本题。\n直接计算 E(x) 是困难的，因为我们要求在游戏过程中不能存在某个 y(y\\ne x) 使得 a_y=s。那么我们考虑减去不合法的情况。\n设 E'(x) 表示仅当 a_x=s 时结束游戏时的期望时间。也就是说我们修改了游戏的规则。\n这其中就有不合法的情况，比如先有 a_y=s 出现，然后再把 y 上的转移到 x 上。\n因此我们设 P(i) 表示在原来的游戏规则下，游戏在 a_i=s 处结束的概率。显然有 \\sum_{i=1}^nP(i)=1。\n设 C 表示在修改了游戏的规则的状态下，从 a_i=s 转移到 a_j=s(i\\ne j) 的期望时间。显然这对于所有的 i,j(i\\ne j) 都是相等的。\n那么我们把不合法的情况减掉，建立等式： E(x)=E'(x)-\\sum_{y=1}^{n}[x\\ne y](E(y)+P(y)C)（E(y) 是不用乘 P(y) 的，因为它计算的是不完全期望，概率已经算在里面了）\n那么移项变换一下得到 \\sum_{y=1}^nE(y) = E'(x)-C \\sum_{y=1}^{n}[x\\ne y]P(y)这个是关于 x 的等式。我们把所有关于 1,\\cdots,n 的等式累加，得到 n\\sum_{y=1}^nE(y)=\\sum_{y=1}^nE'(y)-C(n-1)那么只要我们能求出 E'(x) 和 C，就可以求出答案。\n而在修改了游戏的规则的状态下，我们只关心 a_x 的值。其他的值满了 s 也没关系。因此设 f_i 表示 a_x 的值当前为 i，从 i 变成 i+1 的期望时间。那么 有 \\frac{i}{s} 的概率选中自己，那么就会变成 i-1；\n否则有 \\frac{s-i}{s} 的概率选中别的数，那么：\n有 \\frac{1}{n-1} 的概率选中自己，变成 i+1；\n否则不变。 因此就得到了 f_i=\\frac{i}{s}(f_{i-1}+f_i+1)+\\frac{s-i}{s}\\left(\\frac{1}{n-1}+\\frac{n-2}{n-1}(1+f_i) \\right)解得 f_i=(if_{i-1}+s)\\frac{n-1}{s-i}f_0 是可以直接求的。那么显然有 E'(x)=\\sum_{i=a_x}^{s-1}f_i。然后 C=\\sum_{i=0}^{s-1}f_i。\n时间复杂度 O(n\\log_2n)。","title":"概率期望习题总结","updated":"2025-04-23T04:07:19.268Z"},{"categories":[],"path":"Probset/21-WC-Training-1/","tags":[{"name":"WC2021","slug":"WC2021","permalink":"https://notes.sshwy.name/tags/WC2021/"}],"text":"染色问题\n给出一个 n 个点 m 条边无向图，求 k 染色方案数（相邻点异色）。\nn\\le 10^5, m\\le n+5，复杂度与 k 无关。 染色 缩点\n染色数是 NPC 的。注意到 m\\le n+5 的条件。常规思路是理解为一棵树加上若干条非树边，但这并不能方便地处理染色问题。\n问题转化：对于一条边 (u,v)，设 f(u,v), g(u,v) 分别表示 u,v 同色和异色时边的权值。初始时 f(u,v) = 0, g(u,v) = 1。图的权值是边权之积。那么问题转化为求所有染色情况下的图的权值之和。\n对于度数为 1 点 u，假设他连到了 v，那么可以直接删掉它，最后答案乘上 k-1。实际上，应该是答案乘上 (k-1)g(u,v) + f(u,v)。\n对于度数为 2 的点 u，假设它分别连接了 x,y，那么删掉 u，加一条边 (x,y)，有 f(x,y) = g(u,x)g(u,y)(k-1) + f(u,x)f(u,y)。即分 u 与 x,y 同色和异色两种情况考虑。\ng(x,y) = g(u,x)g(u,y)(k-2) + g(u,x)f(u,y) + f(u,x)g(u,y)。即分三种情况考虑。 有一个小细节：如果删除 u 后 x,y 出现了重边，那么应该把两条边合并，权值则是 f 和 g 分别相乘。\n这样图中就只剩下了 3 度及以上的点。即 3n'\\le 2m'。又因为 n+5\\ge m，可以得到 n'\\le 10, m'\\le 15。\n设新图为 G=(V,E)，设 F(i,S) 表示用 i 种颜色对集合 S 中的点染色的方案数。则 F(i,S) = \\sum_{T\\subseteq S}F(i-1,S\\setminus T)\\prod_{(u\\in T,v\\notin T)\\in E} g(u,v)\\prod_{(u\\in T, v\\in T)\\in E} f(u,v)从而算出答案。\n时间复杂度 O(n+m+n'm'3^{n'})。\n代码\nThe Journey of Geor Autumn\n给出 n,k，求有多少个 n 的排列 p 满足 \\forall i\\in[k+1,n]，p_i &gt; \\min_{1\\le j\\le k}p_{i-j}。\nk, n\\le 10^7。 DP\n枚举 1 在排列中出现的位置。显然它只能出现在 p_1,\\ldots,p_k 中。假设 p_x=1。\n那么 p_x 左边的位置可以随便填。右边的位置则是个递归子问题。设 f_n 表示长度为 n 的排列的答案，因此 f_n = \\sum_{x=1}^k {(n-1)}^{\\underline{x-1}} f_{n-x}变换一下可以得到 f_n = (n-1)! \\sum_{x=1}^k \\frac{f_{n-x}}{(n-x)!}那么维护一下 \\frac{f_i}{i!} 的前缀和即可 O(n) 计算。\n代码\nSum of Log\n给出 X,Y，计算 \\sum_{i=0}^X\\sum_{j=[i=0]}^Y[i\\&j=0]\\lfloor\\log_2(i+j)+1\\rfloor。X,Y\\le 10^9。 DP 数位\n即统计 i+j 的二进制位数。\n设 f(i,S) 表示考虑到第 i 位（从高到低或者从低到高都行）的方案数，g(i,S) 表示贡献和。\n状态 S 包括：X,Y 是否到达上界、当前的数字是否为 0（是否有最高位的 1）。\n时间复杂度 O(2^3\\log_2X)。\n代码\nIOer\n给出 u,v,m,n，计算 [x^n]\\prod_{i=1}^m\\frac{1}{1-(ui+v)x}m\\le 2\\times 10^5, n\\le 10^{18}。 生成函数 组合意义\n直接分治 NTT 没有用到 (ui+v) 的特殊形式。\n这个组合意义做法是题解做法，感觉很反思维。\n考虑我们要求的是 \\sum_{t_1+\\cdots + t_m = n}(u+v)^{t_1}(2u+v)^{t_2}\\cdots (mu+v)^{t_m}假装我们有理有据地想到：构造一个序列计数问题。\n我们定义一个球具有编号和颜色两种属性：对于编号 &lt; m 的球，有 u 种颜色可选。对于编号为 m 的球，有 u+v 种颜色可选。两个球不同当且仅当颜色或者编号不同。考虑 求长度为 n+m-1 的球的序列满足： 编号在 [1,m-1] 中的球都有出现；\n设 p_i 表示编号为 i 的球第一次出现的位置，那么 \\forall i&lt;m，有 p_{i-1} &lt; p_i。 的方案数。 枚举序列 p_1,\\ldots,p_{m-1}，那么 p_i 位置上的球有 u 种选法（编号被钦定了）。[1,p_1) 只能放编号为 m 的球，因此有 (u+v)^{p_1-1} 种选法。(p_1,p_2) 能放编号为 1 或者 m 的球，因此有 (2u+v)^{p_2-p_1-1} 种选法。推广得到，总方案数是 u^{m-1}\\sum_p (u+v)^{p_1-1}(2u+v)^{p_2-p_1-1}\\cdots(mu+v)^{n+m-1-p_{m-1}}不妨设 p_0=0,p_m = n+m。\n设 d_i = p_i-1-p_{i-1}，那么得到 u^{m-1}\\sum_d (u+v)^{d_1}(2u+v)^{d_2}\\cdots(mu+v)^{d_m}那么我们只需要求出序列的方案数即可求出答案。\n不妨去掉第二个条件。由于编号 &lt;m 的球的可选颜色数都是 u，因此可以看作等价。则 长度为 n+m-1 的球的序列满足：编号在 [1,m-1] 中的球都有出现 的方案数是 (m-1)!u^{m-1}\\sum_d (u+v)^{d_1}(2u+v)^{d_2}\\cdots(mu+v)^{d_m}这个问题可以容斥：钦定有 i 个编号的球没出现，得到 \\sum_{i=0}^{m-1}(-1)^i\\binom{m-1}{i} ((m-i)u+v)^{n+m-1}这样我们就得到了问题的答案。\nFlip and Reverse\n你有一个 01 串 s，每次你可以选择 s 的一个子串 s[l,r] 满足 s[l,r] 中 01 出现的次数相等，然后将其反转并交换 01 字符（0 变 1，1 变 0）。求若干次操作最小化 s 的字典序，并输出这个新的 s。\n|s| \\le 5\\times 10^5。 折线图 贪心\n01 序列通常可以理解为： 括号序列\n折线图 使用折线图来理解，相当于每次我可以反转一段折线。\n进一步，其实我们不关心折线图的形态，我们只关心每一层的上行和下行的折线数。\n进一步，我们甚至不用区分是上行还是下行。也就是说，记 a_i 表示 i 和 i+1 之间的折线数。那么我们的问题转化成，优先往下走，要求走完所有折线，求路径。\n可以局部贪心。\n朴素策略：在每一步，如果能够往下走就走。\n这个策略有个问题：如果上面存在未走的折线，而下面的折线数是 1（回不来），那么就走不完所有折线了。\n所以特判一下，大于 1 或者上面已经走完了才走下面即可。\n时间复杂度 O(|s|)。\n代码\nLatin Square\n给出一个 n\\times n 的 Latin Square A：每一行每一列都是 n 的排列的矩阵。维护以下操作： 每一行循环左移 / 右移一位。\n每一列循环上移 / 下移一位。\n将每一行的排列取其逆元。\n将每一列的排列取其逆元。 一个排列 p_1,\\ldots,p_n 的逆元是指排列 q 使得 p_{q_i} = i。\n输出最终的矩阵。操作次数不超过 m。\nn\\le 10^3, m\\le 10^5。 矩阵 Latin Square\n考虑排列的逆元：q_{p_i} = i。\n不妨将矩阵映射为三维点：A_{ij} \\to (i,j,A_{i,j})。\n那么对行取逆元相当于：(i,j,A_{i,j}) \\to (i,A_{i,j},j)。我们这个变换并不是原题目中的变换。严格来说，应该每一行再按照第二维坐标排序才行。但注意，我们维护的是三维空间的点集，不存在顺序的问题。\n同理，对列取逆元相当于 (i,j,A_{i,j}) \\to (A_{i,j},j,i)。\n也就是说，取逆元等价于坐标不同维度的交换。之后的部分就 trivial 了。\n代码\n珍珠\n有 n 个 [1,d] 范围内的整数均匀随机变量。问满足以下条件的概率： 可以找出至少 m 个 pair，每个 pair 包含两个值相同的变量。 n,m\\le 10^9, d\\le 10^5。 CTS2019 生成函数\n这题有个很迷的地方。先二项式反演再推 gf 可以很轻松，但直接推 gf 就会有一些高深步骤。\n设 c_i 表示值为 i 的变量的个数。那么条件等价于 \\sum_{i} \\lfloor\\frac{c_i}{2}\\rfloor\\ge m。\n变换一下得到 \\sum_{i}c_i\\bmod 2\\le n- 2m。也就是说出现次数为奇数的变量数 \\le n-2m。\n于是我们设 f_k 表示出现次数为奇数的有 k 个的方案数。方案数除以 d^n 就是答案。\n直接干这玩意可以直接有 f_k = \\binom{d}{k}n![x^n]\\left(\\frac{e^x-e^{-x}}{2}\\right)^k\\left(\\frac{e^x+e^{-x}}{2}\\right)^{d-k}然后就会有一些 神必操作。这里就不复读了。 复读一个稍微好一点的。\n考虑容斥，我们钦定 k 个数出现奇数次，其他的不做限制。那么有 \\sum_{i\\ge k}\\binom{i}{k}f_i = \\binom{d}{k}n![x^n]\\left(\\frac{e^x-e^{-x}}{2}\\right)^ke^{d-k}解释一下序列 \\{0,1,0,1,\\ldots\\} 即 a_i = \\frac{1}{2}(1 - (-1)^i) 的 EGF 是 \\frac{e^x-e^{-x}}{2}，这个序列在 i 是奇数时值为 1，否则为 0。\n(\\frac{e^x - e^{-x}}{2})^k 的含义是选 k 个数出现奇数次的方案数。其他数的方案数就是 e^{d-k}。\n因为是 EGF，得乘上一个 n! 表示系数。 不妨设 g_k = \\sum_{i\\ge k}\\binom{i}{k} f_i。那么 f 可以用 g 容斥（二项式反演）算出。\n这玩意可以这么化简： \\begin{aligned}\ng_k &= \\binom{d}{k}n![x^n]\\left(\\frac{e^x-e^{-x}}{2}\\right)^ke^{(d-k)x} \\\\\n&= 2^{-k}\\binom{d}{k}n![x^n] \\sum_{j=0}^k\\binom{k}{j}(-1)^{k-j}e^{(2j-2k+d)x} \\\\\n&= 2^{-k}\\binom{d}{k}n!k!(-1)^k \\sum_{j=0}^k\\frac{(-1)^j}{j!} \\frac{1}{(k-j)!} [x^n] e^{(2(j-k)+d)x} \\\\\n&= 2^{-k}\\binom{d}{k}n!k!(-1)^k \\sum_{j=0}^k\\frac{(-1)^j}{j!(k-j)!} \\frac{(2(j-k)+d)^n}{n!} \\\\\n&= 2^{-k}\\binom{d}{k}n!k!(-1)^k \\sum_{j=0}^k\\frac{(-1)^j}{j!(k-j)!} \\frac{(2(j-k)+d)^n}{n!}\n\\end{aligned}化简的方向就是，能提到前面去的就提到前面去。\n把 j 和 k-j 相关的部分分开，可以做卷积。卷积的长度是 O(d) 的，故时间复杂度 O(d\\log_2d)。\n树上游走\n给定一颗 n 个点的树，每个点有点权 v_i ，你在点 S 开始随机游走。\n当你离开一个点第二次的时候这个点就会消失，与其相连的所有边也会消失。\n你每次会等概率地选择一个与当前所在节点有边相连的一个未消失节点并前往那个点。\n如果不存在与当前所在节点有边相连的点，你就会停止随机游走并等于获取当前所在节点权值的分数。\n求你获得分数的期望，对 998244353 取模。\nn\\le 10^5, v_i\\le 1000。 DP 期望 分类讨论\n以 S 为根。钦定最后走到的结点是 u。\n记 \\deg u 表示结点 u 的度。\n容易发现，与 u 相邻的结点都必须被删掉。因此 \\deg u \\le 2，否则不可能停在 u。\n从 S 到 u 的简单路径上的点是必经点。由此我们可以按照结点访问顺序（DFS）刻画出 DP 状态。考虑到改变结点度的因素，设 f(u) 表示从 S 出发第一次到达 u 的概率。 \\gdef\\fa#1{\\text{fa}({ #1 })}\n\\gdef\\son#1{\\text{son}({ #1 })}第一部分设 p=\\fa{u} 表示 u 的父节点。那么我们一定先到达 p 再到达 u。从 p 到 u，走 (p,u) 这条边的概率取决于 p 的度。为了方便转移，设 g(u) 表示删掉 p 并第一次到达 u 的概率。\n第一种情况：到达 p 后直接到 u： P_1= \\frac{g(p)}{\\deg(p) - 1} + \\frac{f(p)-g(p)}{\\deg(p)}第二种情况：到达 p 后，先走到 p 的儿子 v（v\\ne u），再走回来，再去 u。这种情况，p 必然会被删除。 P_2 = \\frac{g(p)}{(\\deg(p)-1)^2}\\sum_{v\\in \\son{p},v\\ne u}\\frac{1}{\\deg(v)}\n+ \\frac{f(p) - g(p)}{\\deg(p)^2}\\sum_{v\\in \\son{p},v\\ne u}\\frac{1}{\\deg(v)}第三种情况：到达 p 后，走到 p 某个儿子 v（v\\ne u）的子树中的某个结点 z（z\\in \\son{v}, z\\ne v），然后走回 p。第二次到达 p 时，\\deg(p) 会发生变化，因为 v 会被删除。这种情况下，p 也会被删除。\n不妨设 v 到 z 简单路径上的点顺次构成序列 a_1,\\ldots, a_k（a_k = z）。那么可以发现除了 a_k，其他结点都会被删。因此 a 的贡献是 w(a) = \\frac{1}{\\deg(a_{k-1})^2\\deg(a_k)} \\prod_{i=1}^{k-2}\\frac{1}{(\\deg(a_i)-1)\\deg(a_i)}于是 P_3 = \\frac{g(p)}{(\\deg(p)-1)(\\deg(p)-2)}\\sum_{a:a_k = z} w(a)\n+ \\frac{f(p) - g(p)}{\\deg(p)(\\deg(p)-1)}\\sum_{a:a_k = z} w(a)第四种情况：要删除 p，还有一个走法：\\fa{p} \\to p \\to \\fa{p} \\to p \\to u。这个走法会同时删除 \\fa{p} 和 p： P_4 = \\frac{g(\\fa{p})}{(\\deg(\\fa{p}) -1)^2\\deg(p)(\\deg(p)-1)} + \\frac{f(\\fa{p}) - g(\\fa{p})}{\\deg(\\fa{p})^2\\deg(p)(\\deg(p)-1)}因此有 \\begin{aligned}\ng(u) &= P_2 + P_3 + P_4 \\\\\nf(u) &= P_1 + P_2 + P_3 + P_4\n\\end{aligned}注意：f(S) = 1, g(S) = 0。这很好理解，因为 S 没有父节点，因此不存在「删掉 S 的父节点」这样的操作。\n第二部分考虑统计答案。\n首先，要能最终停在 u 的条件是 \\deg(u)\\le 2。\n我们必须要删掉 \\fa{u} 或者 u 没有父节点才能保证停在 u。\n第一种情况：在第一次到达 u 时删掉 \\fa{u}：\n如果 u 是个叶子结点（此时必然有 u\\ne S），那么对答案的贡献就是 g(u)v_u。\n如果 u 是个只有一个儿子 v 的结点，那么我们可以模仿第三种情况的 DP 转移，先删掉 \\fa{u} 走到 u，再走到 v 子树里的结点 z（z\\ne v）再走回 u，以删除 v。这部分的贡献是 v_u\\left(\\frac{g(u)}{\\deg(u)-1} + [u=S]\\frac{f(u)}{\\deg(u)} \\right) \\sum_{a: a_k = z}w(a)第二种情况：在第二次到达 u 时删掉 \\fa{u}。\n这种情况适用于 u 是叶子结点，那么我们第一次到达 p 后一定会走 p\\to u\\to p\\to u 的路线。因此贡献为 v_u \\left( \\frac{g(p)}{(\\deg(p)-1)^2} + \\frac{f(p) - g(p)}{\\deg(p)^2} \\right)代码\n树的同构\n给出一个 n 个点的树，要求找到两个同构的不相交的连通块，求连通块最大大小。\nn\\le 51。 枚举一个点 x，则 x 和 x 父亲的边将这棵树分成两个部分。然后选一个不在 x 子树里的点 y ，做为另一个部分的根。这样就可以树形 DP 了。f(i,j) 表示 i 和 j 的子树的最大同构连通块，且 i 和 j 匹配。\n转移是个二分图最大权匹配。用 KM 算法做就行。\n这题的一个难点是算复杂度。\n考虑 f(i,j) 这个状态被计算的次数，复杂度为 \\sum_{i}\\sum_j n \\text{dist}(i,j) (d_i + d_j)^3 \\\\我也不知道为啥它是 O(n^5)。但既然题解这么说了那就是吧。\n移球游戏\n有 n+1 个柱子，每个柱子上有 m 个位置。第 1 到 n 个柱子上放满了球，颜色为 i 的球有 m 个，总共 n\\times m 个球。\n每次你可以把一个柱子顶端的球移到另一个柱子顶端，前提是目标柱子有空位。\n要求在 8.2\\times 10^5 步内将每种颜色的球各自集中到一个柱子上。\nn\\le 50, m\\le 400。 首先，这东西可以桶排。\n直接桶排不太行。考虑分治。\n将颜色小于 mid 的记为 0，否则记为 1。那么我们每一轮，对于当前区间柱子，干两件事： 对于每个柱子，把它变成 00\\cdots011\\cdots 1 或 11\\cdots100\\cdots 0 的形式。\n把每个柱子两两合并，最终变成全 0 或全 1 的形式。 这两个都可以简单操作得到。\n操作一就不说了。对于操作二，我的方法是：对于 000111 和 111000 两个柱子的合并可以做到 O(3m)，对于两个 000111 的柱子，把其中一个反转一下就行。\n这样的步数是大概是 5n\\log_2nm 的。\n代码","title":"WC 赛前训练日志 2","updated":"2025-04-23T04:07:19.273Z"},{"categories":[],"path":"Gao/part-1/","tags":[],"text":"城市建设\n给你一个加权无向图 (V,E)，有 Q 次操作，每次会改变一条边的边权。求每次操作后的 MST 的边权和。\n|V|\\le 4\\times 10^4,|E|\\le 5\\times 10^4,Q\\le 5\\times 10^4. 离线 CDQ 分治 可撤销并查集\n考虑离线算法。容易想到线段树分治 + LCT 的算法（即每次加入一条边或者撤消）。然而这个算法常数过大，并不能过。\n首先，如果没有修改操作，那么我们可以很快地使用 kruskal 算法求出 MST 边权和。\n如果修改操作很少，假设边集和点集都是 O(n) 级别，修改操作数量是 O(q) 级别。那么我们能否找到一种预处理复杂度关于 n，询问的复杂度关于 q 的算法？容易发现，在这种情况下，有一些从来没有修改过的边，它会一直在 MST 中。那么我们把这些边预处理出来，然后缩点。这样就能使问题的规模减小。同样的，也会有一些边，他们从来都不在 MST 中，这种边就可以扔了。\n更准确地说，对于一个关于 E（边集）的操作序列，我们将 E 分成： 动态边：受到过修改的边。\n静态边：从来没有被修改的边。静态边可以进一步分类：\n无用边：从来都不在 MST 中的边。\n有用边：有时会出现在 MST 中的边。这其中可以分类：\n必须边：一直在 MST 中的边。\n非必须边：有时不在 MST 中的边。 为了找出必需边，我们把动态边的权值设成 -\\infty，然后使用 kruskal 算法，这样求出的 MST 中的静态边就是必需边；为了找出无用边，把动态边权值设成 \\infty，使用 kruskal 算法，不在 MST 中的边就是无用边。\n把无用边扔掉，把必需边缩点。这样就减小了问题的规模。\n考虑原问题。\n首先使用 CDQ 分治，考虑操作区间 [L,R]。对于 [L,mid]，我们需要先把 [L,R] 的一些动态边变成静态边（如果这些边只在 [mid+1,R] 中有修改操作），然后删掉无用边，缩点必需边，递归下去。对于 [mid+1,R] 同理。\n递归到边界如何计算答案？在递归的过程中使用可撤消（带权）并查集处理所有的压缩操作。边界情况 L=R，在并查集中略做修改查询即可。\n时间复杂度 O(n\\log_2^2n)。\n代码\nUOJ50 链式反应\n题面太长 首先设 f_n 表示答案，那么对于 n&gt;0： f_n=\\sum_{c\\in A}\\binom{n-1}{c}\\frac{1}{2}\\sum_{j=1}^{n-2}\\binom{n-1-c}{j}f(j)f(n-1-c-j)+[n=1]令 f_0=0，设 \\hat{F}(x)=\\sum_{n\\ge 0}f_n\\frac{x^n}{n!},\\hat{G}(x)=\\sum_{n\\ge 0}[n\\in A]\\frac{x^n}{n!} 分别为两者的 EGF，可以得到 F'=\\frac{1}{2}GF^2+1然后有两种思路。牛迭然后多项式全家桶，常数爆炸。\n另一个思路是直接 CDQ 分治。设 f'_n=\\frac{f_n}{n!},g'_n=\\frac{g_n}{n!}，那么我们计算 f'_n,g'_n 即可。\n容易发现，上述式子实际上就是 f'_if'_jg'_k 贡献到了 f'_{i+j+k+1} 上。\n考虑 CDQ 分治。那么我们的问题就是，统计满足 \\max(i,j)\\in[l,mid], mid &lt;i+j+k+1\\le r 的 i,j,k 对 i+j+k+1 的贡献分别是多少。\n这里有一个重要的引理：线段树上的区间 [L,R]，一定满足 L=1 或者 L&gt;R-L。\n那么，如果 l=1，我们可以直接 FFT 计算对 [mid+1,r] 的贡献。\n因此，i\\in[l,mid] 和 j\\in[l,mid] 不可能同时满足。则我们钦定 i\\in[l,mid],j\\in[0,mid-1]，这样再约束一下 j,k 的限制条件就可以快速算出对 mid+1,r 的贡献，把这部分的贡献乘 2 后累加即可。\n时间复杂度 O(n\\log_2^2n)。\n附：CDQ 的重要一步就是计算上下界，把问题规模缩小到与区间长度有关。\n代码\nIOI2000 邮局\n数轴上 n 个整点，从中取 m 个作为关键点，要求最小化每个点到离它的最近关键点的距离的和。\nn\\le 5000,m\\le 3000。 摘要：决策单调性，分治优化 DP。\n前置知识对于二元函数 w(l,r)，若满足 \\forall a\\le b\\le c\\le d, w(a,c)+w(b,d)\\le w(a,d)+w(b,c)称 w 满足四边形不等式。\n对于一类 1D/1D 的区间 DP f(i)=\\min_{j=1}^{i-1}\\{f(j)+w(j,i)\\}若 w 满足四边形不等式，则 f 也满足决策单调性。\n对于形如 dp(i, j) =\\min_{k \\leq j} \\{ dp(i - 1, k) + C(k, j) \\}的转移方程，其中 C(k,j) 是代价函数，可以 O(1) 计算。设 opt(i,j) 表示 dp(i,j) 的最优决策，即 opt(i,j)=\\arg\\min_{k \\leq j} \\{ dp(i - 1, k) + C(k, j) \\}如果 \\forall i,j, opt(i,j)\\le opt(i,j+1) ，即同一层满足决策单调性，那么我们可以考虑分治优化 DP。\n具体地，固定 i ，考虑分治地计算 opt(i,j),1\\le j\\le n 。我们首先计算 opt\\left(i,\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor\\right) ，然后把区间分成两部分，两边递归下去做，求出所有的 opt(i,j) 。由于递归的每一层的规模都是 O(n) ，一共 O(\\log_2n) 层，因此转移一层的总复杂度 O(n\\log_2n) （注意，复杂度与 opt(i,j) 是否平衡无关）。\n题解设 w(l,r) 表示在 [l,r] 的点建一个关键点，最小的距离总和。容易发现 w(l,r)=w(l+1,r-1)+x_r-x_l。可以证明 w(l,r) 满足四边形不等式。因此使用上述分治算法即可。\n代码\nUOJ191 Unknown\n维护一个向量序列： 在末尾添加一个向量\n删除末尾的向量\n询问 [l,r] 的向量与 (x,y) 叉积的最大值 空间较小。Q\\le 5\\times 10^5。 如果使用二进制分组的话，删除和询问就假了。\n考虑一个类似二进制分组的做法，使用线段树维护。插入的时侯，如果两个儿子的区间都满了，就把这个结点的凸壳建出来（凸壳的合并）。否则不建。查询的时候在已经建出凸壳的结点上查。没建出就递归下去。\n但是删除还是很假。我加一次删一次重复下去就假了。\n考虑延迟合并。在插入的时侯，如果线段树上结点 u 的区间满了，并且 u 的同一层的上一个（左边的）结点还没有建凸壳，就把左边的这个点建了（结点 u 就不管，放在这不动它）。删除的时侯该咋删。这样的复杂度就对了。\n总复杂度 O(Q\\log_2^2n)。","title":"高爸的杂题练习 1","updated":"2025-04-23T04:07:19.264Z"},{"categories":[],"path":"Gao/part-3/","tags":[],"text":"Cool Slogans\n给出一个字符串 S，要求构造一个字符串序列 s_1,\\cdots,s_k 满足： s_k=S；\ns_{i} 是 s_{i+1} 的子串且在 s_{i+1} 中出现了至少 2 次（出现的位置可以部分重叠）。 求出最大的 k。\nn\\le 2\\times 10^5。 摘要：Fail 树上双指针，线段树维护 Right 集合。\n我们可以让 s_k 是 S 的子串，这样答案不会变劣。\n容易发现，一定存在一种最优方案使得： s_k 是 S 的子串；\ns_i 是 s_{i+1} 的后缀且在 s_{i+1} 中出现了至少 2 次（出现的位置可以部分重叠）。 这样的话 s_i,s_{i+1} 就是在 Fail 树上的祖先关系。\n考虑建出 S 的 Fail 树后，记 f_u 表示 s_k 为 u 代表的子串时的 k 的最大值。我们可以不停跳父亲，直到遇到第一个在 u 中出现 2 次的状态，然后转移。然后容易发现我们可以用树上双指针（或者倍增、二分）来完成这个过程。因此问题转化为，如何快速判断状态 v 在状态 u 中出现了至少 2 次。\n这个问题也不难。使用线段树合并求出每个结点的 Right 集合后，我们只需要在 u 的 Right 集合中随便找一个位置，然后在 v 的 Right 集合中求出这个位置的前驱就可以判断了。\n时间复杂度 O(n\\log_2n)。\n代码\nHow Many Substrings\n给你一个串 S，q 次询问 (l,r)，问 S[l,r] 的本质不同子串的个数。\n|S|,q\\le 10^5。 摘要：离线，线段树按左端点统计子串个数，在 Fail 树链上更新线段树，用 LCT 维护 Fail 树。\n考虑离线，将询问按右端点分类。\n对于 S 的一个前缀 S[1,x]，维护序列 c_i 表示最晚出现位置的左端点为 i 的本质不同子串数。因此对于 r=x 的询问，我们可以查询 c 上的区间和来求出答案。\n当在 S[1,x] 后面加一个字符，我们就需要更新一部分子串的最晚出现位置。\n容易发现，在 S 的 SAM 增量构造过程中，我们插入了 S[x+1] 这个字符后，Fail 树上新的 Last 到根的路径上的状态的最晚出现位置都发生了变化。因此我们可以暴力跳 Fail 树的父亲来更新 c。由于一个状态 u 代表了长度为 [\\text{len}(\\text{fail}(u))+1,\\text{len}(u)] 的若干个子串，因此一次更新操作相当于是做 O(1) 次区间加（减）。\n使用线段树维护 c，则时间复杂度是 O(n^2\\log_2n) 的。\n容易发现，对于 Fail 树上的一条链（端点为祖孙关系的链）P，如果满足 P 中的所有结点的最晚出现位置相同，那么 P 这条链所代表的所有子串的左端点也是一段连续的区间。因此对于一条链我们可以在 O(\\log_2n) 的时间内更新 c。\n既然可以快速维护一条链的信息，那么我们使用 LCT 维护 Fail 树即可，时间复杂度 O(n\\log_2^2n)。\n代码\n历史研究\n给你一个长度为 n 的序列 A，定义 x 在区间 [L,R] 中的权值为 x 的出现次数乘 x。定义区间 [L,R] 的权值为 x\\in[L,R] 的最大的 x 的权值。\nq 次询问区间权值。\nn,q\\le 10^5。 摘要：分块。\n考虑分块，设块大小为 T。预处理 f(i,j) 表示第 i 块到第 j 块的区间的权值。\n预处理 v_x 表示权值 x 的出现位置集合。\n查询的时候，整块的部分直接 O(1) 在 f 上查询。零散的部分，我们枚举零碎部分的权值 x，然后在 v_x 上查询 x 在 [l,r] 中的出现次数来更新答案。\n要离散化。\n预处理复杂度 O(n\\log_2n+\\frac{n^2}{T})。查询复杂度 O(qT\\log_2n) 且在线。取 T=\\sqrt{n} 可过。\n代码\nWC2013 糖果公园\n给出两个序列 W,V。定义权值 x 在可重集合 S 中的价值：假设 x 在 S 中出现了 k 次，则价值为 \\sum_{i=1}^kV_xW_i。一个可重集合的价值是其中所有权值（不是所有元素）的价值和。\n给你一棵树 T，定义其中的点的点权为 C_i。有 q 次操作： 修改单点点权；\n询问从 x 到 y 路径上的点的点权组成的可重集合的价值。 n,q,|W|\\le 10^5,C_i\\le |W|,n=|V|。 摘要：树上带修莫队。\n考虑一条链且不带修改的情况。容易想到莫队算法。复杂度 O(n\\sqrt{n})。\n考虑一条链且带修改的情况。那么加一维时间上去，由于加入一个权值和删除一个权值的复杂度都可以做到 O(1)，因此复杂度为 O(n^{\\frac{5}{3}})。\n考虑原问题。不妨求出任意一个 DFS 序。那么从 x 到 y 的路径可以在 DFS 序列上表示为一个区间。如果一个点在区间中出现了偶数次，那么它就不在这条路径上。那么我们就在 DFS 序列上做莫队即可。\n更具体地，对于点 u，我们记录第一次到达这个点的 DFS 时间戳，以及从这个点回溯时的时间戳，分别为 L_u,R_u。显然 L_u\\le R_u。那么从 x 到 y 的路径有两种情况： x 和 y 是祖孙关系（x=y 的情况也包含在这里）；\nx 和 y 不是祖孙关系； 对于第一种情况，设 x 是 y 的祖先，显然 L_x\\le L_y。我们取 [L_x,L_y] 区间做为路径 (x,y) 对应的区间。容易发现，路径上的每个点 u 的 L_u 都在区间中出现了一次，R_u 则没有出现；\n对于第二种情况，设 z=\\text{lca}(x,y)，不妨设 L_x&lt;L_y，显然 R_x&lt;L_y。则我们取 [R_x,L_y] 作为路径 (x,y) 对应的区间。容易发现，x 到 z 路径上每个点 u 的 R_u 都出现了一次；而 y 到 z 路径上的每个点 u 的 L_u 都出现了一次。但 z 是个例外，L_z,R_z 都没有出现。因此我们在处理这个询问的时候要单独把 C_z 加上去，统计完了再减掉。\n在莫队移动端点的过程中，通过判断结点出现次数的奇偶性来决定是加入权值还是删除权值即可。\n时间复杂度 O(n^{\\frac{5}{3}}+n\\log_2n)。\n代码\n在线区间众数查询\n给出长度为 n 的序列 a，有 m 次询问，每次查询区间众数的出现次数。强制在线。\nn,m\\le 5\\times 10^5,a_i\\le 10^9。（2 秒） 摘要：分块。\n考虑分块。设块大小为 T。\n预处理 w(l,r) 表示第 l 块到第 r 块的区间众数的出现次数，时间复杂度 O(\\frac{n^2}{T})，空间复杂度 O(\\frac{n^2}{T^2})。\n预处理序列 v_{x} 表示数值 x 在 a 中出现的位置。预处理 p_i 表示 a_i 在 v_{a_i} 中出现的位置。时间复杂度 O(n)。\n考虑查询。则区间 [L,R] 的众数出现次数有两种情况： 等于整块的众数；\n出现次数大于整块的众数。 整块的众数可以 O(1) 查询。考虑零散部分。假设当前的答案是 C，考虑判断答案能否为 C+1。\n以左边的零碎部分为例。我们枚举其中的数 a_x，那么 a_x 就是第 p_x 个出现的 a_x。我们 O(1) 求出第 p_x+C 个 a_x 出现的位置 P，如果 P\\le R 说明 a_x 在 [L,R] 中出现的位置至少是 C+1。\n右边的类似。\n零碎部分的大小是 O(T) 的，因此 C 最多增加 O(T) 次。查询的复杂度是 O(T)。\n因此时间复杂度为 O(\\frac{n^2}{T}+n+mT)。\n取 T=\\sqrt{n}。时间复杂度 O((n+m)\\sqrt{n})，空间复杂度 O(n)。\n代码\nSouvenirs\n给出长度为 n 的序列 a，有 m 次询问形如 (l,r)，求 \\min_{l\\le x&lt;y\\le r}|a_x-a_y|。\nn\\le 10^5,m\\le 3\\times 10^5,a_i\\le 10^9。 离线 扫描线 权值线段树\n考虑离线，我们对每次询问 (l,r) 求 \\min_{l\\le x&lt;y\\le r,a_x\\ge a_y}(a_x-a_y)，然后求 \\min_{l\\le x&lt;y\\le r,a_x\\le a_y}(a_y-a_x)，两者取 \\min 即可。考虑求前者。\n考虑使用扫描线。即我们每次加入 a_i 并处理所有 r=i 的询问。我们维护序列 c，c_j 表示在扫描线的当前状态下，l=j 的询问的答案。\n那么当我们加入了 a_i 之后，显然我们会用 a_j-a_i(a_j\\ge a_i) 的值来更新某些询问的答案。自然想到，我们想办法找到最大的 j 使得 j&lt;i,a_j\\ge a_i（a_i 往前第一个比它大的数）。那么 c[1,j] 的值就都要对 a_j-a_i 取 \\min。\n第一部分但是只有这一个 j 是不够的。我们还需要找更多的 j'(j'&lt;i,a_{j'}\\ge a_i)，并用 a_{j'}-a_i 来更新答案（关于如何找这些 j 见第二部分）。\n我们还要求 a_{j'}-a_i&lt;a_j-a_i，即 a_{j'}&lt;a_j。因为你用 a_{j'}-a_i\\ge a_j-a_i 的 j' 再去更新答案是没有任何意义的，你已经有了 a_j 了。\n上述有关 j' 的条件可以容易地推出 j'&lt;j。当然，我们希望 j' 尽可能大。\n我们还可以加一个条件：a_{j'}-a_i&lt;a_j-a_{j'}。因为区间 [j',i] 是包含 [j',j] 的。如果 a_{j'}-a_i\\ge a_j-a_{j'} 也没有更新意义。这是本题的一个关键点。有了这个条件我们可以推出 a_{j'}&lt;\\frac{1}{2}(a_i+a_j)（这个条件比 a_{j'}&lt;a_j 更强）。\n综上所述，当我们用 a_j-a_i 更新完 c[1,j] 的值后，我们尝试找到下一个 j'，并用 a_{j'}-a_i 更新 c[1,j'] 的值。则 j' 需要满足条件：j' &lt;j,\\,a_i\\le a_{j'} &lt;\\frac{1}{2}(a_i+a_j)。\n当我们用 a_{j'}-a_i 更新完后，我们可以再如法炮制找到下一个 j''，可以类似地发现 j'' 满足 j'' &lt;j',\\,a_i\\le a_{j''} &lt;\\frac{1}{2}(a_i+a_{j'})&lt;\\frac{3}{4}a_i+\\frac{1}{4}a_j。\n以此类推，则 j^{(k)} 需要满足的条件是 j^{(k)} &lt;j^{(k-1)},\\,a_i\\le a_{j^{(k)}} &lt;\\frac{1}{2}(a_i+a_{j^{(k-1)}})&lt;\\frac{2^k-1}{2^k}a_i+\\frac{1}{2^k}a_j\n=a_i+\\frac{1}{2^k}(a_j-a_i)因此我们得到 a_i\\le a_{j^{(k)}}&lt;a_i+\\frac{1}{2^k}(a_j-a_i)，因此 k\\le O(\\log_2W)，即我们最多找到 \\log_2W 个有更新价值 j 来更新。\n如果使用线段树维护 c 的话，那么做一次更新的复杂度是 O(\\log_2n) 的，更新 a_i 的复杂度就是 O(\\log_2n\\log_2W) 的。\n第二部分那么接下来的问题是： 如何找到最大的 j 使得 j&lt;i,a_j\\ge a_i。\n找到最大的 j^{(k)} 使得 j^{(k)} &lt;j^{(k-1)},\\,a_i\\le a_{j^{(k)}} &lt;\\frac{1}{2}(a_i+a_{j^{(k-1)}})（记 j^{(0)}=j）。 一个直接的思路是对 a[1,i-1] 建立权值线段树，在对应的权值上存下标。那么上面两个问题就相当于是求区间 \\max。当然也可以建立离散化的权值线段树。\n那么这部分的查询复杂度就是 O(\\log_2n\\log_2W)。\n总复杂度 O(n\\log_2n\\log_2W)。\n小插曲：在求 a_j\\le a_i 的情况的时候，可以直接把 a_i 变成相反数再做一次。\n代码","title":"高爸的杂题练习 3","updated":"2025-04-23T04:07:19.264Z"},{"categories":[],"path":"Probset/21-WC-Training-2/","tags":[{"name":"WC2021","slug":"WC2021","permalink":"https://notes.sshwy.name/tags/WC2021/"}],"text":"Nagisa\n二维平面，给出三个 n 个点的凸多边形，有 q 次询问，每次给出一个点，问是否存在一个三个顶点分别在凸多边形里的三角形，使得三角形的重心是这个点。\nn,q\\le 10^6。 计算几何 凸包 闵可夫斯基和\n这题的重点是，我凸包求错了。有两个问题： 分类讨论的时候没有讨论全，被 assert 打爆了。\n求凸包的时候如果按照 (x,y) 排序，求上凸包是对的，求下凸包就不对了。虽然我也不懂为啥。 最好的策略似乎是只求上凸包，然后翻转一下再做一次。\nTomoya\n给出一个 n 个点 m 条边有向有自环有重边无非自环的环的图，即一个 DAG 加上若干个自环。每条边有一个实数边权。要求你从 S 走到 T。你每走到一个点（包括最开始的 S），这个点的出边（自环也算出边）的边权就会被等概率随机打乱，而你可以看到打乱后的结果，并决定走哪条边。你的目标是走过的边权和最小。\n问最优策略的期望边权和，输出实数。\nn, m\\le 1000。 期望\n期望题的套路：设 E(u) 表示 u 走到 T 的期望。\n没有自环记 u 的后继分别是 v_1, \\ldots, v_k。记 u 的出边边权分别为 w_1,\\ldots,w_k。\n如果 u 没有自环，那么你会选择 E(v)+w 最小的走。对于 w 的每个排列，我们要算 E(v_i) + w_i 的最小值。\n由于 E(v) + w 只有 O(k^2) 个不同的值。考虑枚举这个最小值 x，那么我们要求剩下 k-1 个的值都大于等于 x。那么把 w 和 v 分别从小到大排序，相当于每个 v_i 能选的 w_j 是一段后缀。方案数是乘积的形式。\n那么我们从小到大枚举 E(v) + w 的值，发现每次对乘积的影响是 O(1) 的。也就是说只有 O(1) 个数能选的范围发生改变。这样就可以 O(k^2\\log_2k) 计算期望。\n有自环如果 u 有自环，那么我们就多了一个决策：走自环到 u。决策涉及到了自身，就不能简单地建立无后效性的转移关系，因此考虑建立等式。也就是说 E(u) = p(c_1 + E(v)) + (1-p)c_2，意思是说我们以 p 的概率走自环，代价为 c_1，然后再走这个期望，或者我们直接走出去，代价是 c_2。\n然而本题难点在于，该等式的系数表达难以得到。也就是说我们不知道这个等式长啥样。\n考虑执行一个结果收敛的迭代过程。假设我已经求出了 E(u) = x_0，那么我们可以建立怎样的等式？\n这时一个精妙的思路来了：因为 E(u) 在逻辑上被视为常量，那么自环就可以变成普通边了！\n如果 u 有 t 个自环，那么我就把这 t 个自环删掉，给 u 新增 t 个后继，新增后继的期望都设为 E(u)。那么这就转化为没有自环的情况了。因此我们就可以用 x_0 求出 u 的期望 E'(u) 了。\n如果 x_0 是 E(u) 的精确值，那么用 x_0 求出的 E'(u) 就应该满足 E'(u) = x_0。否则，E'(u) 就与 x_0 有误差。而这个误差是收敛的。也就是说我们不断地令 x_0 = E'(u) 然后再用 x_0 求出新的 E'(u)，无限次后就可以得到 E(u) 的精确值。\n直接迭代太慢。改成二分就行。\n时间复杂度 O(nm\\log_2W)。\nBattle Lemmings\n有一个长度为 n 的 01 序列 s。每次你可以把一个 1 和与它相邻的 0 交换位置。定义一个序列的价值是满足以下条件的区间 [l,r] 的个数： s_l = s_r = 0。\n存在 l&lt;i&lt;r 使得 s_i=1。 现在对于 k = 0,1,\\ldots, \\frac{n(n-1)}{2}，要求你求出在执行至多 k 次操作的情况下，序列的价值的最大值。\n1\\le n\\le 80。 将求最大价值转化为求最小代价。设由 0 构成的极长连续段的长度的集合是 L，那么序列 s 的代价可以描述为 \\sum_{l \\in L(s)} \\binom{l}{2}f(i,j,k) 表示考虑前 i 个 1，第 i 个 1 的位置是 j，一共动了 k 步的最小代价。\n考虑转移，f(i,j,k) = \\min_{p&lt;j} f(i-1,p,k-|a_i-j|) + \\binom{j-p-1}{2}。\n不妨分类讨论。\nCase 1对于 a_i\\ge j 的情况，f(i,j,k) = \\min_{p&lt;j} f(i-1,p,k-a_i+j) + \\binom{j-p-1}{2}。\n固定 x = k - a_i + j，固定 i ，那么\nf(i,j,x+a_i - j) = \\min_{p&lt;j}f(i-1,p,x) + \\binom{j-p-1}{2}。\n右边是一个只与 j 和 p 有关的式子，那么\n2f(i,j,x+a_i-j) - j^2 + 3j = - 2jp + (2f(i-1,p,x) + p^2 + 3p + 2).\n不妨设左边的是 b_j，与 p 有关的部分是 y_p，设 k_j = 2j，那么\nb_j = -k_jp + y_p。这是让一条斜率为 k_j 的直线过 (p,y_p) 这个点，并最小化截距 b_j 的问题。\n注意到 k_j 和 p 都是单调的，可以直接斜率优化。\n计算的时候按照 j 从小到大的顺序。固定 i，将 DP 状态 f(i,j,k) 按照 j+k 的值分类（可以发现是一条一条斜线）。这样我们可以用单调队列维护凸壳，计算完同一类的 DP 状态。\nCase 2对于 a_i &lt; j 的情况，f(i,j,k) = \\min_{p&lt;j} f(i-1,p,k+a_i-j) + \\binom{j-p-1}{2}。\n固定 x = k + a_i - j，固定 i，那么\nf(i,j,x - a_i + j) = \\min_{p&lt;j} f(i-1,p,x) + \\binom{j-p-1}{2}.\n2f(i,j,x - a_i + j) - j^2 + 3j = -2jp + (2f(i-1,p,x) + p^2 + 3p + 2).\n不妨设左边的是 b_j，与 p 有关的部分是 y_p，设 k_j = 2j，那么\nb_j = -k_jp + y_p。\n同样的方法，按照 j-k 对状态分类即可。\n代码","title":"WC 赛前训练日志 3","updated":"2025-04-23T04:07:19.273Z"},{"categories":[],"path":"Probset/BJOI2018/","tags":[],"text":"那道人类智慧题咕掉了……\n求和太简单了，就 8 写了\n链上二次求和\n给出一个长度为 n 的整数序列 a，有 m 次操作，要求支持区间加，询问 f(l,r)=\\sum_{i=1}^n\\sum_{j=i}^n[l\\le j-i+1\\le r]\\sum_{k=i}^j a_k \\pmod{10^9+7}n\\le 2\\times 10^5,m\\le 5\\times 10^5。 线段树\n首先有一个小差分。\n如果这个序列是一个环，那么答案就很好求。断成链之后，有些区间就不能统计到。对于长度为 x 的区间，那么 a_{n-x+1} 会少统计 1 次，a_{n-x+1} 少统计 2 次……，a_n 少统计 x-1 次。同理，a_1 少统计 x-1 次，a_2 少统计 x-2 次，以此类推。\n那么对于长度小于等于 x 的区间，则系数就是 A=\\{1,3,6,10，\\cdots\\}，也就是 B=\\{1,2,3,\\cdots\\} 的前缀和。只要能快速维护带系数的区间和即可。那么使用线段树维护，也就转化为，快速求出这两个序列的区间和。其中 1,2,3,\\cdots 的很好求，而 1,3,6,\\cdots 可以求出前缀和公式 S(i)=\\frac{i(i+1)(i+2)}{6}，当然也可以预处理。\n然后还需要把 \\sum_{L\\le i\\le R} A_ia_i 给转化为 \\sum_{L\\le i\\le R}A_{i-L+}a_i，那么这个可以用 \\sum_{L\\le i\\le R}B_ia_i 和 \\sum_{L\\le i\\le R}a_i 来辅助计算。处理一下细节即可。\n时间复杂度 O(n\\log_2n)。\n代码\n治疗之雨\n给你 m+1 个数，第一个数值为 p，有上界 n 和下界 0，其他 m 个数值为 \\infty，没有上界也没有下界。\n你每次会进行如下操作： 等概率随机选择一个没有达到上界的数并把它 +1。如果没有就不操作。\n进行 k 次：等概率随机选择一个没有达到下界的数并把它 -1，如果没有就不操作。 问期望进行多少次操作后第一个数会达到下界。如果第一个数无法达到下界输出 -1。\n1\\le p\\le n\\le 1500,0\\le m,k\\le 10^9。 高斯消元 期望 卡常 海森堡矩阵\n设 f_p 表示第一个数值为 p 时的期望。在一个回合，它有概率 +1，也有概率 -j。设 p_j 表示一回合减 j 的概率，易得 p_j=\\frac{\\binom{k}{j}m^{k-j}}{(m+1)^k}（若 j&gt;k 则 p_j=0）\n另一方面，设 g_j 表示第一个数值为 j 时，一回合就达到下界的概率。容易发现 g_j=\\sum_{x\\ge j}p_x=\\sum_{x=j}^k p_x那么现在就可以容易地得到 f 的关系式： f_i=\\frac{m}{m+1}\\left( g_i+\\sum_{j=0}^{i-1}p_j(f_{i-j}+1) \\right) + \\frac{1}{m+1} \\left( g_{i+1}+\\sum_{j=0}^ip_j(f_{i+1-j}+1) \\right) \\quad(i&lt;n)特殊地，f_n=g_n+\\sum_{j=0}^{n-1}p_j(f_{n-j}+1)。\n不妨把 g 去掉，得到 f_i=\\frac{m}{m+1}\\left( 1+\\sum_{j=0}^{i-1}p_jf_{i-j} \\right) + \\frac{1}{m+1} \\left( 1+\\sum_{j=0}^ip_jf_{i+1-j} \\right) \\quad(i&lt;n)特殊地，f_n=1+\\sum_{j=0}^{n-1}p_jf_{n-j}。\n这时容易想到高斯消元。而 f 是一个海森堡矩阵，可以使用一些技巧做到 O(n^2)。\n注意要特判 m=0 的情况。\n代码\n染色\n给一个无重边自环的无向图， 每个点分别给了一个大小为 2 的颜色集合，你只能从这个集合中选一种颜色给这个点染色。要求没有两个相邻的点被染了相同的颜色。\n求是否无论给定的颜色集合是什么，均有办法按照要求染色。Yes or no。\n1\\le n\\le 10^5.0\\le m\\le 2\\times 10^5。 构造 图论 盲猜\n如果不是二分图那么显然是 NO。\n考虑给你一个环 a\\to b\\to c\\to d \\to a，那么你可以构造 a:\\{A,B\\},b:\\{B,C\\},c:\\{C,A\\},d:\\{A,B\\} 来钦定 a 必须选颜色 A。因为如果 a 选 B 的话会和 d 冲突。长度更大的环同理。\n既然我们能钦定一个点的颜色，那么只要存在一个环与 a\\to b\\to c\\to d\\to a 的环共边数小于等于 1，就意味着我们可以构造出 NO 的情况了。这里要注意，如果有一条共边，仍然是可以构造出 NO 的。\n因此总结一下，判定方式如下： 如果不是二分图，则 NO；\n删掉所有的 1 度点（拓扑）后，如果存在某个点不在任何一个简单环上，则 NO；\n如果存在某个点度数大于 3，则 NO；\n如果存在两个相邻的 3 度点，则 NO；\n如果都没有，那么就是 YES。 由于使用了一些 STL 数据结构，因此我实现的时间复杂度是 O(n\\log_2n)。\n代码\n二进制\n若一个 01 串能在任意重排后变成一个 3 的倍数的数的二进制表示（可含前导 0），称这是好的。比如 101,000,11 都是好串。\n现在给你一个长度为 n 的 01 串 s，要求支持 m 次操作： 单点修改\n询问满足 l\\le x\\le y\\le r 的 s[x,y] 中有多少个好串。 分类讨论\n容易发现，满足以下任意一个条件的都是好串： 有偶数个 1。\n有奇数个 1，且有至少 3 个 1 和至少 2 个 0。 这个不好算，我们考虑计算不是好串的串的个数，那么不是好串的串就是： 有 1 个 1，有任意个 0；\n有奇数个 1，没有 0；\n有奇数个 1，1 个 0。 上述三者有一部分算重了，因此要减去 只有 1 个 1，没有 0；\n只有 1 个 1，1 个 0。 的个数。\n这 5 个都可以简单地使用数据结构维护。\n使用 set+ 树状数组实现，时间复杂度 O(n\\log_2n)。\n代码","title":"BJOI 2018 大部分题解","updated":"2025-04-23T04:07:19.273Z"},{"categories":[],"path":"Probset/May-Day-Prob/","tags":[],"text":"Mole Tunnels\n有一棵 n 个点完全二叉树，i 的父亲是 \\lfloor\\frac{i}{2}\\rfloor。有 m 个球，分别位于 p_i 号结点。同时，每一个结点有一个容量 c_i，表示可以容纳的球的个数。如果一个点容纳不下了，就要把多于的球移动到其他点去。\n对于所有 1\\le i\\le m，询问前 i 个球要放到结点且不超过容量的的最小移动的总步数。\nn,m\\le 10^5，保证有合法方案。 费用流 细节\n容易想到费用流。由于树高是 O(\\log_2n) 的，因此我们可以暴力模拟増广的过程。每次増广的路径一定是先向上后向下的，因此记录 f(u) 表示结点 u 子树里费用最小的能到达汇点的流。増广的时候可以暴力増广，更新。\n时间复杂度 O(n\\log_2n)。\n代码\nAddition and Subtraction Hard\n给你一个只有加法和减法的表达式，你需要向里面加括号，使得表达式的值最大。\nn\\le 10^5。 贪心\n左括号一定在减号后面。第一个左括号后的一些加都会变成减，其他可以变成绝对值的形式。例如 a-b+c-d-e+f-g可以变成 a-(b+c-d-(e+f)-g)=a-b-c+d+e+f+g枚举左括号找最小即可。\n时间复杂度 O(n)。\n代码\nK-th K\n给定长度为 n 的序列 x_i，求一个长度为 n^2 的序列，其中 1,\\cdots,n 每个数都出现了 n 次，要求满足第 i 个 i 在第 x_i 个位置。构造可行解或输出无解。\n1\\le n\\le 500。 贪心\n每个位置都尽可能的选择在 x_i 之前还没满 i−1 个 i 的 x_i 最小的 i 即可。\n时间复杂度 O(n^3) 或者 O(n^2)。\n代码\nYet Another String Matching Problem\n给定两个字符串 S, T，字符集为 a\\sim f，每次操作任选两个字符 c_1,c_2，可以将 S 和 T 中的所有 c_1 替换成 c_2。对 S 中每一个长度为 |T| 的子串，求最小操作次数使得它们相等。\nn\\le 125000。 去你妈的 多项式\n我们要 KMP\n对于两个等长字符串 a,b，考虑求出让它们相等的操作次数。如果 a_i\\ne b_i，我们就把字符 a_i 和 b_i 连边。那么答案就是 |\\Sigma| 减去连通块的数量。\n那么我们设 f(x,y,i) 表示字符 x,y 在 S[i,i+|T|-1] 和 T 上是否连边。那么 f(x,y) 可以一波 NTT 猛如虎。\n然而我们不要用这个憨批做法。\n考虑枚举字符集的子集 S。设 a_i=[s_i\\in S]，b_i=[t_i\\in S]。那么如果 a[i,i+|T|-1] 和 b 匹配，说明这个子集没有向外连出的边，也就是说这个子集恰好包含了若干个连通块。而满足这个条件的子集恰好是 2 的连通块个数次方。因此求出了匹配的数量就可以快速算出连通块个数。匹配就直接 KMP 就行了。\n时间复杂度 O(2^{|\\Sigma|}n)。\n代码\n树上的最短路\n给出一棵 n 个点边带权的树，树边是无向边。有 m 个五元组 (a,b,x,y,c) 表示对于路径 (a,b) 上的任意结点 u 和 (x,y) 上的任意结点 v，都有从 u 到 v 权值为 c 的无向边。\n给出一个点 s，求从 s 出发到所有点的单源最短路。\nn\\le 2.5\\times 10^5,m\\le 10^5。 算法一树链剖分，每条路径可以拆成 O(\\log_2n) 个点。对于一个五元组，建立一个中间点，可以建 O(\\log_2n) 条边。总边数是 O(n+m\\log_2n)。使用 Dijkstra 算法，时间复杂度 O(n\\log_2n + m\\log_2^2n)。\n算法二考虑 Dijkstra 的一个变种算法。我们在堆里同时存点和边。对于一个点我们存到达这个点的最短路，对于一条（有向）边我们存到达它起点的最短路加上它的长度。每次取出堆顶： 如果是一个点，那么它所有邻边的最短路就确定了，把它的邻边放进堆里（如果这些邻边之前没有被访问过）。\n如果是一条边，那么它的终点的最短路就确定了，把它的终点放进堆里（如果这个点之前没有被访问过）。 这样我们发现，每个点和每条边最多被更新一次。\n那么我们算法的复杂度下界就变成了总点数（O(n+m\\log_2n)）。\n接下来我们优化 Dijkstra 的过程。如果说我们能把一个五元组用一个对象来代替（算法一使用了 O(\\log_2n) 个对象），那么总的对象数（边数）就变成了 O(n+m)，则 Dijkstra 的堆操作复杂度就优化成了 O((n+m)\\log_2n)。也就是说，Djikstra 的堆里存两类对象： 边的集合：也就是一个五元组 (a,b,x,y,c)。可以更新它到达的点集的最短路。所谓到达的点集，就是路径 (x,y) 上的点。\n结点：可以更新包含它作为起点的五元组（边集）的最短路。 接下来考虑具体的更新方法。\n如果堆顶是一个五元组 (a,b,x,y,c)，那么我们就要找到路径 (x,y) 上所有还未被访问过的点。这个可以并查集维护。这部分的均摊复杂度是 O(\\log_2n)。\n如果堆顶是一个结点 u，我们就要找到所有包含 u 作为起点的，还未被访问过的五元组，即所有 u 被包含在路径 (a,b) 的五元组 (a,b,x,y,c)。而包含 u 的路径有两种情况： 一个端点在 u 子树内，一个端点在 u 子树外。\nu 是两个端点的 LCA。 第二种情况可以每个点开一个 vector 维护。\n对于第一种情况，我们预处理整颗树的 DFS 序，那么子树的 DFS 序是一段连续的区间。考虑一个小根堆序列 A_1,A_2,\\ldots,A_n，其中 A_i 表示满足 \\textit{dfn}(a)=i 或 \\textit{dfn}(b)=i 的五元组集合。它的优先级是：另一个端点的 DFS 序越小，优先级越大。那么对于 u 的子树，假设它对应的区间是 L_u,R_u，我们就查询 A[L_u,R_u] 里的最小值。如果最小值的端点在 u 的子树外，就更新它，然后从堆中删除它。\n类似地，维护一个大根堆序列来处理最大值。每一个五元组至多被删除两次（两个序列里各一次），因此均摊复杂度仍是 O(\\log_2n)。\n算法总复杂度 O((n+m)\\log_2n)。\n代码","title":"五一集训 杂题练习","updated":"2025-04-23T04:07:19.274Z"},{"categories":[],"path":"Probset/NOIo-day2/","tags":[{"name":"Complete-Solution","slug":"Complete-Solution","permalink":"https://notes.sshwy.name/tags/Complete-Solution/"}],"text":"比赛经历按序开题，写了 T1 正解后写了 T270。然后使用了一些神秘力量学会了 T3（其实就是 xd 指点了一下）。\n回来把 T2 卡卡常就卡进 2s 了。\n涂色游戏\n你有 10^{20} 个格子，它们从 0 开始编号，初始时所有格子都还未染色，现在你按如下规则对它们染色： 编号是 p_1 倍数的格子（包括 0 号格子，下同）染成红色。\n编号是 p_2 倍数的格子染成蓝色。\n编号既是 p_1 倍数又是 p_2 倍数的格子，你可以选择染成红色或者蓝色。 其中 p_1 和 p_2 是给定的整数，若格子编号是 p_1 或 p_2 的倍数则它必须要被染色。在忽略掉所有未染色格子后，你不希望存在 k 个连续的格子颜色相同，因为你认为这种染色方案是无聊的。现在给定 p_1,p_2,k，你想知道是否有一种染色方案不是无聊的。\n1\\le T\\le 10^6,1\\le p_1,p_2,k\\le 10^9. 暴力\n如果 p_1=p_2 就是 Yes。如果 k=1 就是 No。\n否则不妨设 p_1&gt;p_2，首先可以除掉 gcd。然后答案是 [\\lceil \\frac{p_1-2}{p_2} \\rceil&lt;k]。\n代码\n子序列问题\n给出一个长度为 n 的正整数序列 a_1,\\cdots,a_n。定义 f(l,r) 表示区间 [l,r] 中不同数字的个数。\n求 \\sum_{1\\le l\\le r\\le n}(f(l,r))^2，对 10^9+7 取模。 线段树 扫描线 卡常\n考虑扫描线，那么左端点移动的时候，会把一个区间的值减 1。\n线段树维护区间加，求区间平方和即可。\n时间复杂度 O(n\\log_2n)。\n代码\n游戏\n有一棵 2m 个结点的有根树。其中有 m 个点是黑点，其他 m 个点是白点。现在你要把黑点白点两两匹配，一个匹配方案的权值是其中祖孙匹配的个数。\n求权值为 0,1,\\cdots,m 的匹配的个数。\n两个匹配不同当且仅当存在一个黑点使得在两个方案中匹配的白点不同。\nm\\le 2500。 容斥 二项式反演 DP\n设 f(i,j) 表示在 i 的子树中选 j 对祖孙匹配的方案数，其他点不匹配。\n对于根结点的 DP 值，把其他点任意匹配的方案数乘上去（阶乘），然后二项式反演即可。\n时间复杂度 O(m^2)。\n代码","title":"NOI Online 提高组 Day2","updated":"2025-04-23T04:07:19.274Z"},{"categories":[],"path":"Probset/SCOI2016/","tags":[{"name":"Complete-Solution","slug":"Complete-Solution","permalink":"https://notes.sshwy.name/tags/Complete-Solution/"}],"text":"背单词\n给你 n 个字符串 s_i，你需要将他们按照某种方式排序。排序后，第 i 个字符串 s_i 的权值定义为： 如果存在 j&gt;i 使得 s_j 是 s_i 的后缀，则权值为 n^2。\n否则，如果 n 个字符串中不存在 s_j（j\\ne i）使得 s_j 是 s_i 的后缀，那么权值为 i。\n否则，求出最大的 j 使得 s_j 是 s_i 的后缀。那么权值为 i-j。 一种排序方案的权值是所有字符串的权值之和。\n要求你最小化排序方案的权值并输出。\n1\\le n\\le 10^5,\\sum |s_i|\\le 5.1\\times 10^5。 Trie DFS 贪心 交换法\n首先把所有字符串倒过来，后缀变前缀。\n容易使用交换法证明，一定不存在第一种情况的权值。即，我们会把一个串的前缀排在它前面。\n对 n 个串建 Trie，然后把关键点拿出来再建一棵有根树。那么排序方案就是这棵树的拓扑序。而且容易发现，一个串的权值就是它和它的父节点在拓扑序上的距离。现在我们要最小化这个距离。\n考虑子树拓扑序合并。仍然使用交换法可以证明，我们把子树按大小排序，按从大到小的顺序把拓扑序拼起来即可。时间复杂度 O(n\\log_2n)。\n代码\n幸运数字\n给出一棵 n 个点带点权 c_i 的树，q 次询问 (x,y)，求 x,y 路径上点权集合中的子集异或和的最大值（即任意选元素异或起来的最大值）。\nn\\le 2\\times 10^4,q\\le 2\\times 10^5,c_i\\le 2^{60}。 线性基 倍增\n容易想到线性基。线性基的合并是 O(\\log_2^2W) 的。考虑倍增（因为树剖 + 线段树更慢），则一次询问的复杂度 O(\\log_2^2W\\log_2n)。总复杂度 O((n+q)\\log_2^2W\\log_2n)。\n代码\n萌萌哒\n给出一个长度为 n 的大数 s，s_1 表示数的最高位。有 m 个限制条件 (l_1,r_1,l_2,r_2)（r_1-l_1=r_2-l_2），表示 s[l_1,r_1]=s[l_2,r_2]。问满足条件的数有多少个。 倍增 并查集\n这是一道倍增思想的好题。\n定义 (i,j) 表示 s[i,i+2^j-1]。那么对于一个限制条件，我们可以将其拆分成 O(\\log_2n) 对形如 (a,j)=(b,j) 的条件。那么我们直接用并查集把 (a,j) 和 (b,j) 并起来。\n另一方面，如果 (a,j)=(b,j)，则 (a,j-1)=(b,j-1)，(a+2^{j-1},j-1)=(b+2^{j-1},j-1)。因此我们可以枚举 (a,j)，如果它不是代表元，那么我们找到它的代表元 (b,j)，然后把两者的两个儿子对应着合并。我们 j 从大到小枚举，最后就可以得到单个元素之间的相等关系，那么就很容易计算答案了。\n并查集有 O(\\log_2n) 个，总大小是 O(n\\log_2n) 的，因此复杂度 O(n\\log_2n\\alpha(n))。\n代码\n美味\n给出一个长度为 n 的整数序列 a_1,\\cdots,a_n，有 m 次询问形如 (b,x,l,r)，求 \\max_{l\\le i\\le r}\\{b\\oplus(a_i+x)\\}1\\le n\\le 2\\times 10^5,0\\le a_i,b,x\\le 10^5,1\\le m\\le 10^5。 权值线段树 扫描线\n考虑 x=0,l=1,r=n 怎么做。我们可以将权值排序。每次查询，我们从高到底枚举每一位，看答案的这一位能不能是 1。那么我们可选的数的区间就会不断缩小，到最后只剩下单独的数，就是答案。\n考虑 l=1,r=n 怎么做。相当于，我们的区间往左平移了 x 个单位。和上一个问题没啥区别。\n考虑原问题。把询问离线，按照右端点分类。每次我们加入一个数 a_i，处理 r=i 的询问。这时我们就需要判断，a_l,\\cdots,a_r 中是否存在某个数，位于值域区间 [L,R] 中。考虑建立权值线段树。那么我们的问题就转化为，是否在值域区间 [L,R] 中是否存在某个下标在 [l,r] 中。由于当前加入的下标是 \\le r 的，那么我们直接求出下标最大值即可。\n时间复杂度 O(n\\log_2n+m\\log_2^2n)。\n代码\n妖怪\n给出 n 个函数 f_i(x)=(1+x)(A_i+\\frac{B_i}{x})。设 F(x)=\\max_{1\\le i\\le n}f_i(x)。求 F(x) 最小值。\nn\\le 10^6,A_i,B_i\\le 10^8。 三分 调参 凸包\nF 是一个凸的函数。三分即可。时间复杂度 O(n\\log_2W)。然而要调参，显然不是正解。\nf_i(k)=A_i+kA_i+B_i+\\frac{1}{k}B_i。考虑一条斜率为 -k 且过 (A_i,B_i) 的直线 y=-kx+kA_i+B_i，容易发现这条直线的纵截距是 kA_i+B_i，横截距是 A_i+\\frac{1}{k}B_i。换言之 f_i(k) 表示的就是 y 的横纵截距之和。\n那么我们枚举斜率。则使得 f_i(k) 最大的 (A_i,B_i) 一定是上凸壳上的点。因此我们求出 n 个点的凸壳。考虑凸壳上编号为 i 的点，那么 f_i(k) 为最大值的 k 就是一段区间。这时我们要求的就是这个区间里 f_i(k) 的最小值。可以简单地使用均值不等式求解。\n时间复杂度 O(n\\log_2n)。\n三分代码\n围棋\n给出一个 n\\times m 的网格，每个格子可以填WBX三种字符。给定 q,c。q 次询问。\n每次询问给出一个 2\\times c 的网格，每个格子是WBX三种字符。问在所有 3^{nm} 种方案里，有多少种方案包含了这个 2\\times c 的网格（出现过）。\nn\\le 100,m\\le 12,c\\le 5,q\\le 5。 轮廓线 DP\n我们可以把 2\\times c 的网格当成两个字符串。不妨考虑计算不合法的方案数。\n考虑轮廓线 DP。设 f(i,j,S,x,y) 表示当前的格子是 (i,j)，且 (i,j) 匹配到第一个串的位置是 x（即 (i,j-x+1),(i,j-x+2),\\cdots,(i,j) 上的字符匹配第一个串长度为 x 的前缀），(i,j) 匹配到第二个串的位置是 y。S 是轮廓线的二进制状态，表示轮廓线上的这个格子是否能匹配第一个串。\n当我们从 (i,j) 转移到 (i,j+1) 的时候，我们枚举 (i,j+1) 上面填的字符。然后 x,y 就可以使用 KMP 求出新的 x',y'。如果 (i-1,j+1) 能匹配第一个串，而 y'=c，相当于出现了一个 2\\times c 的网格，这种转移就不能进行。其他情况都可以转移。在求出了新的 S' 后，从 f(i,j,S,x,y) 转移到 f(i,j+1,S',x',y') 即可。\n从 (i,m) 转移到 (i+1,0) 比较简单。\n代码","title":"SCOI 2016 完整题解","updated":"2025-04-23T04:07:19.274Z"},{"categories":[],"path":"Probset/Twelve-Provinces/","tags":[{"name":"Provincial-selection","slug":"Provincial-selection","permalink":"https://notes.sshwy.name/tags/Provincial-selection/"}],"text":"异或粽子\n给出一个序列 a，设 w(l,r) 表示区间 [l,r] 的异或和。\n我们把所有 1\\le l&lt;r\\le n 的 w(l,r) 拿出来排序，求前 k 大的和。\nn\\le 5\\times 10^5,k\\le 2\\times 10^5,0\\le a_i&lt;2^{32}。 持久化 Trie 二分\n由于 k 不大，我们考虑依次求出第 i 大的异或和。那么区间异或可以转化为两个数的异或，于是我们维护一个堆，首先把以 i 为右端点的最大异或和放进去。每次我们拿出来一个 (i,k)（表示以 i 为右端点第 k 大的异或和）后，我们就把 (i,k+1) 求出来并放到堆里。\n查询的话，把 Trie 可持久化一下，就变成了异或第 k 大的问题，可以在 Trie 上二分求解。\n时间复杂度 O((n+k)\\log_2n)。\n代码\n字符串问题\n给出一个字符串 S。\n从中取 n_a 个子串 S[la_i,ra_i]，称为 A 类串。\n从中取 n_b 个子串 S[lb_i,rb_i]，称为 B 类串。\n此外，有 m 个关系 (x_i,y_i)（1\\le x_i\\le n_a,1\\le y_i\\le n_b），表示第 x_i 个 A 类串支配第 y_i 个 B 类串。\n现在要求你构造一个字符串 T，使得： T 可以被划分为 t_1t_2\\cdots t_k（k\\ge 0）使得每个 t_i 都是 A 类串；\nt_i 支配 t_{i+1} 的前缀（1\\le i&lt;k）。 要求你最大化 T 的长度并输出。如果 T 可以无限长，输出 -1。\nn_a,n_b,|S|,m\\le 2\\times 10^5。 SAM DP 拓扑 倍增 建图\n考虑把 S 和 T 倒过来。这样就变成了，t_i 的后缀被 t_{i+1} 支配。如果从支配关系中 y 向 x 连有向边，那么相当于 t_i 跳到它的后缀再跳到 t_{i+1}。而后缀连边显然可以后缀树来做。\n具体地，把后缀树中的节点和 A 类串，B 类串放在一起建图。边要分两种，支配边和非支配边。如果图中有环则可以无限长。否则就是 DAG 上做一个简单 DP 即可。\n在建图过程中，由于要定位 A（B）类串在 SAM 上的状态，可以在后缀树上倍增。\n时间复杂度 O(n|\\Sigma|+(n_a+n_b)\\log_2n+m)。\n代码\n春节十二响\n给出一棵 n 个点有根树，每个点有点权 m_i。要求你把 n 个节点划分到若干个集合中使得： 每个点属于且仅属于一个集合；\n若 u,v 是祖孙关系，则 u 和 v 在不同的集合。 一种划分的代价是所有集合点权最大值的和。求最小代价。\nn\\le 2\\times 10^5,m_i\\le 10^9。 启发式合并 盲猜\n根节点一定单独一个集合。那么考虑根节点的儿子，他们会划分在哪些集合中？\n不同的子树是互不影响的。因此根节点的儿子要么自己开一个集合，要么放在别的子树中点权最大值比它的点权大的集合。\n然后再简单盲猜一下，发现两个不同子树的集合是可以合并的。对于两个子树的集合，我们把他们分别按照点权最大值排序，然后依次合并（两个集合的合并就是取 max）即可。\n可以启发式合并。\n使用 multiset 实现，时间复杂度 O(n\\log^2n)。\n注意：虽然本题不需要担心这个问题，但 multiset 仍然不是个好东西，它的 count() 方法复杂度与找到的元素数线性相关。\n代码\n皮配\n有 n 个数（学校）s_i，第 i 个数的颜色（城市）是 b_i。\n你有四个集合 A_0,A_1,B_0,B_1（A 和 B 是两个阵营），你需要给每个数选一个集合放进去。\n要求颜色相同的数放进相同的阵营（即，颜色相同的数，要么都放入 A_0,A_1，要么都放入 B_0,B_1）。\n同时要求： A_0,A_1 里数的和 \\le C_0；\nB_0,B_1 里数的和 \\le C_1；\nA_0,B_0 里数的和 \\le D_0；\nA_1,B_1 里数的和 \\le D_1； 同时，有 k 个数，他们有特殊的要求（偏好学校）：不能放在某一个集合中。\n问总方案数。\nc\\le n\\le 1000,k\\le 30,\\max(C_0,C_1,D_0,D_1)\\le 2500。 生成函数\n考虑生成函数。对于一个人数为 s 的学校，假设 x 的系数代表 C_1 的贡献，y 的系数代表 D_1 的贡献，那么一个学校的生成函数就是 (1+x^s)(1+y^s)=1+x^s+y^s+x^sy^s。\n考虑一个城市的生成函数。假设这个城市的学校的集合是 S。\n先假设这个城市里没有偏好学校。由于他们选的阵营是一样的，容易得到 \\left(1+x^{\\sum_{s\\in S}s}\\right)\\prod_{s\\in S}(1+y^s)而对于偏好学校，首先要知道，他们的生成函数是与普通学校不同的（少一项），因此基本上是不能整理成 (1+x^s)(1+y^s) 的形式的。而由于一个城市选的阵营得一样，因此我们需要把偏好学校的生成函数整理成 1\\cdot A+x^s\\cdot B 的形式。\n对于含有偏好学校的城市，假设这个城市中普通学校集合为 S_0，偏好学校集合为 S_1，那么可以得到 \\left(1\\cdot \\prod_{S_1}A + x^{\\sum_{s\\in S_0\\cup S_1}s}\\cdot \\prod_{S_1}B\\right)\\prod_{s\\in S_0}(1+y^s)那么所有城市的生成函数就是每个城市生成函数的乘积。设总人数为 X，那么我们要求的就是满足 X-C_0\\le a\\le C_1,X-D_0\\le b\\le D_1 的 x^ay^b 的系数和。\n考虑如何计算这个生产函数。对于无偏好学校的城市，他们的生成函数可以分别计算 x 和 y 的多项式系数。\n对于含有偏好学校的城市，首先可以把后面的 (1+y^s) 的系数快速计算出来，合并到之前的多项式中。注意到这类学校的个数不超过 30 个，而 s_i\\le 10，因此我们可以暴力计算出 \\prod_{S_1}A 和 \\prod_{S_1}B，然后计算出偏好学校的二维生成函数。\n然后我们枚举二维生成函数中的每一项，则他们对答案的贡献系数就是 x 和 y 多项式的一段区间和。那么前缀和优化一下即可。\n时间复杂度 O(k^2s^2_i+\\max(n,C_0,C_1,D_0,D_1)^2))。我也不知道复杂度算对没有，反正能过就对了。\n代码","title":"十二省联考 部分题解","updated":"2025-04-23T04:07:19.275Z"},{"categories":[],"path":"Probset/United-Provincial-Selection/","tags":[],"text":"冰火战士\n有两个二元组集合 (A,B)。有 q 次操作形如： 在 A 中插入 / 删除一个二元组。\n在 B 中插入 / 删除一个二元组。 每次操作后，你要输出 \\max_{t} \\min\\left( \\sum_{(x,y)\\in A}[x\\le t]y, \\sum_{(x,y)\\in B}[x\\ge t]y \\right)q \\le 2\\times 10^6, x\\le 2\\times 10^9, \\sum y\\le 2\\times 10^9. 树状数组 三分 二分\n注：时限 3s。\n首先把 x 离散化。容易发现 \\min 里的第一个函数是关于 t 不降的，而第二个函数是关于 t 不增的。那么可以把三分改成二分。\n在线段树上二分，常数爆炸。\n在树状数组上二分就赢了。当然，能使用树状数组的前提是函数里的运算可逆。\n时间复杂度 O(n\\log_2n)。\n代码\n组合数问题\n给出 n, z, p, m, a_i，求 \\sum_{k=0}^n \\binom{n}{k} f(k)z^k \\bmod p其中 f(x) = \\sum_{i=0}^m a_ix^i。\nn\\le 10^9, m\\le 1000, a_i\\le 10^9, z\\le 10^9。 斯特林数 下降幂\n推式子题。 \\begin{aligned}\n& \\sum_{k=0}^n \\binom{n}{k} f(k)z^k \\\\\n= & \\sum_{j=0}^m a_j\\sum_{k=0}^n \\binom{n}{k} k^jz^k \\\\\n= & \\sum_{j=0}^m a_j \\sum_{i=0}^jS(j,i) \\sum_{k=0}^n \\binom{n}{k} k^{\\underline{i}} z^k \\\\\n= & \\sum_{j=0}^m a_j \\sum_{i=0}^j S(j,i) \\binom{n}{i} i! \\sum_{k=0}^n \\binom{n-i}{k-i} z^k \\\\\n= & \\sum_{j=0}^m a_j \\sum_{i=0}^j S(j,i) n^{\\underline{i}} z^i (z+1)^{n-i}\n\\end{aligned}推式子的过程中有用到一个小结论： \\binom{a}{b} \\binom{b}{c} = \\binom{a}{c}\\binom{a-c}{b-c}代码\n树\n给出一棵带点权 a_i 的树，设 u 的子树是 T_u，那么定义 u 的价值 val(u) = \\bigoplus_{v\\in T_u}\\text{dist}(u,v)a_v求 \\sum_{i=1}^n val(i)。\nn, a_i \\le 5.5\\times 10^5。 Trie 启发式合并\n一道 zerobit 模板题。我们需要支持 插入一个数。\n把所有数加 1。\n合并两个集合。\n求异或和。 考虑从低位到高位建 Trie，即把数字的二进制表示反转，然后建 Trie。\n把所有数加 1 相当于左右儿子交换，即模拟二进制的进位过程。\nvoid inc(int u)&#123; if(!u)return; swap(lc[u], rc[u]); inc(lc[u]); pushup(u);\n&#125;\n算上启发式合并的复杂度，总复杂度 O(n\\log n)。\n完整代码\n信号传递\n有一个长度为 n 的序列 s，其中 1\\le s_i \\le m。对于一个 m 的排列 p，规定 f(i) = \\begin{cases}\np_{s_{i+1} } - p_{s_i} & p_{s_i} \\le p_{s_{i+1} }\\\\\nk(p_{s_{i+1} } + p_{s_i}) & p_{s_I} &gt; p_{s_{i+1}}\n\\end{cases}求一个排列 p 使得最小化 \\sum_{i=1}^{n-1} f(i)。输出这个最小化的和即可。\nm\\le 23, n\\le 10^5, k\\le 100。 状圧 DP 卡空间\n一看 m 很小，考虑状圧。那么对于 [m] 的一个子集 S，假设这个子集分布在 p 的一个前缀 p[1,|S|]，那么我们枚举 p_{|S|+1} 上的数，容易算出增量。这样就可以转移了。\n但这题卡空间。\n一个比较 OK 的做法是用 STL 的 queue 把状态按照 pop count 来 BFS。可以看 dyls 的博客。\n复杂度可以做到 O(2^mm)。\n作业题\n给出一个 n 个点 m 条边带边权 w 的无向图 G。对于其生成树 T，记 val(T) = \\gcd_{(u,v)\\in T}w(u,v)\\cdot \\sum_{(u,v)\\in T}w(u,v)求 G 的所有生成树的权值和。\nn\\le 30, w(u,v)\\le 1.6\\times 10^5。 矩阵树定理 莫比乌斯反演\n做这种题有两个要点： 相应的知识点要掌握；\n会算复杂度。 首先看到 \\gcd，给它上一个 \\varphi \\ast 1=\\text{ID}： val(T) = \\sum_{d | w_1,d|w_2,\\ldots, d|w_{n-1}}\\varphi(d)\\cdot \\sum_{(u,v)\\in T}w(u,v)那么改一下枚举顺序得到 \\sum_{d=1}^{W} \\varphi(d) \\sum_{T\\in\\text{span}(G(d))} \\sum_{(u,v)\\in T}w(u,v)这里 G(d) 指 (V, E'=\\{(u,v)\\in E : d | w(u,v)\\})，也就是仅保留 d 的倍数的边。\n当然，边权得整成一个 1+w(u,v)x 来做矩阵树。详情见 矩阵树定理学习笔记\n你一看，复杂度 O(Wn^3)，它说它是暴力。\n它可不是暴力啊。把 E'=\\varnothing 的情况去掉，考虑边数是 O(n^2) 的，看来是 O\\left(\\frac{\\sum_{(u,v) \\in E}\\sigma_0(w(u,v))}{n-1}n^3\\right) = O(n^4\\max_{w\\le W}\\sigma_0(w)) 啊。\n不用劝了\n另外，这题涉及到一个多项式求逆的问题。对于常数项为 0 的多项式，它没有逆。如果在高斯消元的过程中这一列剩余元素里 (i,i) 下方的元素找不到常数项非 0 的多项式，我们可以把这些元素对应的多项式同时除以 x，然后继续求行列式。求出的行列式再乘上 x 即可。\n正确性考虑这样一个消元过程：枚举 i： 找到 (i,i) 下方第一个非零（有逆元）元素并将它所在行与第 i 行交换（行列式反号）。\n把 (i,i) 下方的元素都消成 0。\n把 (i,i) 右方的元素都消成 0。 这样我们会得到一个对角矩阵。而如果在这个过程中出现找不到非零元素（常数项非零的多项式) 的情况，我们可以直接把第 i 列所有元素都除以 x。因为 (i,i) 上面的元素都是 0，除以 x 后还是 0。因此在这个消元算法的情形下我们的做法是对的。\n那么对于原本的高斯消元做法呢？原本的算法里，(i,i) 上面可能有常数项非 0 的多项式，对它们除以 x 是没有解的（因为一个多项式乘 x 常数项必为 0）。但这影响吗？不影响！因为 (i,i) 上面的元素既不会参与接下来的消元，也不会参与行列式的计算。换个角度想，你把 (i,i) 右边元素消成 0 的过程，也不会对第 i 行下面的元素造成影响。因此从行列式计算的角度，这一步可以不做。 代码\n魔法商店\n给出 n 个二元组 (c_i, v_i)。\n满足 \\{c_e : e\\in A\\} 是线性基的 A 被称作礼品集合。定义礼物集合 A 的价值 W(A) = \\sum_{e\\in A}v_e。\n给出两个不同的礼物集合 ，要求将 v_i 变成 v_i' 使得对于任意礼物集合 C 都有 W(A)\\le W(C)\\le W(B)。\n最小化变换的代价： \\sum_{i=1}^n (v_i - v_i')^2 并输出。\nn\\le 1000, m\\le 64, v_i\\le 10^6, 0\\le c_i&lt; 2^{64}。 保序回归 拟阵 网络流 最大权闭合子图 整体二分\n线性空间是拟阵，则根据强基交换定理，对于 A，我们找到所有 x\\in A, y\\notin A 使得 A' = A-\\{x\\}+\\{y\\} 是礼物集合，那么只要保证 W(A)\\le W(A') 即可。\nW(A)\\le W(A') 等价于 v_x'\\le v_y'。\n因此我们对于 A 和 B 分别建出偏序关系，然后跑一个保序回归即可。\n时间复杂度 O(n^2m\\log_2n)。其中 Dinic 复杂度 O(n^2m)。\n要写当前弧优化。\n代码\n消息传递\n给出一棵 n 个点的树，m 次询问 (x,k)，求距离点 x 为 k 的点数。T 组数据。\nn,m\\le 10^5,T\\le 5。 点分治\n强制在线的话可以点分树。\n但其实可以直接点分离线做。\n对于当前的连通块的分治重心 c 和这个连通块里的询问集合 Q，以 c 为根，求出 a_i 表示到 c 距离为 i 的点数，再对于 c 的所有儿子 v 求出 b_{v,i} 表示 v 子树中的点到 c 的距离为 i 的点数，就可以统计关于每个询问的贡献了。\n时间复杂度 O(T(n+m)\\log n)。\n代码\n丁香之路\n有一个 n 个点的完全图，其中 (u,v) 的长度是 |u-v|。对其中的 m 条边打标记。给定起点 s，对于每个结点 i，求出从 s 走到 i 且每条被打标记的边至少被经过一次的最短距离。\n边可以多次被经过。\nn\\le 2500。 欧拉回路 最小生成树\n固定 i。问题可以转化为：给出无向图 G = (V,E)，其中 E 表示被打标记的边。要求往 E 里加 (s,i)，再加若干条长度和最小的边，使得有欧拉回路。允许有重边，即 E 是可重集。\n设 E' = E + \\{(s,i)\\}，不难想到将奇度点两两配对连边，但这样构造出来的不一定是连通的欧拉图。\n但注意到本题边长度特殊，我们可以把点按照 1,2,\\ldots,n 的顺序排成一行。对于加入的边 (u,v)，我们可以将其分解为 (u,u+1), (u+1,u+2),\\ldots, (v-1,v)。这与原边是等价的，并且可以连上沿途的点。\n我们先不管奇度点匹配的方法，假设我们已经匹配完了奇度点并按照上面的方法分解连边，使得图中没有奇度点了。那么为了让剩下的块连通，我们找一个 MST 即可，这个 MST 的边会被走两次。这个用 MST 算法就行，MST 的连边同样要分解。\n最后，考虑奇度点如何匹配的问题。由于 MST 的边会被走两次，因此对于四个奇度点 a,b,c,d，按照上面的连法，(a,b),(c,d) 匹配，是比 (a,d),(b,c) 匹配更优的。所以我们直接把奇度点按标号排序，相邻的依次匹配即可。\n要对每个 i 求答案，稍微优化一下复杂度就行。\n时间复杂度 O((n^2+m)\\log n)。\n非要用桶排或者并查集优化也不是不行，但没必要。\n代码","title":"联合省选 2020 补题记录","updated":"2025-04-23T04:07:19.275Z"},{"categories":[],"path":"Probset/eJOI/","tags":[],"text":"元素周期表\nn\\times m 个网格，事先标记 q 个位置。\n操作：如果 (x_1,y_1),(x_1,y_2),(x_2,y_1) 都被标记了（x_1\\ne x_2,y_1\\ne y_2），那么就可以标记 (x_2,y_2)。\n你需要在这个 q 个标记的基础上再加尽量少的标记，使得执行上述操作若干次可以标记所有格子。\nn,m,q\\le 2\\times 10^5。 并查集 二分图\n把 (x,y) 当成二分图的一条边。那么上文中的 (x_1,y_1),(x_1,y_2),(x_2,y_1) 显然是在一个连通块内的。\n一次操作不会改变连通块数量。\n操作可以让连通块变满。\n因此我们需要最少的标记把所有连通块连在一起。\n统计连通块数量即可。\n代码\n塔\n一个序列，初始时只有一个 1。每次可以选择一个区间，把它们的和加到序列的末尾。问最少多少次操作可以构造出数字 s。\n多组询问。\ns\\le 10^{18}。 一开始序列的和是 1。注意到你可以一次操作 让序列的和乘 2\n让序列的和乘 2 减 1 因此我们想办法让序列总和为 s，再操作一次就可以得到 s 了。\n容易证明这是答案的下界。\n时间复杂度 O(t\\log_2s)。\n代码","title":"eJOI 题目选做","updated":"2025-04-23T04:07:19.275Z"},{"categories":[],"path":"String/SAM-Application/","tags":[{"name":"Automaton","slug":"Automaton","permalink":"https://notes.sshwy.name/tags/Automaton/"},{"name":"SAM","slug":"SAM","permalink":"https://notes.sshwy.name/tags/SAM/"},{"name":"Suffix-Tree","slug":"Suffix-Tree","permalink":"https://notes.sshwy.name/tags/Suffix-Tree/"}],"text":"关于本文中的符号的定义，参见《后缀自动机与后缀树》一文的摘要。\nA 简单应用两个后缀 LCP后缀树\n就是两个结点在 fail 树上的 LCA。\n本质不同的子串个数后缀树\n设 \\ell(q) 表示等价类 q 中最长的字符串的长度，也就是通常称的 \\text{len}(q)。则显然 |q|=\\ell(q)-\\ell(\\theta(q))。因此 s 的本质不同子串个数为 \\sum_{q\\in Q,q\\ne q_0}\\ell(q)-\\ell(\\theta(q))字典序第 k 小子串SAM 多组询问，查询 s 的子串中字典序第 k 小的子串。 遇到字典序最小的问题，就不太能用后缀树求解。因此我们直接利用 \\delta，在 SAM 上 DFS 一遍即可。\n复杂度 O(|S||\\Sigma|)。\n匹配同构串\n询问在串 s 中出现了多少次 x 的循环同构串。 SAM\n首先对 s 建 SAM，然后先在 SAM 上跑一遍 x。再接着跑一遍，这次就可以记录答案了。我们记录一个当前匹配的长度，对 x 的长度取 min。这样我们就可以判断当前结点包含的状态中是否有 x 的循环同构串。有一个贪心的想法就是，每次走了一个字符，就贪心地跳 fail，要求 fail 的长度也大于等于当前匹配长度。因为 fail 的转移指针是包含它的儿子结点的。然后加上当前状态的出现次数即可。\nCF 234C\nB 进阶套路B1\n设 f(i) 为所有长度为 i 的子串的出现次数的最大值，求 f(1),f(2),\\cdots,f(|S|)。|S|\\le 250000。 SAM 可以算出每个子串的出现次数。对于结点 u，相当于区间 [\\ell(\\theta(u))+1,\\ell(u)] 的答案对 cnt(u) 取 \\max。\n事实上没有这么复杂。由于 f(i)\\ge f(i+1)，因此可以把区间左端点置为 1，也就是个前缀 \\max。扫一遍即可。\n时间复杂度 O(n)。\nB2\n维护串 S，支持 在末端添加一个字符\n询问 T 在 S 中的出现次数。 \\sum |T|,Q\\le 10^5。 显然，我们需要动态维护 Fail 树，支持： 添加一个叶子结点 / 中间多一个结点\n查询子树和 可以直接 LCT。但这题动态性较弱，可以平衡树维护 DFS 序来做。\n离线的话直接把整个 SAM 建出来，然后询问离线搞一下就行。\nB3\n给定串 T。对于串 s，定义它的权值是至少需要几个 T 的子串拼起来得到。拼不出来就是 -1。求长度为为 n 的权值最大的串的权值。\nn\\le 10^{18},1\\le |T|\\le 10^5,|\\Sigma|\\le 4。 对于一个串 s，如何计算它的权值？\n它满足贪心条件，我们贪心地匹配 T 的子串直到不能匹配，就断开。\n假设分成 k 段 s_1\\cdots s_k，那么有 \\forall s_i\\in T, s_i(s_{i+1}[1])\\notin T。\n于是我们设 w(x,y) 表示最短的串 s 使得 s[1]=x,s\\in T,sy\\notin T 的长度。显然可以瞎搞搞出来。\n然后用它二分 + 矩乘即可得到答案。这是双 log 的。\n把二分改成倍增就是单 log。\nB4\n给定字符串 S，对于每个 k，求把 S[k] 变成#后，本质不同的 S 的子串的个数。\n1\\le |S|\\le 10^5。 容斥，我们要求的就是 S[1,k-1] 的本质不同数，S[k+1,|S|] 的本质不同数，S[1,k-1],S[k+1,|S|] 的公共本质不同子串数。前两者可以正着倒着建 SAM 求出。\n对于后者，我们考虑每个 SAM 结点的贡献。\n对于每个结点 u，我们求出它出现的最左边和最右边的位置，分别记为 L,R。\n那么对于 x\\in (\\ell(\\theta(u)),\\ell(u)]，区间 [L+x,R-1] 的答案就会加 1。\n差分一下，就变成了 x\\in (\\ell(\\theta(u)),\\ell(u)]，L+x 的加 1，R 的减 1。\n二次差分就变成纯单点了。\n这样，总复杂度就是 O(|S||\\Sigma|) 的。\nB5 线段树维护 Right 集合所谓的 Right 集合是指一个状态 q 在原串中所有出现的位置的集合。\n与求子串出现次数类似，我们在构建 SAM 的时候每次在 last 结点的集合里插入一个位置。然后建完 SAM 后线段树合并一下即可。\nCHEOI2016 字符串\n给定字符串 s 和 q 个询问，每个问题形如 a, b, c, d 四个参数，询问 s[a,b] 的所有子串和 s[c,d] 的 LCP 的长度的最大值。1 \\le n, q \\le 10^5。 首先把串翻转，问题转化为 s[a,b] 的子串与 s[c,d] 的 LCS 的长度的最大值。\n也就是说我们想知道 s[c,d] 的最长的被包含在 s[a,b] 中的后缀。二分转化为判定问题。判定问题可以使用线段树维护 Right 集合来解决。\n时间复杂度 O(n\\log_2^2n)。\n参考文献OIWIKI. 后缀自动机 (SAM). https://oi-wiki.org/string/sam/","title":"SAM 应用","updated":"2025-04-23T04:07:19.276Z"},{"categories":[],"path":"21-WC-Sum/","tags":[{"name":"Original","slug":"Original","permalink":"https://notes.sshwy.name/tags/Original/"},{"name":"WC2021","slug":"WC2021","permalink":"https://notes.sshwy.name/tags/WC2021/"}],"text":"一波三折。\n本文主要内容会有我发的三篇 QQ 动态，有相应的补充（比如比赛过程），整理成一篇游记。\nDay 0比赛前夜，我失眠了。\n酒店房间离公路有点近，窗帘也拉不严实，有微光渗入。但其实，主要还是我很紧张的缘故。\n半夜有被我妈吵醒过一次，然后直到 2 点过才睡着（我最后一次看表的时间）。当时我有点埋怨，但很快就意识到\n这不能解决问题。\nDay 1 AM迷迷糊糊终于到早上。\n为了赶时间，早餐（抄手）没吃完就赶路去了。\n进了考场才 TM 告诉我不能带食物进机房。而且我身上的荷氏（薄荷糖）会被金属检测的那个东西检测出来（我：？？？）\n开考前那一段时间（从起床算起）我大概进入了一种奇妙的状态，睡不醒、压力、紧张、害怕。\n而且这次四川的时间管得特严，到了 8:30 才允许碰键盘。往常是坐到位置上就可以敲板子的那种。\n比赛历程： 打开虚拟机，写 vimrc，解压压缩包。\n按顺序开完三道题，一道都不会。我当时看 T3 的 20 分部分分，只会 O(nm^2) 的做法。感觉是因为失眠导致思维僵化。可能不只是僵化，直接思考不能 /youl\n回头看了看 T1，发现我连个暴搜都不太会，于是去看 T2，发现没有问号的部分就是个表达式解析，有 50 分，然后就开始写代码。\n写完 T2 50 分时，脑子稍微清醒一点了，然后发现建出表达式树就可以搞一个 O(nm|S|) 的做法了，两个做法合起来有 70 分。\n当时我写完 O(nm|S|) 做法后，然后写了数据分治。结果等我写完数据分治，脑子抽了一下，把没有问号的部分分的复杂度也算成了 O(nm|S|)（本来应该是 O(n|S|)），然后我啪得一下，很快啊，就把数据分治删掉了，只保留了 O(nm|S|) 做法。\n然后发现 T3 的 20 分是傻逼玩意，就 10 分钟写出来了。\n到此时，比赛大概过去了两个半小时。然后我回头看 T1 去了。从这里开始可以算是剧情发展的一个小高潮。\n当时我的心理活动是这样的：\n这题是个计数。计数题要么不重不漏，要么容斥。\n这个题看着就很不容斥。\n不是个 DAG，没有偏序关系。图没有特殊的性质。\n枚举一个点，计算另一个点的方案数？看起来，既不可做，又不能不重不漏。\n这什么憨批题啊 后来仔细想了想，题目的突破口不是图的结构，那就只能是括号序列。这题的括号序列还分多种不同括号，据此我就想到了自己出的一道题（当时是出给 EOJ round 的，但东哥说有点难就换成了一道签到题，这道题丢库存了），是道祖传折叠题，题目的约束是只有边权相同的边能折到一起。\n于是我想到从一个点出发，走两条括号序列相同但终点不同的路径，则这两个终点就是满足题意的一个 pair。这可以维护 (&#123;()&#125;)，即括号序列 A 外面套一对括号的情况。\n我发现，用并查集维护这东西，就能顺便把两个括号序列连接的情况考虑了。\n当时我就不困了，有种心跳加速的感觉，眼皮也不酸了，激动的我决定，去上个撤硕（雾）\n然后就开始写了，由于当时想得不太清楚，重构了一次代码才写出来一个俩 log 做法。\n然后发现这个俩 log 做法过不了第四个样例——WA 了。\n然后我调了半个小时才发现，是我并查集写错了。我写的并查集：int get(int u) &#123; return fa[u] == u ? u : fa[u]; &#125;。这么写甚至能过第三个样例。\n然后离比赛结束还有大概 20 分钟。就检查了一会，结束。 Day 1 PM考完后估分：100+70+20\n然后和刘哥交流了一下，发现 T2 复杂度算错了，于是变成了：100+55+20\n考完后跟着刘哥一起吃了一顿烤肉，很开心。\n然后和高爸交流了一下，发现俩 log 不太能过 3e5 的 1s，于是变成了：80+55+20\nsshwy 的心态发生了一点变化……\nDay 2CCF 评测结果：92+0+20？？？\n我当时就感觉一块巨石突兀地出现在胸口。\n然后我本机测了一下 T2 的 test1，发现它是对的！然后我用 lemon 测了一下所有数据，有 55 分。\n果断申诉。\n但是我发现，CCF 已经把冬令营获奖名单放到官网了，我直接铜牌。感觉申诉通过十分渺茫，心态差点就炸了。没炸的原因是我这天有 6h 都在补文化课，转移了注意力。\nDay 3教练那边说没消息。不过经过昨晚的调整，我的心态稳了不少，感觉也没啥了。虽然还是不太舒服就是了。\n直到晚上 11 点半，我听到我妈接了个电话。隔着一扇门，我隐约听见我教练的声音，还听我妈说了一句「真的吗？」\n于是我果断下床。之后的剧情也没必要说了。概括一下就是我简直 high 到不行。\n申诉后的成绩：92+70+20。“考好了就是逆风翻盘。”\n这个晚上，我也失眠了。\n结语OI 对我就像是一次旅行。\n每一段旅行都有终点。\n我有期待，有担忧，有后悔，在乐观和悲观之间徘徊，但是没有挣扎。\n每一段旅行，都有终点。\n非常感谢鼓励我前行的各位，也很幸运与各位一起走过这段旅途。当然，它尚未结束。\n其实还是有点不放心，因为 CCF 官网的冬令营获奖名单还没更新。不过应该会更新的，不然申诉就没意义了。等吧。\n好，四川信奥委的文件发下来了，省队名单公布了，放心了。\n更多背景事件可以看这篇游记","title":"2021 CCF 冬令营 游记","updated":"2025-04-23T04:07:19.260Z"},{"categories":[],"path":"Isotonic-Regression/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"和拟阵一样，做一道联合省选题的时候遇到了这个，之前高爸也屡次♂邀请♂我学它，于是就有了本文。\n保序回归问题对于有向无环图 G = (V,E)，定义代价函数 w 和初态函数 y，求一个终态函数 f 使得 若 (u,v) \\in E，则 f_u \\le f_v。 求 \\min \\sum_{u\\in V} w_u|f_u - y_u|^p（1\\le p&lt;\\infty）。\n另一种形式的保序回归问题，以后再讨论。\n特殊情形当 p=1，一定存在一个最优解使得 \\{f_i\\}\\subseteq\\{y_i\\}。\n我们可以对 V 做整体二分，对于区间 [L,R] 假设其中点为 M，那么我们强制 y_M\\le f_i \\le y_{M+1}，也就是说 f_i 的取值只有 \\{y_M,y_{M+1}\\}，求最小回归代价。\n这是一个 01 决策问题，可以转化为最小权闭合子图问题。\n在得到每个点的决策后，对于两边再分别整体二分即可。\n最大权闭合子图问题最大权闭合子图问题为：给出一个带点权的有向图 G=(V,E)，要求选择 V 的一个子集使得点权和最大，同时满足：若 u 被选那么 u 的后继也要被选。\n这个问题可以利用最小割解决。直接把这个有向图当作网络图，E 中的边容量都为无限大。加入一些新的边： 若 u 的点权为正，则加一条 s 到 u 的容量为点权的边；\n若 u 的点权为负，则加一条 u 到 t 的容量为点权绝对值的边。 对这个图跑最小割，答案即为正权点的和减去最小割的容量。\n可以理解为：割一条 (s,u) 的边代表不选这个点，割一条 (u,t) 的边代表选这个点。\n一般情形只要 p&lt;\\infty，那么我们将在 V 上二分更改为在实数集上整体二分即可求出关于某个精度的近似解。\n在信息学竞赛中，一般求的是整数解，因此在整数集上二分也可。\n参考文献高睿泉，《浅谈保序回归问题》，IOI2018 中国国家集训队论文。","title":"保序回归学习笔记","updated":"2025-04-23T04:07:19.266Z"},{"categories":[],"path":"Matroid/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"做一道联合省选题的时候遇到了这个，之前高爸也屡次♂邀请♂我学它，于是就有了本文。\n本文旨在介绍拟阵的概念和应用，其中部分定理不会作出证明，详细的证明请阅读集训队论文。\n拟阵第一定义拟阵（Matroid）是指一个集合 S 与其幂集的子集（family of subset）\\mathcal{I}（\\mathcal{I}\\subseteq 2^S）构成的二元组 (S,\\mathcal{I}) 使得 \\mathcal{I} 满足： 遗传性：若 I\\in \\mathcal{I}，那么 \\forall A\\subseteq I，有 A\\in \\mathcal{I}。\n扩张性（也称交换性）：对于 A,B\\in \\mathcal{I} 且 |A| &lt; |B|，一定存在 e\\in B\\setminus A 使得 A+\\{e\\} \\in \\mathcal{I}。 其中 S 被称为基础集，I\\in \\mathcal{I} 被称为独立集，\\mathcal{I} 则是独立集的集合。\n上述两个条件也被称作拟阵公理，它们是拟阵最基本的特征。基于拟阵公理，我们可以容易地理解以下模型的拟阵性。\n图拟阵图拟阵描述的是对于无向图 G=(V,E)，以边集 E 做为基础集的拟阵 (E, \\mathcal{I})，其中 I\\in \\mathcal{I} 当且仅当 I 无环。\n从拟阵公理的角度： 图拟阵的遗传性是显然的。\n扩张性：对于 A,B\\in \\mathcal{I}，若 |A| &lt; |B|，那么图 (V,A) 的连通块数一定多余 (V,B) 的连通块数，那么一定存在 B 的一个连通块，它在 A 里是不连通的，这时我们就可以找到一条边 e \\in B\\setminus A 使得 A+ \\{e\\} 无环，即 A\\cup \\{e\\} 是独立集。则扩张性成立。 线性空间拟阵这名字我起的，不够严谨。\n线性空间拟阵描述的是以线性空间 S 做为基础集的拟阵 (S,\\mathcal{I})，其中 I \\in \\mathcal{I} 当且仅当向量组 I 线性无关。\n同样地，从拟阵公理的角度： 遗传性显然。\n扩张性：对于 A,B\\in \\mathcal{I}，若 |A| &lt; |B|，则 B 中一定存在一个向量 e 不能被 A 中的向量线性表出（如果不存在，那么 B 就能被 A 表出，则 B 中的向量不可能互相线性无关）。 拟阵第二定义拟阵的第二定义是从秩函数的角度出发。对于基础集 S 和其幂集的子集 \\mathcal{I}（\\mathcal{I}\\subseteq 2^S），定义秩函数（rank function）r(U)： r(U) = \\max_{I\\subseteq U, I\\in \\mathcal{I}} |I|即 U 的极大独立子集。\n那么如果 r 满足如下三个性质，我们就称 (S,\\mathcal{I}) 是拟阵： 有界性：r(U)\\le |U|；\n单调性：\\forall A\\subseteq B\\subseteq S，有 r(A) \\le r(B)；\n次模性：\\forall A,B\\subseteq S，r(A\\cup B) + r(A\\cap B) \\le r(A) + r(B)。 如何理解次模性次模性可以理解为边际效益递减，其有一个更直观的等价的表达式：\n\\forall A\\subseteq B\\subseteq S 且 \\forall e\\notin B, e\\in S，有 r(A+\\{e\\}) - r(A)\\ge r(B+\\{e\\}) - r(B)。\n也就是说我往 A 里加一个元素的秩的增量大于等于往 B 里加一个元素的秩的增量。\nB 是 A 已经吸纳了 B\\setminus A 这部分元素得到的，于是 B 再吸纳 e 带来的收益就比不上 A 直接吸纳 e 带来的收益。\n如果放在全序集合上，这其实就是凸性的体现。 拟阵第一定义和第二定义是可以互推的。\n我们同样用两个例子来补充叙述这一定义。\n图拟阵：对于图拟阵 (E, \\mathcal{I})，其秩函数 r(U) 实质上是 G[U] 的生成森林的边数。其单调性和有界性都很容易证明，而次模性可以使用其第二种表达式来证明。\n线性空间拟阵：对于线性空间拟阵 (S,\\mathcal{I})，其秩函数 r(U) 描述的是 U 中的最大线性无关组（或者说线性基）的大小。证明不做详细阐述。\n接下来我们用拟阵的两种定义来介绍更多关于拟阵的概念，以丰富它的工具性。\n基与交换定理对于拟阵 M = (S, \\mathcal{I}) 中的一个独立集 I，若往 I 中加入任意一个元素都会让它变成非独立集，那么称 I 是拟阵 M 的一个基，也称极大独立集。\n容易证明，拟阵的基大小相同。\n基有另一个等价的定义形式：满足 |I| = r(S) 的独立集 I 是拟阵 M 的基。\n关于基有两个定理，分别是（弱）基交换定理和强基交换定理。\n弱基交换定理：对于任意拟阵 M，若存在两个不同的基 A,B，则 \\forall x\\in A\\setminus B，\\exists y\\in B\\setminus A 使得 A-\\{x\\} + \\{y\\} 是基。\n强基交换定理：对于任意拟阵 M，若存在两个不同的基 A,B，则 \\forall x\\in A\\setminus B，\\exists y\\in B\\setminus A 使得 A-\\{x\\} + \\{y\\} 和 B-\\{y\\} + \\{x\\} 都是基。\n具体的证明参见论文。\n拟阵上的最优化问题拟阵上的最优化问题定义为：给出拟阵 M=(S,\\mathcal{I})，给出价值函数 w:S\\to\\mathbf{R}。对于 A\\subseteq S 定义 W(A) = \\sum_{e\\in A}w(e)。求 \\max_{I\\in \\mathcal{I}}W(I)。\n拟阵上的最优化问题可以使用贪心算法，即将 e\\in S 按照 w(e) 不升的顺序排列，令 I 初始为空集，然后从大到小在保证 I 独立的前提下将 e 加到 I 中，最后得到的就是最优解。\n详细的证明不展开叙述。\n最小生成树问题（MST）和和寻找线性基的问题都可以规约为拟阵上的最优化问题。有关的贪心算法的正确性因此得到了保证。\n拟阵的基础操作接下来介绍三种关于拟阵的操作，这可以帮助我们更深刻地理解拟阵模型的变换。\n对偶对于拟阵 M = (S,\\mathcal{I})，定义其对偶拟阵为 M^\\ast = (S,\\mathcal{I}^\\ast)，其中 \\mathcal I^\\ast = \\{I : \\exists B\\in\\mathcal I, |B|=r(S), B\\subseteq S\\setminus I\\}，即存在一个 M 中的基 B 使得 B\\subseteq S\\setminus I。\n这里我们断言拟阵的对偶仍是拟阵，这一点不论是用拟阵第一定义还是第二定义都可以证明。\n对偶运算具有自反性，这从它的定义就可以得知。\n举一个对偶拟阵的例子：图拟阵 (E, \\mathcal I) 的对偶拟阵为 (E, \\mathcal I^\\ast)，其中 I\\in \\mathcal I^\\ast 当且仅当 E-I 存在基，即存在生成树，即连通。\n换言之，I\\in \\mathcal I^\\ast 当且仅当删掉 I 中的边后，图仍然连通。\n删除对于拟阵 M = (S,\\mathcal I) 和 Z\\subseteq S，定义 M 删除 Z 的拟阵是 M\\setminus Z = (S - Z, \\mathcal I')，其中 \\mathcal I' = \\{I : I\\subseteq S-Z, I\\in \\mathcal I\\}。\n换言之，就是删掉 Z 中的部分得到的拟阵。\n同样以图拟阵为例，(E, \\mathcal I) 删除 Z（Z\\subseteq E）的拟阵就是 G=(V, E-Z) 对应的图拟阵。\n收缩对于拟阵 M = (S,\\mathcal I) 和 Z\\subseteq S，定义 M 收缩 Z 的拟阵是 M/Z = (M^\\ast\\setminus Z)^\\ast。\n这东西看着不太直观，经过一番推导我们得到它的秩函数 r_{M/Z}(U) = r_M(Z\\cup U) - r_M(Z)。\n通过这个秩函数，我们将收缩理解为强制选取了 Z 中的一组基。\n仍然以图拟阵为例，对应 M_G = (E,\\mathcal I)： M_G^\\ast 的独立集 I：删掉 I 中的边后图仍然连通。\nM_G^\\ast \\setminus Z 的独立集 I：强制 Z 中的边不能被删（即强制 I\\cap Z = \\varnothing），删掉 I 中的边后图仍然连通。\n(M_G^\\ast \\setminus Z)^\\ast 的独立集 I：强制 I 满足 I\\cap Z 是 Z 的生成森林（基）。 因此图拟阵收缩 Z 可以理解为缩边操作。\n拟阵的交提示：这部分内容与拟阵的基础操作不太相关。\n对于两个相同基础集 S 上的拟阵 M_1= (S, \\mathcal I_1) 和 M_2 = (S, \\mathcal I_2)，定义它们的交 (S, \\mathcal I_1\\cap \\mathcal I_2)。\n拟阵的交，不一定是拟阵。\n（带权）拟阵交问题定义为：给出价值函数 w:S\\to\\mathbf{R}。对于 A\\subseteq S 定义 W(A) = \\sum_{e\\in A}w(e)。则求 \\max_{I\\in \\mathcal I_1 \\cap \\mathcal I _2} W(I)。\n为了描述求拟阵交的算法，我们先定义关于两个拟阵 M_1, M_2 的交换图 D_{M_1, M_2}(I)： 其为二分图，左部和右部的点集分别为 I 和 S\\setminus I。\n一条从 I 到 S\\setminus I 的边 (u,v) 存在，当且仅当 I-\\{u\\} +\\{v\\}\\in \\mathcal I_1。\n一条从 S\\setminus I 到 I 的边 (v,u) 存在，当且仅当 I-\\{u\\} +\\{v\\}\\in \\mathcal I_2。 也就是说这个二分图里从左到右的边都是满足 \\mathcal I_1 的，从右到左的边都是满足 \\mathcal I_2 的。\n我们还需要定义关于 I 的两个集合 X_1, X_2： X_1 = \\{x \\in S\\setminus I: I+\\{x\\}\\in \\mathcal I_1\\}。\nX_2 = \\{x \\in S\\setminus I: I+\\{x\\}\\in \\mathcal I_2\\}。 以及一个关于 I 的点权函数： f(u) = \\begin{cases}\nw(u) & u\\in S\\setminus I\\\\\n-w(u) & u\\in I\n\\end{cases}接下来我们就可以描述求拟阵交问题的算法——称之为增广路算法足够恰当。\n考虑逐步扩张 I。初始 I=\\varnothing。每次我们找一条从 X_1 中的点出发，交替经过 I 和 S\\setminus I 中的点，最后到达 X_2 中的点的点权和最小的简单路径 P，然后令 I\\gets I\\Delta P，即 I 和 P 的对称差。直到找不到 P。最后得到的就是拟阵交的最大权独立集。\n注意，若 X_1\\cap X_2 非空，算法可能会直接扩张一个属于交集的元素。\n算法的正确性证明见论文。\n从算法应用的角度，我们关注的是如何快速求出二分图的边集，或者说在找增广路的过程中如何快速找到后继。若只考虑增广的复杂度，我们最多增广 r = \\max(r_1(S), r_2(S)) 次，则总复杂度 O(r^2n)。\n例题时间有点晚，写一道吧，有时间再补补。\nRainbow Graph\n给定一张带权无向图 G = (V, E)，每条边是三种颜色红绿蓝之一。要求对于从 1 到 |E| 的每个 k ，都求出来：选出 k 条边并使得不含红色边的图和不含蓝色边的图都连通的最小权值，如果不存在则输出 -1。\n|V|, |E| \\le 100。 将问题转化为：删除 k 条边使得不含红色边的图和不含蓝色边的图都连通。因此构造： M_1 = (E,\\mathcal I_1)，I\\in \\mathcal I_1 描述的是删掉 I 中的边后不含红色边的图连通。\nM_2 = (E,\\mathcal I_2)，I\\in \\mathcal I_2 描述的是删掉 I 中的边后不含蓝色边的图连通。 通过拟阵第一定义可以证明这两个都是拟阵。求拟阵交即可。由于拟阵交的增广路算法是从空集逐步拓展的，因此可以得到每个 k 的答案。\n参考文献杨乾澜 ，《浅谈拟阵的一些拓展及其应用》，IOI2018 中国国家集训队论文。","title":"拟阵学习笔记","updated":"2025-04-23T04:07:19.271Z"},{"categories":[],"path":"Math/Linear-Algbra/Matrix-Tree/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"矩阵树定理（Matrix-tree Theorem）是把图的生成树个数和矩阵行列式联系起来的一个定理。\n矩阵树定理有向图内向生成树计数对于无自环（允许有重边）的有向图 G=(V,E)。设出度矩阵 D(G) 表示每个点的出度的对角矩阵。而 A(G) 表示邻接矩阵，A_{ij} 表示 (i\\to j) 的边数。那么可得到对应的拉普拉斯矩阵（Laplacian Matrix） L(G)=D(G)-A(G)。\nL(G) 关于 L(G)_{k,k} 的余子式（也是主子式）是以 k 为根的内向生成树的个数。\n无向图生成树计数主子式形式对于无自环（允许有重边）无向图 G=(V,E)，设度数矩阵 D(G) 表示每个点的度，而 A(G) 表示邻接矩阵，A_{ij} 表示 (i,j) 的重边数。则 L(G)=D(G)-A(G)。\n对于任意 i\\in[1,n]，L(G) 关于 L(G)_{i,i} 的余子式是生成树的个数。即，无向图的拉普拉斯矩阵的所有 n-1 阶主子式的行列式值都相等。\n注意到无向图矩阵树定理求的实际上是 \\sum_{T}\\prod_{(i,j)\\in T}A_{ij}，因此它也可以理解为是求所有生成树的边权乘积的和。\n特征值形式对于 L(G) 的 n-1 个非零特征值（即无向图的 L(G) 至少有一个特征值为 0）\\lambda_1,\\lambda_2,\\cdots,\\lambda_{n-1}，G 的生成树个数为 \\frac{1}{n}\\prod_{i=1}^{n-1}\\lambda_i关联矩阵在矩阵树定理应用的过程中，我们不太需要关注证明，但需要知道拉普拉斯矩阵是怎么来的。\n对于无向图G，我们给 G 的每条边随便定向，定向后的图为 G'。另外我们给边标号，第 i 条边是 (u_i,v_i) 那么定义 G' 的关联矩阵 M(G') 为 M_{ij}=\\begin{cases}\n-1 & i=u_j\\\\\n1 & i=v_j\\\\\n0 & \\text{otherwise}\n\\end{cases}容易证明， L(G) = M(G')M(G')^T。\n实际上我们也很少关心关联矩阵的性质，我们关注的是：L 是由两个矩阵相乘得到的。\n生成树计数\n给出一个 n 个点边带权完全图 G=(V,E,w:E\\to \\mathbf{Z})，求其所有生成树的边权和的 k 次方之和，即 \\sum_{T}\\left(\\sum_{(u,v) \\in T}w(u,v)\\right)^k1\\le n\\le 30, 0\\le k\\le 30。 首先这题用斯特林数是不方便的，考虑生成函数。\n我们想办法转化为矩阵树定理方便处理的形式。\n注意到 (w_1+w_2+\\cdots +w_m)^k = k![x^k]\\prod_{i=1}^m e^{w_ix}，即上式等于 k![x^k]\\sum_{T}\\prod_{(u,v) \\in T} e^{w(u,v)x}而我们只需要求 x^k 项，则可以把多项式对 x^{k+1} 取模。所以我们让边权是 e^{w(u,v)x} \\bmod x^{k+1} 即可。\n有个细节：每个点的度是 d_u = \\sum e^{w(u,v)x}，而不是 \\prod。理解了拉普拉斯矩阵怎么来的就可以理解这一点。\n时间复杂度 O(n^3k^2)。\n代码","title":"矩阵树定理学习笔记","updated":"2025-04-23T04:07:19.269Z"},{"categories":[],"path":"Banknote-Proposition-Report/","tags":[{"name":"Original","slug":"Original","permalink":"https://notes.sshwy.name/tags/Original/"}],"text":"本来是没有打算写命题报告的。不过在讨论的过程中发现，这题似乎的确有一定的难度。于是就有了本文。\n题目大意题目链接\n给出一个长度为 n 的正整数序列 a。我们可以折叠序列 a。例如 [3,4,4,3,2,2,3,4,1,3,1,1] 可以折叠为 3-4╮\n╭2-3-4╯\n╰2-3-4-1-3-1╮ 1╯\n它可以被折叠 3 次。再举一个例子，[1,1,1,1,1,1] 可以被折叠 5 次： 1╮\n╭1╯\n╰1╮\n╭1╯\n╰1╮ 1╯\n形式化地，我们定义 a 的一个折叠序列是长度为 n 的整数序列 b 满足： b 仅由 1 和 -1 构成，且 b_1=1；\n设 p(i)=[b_i=1]+\\sum_{j=1}^{i-1}b_j。则对于任意 1\\le i&lt;j\\le n 且 p(i)=p(j)，必满足 a_i=a_j。 显然，可能有多个不同的 b 都满足 a 的折叠序列条件。\n定义折叠序列 b 的折叠次数为 f(b)=\\sum_{i=1}^{n-1}[b_i\\ne b_{i+1}]。那么 a 的最大折叠次数定义为所有合法的折叠序列 b 中 f(b) 的最大值。\n现在 Boboniu 正操纵着一个序列 a。初始时 a 长度为 0。他会执行 n 次操作，每次他会在 a 末尾加入一个元素。他想知道每次插入元素后，a 的最大折叠次数。\n1\\le n\\le 10^5,1\\le a_i\\le n。\n从左到右在讨论算法的过程中，我们把序列理解为一个字符集较大的字符串。这样解释起来方便一些。\n另外，本文中所有的回文，一般情况都指偶回文。\n在开始讨论关于此题的算法之前，我想讲述关于折叠操作的一些直观理解。大家可以想象，你拿着一张纸条做各种各样的折叠。比如对折再对折： 但是其实这种折叠方式（在本题中），等价于你做一个 Z 字型（或者说 M 字型）的折叠： 因为在本题中的折叠次数，实际上指的是折痕的数量。而两种折叠方式的折痕数量是一样的。\n考虑一个更具体的例子：a=[1,2,2,2,2,1,1,2,2]。我们分别按照以下两种方式折叠： （红色表示折叠的位置）\n实际上，两种折叠方式折出来是等价的。你把第二种折叠方式的外面那个圈收到里面来，就变成了第一种折叠方式： 观察第一种折叠方式，它始终呈 Z 型折叠，并且它是按照从左到右的顺序依次折过来的。也就是说我们得到了两个关键信息：\nKey point 1：任意一种折叠方案，都可以通过改变圈的位置，变成 Z 型折叠。\nKey point 2：任意一种折叠方案，只要折到了不能继续折下去的程度，那么得到的折痕数量是始终相等的。\n也就是说我们把原本的任意折叠，归约成了从左到右依次折叠。\n从左到右依次折叠还有一个好处：每次都只折了一层纸。如果随意折叠，就可能会出现折多层纸的情况，这时的折叠次数就要多次计算。比如在上述例子中，第二种折叠方式的第二次折叠就一次折了 3 层纸，因此折痕数量加 3。也就是说，如果我们从左到右折叠，那么只用考虑折叠的次数，不用考虑每次折叠的层数。\n这部分希望大家自己动手折叠一下，先理解直观的感受。\n接下来，我们就按照从左到右的顺序讨论关于本题的算法。\n三折考虑 [\\cdots,1,2,2,2,3,\\dots] 中的三个 2。我们一定会把他们折成一个 2（2 次折叠，Z 型）。假设你不折，那么最终的方案里一定含有 [2,2,2] 的子串。于是你就可以再折 2 次来获得更多折痕。\n推广之，考虑三个连续的字符串 XYX，其中 Y 是 X 的反串。那么我们可以贪心地把它们折成一个 X： 我们称形如 XYX（其中 Y 是 X 的反串）的字符串为三折。\n另外，我们定义最简三折为一个形如 XYX 的字符串，满足它不存在三折真子串。\n根据 Key point 2，我们有一个大致的思路：先把所有能折的三折给折了，剩下一个没有三折的串，再来折这个串。具体地，我们分为两个部分： 考虑字符串 b，初始时为空串。我们执行 n 次操作，每次在 b 末尾插入 a_i，然后检查 b 是否产生了新的三折，有就折，没有就不折。\n对于一个没有三折的串 b，我们要求出它还能被折多少次。 那么我们只需要在每次做第一步后做第二步，就可以求出每次操作完之后的答案了。\nEasy Version第一部分设 b 末位插入 a_i 后变成了 b'。\n首先我们证明一个引理，这在之后的复杂度证明中都会发挥作用。\nLemma 1：对于一个串 S 的两个偶回文子串 S[l_1,r_1]，S[l_2,r_2]，如果 [l_1,r_1] 包含 S[l_2,r_2] 的中心且 [l_2,r_2] 包含 S[l_1,r_1] 的中心，那么 S 一定包含三折子串。\n证明不妨设 l_1&lt;l_2，|r_1-l_1|\\ge |r_2-l_2|。那么通过简单的构造可以发现： 这样就产生了三折。证毕。 Key point 3：b' 至多有一个三折。\n证明证明：考虑反证法。\n首先，b' 的三折一定是它的后缀，因为 b 没有三折。\n那么如果 b' 产生了多个三折后缀，有三种情况： 黑和红：这种情况很容易反证。在第一个 X 里也会出现一个三折，那么 b 中就含有三折了，矛盾。\n黑和蓝、黑和绿：可以发现，蓝色的 XY 和黑色的 YX 形成了 Lemma 1 的情况，绿色的 XY 和黑色的 XY 也形成了 Lemma 1 的情况。因此 b 中含有三折，矛盾。\n证毕。 由 Key point 3 我们还可以发现，这个三折一定是最简三折。\n因此我们使用一些算法找到这个三折后，把它折叠。折叠的过程就是删掉 b' 的一个偶回文后缀。如果找不到三折，就不变。\n第二部分对于一个没有三折的串 b，我们要求出它还能被折多少次。\n没有三折，我们就只能对折——也就是把一个偶回文前缀或者偶回文后缀折叠。\n考虑贪心，以偶回文后缀为例，我们每次折叠最短的偶回文后缀。那么每次折叠的后缀长度一定是严格递增的： 因为如果不递增，那么就会出现 Lemma 1 的情况，导致出现三折，矛盾。\n因此 b 折叠出来的应该大致是这个样子： Key point 4：对于没有三折的串 b，最多被折叠 O(\\sqrt{b}) 次。 对于偶回文后缀的折叠 ：设 p_i 表示 b[1,i] 的最短偶回文后缀。\n对于偶回文前缀的折叠：设 q_i 表示，在 b[1,i] 串上从开头开始折叠，每次折叠最短偶回文前缀，最多能折叠到什么位置。设 c_i 表示前缀的折叠次数。 算法描述我们使用 hash 来处理两个部分。\n找三折：对于每个后缀判断是否是偶回文后缀，如果是，就判断是否构成三折。时间复杂度 O(n) 的。\n当 b 变成 b' 时： 如果没有出现三折，那么我们就 O(n) 求出 p_{|b'|}，然后 O(1) 地求出 q_{|b'|},c_{|b'|}（基于 q_{|b|},c_{|b|}）。然后我们可以 O(1) 更新字符串的 hash。\n否则我们要删除 b' 的后缀，那么我们直接舍弃那部分的后缀对应的 p,q,c 和 hash 值即可，时间复杂度 O(1)。 回答询问：我们可以 O(1) 查询 c_i，O(\\sqrt{n}) 查询 p_i 来回答询问。\n总时间复杂度 O(n^2)。\nHard Version为了让获得更快的算法，我们需要挖掘更多有关三折的性质。\n第一部分我们需要优化找三折的复杂度。\nKey point 5：最简三折只有一个偶回文后缀（就是 XYX 的 YX）。\n这个同样可以反证，并结合 Lemma 1 导出矛盾。\n根据 Key point 3，我们发现，b' 的三折一定由它的最短偶回文后缀产生。因此我们只需要快速找到 b' 的最短偶回文后缀，然后看它是否构成三折即可。\nKey point 6：b' 的偶回文后缀数量是 O(\\log_2n) 的。\n因为 b' 的偶回文后缀不能出现 引理 1 的情况，所以必须是一个包含另一个，且不跨过中心。那么偶回文后缀的长度每次至少倍增： 设 v_i 表示 b[1,i] 的偶回文后缀的集合。由于 v_i 的大小是 O(\\log_2n) 的，因此可以使用 vector 维护。于是 找最短回文后缀的复杂度就是 O(\\log_2n) 的。\n判断一个串是否是三折，可以转化为判断一个子串是否是回文串，同样可以 O(\\log_2n) 判断。\n在 b 末尾插入 a_i 的时候，可以枚举 v_{|b|} 的偶回文后缀，求出 v_{|b'|}，时间复杂度 O(\\log_2n)。 如果找到了一个三折，就删掉 b' 的一个偶回文后缀。\n这样，找三折以及更新 b 的复杂度就优化为了 O(n\\log_2n)。\n第二部分沿用 easy version 的算法，单次询问的复杂度仍是 O(\\sqrt{n})，可以通过本题。\n算法描述找三折：在 v_i 中查询最小值，时间复杂度 O(\\log_2n)。\n当 b 变成 b' 时： 如果没有出现三折，那么我们就 O(\\log_2n) 求出 p_{|b'|}，然后 O(1) 地求出 q_{|b'|},c_{|b'|}（基于 q_{|b|},c_{|b|}）。然后我们可以 O(\\log_2n) 利用 v_{|b|} 求出 v_{|b'|}。\n否则，我们要删除 b' 的后缀，直接舍弃对应变量即可。时间复杂度 O(1)。 回答询问：我们可以 O(1) 查询 c_i，O(\\sqrt{n}) 查询 p_i 来回答询问。\n总时间复杂度 O(n(\\log_2n+\\sqrt{n}))。\n数据首先肯定有随机数据，然后还要有一些 corner 的情况，还有 O(n\\sqrt{n}) 的没有三折数据。\n验题的时候，丁神在比赛开始前一晚，写了一个暴搜剪枝过了。当时把我吓傻了，然后就赶紧研究了一下，hack 掉了这个暴搜。生成器长这样：\ncur = 3\na = [1,1] for i in range(3,17): b = a.copy() a.append(cur) # new fuck cur += 1 a.reverse() a.extend(b) # link a.append(cur) # fuck a.reverse() print(len(a))\na.reverse()\nfor x in a: print('&#123;&#125; '.format(x),end='')","title":"Banknote Collection 命题报告","updated":"2025-04-23T04:07:19.260Z"},{"categories":[],"path":"Graph/Tri-Four-Cycle/","tags":[],"text":"本文讨论 n 个点 m 条边简单无向图 G=(V,E) 的三元环和四元环计数的相关问题。\n记 \\deg_u 表示点 u 的度。\n记 \\text{out}_u,\\text{in}_u 分别表示点 u 的出度和入度。\n三元环计数考虑将每条边定向，从度数大的点指向度数小的点，度数相同的点则从编号小的指向编号大的。这是全序的，因此定向完后的 G'=(V,E') 是个 DAG。\n对于 u\\in V，枚举 (u\\to v)\\in E'，再枚举 (v\\to w)\\in E' 来统计三元环。\n首先，每个环只会被统计一次。\n算法时间复杂度为 \\sum_{u\\in V}\\text{in}_u\\cdot \\text{out}_u。\n如果 \\deg_u&gt;\\sqrt{m}， 那么 \\text{in}_u &lt; \\sqrt{m}。因为 \\deg_v&gt;\\deg_u&gt;\\sqrt{m} 的结点 v 的数量是 O(\\sqrt{m}) 的。\n如果 \\deg_u\\le \\sqrt{m}，那么 u 的邻边数是 O(\\sqrt{m}) 的，也就是说 \\text{in}_u&lt;\\sqrt{m} 仍然成立。因此 \\sum_{u\\in{V}}\\text{in}_u\\cdot \\text{out}_u &lt; \\sqrt{m}\\sum_{u\\in{V}}\\text{out}_u &lt; m\\sqrt{m}这变相证明了三元环的数量是 O(m\\sqrt{m}) 的。\nFOR(i,1,m)&#123; scanf(\"%d%d\",ex+i, ey+i); dg[ex[i]] ++; dg[ey[i]] ++;\n&#125;\nFOR(i,1,m)&#123; int u = ex[i], v = ey[i]; if(dg[u] &lt; dg[v] || (dg[u] == dg[v] &amp;&amp; u&lt;v))swap(u,v); addEdge(u,v);\n&#125;\nFOR(u,1,n)&#123; for_adj(i,u,v) tag[v] = u; for_adj(i,u,v) for_adj(j,v,w) if(tag[w] == u) ++cnt;\n&#125;\n四元环计数仍然考虑从度数大的点定向到度数小的点。这里我们需要处理两种环：a\\to b\\to c\\to d\\gets a，或者 a\\to b\\to c\\gets d\\gets a。\n对于 u\\in V： 枚举 (u\\to v)\\in E'，再枚举原图上的边 (v, w)\\in E，根据标记累加四元环个数，然后更新标记。 第一部分的复杂度与三元环相同。\n第二部分的复杂度是 \\sum_{u\\in V}\\text{in}_u\\cdot \\text{deg}_u。\n因为 \\text{in}_u&lt;\\sqrt{m}，于是 \\sum_{u\\in{V}}\\text{in}_u\\cdot \\deg_u &lt; \\sqrt{m}\\sum_{u\\in{V}}\\deg_u &lt; m\\sqrt{m}bool good(int u, int v)&#123; return dg[u] > dg[v] || (dg[u] == dg[v] &amp;&amp; u > v);\n&#125;\nFOR(u,1,n)&#123; // g2: 有向图, g1: 原图 for_adj(g2,i,u,v) for_adj(g1,j,v,w)&#123; if(w == u || !good(u,w))continue; if(tag[w] != u) tc[w] = 0; cnt += tc[w]; tag[w] = u, ++tc[w]; &#125;\n&#125;","title":"三元环与四元环计数","updated":"2025-04-23T04:07:19.265Z"},{"categories":[],"path":"Data-Structure/Fenwick/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"Lowbit我们定义 \\operatorname{lowbit}(x) 表示 x 的二进制最低位的 1 及其后面的 0 构成的数，或者用位运算可以表示为 \\operatorname{lowbit}(x)=x\\wedge (-x)=x-x\\wedge(x-1)其中 x\\wedge (-x) 利用了补码的性质。\n树状数组树状数组 c_1,\\ldots,c_n 是基于一个序列 a_1,\\ldots, a_n 建立的： c_i=\\sum_{j=i-\\operatorname{lowbit}(i)+1}^ia_j即从 j 往前数 \\operatorname{lowbit}(i) 个数的和。\n树状数组用于维护前缀和。广义地说，树状数组可以维护可减信息（或者不涉及到减法的信息）。\n单点修改与单点查询修改：容易想到，把包含这个点的值都更新一遍：\nvoid add(int p,int v)&#123; for(int i=p;i&lt;=n;i+=lowbit(i))c[i]+=v;\n&#125;\n查询：把前缀的 \\operatorname{lowbit} 段都加起来：\nint pre(int p)&#123; int res=0; for(int i=p;i>0;i-=lowbit(i))res+=c[i]; return res;\n&#125;\n区间修改与单点查询区间加上一个数，我们可以维护差分数组 d_i=a_i-a_{i-1},d_1=a_1。于是区间修改可以转化为差分数组上两个单点修改，单点查询就转化为差分数组上前缀和查询：\n/* * add(int,int), pre(int) 即上文所定义 */\nvoid add(int l,int r,int v)&#123; add(l,v),add(r+1,-v);\n&#125;\nvoid query(int p)&#123; return pre(p);\n&#125;\n区间修改与区间查询区间查询可以转化为两个前缀和查询。则我们考虑差分数组上的前缀和查询。我们约定记号 F(\\left\\langle A_i\\right\\rangle,x) 表示在序列 \\left\\langle A_i\\right\\rangle _{i=1}^n 上的前 x 个数的和（前缀和），则可以推一推得到： \\begin{aligned}\nF(a,x)&=\\sum_{i=1}^xa_i=\\sum_{i=1}^x\\sum_{j=1}^id_j\\\\\n&=\\sum_{j=1}^xd_j(x-j+1)\\\\\n&=(x+1)\\sum_{j=1}^xd_j-\\sum_{j=1}^xd_j\\cdot j\\\\\n&=(x+1)F(\\left\\langle d_i\\right\\rangle,x)-F(\\left\\langle d_i\\cdot i\\right\\rangle,x)\n\\end{aligned}于是我们维护两个数组的前缀和即可。区间修改则转化为单点修改，在两个数组上都做一遍即可。\n树状数组上二分更准确地说，是在树状数组上倍增。例如，求 \\sum_{j=1}^i a_j \\le T 的最大的 i。根据树状数组的结构，我我们判断一下是否跳过下一子树，或者进入下一子树：\nint find(int T)&#123; int cur = 0, curA = 0; for(int j=20; j>=0; j--)&#123; int nex = (1&lt;&lt;j) + cur; if(nex >= N)continue; int nexA = curA + A[nex]; if(nexA &lt;= T) cur = nex, curA = nexA: &#125; return cur;\n&#125;\n二维树状数组推广得到，对于矩阵 [a_{ij}]_{1\\le i\\le n,\\,1\\le j\\le m} 建立二维树状数组（矩阵）[c_{ij}]： c_{ij}=\\sum_{x=i-\\operatorname{lowbit}(i)+1}^i\\sum_{y=j-\\operatorname{lowbit}(j)+1}^ja_{xy}单点修改与单点查询修改：同理：\nvoid add(int x,int y,int v)&#123; for(int i=x;i&lt;=n;i+=lowbit(i))&#123; for(int j=y;j&lt;=n;j+=lowbit(j))&#123; c[i][j]+=v; &#125; &#125;\n&#125;\n查询：同理：\nint pre(int x,int y)&#123; int res=0; for(int i=x;i>0;i-=lowbit(i))&#123; for(int j=y;j>0;j-=lowbit(j))&#123; res+=c[i][j]; &#125; &#125; return res;\n&#125;\n区间修改与单点查询这里的区间修改指修改一个子矩阵。类似的，我们也定义一个二维上的差分数组。即 a_{ij}=\\sum_{x=1}^i\\sum_{y=1}^jd_{xy}而注意到 a_{ij-1}+a_{i-1j}-a_{i-1j-1}+d_{ij}=a_{ij}于是我们得到了 d_{ij} 的公式： d_{ij}=a_{ij}-a_{ij-1}-a_{i-1j}+a_{i-1j-1}而区间修改，则可以转化为差分数组上 4 个单点的修改，于是有\n/* * add(int,int,int), pre(int,int) 即上文所定义 */\nvoid add(int rL,int rR,int cL,int cR,int v)&#123; add(rL,cL,v); add(rL,cR+1,-v); add(rR+1,cL,-v); add(rR+1,cR+1,v);\n&#125;\nvoid query(int x,int y)&#123; return pre(x,y);\n&#125;\n区间修改与区间查询我们约定记号 F([A_{ij}],x,y) 表示在矩阵 [A_{ij}]_{1\\le i\\le n,\\,1\\le j\\le m} 上的 \\sum_{1\\le i\\le x,\\,1\\le j\\le y}A_{ij} 的和（二维前缀和）： \\begin{aligned}\nF([a_{ij}],x,y)=&\\sum_{i=1}^x\\sum_{j=1}^ya_{ij}\n=\\sum_{i=1}^x\\sum_{j=1}^y\\sum_{p=1}^i\\sum_{q=1}^jd_{pq}\\\\\n=&\\sum_{p=1}^x\\sum_{q=1}^yd_{pq}(x-p+1)(y-q+1)\\\\\n=&\\sum_{p=1}^x\\sum_{q=1}^yd_{pq}\\left((x+1)(y+1)-(x+1)q-p(y+1)+pq\\right)\\\\\n=&(x+1)(y+1)F([d_{ij}],x,y)-(x+1)F([d_{ij}\\cdot j],x,y)\\\\\n&-(y+1)F([d_{ij}\\cdot i],x,y)+F([d_{ij}\\cdot i\\cdot j],x,y)\n\\end{aligned}于是维护 4 个树状数组即可。单点修改的时候给 4 个都改一下。\n模板ZROI1011\n#include&lt;bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i&lt;=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\n#define lowbit(x) (x&amp;(-x))\nint n,P,q,op,las;\nshort s[8010][8010][4];\nvoid add(const int &amp; r,const int &amp; c,const int &amp; val)&#123; int a[4]=&#123;val%P,val*c%P,val*r%P,val*r*c%P&#125;; for(int x=r;x&lt;=n;x+=lowbit(x)) for(int y=c;y&lt;=n;y+=lowbit(y)) for(int i=0;i&lt;4;++i) s[x][y][i]=((int)s[x][y][i]+a[i])%P;\n&#125;\nint query(const int &amp; r,const int &amp; c)&#123; int a[4]=&#123;0,0,0,0&#125;; for(int x=r;x>0;x-=lowbit(x)) for(int y=c;y>0;y-=lowbit(y)) for(int i=0;i&lt;4;++i) a[i]=(a[i]+s[x][y][i])%P; return ((r+1)*(c+1)%P*a[0]-(r+1)*a[1]-(c+1)*a[2]+a[3])%P;\n&#125;\nint main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;q,&amp;P); while(q--)&#123; int rL,rR,cL,cR; scanf(\"%d%d%d%d%d\",&amp;op,&amp;rL,&amp;rR,&amp;cL,&amp;cR); rL=(rL+las)%n+1; rR=(rR+las)%n+1; cL=(cL+las)%n+1; cR=(cR+las)%n+1; if(rL>rR)swap(rL,rR); if(cL>cR)swap(cL,cR); if(op==1)&#123; add(rL,cL,1); add(rL,cR+1,-1); add(rR+1,cL,-1); add(rR+1,cR+1,1); &#125; else &#123; int ans=(query(rR,cR)-query(rL-1,cR)-query(rR,cL-1)+query(rL-1,cL-1))%P; ans=(ans+P)%P; printf(\"%d\\n\",ans),las=(las+ans)%n; &#125; &#125; return 0;\n&#125;","title":"树状数组全讲","updated":"2025-04-23T04:07:19.263Z"},{"categories":[],"path":"Math/Polynomial/OGF/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"},{"name":"OGF","slug":"OGF","permalink":"https://notes.sshwy.name/tags/OGF/"}],"text":"普通生成函数序列 a_i 的普通生成函数（Ordinary generating function，OGF）： F(x)=\\sum_{i\\ge 0}a_ix^i举个例子，等比数列的生成函数为 \\sum_{i\\ge 0}x^i=\\frac{1}{1-x}\\\\\n\\sum_{i\\ge 0}a^ix^i=\\frac{1}{1-ax}\\\\这也是 OGF 的常用封闭形式。\n牛顿二项式定理首先我们定义组合数的计算： \\binom{r}{k}=\\frac{r^{\\underline{k}}}{k!}(r\\in \\mathbb{C},k\\in \\mathbb{N})其中 r^{\\underline{k}} = r(r-1)(r-2)\\cdots(r-k+1)，r^{\\underline{0}} = 1。k! 是阶乘。\n这样就可以扩展二项式定义为 (1+x)^\\alpha=\\sum_{k\\ge 0}\\binom{\\alpha}{k}x^{k}卡特兰数的生成函数考虑卡特兰数的递推式 h(i)=\\sum_{j=0}^{i-1}h(j)h(i-j-1)第一部分其生成函数定义为 \\begin{aligned}\nC(x)&=\\sum_{i\\ge 0}h(i)x^i\\\\\n&=1+\\sum_{i\\ge 1}\\sum_{j=0}^{i-1}h(j)x^jh(i-j-1)x^{i-j-1}x\\\\\n&=1+x\\sum_{j\\ge 0}h(j)x^j\\sum_{i\\ge 0}h(i)x^{i}\\\\\n&=1+xC^2(x)\n\\end{aligned}那么解方程得到 C(x)=\\frac{1\\pm \\sqrt{1-4x}}{2x}=\\frac{2}{1\\mp\\sqrt{1-4x}}因为 \\lim_{x \\to 0}\\frac{2}{1+\\sqrt{1-4x}}=\\frac{2}{1+\\sqrt{1}}=1=h(0)，所以 C(x)=\\frac{1-\\sqrt{1-4x}}{2x}第二部分接下来我们将它展开为无穷级数。 \\begin{aligned}\n(1-4x)^{\\frac{1}{2}}&=\\sum_{i\\ge 0}\\binom{\\frac{1}{2}}{i}(-4x)^i\\\\\n&=1+\\sum_{i\\ge 1}\\frac{\\left(\\frac{1}{2}\\right)^{\\underline{i}}}{i!}(-4x)^i\n\\end{aligned}\n\\tag{1}化简下降幂的分式： \\frac{\\left(\\frac{1}{2}\\right)^{\\underline{i}}}{i!}=(-1)^{i-1}\\frac{1}{2^i}\\frac{(2i-3)!!}{i!} \\tag{2}化简双阶乘： (2i-3)!!=\\frac{(2i-2)!}{(2i-2)(2i-4)\\cdots 2}=\\frac{(2i-2)!}{2^{i-1} (i-1)!}于是 (2) 就变为 \\frac{\\left(\\frac{1}{2}\\right)^{\\underline{i}}}{i!}=(-1)^{i-1}\\frac{1}{2^{2i-1}}\\frac{(2i-2)!}{(i-1)!i!} \\tag{3}把 (3) 带回 (1) 得到 \\begin{aligned}\n(1-4x)^{\\frac{1}{2}} &= 1+\\sum_{i\\ge 1}\\frac{\\left(\\frac{1}{2}\\right)^{\\underline{i}}}{i!}(-4x)^i \\\\\n&= 1-\\sum_{i\\ge 1}2\\frac{(2i-2)!}{(i-1)!i!}x^i\n\\end{aligned}\n\\tag{4}把 (4) 带回原式得到 \\begin{aligned}\nC(x)&=\\sum_{i\\ge 1}\\frac{(2i-2)!}{(i-1)!i!}x^{i-1}\\\\\n&=\\sum_{i\\ge 0}\\frac{(2i)!}{i!(i+1)!}x^{i}\\\\\n&=\\sum_{i\\ge 0}\\frac{1}{i+1}\\binom{2i}{i}x^{i}\n\\end{aligned}例题食物生成函数依次写成 \\frac{1}{1-x^2}(1+x)\\frac{1-x^3}{1-x}\\frac{x}{1-x^2}\\frac{1}{1-x^4}\\frac{1-x^4}{1-x}(1+x)\\frac{1}{1-x^3}化简得到 \\frac{x}{(1-x)^4}根据牛顿二项式定理得到 \\begin{aligned}\n(1-x)^{-4}&=\\sum_{i\\ge 0}\\binom{-4}{i}(-x)^i\\\\\n&=\\sum_{i\\ge 0}\\binom{4+i-1}{i}x^i\n\\end{aligned}那么带回原式得到 \\begin{aligned}\n\\frac{x}{(1-x)^4}&=\\sum_{i\\ge 0}\\binom{3+i}{i}x^{i+1}\\\\\n&=\\sum_{i\\ge 0}\\binom{3+i}{3}x^{i+1}\\\\\n&=\\sum_{i\\ge 1}\\binom{2+i}{3}x^i\n\\end{aligned}Sweet生成函数为 \\begin{aligned}\n\\prod_{i=1}^n\\left(\\sum_{j=0}^{m_i}x^j\\right) &= \\prod_{i=1}^n\\frac{1-x^{m_i+1}}{1-x}\\\\\n&=(1-x)^{-n}\\prod_{i=1}^n(1-x^{m_i+1})\\\\\n\\end{aligned}根据牛顿二项式定理得到 (1-x)^{-n}=\\sum_{i\\ge 0}\\binom{n+i-1}{i}x^i我们暴力展开后面的多项式，最多只有 2^n 项。考虑每一项对答案的贡献，发现 c_ix^i 的贡献是 c_i\\sum_{j=a-i}^{b-i}\\binom{n+j-1}{n-1}这样就做完了。","title":"普通生成函数学习笔记","updated":"2025-04-23T04:07:19.270Z"},{"categories":[],"path":"Graph/Flow-and-2-SAT/","tags":[],"text":"Fizzydavid 的讲课内容\n概念引入网络图对于有向图 G=(V,E)，定义其中的两个点分别为源点 s 和汇点 t。G 中的边 (u,v)，定义其容量为 c(u,v)，流量 f(u,v)，满足 f(u,v) = - f(v,u)。\nf(u,v) \\le c(u,v)。\n\\sum_{(u,v) \\in E}f(u,v) = \\sum_{(v,u)\\in E}f(v,u)，其中 u\\ne s,u\\ne t。 注意：如果 G 中同时存在 (u,v) 和 (v,u) 的边，我们可以拆点将其转化为不存在反平行边。实际上在实现的过程中大部分算法对于存在反平行边的 G 也适用。只不过在本文描述的过程中我们只考虑不含反平行边的图。\n流与割对于一个流函数 f，定义其流量为 |f| = \\sum_{(s,u) \\in E}f(s,u)。使得 |f| 最大的流函数被称为最大流。\n割是 G 的一个划分 (S,T)，使得 s\\in S, t\\in T。割的容量定义为 c(S,T) = \\sum_{(u,v)\\in E, u\\in S, v\\in T}c(u,v)。最小化 c(S,T) 的割被称为最小割。\n残量网络残量 r(u,v) 定义为 r(u,v) = c(u,v) - f(u,v)。\n考虑流 f 对应的残量 r。我们将 r(u,v)&gt;0 的边与 V 构成的子图 G' 称为残量网络。\n最大流的残量网络中，s,t 不连通。\n令 S 为残量网络上 s 出发能到达的点集，T=V\\setminus S，则 (S,T) 恰是最小割。\n因此我们证明了最大流最小割定理。\n对于任意最大流形成的残量网络，(S,T) 割是最小割的充要条件是对于任意割边 (u,v) 有 r(u,v) = 0。\n最大流的方案不唯一，因此不同的最大流对应的残量网络是不同的。不同最大流的残量网络可以用循环流相互转化（循环流不会影响最大流）。\n对于残量函数 r，其上的最小割的充要条件： s\\in S，t\\notin S。\n\\forall (u,v):r(u,v)&gt;0，有 u\\in S \\Rightarrow v\\in S 成立。 残量网络的 SQT 划分对于任意一个最大流对应的残量网络 G'，设 s 出发能到达的点集是 S，设能到达 t 的点的点集是 T，设 Q 表示既不在 S 也不在 T 中的点的点集。\n首先，(S,Q,T) 划分只和 G 有关，与最大流的方案无关。也就是说这样的划分是唯一的。\n证明考虑 (u,v) : u\\in S, v\\notin S 的边，即 (S,V\\setminus S) 割。首先一定有 r(u,v)=0。如果 (S,V\\setminus S) 割发生变化，一定伴随最大流的变化。而最大流是不变的，因此 (S,V\\setminus S) 割是唯一的。\n同理，(V\\setminus T,T) 割也是唯一的。\n因此 S 和 T 集合是不变的，则 Q 也不变。 最小割的 2-SAT 模型考虑原图上的边 (u,v)，我们要询问 (u,v) 与最小割相关的问题。考虑建立 2-SAT 模型。\n维护两种标记：A,B。x 拥有标记 X 记作 x\\in X。\nx\\in A 表示 x 一定在割 (S,T) 的 S 中，x\\in B 表示一定在 T 中。\n在残量网络 G'=(V,E') 上，对于任意结点 x\\in V，我们可以添加两种限制： 若 x\\in A，则我们将 x 能到达的点标记为 A。即 \\forall (x,y) \\in E', y\\in A。\n若 x\\in B，则我们将能到达 x 的点标记为 B。即 \\forall (y,x) \\in E', y\\in B。 由于我们考虑的是 s-t 割，因此一定有 s\\in A, t\\in B。\n要判断 (u,v) 是否在最小割中，则我们令 u\\in A, v\\in B，然后加入上述限制，跑一个 2-SAT 看是否有解。如果一个结点被同时标记为 A,B 就矛盾了，就无解。\n应用A1\n判断最小割是否唯一。 最小割唯一等价于不存在未被标记的点。\nA2\n判断原图上 (u,v) 是否可能在最小割中。 考虑其逆命题：(u,v) 不可能在最小割中。\n我们强制 u\\in A, v\\in B，看 2-SAT 是否矛盾。如果矛盾，则说明 (u,v) 不可能在最小割中。\n出现矛盾，等价于：u 能到达 v，或者 v 能到达 v。也就等价于 u 到 v 存在増广路。\n从 2-SAT 角度思考问题与从网络流角度思考问题只是思路的不同，但实现可能是一样的。\nA3\n判断原图上 (u,v) 是否一定在最小割中。 考虑其逆命题 p：存在一个最小割方案使得 (u,v) 不在最小割中。\n对于某个 2-SAT 解，如果 u,v 有相同的标记，或者 u,v 两者中存在没有标记的结点，则 (u,v) 不在最小割中。\n因此 p 等价于：存在一个 2-SAT 解使得 u,v 有相同的标记，或者 u,v 两者中存在没有标记的结点。\n我们先利用 s\\in A, t\\in B 跑一次 2-SAT。若 u 和 v 都有了标记，就可以 O(1) 判断 p 是否成立。\n若 u 或者 v 存在未标记的点，那么这恰好就是个满足 p 的 2-SAT 解。","title":"最小割问题中的 2-SAT 思维","updated":"2025-04-23T04:07:19.265Z"},{"categories":[],"path":"String/KMP/","tags":[],"text":"约定\nS,T 通常表示一个字符串。\n|S| 表示 S 的长度。\nS[i] 表示 S 的第 i 个字符，S[l,r] 表示 S[l],S[l+1],\\cdots,S[r] 构成的子串。\n记 \\nu(i) 表示 i 的 fail 指针。\nS^k 表示 k 个 S 拼在一起。 Border在进阶之前先铺垫一个基础概念——Border。KMP 的 fail 指针指向的是它的一个最长的 Border。\n如果 |S| 被 (|S|-\\nu(|S|)) 整除，那么 S 就是一个循环串。\n对于一个串 S，如果它的最长 Border 的长度为 L=\\nu(|S|)，且 L\\ge \\frac{|S|}{2}，那么 S 就可以写成 AB^k 的形式，且 |B|=|S|-L，A 是 B 的后缀。此时最长的 Border 是 AB^{k-1}。这种情况下的 fail 链是 AB^{k},AB^{k-1},\\cdots,AB。相当于每一次跳一个 B。\nRank KMP\nFor sequence A and B length of n, we say A similar to B, IFF for all i and j, A_i&lt;A_j \\Leftrightarrow B_i&lt;B_j.\nNow you have two sequence X and Y, consider the number of consistent subsequence of X that similar to Y.\n|X|,|Y|\\le 10^6. 与 KMP 算法类似。在扩展的时候，KMP 是判断两个字符是否相等。这里我们则改为判断两个字符在前面的排名是否相同。\n主席树即可。\n时间复杂度 O(n\\log_2n)。\n树上 KMP\n给一个 Trie，求每个点到根的路径表示的字符串的最长 Border。\nN,|\\Sigma|\\le 10^6。 对于 u 的父节点 p_u，假设到 p_u 的串表示为 AB^k，那么每次跳 fail 匹配的是同一个字符 B[1]。因此如果 B[1] 不匹配就可以直接跳到 AB 了。如果不是 AB^k 就正常跳 fail。这样每次至少减少一半，复杂度 O(n\\log_2n)。\nCHO-Hamsters\n给出 n 个互不包含的字符串 s_i，要求你求出一个最短的字符串 S，使得这 n 个字符串在 S 中总共至少出现 m 次，问 S 最短长度。\nn\\le 200,m\\le 10^9,\\sum |s_i|\\le 10^5。 设 f(i,j) 表示 S 中出现了 i 次这 n 个字符串，末位字符串是 s_j 的 S 的最短长度。\n套一个矩阵乘法即可。\n时间复杂度 O(n^3\\log_2m)。\nFedya the Potter Strikes Back\n给定长度为 n 的字符串 s 和权值数组 w_1,\\ldots,w_n。\n定义 s 的⼀个⼦串是好的，当且仅当这个⼦串等于 s 的某个前缀。\n⼀个⼦串 s[l,r] 的权值是 w[l,r] 的最⼩值。\n对于 s 的每个前缀，求他的所有好的⼦串的权值之和。\nn\\le 10^5。 相当于，对 s[1,i] 求它所有后缀 border 的权值之和。考虑 KMP 算法。从 s[1,i-1] 扩展到 s[1,i] 时： 有可能删除一些 border。删除的个数是均摊 O(1) 的。\n有可能增加一个长度为 1 的 border。\n其他的 s[1,i-1] 的 border 末尾添加 s_i，就变成了 s[1,i] 的 border。 那么，想办法 O(1) 找到被删除的 border，然后维护一下权值即可。\n对每个 border 维护一下它最远能延伸到的位置即可。\n时间复杂度 O(n\\log_2n)。\nSZA-Template\n给出一个字符串 S，求一个长度最小的字符串 T 使得 S 可以被 T 印出来。\n印的规则是：重叠部分的字符串要一样。\n|S|\\le 5\\times 10^5。 求出 S 的 next 数组。\n设 f_i 表示前缀 i 的答案。\n那么 f_i\\in\\{i,f_{\\text{nex}_i}\\}。因为你要印出 i，就得先印出 \\text{nex}_i。\n而 f_i=f_{\\text{nex}_i} 的条件是，存在一个 j，f_j=f_{\\text{nex}_i} 且 j\\ge i-\\text{nex}_i。\n时间复杂度 O(n)。","title":"KMP 应用","updated":"2025-04-23T04:07:19.276Z"},{"categories":[],"path":"Math/Linear-Algbra/Intro/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"遇到一道毒瘤的数理知识题，就有了本文。\n矩阵将一些元素排列成若干行，每行放上相同数量的元素，就是一个矩阵（Matrix）。\n矩阵通常用大写字母表示。一个矩阵 A 从左上角数的第 i 行第 j 列的数称作第 i,j 项，记作 A_{i,j} 或 A_{ij}。\n如果 A 的元素可以用只与行数和列数有关的函数 f 表示，则可以用 A=[f(i,j)]_{m\\times n} 表示。其中 m 表示行数，n 表示列数。\n对于 m=n 的矩阵我们称之为方阵（方块矩阵）。\n矩阵基本操作加法、标量乘法、转置加法：对于矩阵 A_{m\\times n},B_{m\\times n}，定义矩阵加法为 A 和 B 对应位置上的元素相加。即 A+B=[A_{i,j}+B_{i,j}]_{m\\times n}。\n标量乘法（Scalar multiplication）：对于矩阵 A_{m\\times n} 和标量 c，他们相乘的结果是 Ac=[A_{i,j}\\cdot c]_{m\\times n}。\n转置（Transposition）：对于矩阵 A_{m\\times n}，其转置矩阵记作 A^T，且 A^T=[A_{j,i}]_{n\\times m}。即横竖翻转。\n矩阵乘法定义 A_{n\\times m} 和 B_{m\\times k} 的矩阵乘法为 AB=\\left[ \\sum_{x=1}^mA_{i,x}B_{x,j} \\right]_{n\\times k}其中 i\\in[1,n],j\\in[1,k]。 分配律：(A+B)C=AC+BC。 结合律：A(BC)=(AB)C。 矩阵乘法不具备交换律。 矩阵初等变换矩阵初等变换有三种，分行操作和列操作。不过行和列是对称的。 行交换：将矩阵 A_{n\\times m} 的第 i 行和第 j(i\\ne j) 行交换。记作 R_i\\leftrightarrow R_j。\n行数乘：将第 i 行的每个元素都乘上一个非 0常数 k，记作 kR_i\\to R_i,k\\ne 0。\n行加法：第 j 行的 k(k\\ne 0) 倍加到第 i 行上，记作 R_i+kR_j\\to R_i,i\\ne j。 方阵初等变换对于方阵而言，由于两个方阵的矩阵乘法不改变方阵的形状，因此我们可以用矩阵乘法表示方阵的初等变换。\n对于 R_i\\leftrightarrow R_j，等价于 A_{n\\times n} 左乘一个 B_{n\\times n} 的矩阵，满足 B_{x,y}=\\begin{cases}\n1 & x=i,y=j\\\\\n1 & x=j,y=i\\\\\n1 & x=y,x\\ne i,x\\ne j\\\\\n0 & \\text{Otherwise}\n\\end{cases}对于 kR_i\\to R_i,k\\ne 0 操作，B 的条件为 B_{x,y}=\\begin{cases}\nk & x=y,x=i\\\\\n1 & x=y,x\\ne i\\\\\n0 & \\text{Otherwise}\n\\end{cases}对于 R_i+kR_j\\to R_i,i\\ne j，B 的条件为 B_{x,y}=\\begin{cases}\nk & x=i,y=j\\\\\n1 & x=y\\\\\n0 & \\text{Otherwise}\n\\end{cases}对于初等列变换，则可以表示为 A右乘一个矩阵 B。设 C_i 表示矩阵的第 i 列。\n对于 C_i\\leftrightarrow C_j，B 的条件与 R_i\\leftrightarrow R_j 相同： B_{x,y}=\\begin{cases}\n1 & x=i,y=j\\\\\n1 & x=j,y=i\\\\\n1 & x=y,x\\ne i,x\\ne j\\\\\n0 & \\text{Otherwise}\n\\end{cases}对于 kC_i\\to C_i,k\\ne 0，B 的条件与 kR_i\\to R_i,k\\ne 0 相同： B_{x,y}=\\begin{cases}\nk & x=i,y=j\\\\\n1 & x=y\\\\\n0 & \\text{Otherwise}\n\\end{cases}对于 C_i+kC_j\\to C_i,i\\ne j，B 的条件是 R_i+kR_j\\to R_i,i\\ne j 的转置： B_{x,y}=\\begin{cases}\nk & x=j,y=i\\\\\n1 & x=y\\\\\n0 & \\text{Otherwise}\n\\end{cases}矩阵求逆定义单位矩阵（Identity Matrix）为主对角线上元素为 1，其他元素为 0 的方阵，记作 I。\n定义 A 矩阵的逆矩阵B 为使得 AB=I 的矩阵。若存在这样的 B 矩阵，称 A可逆。A 的逆矩阵记作 A^{-1}=B。\n定义符号 (A | B) 表示在 A_{n\\times n} 矩阵右边放置 B_{n\\times n} 矩阵，形成 n\\times 2n 的矩阵。\n那么我们使用高斯消元将 (A|I) 中的 A 消成 I，得到 (I|B)，那么这里的 B 就是 A^{-1}。若 A 消不成 I 则 A 不可逆。\n相似矩阵相似矩阵（similar matrix）是指存在相似关系的矩阵。两个 n\\times n 的方阵 A 和 B 为相似矩阵当且仅当存在 n\\times n 的可逆矩阵 P 满足 P^{-1}AP=B相似矩阵的秩、行列式、特征值、特征多项式相同。\n行列式行列式通常是对于方阵定义的。\n方阵 A_{n\\times n} 的行列式（Determinant）是一个将其映射到标量的函数，记作 \\det(A) 或者 |A|。通常可以将其理解为是高维空间的欧氏体积。\n定义 P_n 表示所有 n! 个长度为 n 的排列 p 构成的集合。矩阵的行列式定义为： |A|=\\sum_{p\\in P_n}\\operatorname{sgn}(p)\\prod_{i=1}^nA_{i,p_i}其中 \\operatorname{sgn} 表示排列的逆序对个数对 -1 的幂。即设 N(p) 表示排列 p 的逆序对个数，则 \\operatorname{sgn}(p)=(-1)^{N(p)}。\n行列式操作方阵乘积的行列式等于行列式的乘积：|AB|=|A||B|。证明\n若 A 可逆，则 |A^{-1}|=|A|^{-1}。\n行列式的计算直接计算根据行列式的公式，易得 对方阵做行（列）交换，行列式反号；\n对方阵做行（列）数乘，行列式乘上同样的常数。\n对方阵做行（列）加法，行列式不变；\n对于上（下）三角矩阵，其行列式为主对角线上元素的积。 因此可以简单地使用高斯消元在 O(n^3) 的时间内求出行列式。\n拆行列式行列式按行拆开：设 a_{ki}=b_i+c_i，那么有 |A|=\n\\left|\\begin{matrix}\na_{11} & a_{12} & \\cdots & a_{1n}\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\na_{k1} & a_{k2} & \\cdots & a_{kn}\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\na_{n1} & a_{n2} & \\cdots & a_{nn}\n\\end{matrix}\\right|\n=\n\\left|\\begin{matrix}\na_{11} & a_{12} & \\cdots & a_{1n}\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\nb_{1} & b_{2} & \\cdots & b_{n}\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\na_{n1} & a_{n2} & \\cdots & a_{nn}\n\\end{matrix}\\right|\n+\n\\left|\\begin{matrix}\na_{11} & a_{12} & \\cdots & a_{1n}\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\nc_{1} & c_{2} & \\cdots & c_{n}\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\na_{n1} & a_{n2} & \\cdots & a_{nn}\n\\end{matrix}\\right|按列拆开同理。\n余子式与伴随矩阵余子式：对于矩阵 A，A_{ij} 的余子式 M_{ij} 定义为 A 去掉第 i 行第 j 列的矩阵的行列式。\n代数余子式：对于矩阵 A，A_{ij} 的代数余子式 C_{ij}=(-1)^{i+j}M_{ij}。\n代数余子式求行列式：\\forall k,|A|=\\sum_{i=1}^nA_{ki}C_{ki}。\n余子矩阵：代数余子式构成的矩阵 C=[C_{ij}]。\n伴随矩阵：A 的伴随矩阵定义为 A 的余子矩阵的转置，即 C^T，记为 \\operatorname{adj}(A)。\n伴随矩阵关于逆矩阵的性质：如果 A 可逆，那么 \\operatorname{adj}(A^{-1})=\\operatorname{adj}(A)^{-1}=\\dfrac{A}{|A|}。\n其他环上行列式的计算对于环 (\\oplus, \\otimes) 上的 n 阶方矩阵 M，其行列式记作 |M|=\\bigoplus_{p\\in P_n}\\operatorname{sgn}(p)\\bigotimes_{i=1}^nA_{i,p_i}那么对于这种矩阵的高斯消元，要点是：消成 \\oplus 对应的单位元。\n可以类比加法乘法环的高斯消元，把除法换成求逆之类的。\n矩阵特征值与特征多项式特征值与特征向量对于矩阵 A_{n\\times n}，若存在向量 \\mathbf{v}_{n} 和标量 \\lambda 满足 \\begin{bmatrix}\nA_{11} & A_{12} & \\cdots & A_{1n}\\\\\nA_{21} & A_{22} & \\cdots & A_{2n}\\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nA_{n1} & A_{n2} & \\cdots & A_{nn}\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nv_{1}\\\\\nv_{2}\\\\\n\\vdots \\\\\nv_{n}\\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\lambda v_{1}\\\\\n\\lambda v_{2}\\\\\n\\vdots \\\\\n\\lambda v_{n}\\\\\n\\end{bmatrix}即 A\\mathbf{v}=\\lambda\\mathbf{v}则称 \\mathbf{v} 是矩阵 A 的特征向量（Eigenvector），且 \\lambda 是 \\mathbf{v} 对应的特征值（Eigenvalue, or characteristic root）。\n上面的等式可以等价地写作 (\\lambda I-A)\\mathbf{v}=0特征多项式若 \\mathbf{v} 不是零向量，则 (\\lambda I-A)\\mathbf{v}=0 的充要条件是 |\\lambda I-A|=0。而 |\\lambda I-A| 可以表示为 \\lambda 的一个多项式。\n根据行列式的计算公式，易知 |\\lambda I-A| 是一个 n 次多项式。那么不妨设它的 n 个零点为 \\lambda_1,\\lambda_2,\\cdots,\\lambda_n，则 A 的特征多项式（Characteristic polynomial）为 p_A(\\lambda)=|\\lambda I-A|=\\begin{vmatrix}\n\\lambda-A_{11} & -A_{12} & \\cdots & -A_{1n}\\\\\n-A_{21} & \\lambda- A_{22} & \\cdots & -A_{2n}\\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n-A_{n1} & -A_{n2} & \\cdots & \\lambda - A_{2n}\n\\end{vmatrix}=(\\lambda - \\lambda _1)(\\lambda - \\lambda _2)\\cdots (\\lambda - \\lambda _n)不妨设 p_A(\\lambda)=f_0+f_1\\lambda+\\cdots + f_n\\lambda^n。\n根据特征多项式的定义，易得 f_n=1；\nf_0=(-1)^n\\prod_{i=1}^n \\lambda_i； 特征多项式的计算首先，你可以通过对 (\\lambda I-A) 高斯消元来求特征多项式，但你不能对 A 高斯消元后再求 A 的特征多项式，两者是不同的。\n根据相似矩阵性质，我们知道与 A 相似的矩阵的特征多项式是相同的。而上三角矩阵的特征多项式是很容易计算的（主对角线上的元素相乘）。因此我们可以尝试把 A 化为与其相似的上三角矩阵。遗憾地是，这样的变换复杂度没有保证。不过，我们有一个类似上三角矩阵的矩阵，叫作上海森堡矩阵。而我们可以快速将 A 变换为与其相似的上海森堡矩阵，然后求出上海森堡矩阵的特征多项式，也就得到了 A 的特征多项式。\n上海森堡矩阵定义上海森堡矩阵（Upper Hessenberg Matrix）为方阵 A_{n\\times n} 满足 \\forall 1\\le j&lt;i\\le n,A_{ij}=0。即 \\begin{bmatrix}\nA_{11} & A_{12} & A_{13} & \\cdots & A_{1n}\\\\\nA_{21} & A_{22} & A_{23} & \\cdots & A_{2n}\\\\\n0 & A_{32} & A_{33} & \\cdots & A_{3n}\\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & 0 & \\cdots & A_{nn}\\\\\n\\end{bmatrix}也就是说主对角线下面的一条对角线也可能非 0。\n如何将 A 化为与其相似的上海森堡矩阵？考虑消元。 如图： 绿色表示非 0 元素；\n蓝色表示我们当前考虑的元素 (i,j)(i&gt;j)；\n黄色表示发生变化的元素（不确定是 0 还是非 0）。 左图是我们目前的矩阵的状态。我们想将 (i,j) 下方的非零元素消掉。首先若 A_{ij} 是 0，我们就要找下方第 j 列非 0 的元素与之替换（如果找不到就不用消元了）。\n图 A：假设我们找到了 A_{kj}\\ne 0(k&gt;i)，那么我们就需要做 R_i\\leftrightarrow R_k 的操作。而为了保证操作后的矩阵与 A相似，我们需要在右边乘上它的逆矩阵。而 R_i\\leftrightarrow R_k 对应的矩阵的逆矩阵是其本身。右边乘上 R_i\\leftrightarrow R_k 对应的矩阵，实际上就是做 C_i\\leftrightarrow C_k 的操作。因此在图 A 中我们进行了行交换和列交换。\n图 B 是我们把 A_{ij} 置为非零元素后的状态。\n图 C：接下来进行消元。我们相当于做若干次行加法操作。同样的为了保证操作后的相似，我们需要右乘行加法操作的逆矩阵。而行加法操作的逆矩阵就是将 k 反号后的行加法矩阵（把它减回去）。放到右边乘就对应了列加法的矩阵。因此在图 C 中我们进行了行加法和列加法操作。（同时列加法操作没有影响到第 j 列。如果你想使用这个算法消成上三角矩阵，那么就会有影响）。\n图 D 就是消元后的矩阵，并展示了哪些元素受到影响。\n算法的伪代码描述为 \\begin{array}{r|l}\n\\hline\n1 & \\textbf{Input: }\\text{Matrix }A\\in\\mathbf{Z}_p^{n\\times n}\\\\\n2 & \\textbf{Output: }\\text{Matrix }A\\text{ in upper Hessenberg form with the same eigenvalues}\\\\\n\\\\\n3 & \\textbf{for }j=1\\textbf{ to }n-2\\textbf{ do}\\\\\n4 & \\qquad \\text{search for a nonzero entry }A_{i,j}\\text{ where }j+1&lt;i\\le n\\\\\n4 & \\qquad \\textbf{if}\\text{ found such entry }\\textbf{then}\\\\\n5 & \\qquad \\qquad \\textbf{do }R_i\\leftrightarrow R_{j+1} \\text{ and }C_i\\leftrightarrow C_{j+1} \\textbf{ if }A_{j+1,j}=0\\\\\n6 & \\qquad \\qquad \\textbf{for }k=j+2\\textbf{ to }n\\textbf{ do}\\\\\n7 & \\qquad \\qquad \\qquad \\textbf{comment }\\text{reduce using }A_{j+1,j}\\text{ as pivot}\\\\\n8 & \\qquad \\qquad \\qquad u\\gets A_{k,j}A_{j+1,j}^{-1}\\\\\n9 & \\qquad \\qquad \\qquad R_k \\gets R_k-uR_{j+1}\\\\\n10 & \\qquad \\qquad \\qquad C_{j+1} \\gets C_{j+1}+uC_{k}\\\\\n11 & \\qquad \\qquad \\textbf{end for} \\\\\n12 & \\qquad \\textbf{end if}\\\\\n13 & \\qquad \\textbf{comment }\\text{now the first }j\\text{ columns of }A\\text{ is in upper Hessenberg form}\\\\\n14 & \\textbf{end for} \\\\\n\\hline\n\\end{array}时间复杂度 O(n^3)。\n上海森堡矩阵的行列式显然，若 A 是上海森堡矩阵，则 (\\lambda I-A) 也是上海森堡矩阵。因此我们只需要能快速求出上海森堡矩阵的行列式即可。\n不妨考虑我将 A 的行列式按第一列展开。因为第一列只有两个非 0 元素： 设 p_i 表示第 i 到第 n 行，第 i 列到第 n 列的子矩阵的行列式。考虑求 p_1。那么我们按第 1 列展开，就得到 p_1=A_{11}p_2-A_{21}|\\text{red}|。而 \\text{red} 子矩阵的行列式也可以按列展开！于是 |\\text{red}|=A_{12}p_3-A_{32}|\\text{pink}|。那么可以继续这样展开下去。这样就可以求出 p_1 也就是原矩阵的行列式了。实现的时候倒着做一次循环就行了。\n复杂度也是 O(n^3) 的，因为多项式长度是 O(n) 的。\n代码\n哈密尔顿 - 凯莱定理哈密尔顿–凯莱定理（Cayley–Hamilton theorem）：对于矩阵 A 的特征多项式 f(\\lambda)，有 f(A)=O。这里的 f(A) 表示说把多项式放在矩阵环的意义下进行，O 表示全 0 矩阵，常数项 a_0 可以理解为 a_0I，I 是单位矩阵。\n常系数齐次线性递推\n给出 x_0,\\cdots,x_{k-1} 和 c_1,c_2,\\cdots,c_k，且定义递推式 x_n=c_1x_{n-1}+\\cdots + c_kx_{n-k}求 x_n。 思路一首先我们可以用矩阵乘法的形式描述这个过程： \\begin{bmatrix}\nx_n\\\\\nx_{n-1}\\\\\n\\vdots\\\\\nx_{n-k+2}\\\\\nx_{n-k+1}\n\\end{bmatrix}\n=A\\begin{bmatrix}\nx_{n-1}\\\\\nx_{n-2}\\\\\n\\vdots\\\\\nx_{n-k+1}\\\\\nx_{n-k}\n\\end{bmatrix}=\n\\begin{bmatrix}\nc_1 & c_2 &\\cdots & c_{k-1} &c_k\\\\\n1 & 0 &\\cdots & 0 & 0\\\\\n\\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\\n0 & 0 &\\cdots & 0 & 0\\\\\n0 & 0 &\\cdots & 1 & 0\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nx_{n-1}\\\\\nx_{n-2}\\\\\n\\vdots\\\\\nx_{n-k+1}\\\\\nx_{n-k}\n\\end{bmatrix}设 V_n=[x_{n+k-1},x_{n+k-2},\\cdots,x_{n+1},x_{n}]^T。上式可以等价地表示为 V_n=AV_{n-1}。\n那么初始向量为 V_0=[x_{k-1},x_{k-2},\\cdots,x_0]^T。显然我们求出 V_n=A^nV_0，这样也就求出 x_n 了。\n直接做矩阵乘法，用矩阵快速幂的复杂度是 O(k^3\\log_2n) 的。\n考虑到这里的 A 是一个 Frobenius matrix。可以得到它的特征多项式 \\begin{aligned}\nf(x)&=|xI-A|\\\\\n&=x^k-c_1x^{k-1}-c_2x^{k-2}-\\cdots - c_{k-1}x-c_k\n\\end{aligned}根据 Hamilton Cayley Theorem，有 f(A)=0。考虑计算 A^n。\n从多项式的角度理解，我们可以把 A^n 表示为 f(A)Q(A)+R(A) 的形式，其中 \\deg R&lt;\\deg f。即 R(x)=x^n\\bmod f(x)。而由于 f(A)=0，因此可以得到 A^n=R(A)。我们可以直接快速幂，把取模的部分改成多项式取模而在 O(k^2\\log_2n) 或者 O(k\\log_2k\\log_2n) 的时间内求出 R(x)。求出来之后，设 R(x)=\\sum_{i=0}^{k-1}r_ix^i则 V_n=A^{n}V_0=\\sum_{i=0}^{k-1}r_iA^iV_0=\\sum_{i=0}^{k-1}r_iV_i由于我们并不需要求出整个向量，我们只需要求出 V_i 的最后一项。而 V_0,\\cdots,V_{k-1} 的最后一项恰好对应 x_1,\\cdots,x_k，因此直接代入上式即可。\n这样的复杂度是 O(k^2\\log_2n) 或者 O(k\\log_2k\\log_2n) 的。\nLuogu4723 代码\n思路二实际上我们有更简单的理解方式。\n因为 x_n=c_1x_{n-1}+\\cdots + c_kx_{n-k}，那么我们继续把 x_{n-1} 写成 \\sum c_ix_{n-1-i} 的形式，然后把 x_{n-2} 写成 \\sum c_ix_{n-2-i} 的形式，这样一直下去，就可以把 x_n 写成关于 x_0,\\cdots,x_{k-1} 的答案。\n把这个过程写成一个代码，就是多项式取模的形式。\n参考文献维基百科 - 矩阵\n维基百科 - 行列式\n维基百科 - 初等矩阵\n维基百科 - 相似矩阵\n维基百科 - 特征值与特征向量\n维基百科 - 哈密尔顿凯莱定理\n拓展资料Matrix-Tree Theorem 1\nMatrix-Tree Theorem 2\nMatrix-Tree Theorem 3\nWolframAlpha Determinant Resultant reference\nWolfram characteristic polynomial reference","title":"线性代数入门","updated":"2025-04-23T04:07:19.268Z"},{"categories":[],"path":"Boboniu-Round/","tags":[{"name":"Original","slug":"Original","permalink":"https://notes.sshwy.name/tags/Original/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://notes.sshwy.name/tags/Codeforces/"}],"text":"致谢见 announcement。\n题目准备由于这是我们第一次准备 CF Round，前期的很多 idea 都被 ban 了。造题 idea 的情况如下：\nDiv. 2 A Problem\nAuthor\nStatus\nComments school\ndysyn1314\ndeclined\nI think this problem is too complicated for D2A :( parkour\nsshwyR\ndeclined\nI think this problem is too complicated for D2A :( balls\ndqa2020\nused\nOK 这个 parkour 本来是 OK 的，但是架不住 tester 们都写 DP（正解贪心），所以 iq 哥说太难了。 Div. 2 B Problem\nAuthor\nStatus\nComments calligraphy\njhdonghj112\ndeclined\nI think exactly this problem has already appeared somewhere else. I definitely saw it. zomboss\nsshwyR\ndeclined\nIt is better to not use expected values and probabilties in d2B chess\nXiejiadong\nused\nOK Div. 2 C Problem\nAuthor\nStatus\nComments treasure\nsshwyR\napproved\nA little bit standard, but ok. Pretty nice in fact! mao\ntriple__a\ndeclined\nComplicated with another future Codeforces Round min-or\nxryjr233\nused\nOK 当时 iq 哥说，有一个正在准备的 Codeforces Round 也有 mao 这题，而且一模一样，给爷整傻了。 Div. 1 A Problem\nAuthor\nStatus\nComments assessment\nxryjr233\ndeclined\nUnfortunately, I don’t think that these interactive problems are interesting enough, it is clear what to do from the beginning because of the statement.. and everything else is just the technical details.. hexagon\nsshwyR\ndeclined\nI think that this constructive problem is interesting, but I don’t think it is suitable for Codeforces, as it is too mathy and won’t be interesting for many competitive programmers :( interview\nxryjr233\ndeclined\nI think this problem is well-known… chat\nsshwyR\nused\nOk! Div. 1 B Problem\nAuthor\nStatus\nComments walk\nsshwyR\nused\nOK 用来垫在 chat 和 string 之间的。 Div. 1 C Problem\nAuthor\nStatus\nComments space\nsshwyR\ndeclined\nI think this problem is too standard.. It does not have any new ideas so we can’t use it.. string\nsshwyR\nused\napproved. Div. 1 D Problem\nAuthor\nStatus\nComments jianghu\nZZZZZZZZZZZZZZZZZZ\nused\nI think this problem is very interesting! But I am not sure about its difficulty, Div. 1 E Problem\nAuthor\nStatus\nComments planetary\nsshwyR\ndeclined\nI am a big fan of cactus graphs myself, but unfortunately, we can’t use this problem. The key problem here is the implementation, and it is evil to use such problems in 2hours-length round. banknote\nsshwyR\nused\nSounds interesting and hard. 哦，这个 planetary 投给多校了。 时间轴March要准备 Codeforces 比赛，首先要有一些题目的 idea。于是在 3 月份的时候我决定，在我的 OI 生涯中留下一些东西。因此我找到了高爸（ZZZZZZZZZZZZZZZZZZ）、徐队（xryjr233）、杜以老师（dysyn1314）和董先生（jhdonghj112）来一起准备这场比赛。在此致谢。\n起初是大家各自贡献了 Idea。凑了 7 题。\n然后在 3 月 12 日，我交了 Proposal 上去。\n前期不太懂 Codeforces 规则，于是就边想 Idea 边在 Polygon 上造题。因此这 7 题都造出来了。我们几个还互测了（主要是 polygon 蛮好玩的）。\n后来我 YY 了 banknote。这其实是算一个尘封的 Idea，因为我以前似乎是想到过的，但当时水平太差就认为这题不可做。然后我花了一个下午的时间想这题，想到了三折必折的部分以及后面的一些处理方式，感觉很妙，于是就和高爸讨论。讨论过程中发现我没有处理不含三折的情况，然后高爸点破，不含三折的只有根号次。于是我花了一些时间证明了一下，边写中文题解边就把这题做出来了。当然，中途也请教过杜老师（MiFaFaOvO），他说难度是 3000 左右。\n然后去写这题的 std，越写越觉得妙。代码不长，但思维很深。这是我自己造出的很有成就感的题，也是我目前造出的最难的题。\n差不多在这个时候吧，我联系了一下东哥（Xiejiadong）来审题。虽然他只审了前三题就咕了，但还是提出了有关题面的意见，以及教会我使用 mashup 开 tester round。然后我们也很开心地一起打过几场比赛。我也和他讨论了一下 banknote。\n由于当时不懂规则，于是东哥就怂恿我找 300iq 对线（当时无知的我并不知道他是 reviewer，只知道他办过 CF Round）。于是我先和 IQ 哥在 Codeforces 的 talk 上聊（其实是我单方发了一个超长信息），然后他就接收了我的 QQ 好友申请。然后和他尬聊了两三句，也没问出个啥，就知道了可能不只等两周（即 CF 很鸽）的信息。\nApril后来打了一场 Div2，发现出题人是 Chinese，于是就给他发 talk 询问经验。结果大家聊天甚欢，就加了 QQ。他就是 triple__a。\n和他交流之后就懂了很多内幕，顺便也邀请他当了 tester。他也审过了我们的题，觉得徐队的交互题不 interesting，于是就魔改了一下。他也提供了一个 D1A 的 Idea。这下我们总共就有 10 个 Idea 了。他也直接秒了 space，问我为啥把 space 放高爸题后面。我想了想觉得有理。但是 space 不是很有趣。因此我也去想了一个新的 Idea。\n由于是在家隔离，反正没事做，就也在 Polygon 上把题造出来了。\n然后就有了三角网格题（string）。本来是三角网格的背景题，结果我套了一个字符串的壳上去。这题也很有意思。我写的二分，徐队和高爸写的是线性做法。结果大家开场就 WA。后来他们过了后，我加强了一下数据一测，结果把高爸的代码卡掉了。他当时只 WA 了一个点。当时的我：非常感谢高爸提供了一个高质量的错解！\n不过这也没完。我写了一个爬山，结果卡不掉。只能无奈把它加到正解中。\n在这期间，由于东哥给了我 CF 的 Polygon Advices，于是我顺便把它翻译成了中文。\n又叫了杜老师，这次是让他 test 这 11 个题。结果咕咕了……\n终于在 4 月 12 日 的时候，Mike 回复了，指定了 IQ 哥来 review。\nIQ 哥在过了三四天后（4 月 16 日），对一些题做了回复。我们经过商讨，D2A 和 D2B 大概要回炉重造了。当然杜以老师向 IQ 哥提出了 D2A 的建议（毕竟是自己的题），让他读一读 legend。至于 space 被 ban 我心里有数，因此回复评论表赞同。\n4 月 27 日，IQ 哥进行了第二轮回复。在回复之前，我们又加了两个 D2B idea，东哥的那个是 OK。planatary 被 ban 了，不过好在折叠题得到了不错的评价（“Sounds interesting and hard”），因此我也觉得不错。\n然而交互题都被 ban 了，这我也没办法。我猜 xry 表示很淦。\n高爸题 IQ 哥不确定难度。果然是高爸出的题，就是不一样。\n我还传了六边形 idea。\n哈哈，School Days 被 ban 了。杜以老师表示很淦。\n之后加了一个 D2A 的 packour。\n4 月 29 日，packour 过了。这天 xry 也给了一个蛮不错的 D1B（interview），也给加上去了。\nMay之前 IQ 哥似乎在忙别的比赛，所以我们这边咕的比较久（我猜我们这边排的日程靠后）。在 5 月 12 日的时候我催了他一下，然后他就来 check 了。不过似乎也只看了一个 proposal——把徐队的 interview 给 ban 了。我还顺便问了他一下什么时候开始准备题目，他表示： For approved problems, you can already start developing them! 所以我们就开始正式准备了。\n在这之后又过了一段时间，我催了催 IQ 哥，于是在 May22 的时候： String, jianghu, and banknote are approved. 这样我们就只剩下 D1B 的 idea 没审了。\n在 5 月 24 日，我加了冲塔题（chat）的 idea，也通知了 IQ 哥。审核结果是 hexagon 被 ban，冲塔题过了。\n现在我们就正式进入造题阶段。\nJune, July &amp; Auguest后来又换了许多 idea，然后找了十几个 tester。iq 哥还帮我们请了一些阿三。比赛时间定在 8 月 12 日。\nhexagon 也投给多校了。\n反正吧，300 爱鸽的日常我们也习惯了。","title":"Boboniu Round 花絮","updated":"2025-04-23T04:07:19.260Z"},{"categories":[],"path":"20-CSP-Sum/","tags":[],"text":"初赛：97 分。\n复赛：难度不够，屑题来凑。\n总结：意料之外又情理之中。\n考场再现： 其实 2:20 我们就拿到密码了。\n开场花了 10 分钟扫了一遍所有题。一看这个 T1 我就知道是个屑题。\n花了 40 分钟写 T1，过了大样例。\n花了 10 分钟写 T2。过了大样例。然后花了 20 分钟写 T2 的暴力和 gen，过了拍。\n花了 10 分钟写 T3 的暴力。写完暴力发现会正解了，花了 40 分钟写，花了 40 分钟调试 + 对拍。\n花了 10 分钟写 T4 的 70 分。\n花了 30 分钟对 T2 T3 进行检验，比如改变随机数据分布。其实是啥都没干。\n花了 20 分钟写了 T1 的暴力和对拍。结果居然拍出错了！然后把 T1 修好了。\n最后 10 分钟，检查各种东西，删除多于文件。 中途上了很多次厕所。带了两瓶农夫山泉刚好喝完。\n考完发现，T2 有 UB 行为。这是意料之外的，不过我想起了某老师说「你不要想考场上不犯低级错误，这是不可能的」，也就觉得情理之中了。\n希望自己再接再厉！\n当然，先得回去补补 whk 了。","title":"2020 CSP-S 游记","updated":"2025-04-23T04:07:19.260Z"},{"categories":[],"path":"Fcitx-Sougou-Dict/","tags":[],"text":"Fcitx 作为 Linux 下常用的中文输入法，其默认中文词库几乎为 0，全靠一个云拼音跟上时代；然而云拼音也不是万能的，就那一个位置。这里介绍一下如何将搜狗的词库导入到 Fcitx 中。\n准备当然是在搜狗的官网下载需要的词库啦\n转码 ORG 文件把下载的文件放到一个文件夹中，执行下列命令\nmkdir org\nfor i in *.scel; do scel2org $i -o org&#x2F;$i.org; done\n然后你的 org 文件夹内就会有你刚刚转码的 ORG 文件啦\n然后下载 fcitx-4.2.7_dict.tar.xz（地址待换）把 data 下面的pinyin.tar.gz解压，可以得到pyPhrase.org文件，这个就是 fcitx 的默认词库。把解压得到的pyPhrase.org复制到 org 文件夹下\n构建词库继续在当前目录下执行\nmkdir dict &amp;&amp; cd dict\ncat ..&#x2F;org&#x2F;*.org &gt; 1.org\nsort 1.org &gt; 2.org\nuniq 2.org &gt; 3.org\nwget https:&#x2F;&#x2F;raw.github.com&#x2F;fcitx&#x2F;fcitx&#x2F;master&#x2F;src&#x2F;im&#x2F;pinyin&#x2F;data&#x2F;gbkpy.org\ncreatePYMB gbkpy.org 3.org\n转换过程可能比较长，耐心等待。最后会生成如下几个文件： pyERROR 词库中重复或有问题的条目，无需保留。\npyPhrase.ok 除错后的 org 词库文件，取代3.org，可保留下次使用。\npyphrase.mb 最终词库，必须保留。\npybase.mb 配套的字码库，必须保留。 移动 pyphrase.mb、pybase.mb 到~/.config/fcitx/pinyin/ 下，然后重新启动 fcitx 输入法即可。","title":"Fcitx 添加搜狗词库","updated":"2025-04-23T04:07:19.264Z"},{"categories":[],"path":"Codeforces/Polygon-advice-chinese-ver/","tags":[],"text":"Translate from Polygon advices by Sshwy.\n如果你准备在 Codeforces 上准备一场比赛（Codeforces Round），那么请将这些建议当作规则，尽可能地遵守。\n带星号的建议仅适用于 Codeforces。\nChecker, validator and interactor\n使用 testlib.h （document，updates，opt-feature）。 不要使用自己的代码模板（头），编写可读的代码。 Checker\n默认情况下，使用 std::ncmp.cpp，除非你确实需要使用另一个 checker。\n尽可能使用标准 checker（std::）。\n对于回答 Yes/No 的问题，使用std::yesno.cpp。\n对于自定义 checker，不要检查空白字符除非你确实需要（尽可能不使用readLine()，使用readToken()代替）。\n不要在 checker 里检查输入文件的合法性（不要使用inf.readSpace()或者inf.readEoln()）。\n务必检查（正解和参赛者程序）输出的合法性，比如answer = readInt(1,n,&quot;answer&quot;)（相当于限定了答案在 1 到 n 之间）。\n务必使用相同的方式来读入和检查正解与参赛者程序（参考 readAns paradigm），不要忘了在 checker 的最开始初始化所有全局变量。 Tests and generators\n不要一直使用“add tests from archive/files”功能。只将你手造的数据来手动上传，其他的请使用生成器（generator）。\n不要在 generator scripts 中使用gen &gt; &#123;1-100&#125;的语法。编写只生成一组数据的生成器。\n使用可区分的生成器名字。\n不好的命名：gen1，gen2，gen3。\n不好的命名（传递参数）：gen type=1，gen type=2，gen type=3。\n好的命名：gen_path，gen_binary，gen type=random。 把所有可能的小数据都生成（比如 n=1,2,3），如果他们的总数不是太多。\n一般来说一共有 20 组到 100 组数据。\n务必构造抵达下界，抵达上界以及范围介于两者之间的数据。\n* 通常来说，pretests 需要包括：\n一组抵达上界的数据（例如最大的 n）；\n一组 32 位整数会溢出的数据（如果有）；\n一些随机小数据；\n容易被发现的极端情况数据（如 n=0 时输出 0 之类的）。如果你故意不想加入一些极端情况数据，可以和 coordinator 商量。 * pretests 的数量在 7~9 之间（D2A），最多在 10~20 之间（D1E）。\n* 对于每种可能的输出格式有至少一个样例，一共至少两个样例。对于简单的问题最好有多个样例。\n务必写样例解释。\n务必创建至少一个随机大数据对正解的 stress，把其他人（tester）的正解加到这里来对拍。也创建一个随机小数据的 stress。\n不要使用生成器的同一个参数生成两次一样数据（即使只是参数一样，随机种子不同）。 Statements\n不要撰写特别长的题面。题面的长度应该恰好能装进文本区在 Polygon 上的初始大小。\n使用拼写检查器（以及语法检查器如果你对你的英语表达不确定）。\n尽量使用常用的短语。如果你想使用一个在别的问题中出现过的句子，直接复制过来即可。\n把每个变量的限制写在它后面的括号中。括号字符不要包含在 TeX 公式中。比如：&#36;n&#36; (&#36;1 \\le n \\le 10^5&#36;)。\n只使用小写字母表示变量。\n所有文字元素（单词，空格，标点）不要包含在 TeX 公式中。\n错误用法：two integers &#36;x, y&#36;。\n正确用法：two integers &#36;x&#36;, &#36;y&#36;。 所有变量和重要的常量要包含在 TeX 公式中。\n错误用法：..., m does not exceed one hundred。\n正确用法：..., &#36;m&#36; does not exceed &#36;100&#36;。 在 Input 段落中，编写清晰的文段结构使得它能反映读入数据的结构。例如把每一行的读入分段落描述，把同一行的读入放在同一段描述。\n对于 HTML 题面（包括 Codeforces），使用 \\t&#123;&#125; 来写以单元减号开头的限制。\n使用下标或者列表来表示一个序列。\n错误用法：a sequence &#36;x_i&#36;。\n正确用法：a sequence &#36;x&#36; of length &#36;n&#36;，或者最好使用 a sequence &#36;x_1, x_2, \\ldots, x_n&#36;。 使用 TeX 撰写题面：\n把所有的公式用美元符号（&#36;）包裹。\n对于破折号，在英文题面中使用~---。例如 word1~--- word2。\n对于下标使用 &#36;i&#36;-th。\n另起一个段落时请空一行。\n使用意大利斜体 \\textit&#123;&#125; 来描述一个定义。使用粗体 \\textbf&#123;&#125; 来标注重要的东西。只在少数几个单词上使用他们。如果你想要把若干句话加粗，请重写题面。\n在公式中使用\\cdot表示乘法符号。\n在公式中使用\\bmod表示取模符号。\n使用\\equiv和\\pmod&#123;&#125;来表示同余方程。 撰写题意清晰的题面。每句话用句点结束。每句话使用大写字母开头。正确使用空格。\n错误用法：word1,word2，word1(word2)word3，word1 ( word2 ) word3。\n正确用法：word1, word2，word1 (word2) word3。 不要使用多个单词构成的短语除非实在需要。\n如果下面的内容中有可以用在你的题面中的，复制粘贴即可。 Statement Sentence Sample\n第一行包含一个整数 n（1\\le n\\le 10^5）。\nThe first line contains a single integer $n$ (1 \\le n \\le 10^5). 第二行包含 n 个整数 a_1,a_2,\\ldots,a_n（1\\le a_i\\le n）。\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$). 接下来的 m 行包含两个数 x 和 y（1\\le x,y\\le n）。\nEach of the next $m$ lines contains two integers $x$ and $y$ ($1 \\le x,y \\le n$).\n或者\n接下来的 m 行，第 i 行包含两个整数 x_i 和 y_i（1\\le x_i,y_i\\le n）。\nThe $i$-th of the next $m$ lines contains two integers $x_i$ and $y_i$ ($1\\le x_i,y_i \\le n$). 你可以任意输出大写或者小写字母。\nYou can print each letter in any case (upper or lower). 如果有多个答案，输出任意一个即可。\nIf there are multiple answers, print any. 如果无解，输出 -1。\nIf there is no solution, print a single integer $-1$. 输出答案模 998~244~353。\nOutput ... modulo $998~244~353$. Formally, let $M = 998~244~353$. It can be shown that the answer can be expressed as an irreducible fraction $\\frac&#123;p&#125;&#123;q&#125;$, where $p$ and $q$ are integers and $q\\not \\equiv 0 \\pmod &#123;M&#125;$. Output the integer equal to $p \\cdot q^&#123;-1&#125; \\bmod M$. In other words, output such an integer $x$ that $0 \\le x &lt; M$ and $x \\cdot q \\equiv p \\pmod&#123;M&#125;$. 我们保证，答案一定存在。\nWe can show that an answer always exists.\n这个句子应该放在 legend/output 的位置，表示对于所有可能的输入都存在答案。这里没有额外的限制。 我们保证……\nIt is guaranteed that ...\n这句话表示，读入数据被特殊处理过来保证满足条件。它应该放在 legend 和 input 段落中。 你的答案被视为正确答案仅当答案的绝对精度或者相对精度不超过 10^{-9}。\n形式化地，设你的答案为 a，正确答案为 b。你的答案被接受当且仅当 \\frac{|a - b|}{\\max{(1,|b|)}} \\le 10^{-9}。\nYour answer is considered correct if its absolute or relative error does not exceed $10^&#123;-9&#125;$. Formally, let your answer be $a$, and the jury's answer be $b$. Your answer is accepted if and only if $\\frac&#123;|a - b|&#125;&#123;\\max&#123;(1,|b|)&#125;&#125; \\le 10^&#123;-9&#125;$. ……，其中 \\oplus 表示 按位异或.\n..., where $\\oplus$ denotes the \\href&#123;https://en.wikipedia.org/wiki/Bitwise_operation#XOR&#125;&#123;bitwise XOR operation&#125;. ……，其中 \\& 表示 按位与.\n..., where $\\&amp;$ denotes the \\href&#123;https://en.wikipedia.org/wiki/Bitwise_operation#AND&#125;&#123;bitwise AND operation&#125;. ……，其中 | 表示 按位或.\n..., where $|$ denotes the \\href&#123;https://en.wikipedia.org/wiki/Bitwise_operation#AND&#125;&#123;bitwise OR operation&#125;. …, 其中 \\gcd(x,y) 表示 x 和 y 的 最大公约数\n..., where $\\gcd(x,y)$ denotes the \\href&#123;https://en.wikipedia.org/wiki/Greatest_common_divisor&#125;&#123;greatest common divisor (GCD)&#125; of integers $x$ and $y$. 字符串字典序的定义：\nA string $a$ is lexicographically smaller than a string $b$ if and only if one of the following holds:\n\\begin&#123;itemize&#125;\n\\item $a$ is a prefix of $b$, but $a$ \\ne $b$;\n\\item in the first position where $a$ and $b$ differ, the string $a$ has a letter that appears earlier in the alphabet than the corresponding letter in $b$.\n\\end&#123;itemize&#125; 序列字典序定义：\nA sequence $a$ is lexicographically smaller than a sequence $b$ if and only if one of the following holds:\n\\begin&#123;itemize&#125;\n\\item $a$ is a prefix of $b$, but $a$ \\ne $b$;\n\\item in the first position where $a$ and $b$ differ, the sequence $a$ has a smaller element than the corresponding element in $b$.\n\\end&#123;itemize&#125; 子序列定义：\nA sequence $a$ is a subsequence of a sequence $b$ if $a$ can be obtained from $b$ by deletion of several (possibly, zero or all) elements. 子区间定义：\nA sequence $a$ is a subsegment of a sequence $b$ if $a$ can be obtained from $b$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. 子串定义：\nA string $a$ is a substring of a string $b$ if $a$ can be obtained from $b$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end. 交互题的注意事项：\nAfter printing a query do not forget to output end of line and flush the output. Otherwise, you will get \\t&#123;Idleness limit exceeded&#125;. To do this, use:\n\\begin&#123;itemize&#125;\n\\item \\t&#123;fflush(stdout)&#125; or \\t&#123;cout.flush()&#125; in C++;\n\\item \\t&#123;System.out.flush()&#125; in Java;\n\\item \\t&#123;flush(output)&#125; in Pascal;\n\\item \\t&#123;stdout.flush()&#125; in Python;\n\\item see documentation for other languages.\n\\end&#123;itemize&#125; Answer ``\\t&#123;...&#125;'' instead of ``\\t&#123;...&#125;'' or ```\\t&#123;...&#125;'' means that you made an invalid query. Exit immediately after receiving ``\\t&#123;...&#125;'' and you will see \\t&#123;Wrong answer&#125; verdict. Otherwise you can get an arbitrary verdict because your solution will continue to read from a closed stream. 多测题的格式大纲：\nEach test contains multiple test cases. The first line contains the number of test cases $T$ ($1 \\le T \\le 100$). Description of the test cases follows. The first line of each test case contains... It is guaranteed that the sum of $n$ over all test cases does not exceed... Solutions\n对于每个题目你需要准备：\n标准正解（主正解）：不包含任何非渐进性（非复杂度层面，比如编译优化）的优化。它的时空应该最多达到时间限制和空间限制的一半。\n如果你的题目有可能让 Java 程序运行得很慢（包括但不限于，C++ 程序使用的时间超过时限的 \\frac{1}{4} 或者使用的内存超过 50MB），那么你需要提供一个 Java 正解。\n其他正解：包括至少一个不是原作者写的正解。所有的正解都需要满足时空最多一半。\n一个暴力解法：暴力模拟题面的描述，它应该是 AC 或者 TLE 的。给它打一个 Time Limit Exceeded or Correct 的标记（使用while(1)如果需要）。\n会 TLE 的程序：给它疯狂加优化，确保它不能过。 对于简单的问题，编写 Python 程序并确保它能在没有优化的情况下通过。\n如果存在整数溢出的可能性，写一个 Python 的正解。\n如果存在因为溢出导致不通过的可能性，编写在那些可能的地方溢出的程序。确保他们不能通过 pretests。\n如果可以，不要卡（卡常，卡时，卡空间）。\n如果有一种分类讨论的解法，或者问题的某个部分需要分类讨论，就写一个这样的程序。并且对于各个情况编写一个不能通过的程序，注释标程哪个情况不能通过。确保他们不能通过 pretests。 General\n* Polygon 的题目中不应该存在警告（warning），除了在题面中写样例。\nTime Limit Exceeded or Correct 只能在那些卡时的程序上标记。对于一定会 TLE 的程序，使用 Time Limit Exceeded 标记。\n题解要写在题面描述下面的文本框中。\n* 在比赛结束时就应准备好英文题解。","title":"Polygon Advices (Chinese version)","updated":"2025-04-23T04:07:19.261Z"},{"categories":[],"path":"String/Suffix-Automaton/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Automaton","slug":"Automaton","permalink":"https://notes.sshwy.name/tags/Automaton/"},{"name":"SAM","slug":"SAM","permalink":"https://notes.sshwy.name/tags/SAM/"},{"name":"Suffix-Tree","slug":"Suffix-Tree","permalink":"https://notes.sshwy.name/tags/Suffix-Tree/"}],"text":"摘要粗略地，对字符串 s 定义 SAM (Q,\\Sigma,\\delta, q_0,F)： Q 是状态集合： s 的等价类的集合。\n\\Sigma 是字符集：s 的字符集；\n\\delta:Q\\times \\Sigma \\to Q 是转移函数：对于 q\\in Q,c\\in \\Sigma，\\delta(q,c) 表示在状态 q 的末尾添加字符 c 到达的状态。\nq_0 （q_0\\in Q）是初始状态：\\varnothing。\nF （F\\subseteq Q）是终止状态：s 的后缀所在等价类的集合。 在常见的代码实现过程中，会记录额外的信息： \\theta: Q\\to Q，对于 q\\in Q，\\theta(q) 表示 q 的最近父类对应的状态。 等价类代表一个 s 的子串集合 T，使得 \\forall x,y\\in T 且 x\\ne y： 要么 x 是 y 的后缀，要么 y 是 x 的后缀。\nx 在 s 中的出现次数与 y 在 s 中的出现次数相等。 设 c(T) 表示 x（x\\in T）在 s 中出现的次数。那么我们称 S 是 T 的父类（T 包含 S）当： \\forall x\\in S, y\\in T，x 是 y 的后缀。\nc(S)&gt;c(T)。 也就是说等价类都包含它的父类，可以类比面向对象中的类继承。\n等价类 T 的最近父类是指它的父类 S 中 c(S) 最小的那个。 后缀自动机后缀自动机（Suffix Automaton，SAM）是一种有限状态自动机。对于一个 SAM，其转移函数是以字符集 \\Sigma 为转移条件，将当前状态 q 转移到另一状态 p 的函数 \\delta(q,x)=p,(p,q\\in Q,x\\in \\Sigma)。\n这个状态分两种：合法与不合法。说白了就是存在和不存在。如果一个字符串不被 SAM 接受，那么 \\delta 就会转移到空指针。初始状态是根结点，也就是字符串开头。\n性质SAM 的空间复杂度与建立的时间复杂度是 O(n) 的。\n对 S 建立的后缀自动机包含 S 的所有子串。因为 S 的子串一定是其某一后缀的前缀。\n不同于 AC 自动机，后缀自动机是一个 DAG。\n后缀自动机中的每一个状态对应了一类子串，这一类子串长度个不相同，并且按长度排序后前一个是后一个的后缀。\n等价类我们假设这一类子串中最长的子串是 \\omega，那么这一类子串满足这样的关系：\\omega 的后缀在 S 中的出现的位置是相同的。这类字符串被称为等价类。\n包含类还有一种情况，就是 S 的某一子串 s 的后缀 s' 在 S 中出现的位置比 s 多，那么称 s' 是 s 的包含类。为什么包含？因为 s 出现的位置 s' 一定出现，而 s' 出现的位置 s 不一定出现。\nFail 树SAM 除了构建自动机还会构建一个 fail 树，fail 树中，当前状态的父结点总是它的包含类，即它的某个后缀形成的等价类。结合等价类和包含类，使得 SAM 的空间复杂度降到了线性级别。\n也可以说，fail 指针指向它的最长的出现次数比它多的后缀。\n模板const int SZ=2e6+6,ALP=26;\nstruct SAM&#123; int tot,last; int tr[SZ][ALP],len[SZ],fail[SZ]; SAM()&#123;tot=last=1;&#125;// 初始化 void insert(int x)&#123; int u=++tot,p=last;// 新建结点，p 是在 fail 上跳指针用的 len[u]=len[last]+1,last=u; while(p&amp;&amp;tr[p][x]==0)tr[p][x]=u,p=fail[p];// 更新 last 在 fail 树上的祖先的转移函数 // 接下来，我们求新建结点 u 的 fail 指针，同时会更新 fail 树 if(!p)fail[u]=1;// 跳到根结点的 fail else &#123; int q=tr[p][x]; if(len[q]==len[p]+1)fail[u]=q; else&#123; // 如果不是 0，说明结点 p 在之前就存在字符 x 的转移函数 // 那么就考虑这个转移到达的状态是否是等价类 // 如果是等价类，那么 fail 就指向 q； // 否则就要从中分离出一个包含类，然后指向这个结点 int cq=++tot; len[cq]=len[p]+1,fail[cq]=fail[q]; memcpy(tr[cq],tr[q],sizeof(tr[q])); fail[u]=fail[q]=cq; while(p&amp;&amp;tr[p][x]==q)tr[p][x]=cq,p=fail[p]; &#125; &#125; &#125;\n&#125;\n后缀树首先我们了解一下后缀树的概念。最基本的后缀树就是把一个串 S 的所有后缀建一个 Trie。以 ababb 为例： 绿色的点表示接受状态的结点（即后缀的末尾）。我们将除了二度点以外的标记为关键点（因为这些点可以刻画这棵树的大致结构），如图 2。\n灰色结点为关键点，并且我们认为接受状态的结点是关键点（尽管它有可能是二度点）。这个后缀树的简化后缀树相当于关键点构成的树，如图 3。\n蓝色边构成的树即为简化后缀树。\n理解增量构造法后缀树与后缀自动机一个串的 SAM 的 Fail 树是其反串的简化后缀树，反串简化后缀树的结点与 SAM 的结点一一对应。\n反串后缀树上结点的深度就对应 SAM 上该状态（结点）的长度。\n例如我们对 bbaba 建立后缀自动机： 可以发现，红树和上文的蓝树是一样的！\n那么为什么是这样的呢？我们感性理解一下。前文所述的 SAM 可以理解为最简状态的 SAM，它将重复的状态合并。而我们把反串的后缀树取一个最简后缀树，其实就是在做类似的事情。\n事实上，反串后缀树上的一条从根挂下来的路径对应原串的一个后缀，它到达的状态就是这个路径往下走遇到的第一个关键点！\n比如在后缀树的图中的 aba，abab，ababb，对应原串的 aba，baba，bbaba，把他们在 SAM 上跑一遍，都会跑到 6 结点去。即结点 6 在 SAM 上接受的状态是 aba，baba，bbaba。\n这样，对 SAM 的操作就可以与对后缀树的操作形成对应。\n类似地，可以将 SAM 的转移边对应到简化后缀树上。转移边相当于在后面添加一个字符，则在反串简化后缀树上就是在开头加一个字符，然后转移到对应状态的结点。\nSAM 的构造方法是一个增量构造法。我们可以通过反串简化后缀树来理解它。\n例如在 bbaba 的后面添加一个字符 b。则相当于在反串开头添加一个 b，那么我们相当于把 bababb 插入到简化后缀树上，完成的效果是这样的： 但是你无法像 Trie 一样直接插入，因为你维护 SAM 的时候是没有这么多信息的，你只知道简化后缀树的信息，即关键点。因此我们尝试用 SAM 的操作来完成这个过程。\n要在增量构造 SAM 的同时增量构造反串的简化后缀树，首先考虑增加一个字符带来的影响。\n设 q_s 表示 SAM 中 s 所在的等价类，即所有等价类的子类。在末尾添加一个字符 c，相当于新建一个状态 q_1，并给 q_s 增加 \\delta(q_1,c)=q_1 的转移。同时，可能有 q_s 的一些父类 q' 也能转移到 q_1，因此也一并加上。\n接下来我们就要确认 q_1 的最近父类，设其为 q_1'。 首先，如果 q_s 的父类中不存在通过 c 转移得到的状态，说明这个 c 是一个新的字符。那么 q_1 的父类就是 q_0（\\varnothing）。\n否则，可以判断，q_1' 一定是由 q_s 的某个父类 q'“分裂”之后，再在其中的每个字符串末位加上 c 得到的。q' 分裂的原因是，在末尾加入了 c 之后，q' 中的某些字符串的出现次数发生了变化，而某些又保存不变。 还有一件事情。在第一步的过程中我们把 q_s 以及 q_s 的父类对字符 c 建立了向 q_1 的转移。而如果遇到 \\delta(q',c) 本身存在的情况，意味着我们找到了用于构造 q_1 父类的等价类。这时我们会直接进行第二步的过程。第二步的过程会给 \\delta(q',c) 中途插入一个分裂出的父类 q_x。因此所有的，关于字符 c 的，原本指向 \\delta(q',c) 的转移，都得改为指向 q_x。因此我们要把 q' 的父类都做更新。\n这样就完成了增量的过程。\n一个具体示例第一部分\n首先，SAM 的 last 指针指向结点 6。反串后缀树上结点 6 对应路径表示的就是它接收的最长的那个状态（SAM 上的结点 6 接受aba，baba，bbaba三个状态，而bbaba是最长的，对于反串后缀树上的路径是 ababb）。\n而你在这个状态开头添加一个 b，相当于在 SAM 上通过转移边（tr(u, b)）跳转到对应状态。而 tr(6,b) 是没有的，因此我们要跳到 6 在简化后缀树上的父节点。因为这个父节点的状态是 6 的状态的后缀（别忘了是反串），而跳父节点就相当于是 SAM 上跳 fail 指针。\n于是我们这样不断跳 fail 指针直到有一个结点的 tr(u,b) 存在，在这个例子中，3 结点存在。则我们转移到 tr(3,b)=13，在简化后缀树中 13 包含了 12 的状态（12 的状态即为bab，指反串）。\n现在相当于，我们要把 12 插入到简化后缀树中，然后从 12 分叉，连出去一条链把剩下的状态补齐（即bababb-bab=abb）。\n把 12 加入到简化后缀树，则需要更新 13,12 的简化后缀树上的父节点指针（对应 SAM 的 fail 指针）。\n然后从 12 连出去一条链，在简化后缀树上就是一条边（可以理解边权为 abb），然后连出这个新的结点也要更新它的简化后缀树上的父节点指针（SAM 上 fail 指针）。\n第二部分\n最后有一件简化后缀树考虑不完全的事情，就是对转移函数的更新（tr(u,c)）。因为转移函数并不能直观地在反串简化后缀树上表现。但我们仍可以这么理解。\n重新回到一开始。在我们不断跳 fail 寻找 tr(u,b) 是否存在的时候，如果这个结点不存在 tr(u,b)，可以将它事先指向我们新建的代表 bababb（原串状态为bbabab）的结点。事实上你也应该这么做，这样才能保证转移函数的完整性。\n第三部分\n由于 3 结点本来转移到 13（tr(3,b)=13），现在我们加了一个结点 12，那么自然 tr(3,b)=12（其实 3 结点本来就转移到 12，但是在之前的 SAM 中 12 状态是被归在 13 结点上的。现在相当于我们把 12 这个状态分离出来）。既然 tr(3,b) 是存在的，而 3 在简化后缀树上的祖先结点状态又是它的后缀状态，因此也存在字符 b 的转移边，那么显然要一并改成 12。于是我们就需要在 3 的基础上不断跳 fail 并更新字符b的转移函数。","title":"后缀自动机与后缀树","updated":"2025-04-23T04:07:19.277Z"},{"categories":[],"path":"WQS-Binary-Search/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"DP","slug":"DP","permalink":"https://notes.sshwy.name/tags/DP/"},{"name":"Quadrangle-Inequality","slug":"Quadrangle-Inequality","permalink":"https://notes.sshwy.name/tags/Quadrangle-Inequality/"},{"name":"Convex","slug":"Convex","permalink":"https://notes.sshwy.name/tags/Convex/"}],"text":"WQS 二分，也称带权二分 / DP 凸优化。\n例一：分段平方和\n把长度为 n 的正整数序列 a 分成若干段。一段的代价是和的平方加一个常数 c。求最小代价。 设 f(i) 表示 i 个数的最小代价。 f(i)=\\min_{j=0}^{i-1}\\{ f(j) +(S_i-S_j)^2+c \\}可以斜率优化。时间复杂度 O(n)。\n例二：分 k 段平方和\n把长度为 n 的正整数序列 a 分成 k 段。一段的代价是和的平方。求最小代价。 首先我们可以设 f(i,j) 表示前 i 个数分成 j 段的最小价值。\n算法一可以有一个 O(n) 的转移 f(i,j)=\\min_{k=0}^{i-1}\\{ f(k,j-1)+(S_i-S_k)^2 \\}时间复杂度 O(n^2k)。\n算法二：斜率优化在算法一的基础上，由于 (S_i-S_k)^2=S_i^2+S_k^2-2S_kS_i，因此可以固定 j，然后使用斜率优化。时间复杂度为 O(nk)。\n算法三：决策单调性观察决策单调性。设 p(i,j) = \\operatorname{opt} k:f(k,j-1)+(S_i-S_k)^2\\to f(i,j)，也就是 f(i,j) 的最优转移决策。\n首先 p(i-1,j)\\le p(i,j)。因为你加入一个 a_i，只会使最后一段的价值增加。因此最后一个分割点只可能往后移。\n其次 p(i,j)\\le p(i,j+1)。因为你多分一段，显然分割点更靠后。\n因此如果我们能先计算出 p(i-1,j) 和 p(i,j+1)，那么 p(i,j) 就有上下界了！\n因此我们可以按照 i-j 从小到大的顺序计算 p(i,j) 和 f(i,j)（初始时 i=j，那么就是一个数单独一段）。因此对于 i-j 相同的那些 DP 值，我们只需要考虑 O(n) 个决策即可。时间复杂度 O(n^2)。\n算法四：WQS 二分我们稍微修改一下代价。我们要求，每一段有一个附带的常数代价 c。也就是说 f'(i,j)=\\min_{k=0}^{i-1}\\{ f'(k,j-1)+(S_i-S_k)^2 +c\\}那么这样计算出来，相当于代价多了 kc。因此 f(i,j)+jc=f'(i,j)。\n从直观的角度，c 越大，意味着分段的成本越高。换言之，设 x=\\arg_i\\min f'(n,i)（也就是最小的代价对应的段数），那么当 c 越大，x 就会越小。因此我们可以二分 c 来让 x=k。这时我们可以使用例题一的算法求出 f'(n,k)。那么 f(n,k)=f'(n,k)-kc，也就求出了答案。\n我们还可以从计算几何的角度理解这个过程。\n考虑二维平面上建立 k 个点 (i,f(n,i))（1\\le i\\le k）。\nc 则对应一条过原点的直线 t(x)=xc。那么 f(n,k)+t(k)=f'(n,k)，可以借此构造 f' 的 k 个点：(i,f(n,i)+t(i))。\n我们可以理解为是把原来的 k 个点按照 t(x) 的斜率拉伸得到了 f' 的 k 个点。\n从直观的角度，c 越大，意味着分段的成本越高。在 t(x) 斜率增大的过程中，这 k 个点中高度最低（纵坐标最小）的点的横坐标是在不断变小（单调不升）的。因此这 k 个点构成一个下凸壳。注意，这是我们使用直观理解来感性证明的。\n以某一个斜率拉伸一个凸壳，会导致它的顶点横坐标发生单调的变化。这就是为什么我们可以使用二分的方式找到顶点横坐标为 k 的情况。那么这时把凸壳拉伸回去就可以得到 (k,f(n,k)) 的纵坐标，也就是答案。\n也就是说，如果我们能快速求出凸壳顶点的纵坐标，那么我们就先想办法把我们要求的点调整为顶点，然后求出它的纵坐标，然后还原。\n例题一的算法，实际上就是在求这个凸壳顶点的坐标（横坐标可以在 DP 的时候附带求出）。\n这样的二分算法是王钦石（WQS）首次提出的，因此我们以 WQS 二分为之命名。\n该算法的复杂度是 O(n\\log_2w)，w 是值域。\n例三：限权最小生成树WQS 二分不局限于 DP 优化。考虑这个问题： 给出一张 n 个点 m 条边加权无向图（边权）。每条边是黑色或者白色。求白色边数恰好为 k 的最小生成树。 设 f(i) 表示白色边数恰好为 i 的 MST 边权和。\n那么同样地，考虑 n 个点 (i,f(i))。然后有一条直线 t(x)=xc。在这道题目中它表示把白边的边权额外加 c。那么 n 个点被 t(x) 拉伸出的点就是 (i,f(i)+t(i))。\n从直观的角度，白边权值越大，那么 MST 中白边的数量就越少。因此随着 t 斜率增大，凸壳的顶点会左移。因此这是一个下凸壳。\n那么使用 WQS 二分即可。时间复杂度 O(m\\log_2m\\log_2w)。可以使用一些简单的优化降到 O((m+n)\\log_2w)。\nWQS 二分问题 · 一般化大多数能够使用 WQS 二分的问题可以归为以下两类：\n题型一： 给出一个长度为 n 的正整数列 a，分成不超过 k 段，一段区间的代价 w(l,r) 满足四边形不等式，求最小的代价。\n注：若 \\forall L\\le l\\le r\\le R，均有 w(L,r)+w(l,R) \\le w(L,R)+w(l,r)，称 w 满足四边形不等式（简记为“交叉小于包含”）。 题型二： 给出一个长度为 n 的正整数列 a，分成不超过 k 段，一段区间的代价 w(x) 满足四边形不等式，求最小的代价。\n注：单元函数的四边形不等式是指，\\forall a\\le b,c\\ge 0，w(a)+w(b)\\le w(a-c)+w(b+c)。也就是内小于等于外。 这样的问题仍然可以使用 WQS 二分来去掉段数的限制。\n注：考场上证明是凸的，建议打表。\nAkvizna\n你有 n 个人。你要干掉他们。假设当前还剩下 a 个人，则在一轮里，你可以选择 b 个人（1&lt;b\\le a）干掉，得分是是 \\frac{b}{a}，剩下 b-a 个人。你需要在恰好k 轮里干掉所有人。求最大得分。\nk\\le n\\le 10^5。 容易写出一个二维 DP。权值函数 w(l,r)=1-\\frac{l}{r}，容易证明它满足四边形不等式（实际上在本题里是反过来的。你求的是最大值，因此这里的不等式应该是 \\ge 的版本）。然后 WQS 二分即可。去掉 k 的限制后，可以斜率优化 DP。\n时间复杂度 O(n\\log_2w)。精度开 10^{-15} 能过。\n代码\n林克卡特树\n给出一棵边带权的树，要求删除其中恰好 k 条边，再加入 k 条 0 权边使得仍是一棵树，最大化新树的直径。\n可能有负权边。\nn\\le 3\\times 10^5,k\\le 3\\times 10^5,|v_i|\\le 10^6。 题意转化：将原树分成 k+1 个连通块，最大化每个连通块直径的和。\n我们将一个点当作退化的路径。那么进一步转化为，求原树上互不（点）相交的 k+1 条链的权值和的最大值。\n考虑树形 DP，设 f_{i,j,k} 表示 i 的子树内有 j 条链，i 的度数是 k（k\\in\\{0,1,2\\}）的权值和的最大值。i 的度数是指，它是否作为链的端点、中间点或者不在链上。\n转移是背包合并。\n对于原树，设 F(k) 表示互不相交的 k 条链的权值和的最大值。仍然给他加一条直线 t(k)=kc。那么直觉告诉我们 c 越大，最优的 k 越大（顶点随斜率的增大右移）。因此它是个上凸壳。打表也可以验证。\n因此二分 c 求出最优的 k 即可。也就是说，一条链的额外代价是 c，在不限制链数的情况下，最大化总的权值和。则把原 DP 的第二维去掉即可。\n时间复杂度 O(n\\log_2n)。\n代码\n参考文献王钦石，浅析一类二分方法，IOI2012 中国国家集训队第二次作业自选部分。","title":"WQS 二分学习笔记","updated":"2025-04-23T04:07:19.277Z"},{"categories":[],"path":"Math/Polynomial/Binary-Lifting-Eval/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"为方便书写，我们把点值序列 f(x_1),f(x_2),\\cdots,f(x_m) 用符号 f(x_1,x_2,\\cdots,x_m) 表示。\n点值平移\n给出（小于等于）k 次多项式 h(x) 的 k+1 个点值 h(0,1,\\cdots,k)，求 h(d,1+d,\\cdots,k+d)。 考虑拉格朗日插值： \\begin{aligned}\nh(x+d) &=\\sum_{i=0}^kh(i)\\prod_{j\\ne i}\\frac{x+d-j}{i-j} \\\\\n&=(x+d)^{\\underline{k+1}}\\sum_{i=0}^k\\frac{1}{x+d-i}\n\\frac{h(i)(-1)^{k-i}}{i!(k-i)!} \\\\\n\\end{aligned}前面的下降幂可以 O(k) 预处理。后面是一个卷积的形式，可以 O(k\\log_2k) 求出。总时间复杂度 O(k\\log_2k)。\n但是存在一个问题。如果 x+d-i=0，就会出现分母为 0 的情况。这个可以细节处理。对于每个 x，x+d-i=0 只会出现一次。因此我们定义一个函数 t(i)=\\frac{1}{i}\\;(i&gt;0)，特别地，t(0)=0。这样就相当于把 x+d-i 的贡献减掉了。然后我们枚举一遍 x，对于存在 x+d-i=0 的情况，把贡献加上去即可（加贡献的时候要变换一下上面的式子，把为 0 的分母去掉就行）。\n总时间复杂度仍为 O(k\\log_2k)。\n接下来我们来看一下点值平移算法的应用。\n阶乘计算\n计算 n!\\bmod p。\nn&lt;p。 设 f_T(x)=\\prod_{i=1}^{T}(x+i)。那么我们求出 f_T(x) 的 \\frac{n}{T} 个点值即可求出答案。\n不妨令 T=\\lfloor\\sqrt{n}\\rfloor。我们求出 f_T(0,T,2T,\\cdots,T^2) 即可。\n考虑倍增。假设我们求出了 f_k(0,T,2T,\\cdots,kT)，如何求出 f_{2k}(0,T,2T,\\cdots,2kT)？\n由于 f_{2k}(x)=f_k(x)f_k(x+k)。问题转化为求出 f_k(kT+T,kT+2T,\\cdots,2kT)。\nf_k(k,T+k,2T+k,\\cdots,2kT+k)。 这两个问题可以转化为点值平移问题。\n那么设 h(x)=f_k(Tx)，那么有：f_k(0,T,\\cdots,kT)=h(0,1,\\cdots,k)，f_k(kT+T,kT+2T,\\cdots,2kT,2kT+T)=h(k+1,\\cdots,2k+1)，令 d=k+1，这样第一个问题就解决了。\n对于第二个问题，我们拆成前后两半。以前半部分为例（两者只差一个常数）。我们要求 f_k(k,T+k,\\cdots,kT+k)。等价于 h(\\frac{k}{T},1+\\frac{k}{T},\\cdots,k+\\frac{k}{T})。因此令 d=\\frac{k}{T} 即可。后半部分同理。\n综上所述，我们可以在 O(k\\log_2k) 的时间内用 f_k(0,T,\\cdots,kT) 求出 f_{2k}(0,T,\\cdots,2kT)。\n另外，用 f_k(0,T,2T,\\cdots,kT) 求出 f_{k+1}(0,T,2T,\\cdots,kT,(k+1)T) 可以直接暴力。复杂度 O(k)。\n该算法的总复杂度是 O(T\\log_2T)。\n自然倒数幂和\n计算 \\sum_{i=1}^ni^{-k} \\bmod p。\nk&gt;0。 首先这并不是一个容易处理的多项式函数。因此我们需要做一些转化： \\sum_{i}\\frac{1}{i^k} = \\sum_{i}\\frac{\\prod_{j\\ne i}j^k}{\\prod_j j^k} =\\frac{\\sum_i\\prod_{j\\ne i}j^k}{\\prod_j j^k}分子分母都是多项式。因此我们分别求出两者在 x=n 处的点值即可。\n设 f_T(x)=\\prod_{i=1}^{T}(x+i)^k，设 g_T(x)=\\sum_{i=1}^T\\frac{f_T(x)}{(x+i)^k}。那么有 \\frac{g_T(x)}{f_T(x)}=\\sum_{i=1}^T(x+i)^{-k}。\n因此我们只需要对 f_T,g_T 分别做多点求值即可。\n注意到 f_T,g_T 是 Tk 次的多项式，而我们要求的点值数是 \\frac{n}{T} 的。不妨令 Tk=\\frac{n}{T}，得到 T=\\sqrt{\\frac{n}{k}}。\n问题转化为求出 f_T(0,T,\\cdots,T^2) 和 g_T(0,T,\\cdots,T^2)。\n考虑倍增。问题转化为 用 f_k(0,T,\\cdots,kT) 求出 f_{2k}(0,T,\\cdots,2kT)。\n用 g_k(0,T,\\cdots,kT) 求出 g_{2k}(0,T,\\cdots,2kT)。 由于 f_{2k}(x)=f_k(x)f_k(x+k)，所以可以类似上一题一样做。\n由于 g_{2k}(x)=g_k(x)f_k(x+k)+f_k(x)g_k(x+k)，所以结合一下 f_k 的计算结果就可以了。\n时间复杂度 O(T\\log_2T)。\n参考文献「翻译向」阶乘模大质数 - ZZQ’s Blog\n階乗 mod 素数 - min-25","title":"点值平移与倍增求值学习笔记","updated":"2025-04-23T04:07:19.269Z"},{"categories":[],"path":"Math/Polynomial/Multi-Point-Eval/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"转置原理转置原理，或称特勒根原理（Tellegen’s Principle），指的是对于矩阵 \\textbf{M} 和向量 \\textbf{v}，为优化计算 \\textbf{Mv}，我们可以考察 \\textbf{M}^T\\textbf{v} 的计算方法。原因是设有分解 \\textbf{M}=\\textbf{E}_1\\cdots\\textbf{E}_k，那么 \\textbf{M}^T=\\textbf{E}_k^T\\cdots\\textbf{E}_1^T。\n也就是说，如果 \\textbf{M}^T\\textbf{v} 有快速的计算方法，那么 \\textbf{M}\\textbf{v} 在原理上也一定拥有相同复杂度的算法。\n多项式多点求值多点求值（multi point evaluation），指的是给出多项式 F(x)=\\sum_{i=0}^{n-1}f_ix^i 以及 n 个横坐标 a_0,a_1,\\cdots,a_{n-1}，快速求出 F(a_0),F(a_1),\\cdots,F(a_{n-1})。目前已有的算法是通过多项式取模来实现。\n注意到，多点求值本质上是对向量 \\textbf{v}=[f_0,\\cdots,f_{n-1}]^T 做一个线性变换： \\begin{bmatrix}\n1 & a_0 & a_0^2 & \\cdots & a_0^{n-1}\\\\\n1 & a_1 & a_1^2 & \\cdots & a_1^{n-1}\\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & a_{n-1} & a_{n-1}^2 & \\cdots & a_{n-1}^{n-1}\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nf_0 \\\\ f_1 \\\\ \\vdots \\\\ f_{n-1}\n\\end{bmatrix}=\n\\begin{bmatrix}\nF(a_0) \\\\ F(a_1) \\\\ \\vdots \\\\ F(a_{n-1})\n\\end{bmatrix}这个矩阵是一个范德蒙德矩阵，记作 \\textbf{V}。我们把矩阵转置一下得到 \\textbf{V}^T\\textbf{v}=\\begin{bmatrix}\n1 & 1 & 1 & \\cdots & 1\\\\\na_0 & a_1 & a_2 & \\cdots & a_{n-1}\\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\na_0^{n-1} & a_1^{n-1} & a_2^{n-1} & \\cdots & a_{n-1}^{n-1}\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nf_0 \\\\ f_1 \\\\ \\vdots \\\\ f_{n-1}\n\\end{bmatrix}观察发现，转置后的变换，向量的第 j 项求的是 \\sum_{i=0}^{n-1}f_ia_i^j。写出它的生成函数，因此我们求的是 \\sum_{j\\ge 0}x^j\\sum_{i=0}^{n-1}f_ia_i^j=\\sum_{i=0}^{n-1}\\frac{f_i}{1-a_ix}这个多项式的前 n 项的系数（对 x^n 取模）。这个东西可以分治多项式乘法计算。\n那么我们把这个矩阵转置回去，就可以得到多点求值的算法。也就是说本质上我们可以把所有初等变换写下来，然后转置一下并反转这个操作序列，然后再照着做一遍，就得到了相同复杂度的多点求值做法。但是这个过于憨批，想必没人会去实现它。为此我们需要分析计算 \\textbf{V}^T\\textbf{v} 的过程中变换的转置变换是什么。\n初等变换本质上我们进行的变换有如下两种： 把变量 x 乘一个常数 c，记作 x\\gets xc。\n把变量 x 乘 c 加到变量 y 上，记作 y\\gets y+xc。 注意，变量的交换可以使用上面两个操作完成。\n它们的转置操作分别是 把变量 x 乘一个常数 c，记作 x\\gets xc（不变）。\n把变量 y 乘 c 加到变量 x 上，记作 x\\gets x+yc。 这个大家可以写出初等变换矩阵，然后转置一下，自行验证。\n多项式乘法多项式乘法的变换过程是，给出多项式 F(x)=f_0+\\cdots+f_{n-1}x^{n-1} 和 G(x)=g_0+\\cdots+g_{m-1}x^{m-1}，那么对于 H(x)=F(x)G(x)，有 h_{i+j}\\gets h_{i+j}+f_ig_j，其中 0\\le i&lt;n,0\\le j&lt;m。\n我们设 g 是一个常数多项式，而 f 是输入。那么这个变换的转置就是：h_i\\gets h_i+f_{i+j}g_j，其中 0\\le i+j&lt;n,0\\le j&lt;m。容易发现，这样求出的 h 有 n 项。我们记这个变换是 h=f\\otimes g。\n这个可以倒过来 NTT 计算。\n转置后的算法接下来我们具体考虑求 \\sum_{i=0}^{n-1}\\frac{f_i}{1-a_ix} 的算法。\n设 g(x)=\\prod_{i=0}^{n-1}(1-a_ix)，那么我们可以先求出 \\sum_{i=0}^{n-1}\\frac{f_ig(x)}{1-a_ix}，然后再乘上 g^{-1} 即可。\n求 T(x)=\\sum_{i=0}^{n-1}\\frac{f_ig(x)}{1-a_ix} 的过程可以分治计算： 如果 n=1，那么直接返回 f_i。 否则，设 m=\\lfloor \\frac{n}{2} \\rfloor。 令 T_L=\\sum_{i=0}^{m-1}\\frac{f_ig(x)}{1-a_ix}，T_R=\\sum_{i=m}^{n-1}\\frac{f_ig(x)}{1-a_ix}。\n令 g_L=\\prod_{i=0}^{m-1}(1-a_ix)，g_R=\\prod_{i=m}^{n-1}(1-a_ix)。\n那么有 T=T_Lg_R+T_Rg_L，g=g_Lg_R。因此两边分别递归求 (T,g) 即可。 最后对于求出的 T，乘上 g^{-1} 并对 x^n 取模。\n由于多项式乘法的复杂度是 O(n\\log_2n) 的，因此该算法的总复杂度为 O(n\\log_2^2n)。\n还原转置那么我们考虑多点求值的算法。\n首先，我们操作是倒过来并且经过转置的。\n其次，g(x) 在算法过程中是常量（只和 a_i 有关，和 f_i 无关）。\n把 f_i 当作输入，也就是说 T(x)=\\sum_{i=0}^{n-1}f_ix^i。\n首先让 T=T\\otimes g^{-1}。注意，对 g 求逆的过程是对常量求逆的过程，因此不需要转置，直接多项式求逆。\n然后我们把上述分治算法倒过来并转置： 如果 n=1，则 T 是一个常数，直接返回 T 即可（存储到数组上）。\n否则，设 m=\\lfloor\\frac{n}{2}\\rfloor。\n原本是 T=T_Lg_R+T_Rg_L，转置后就变成了：T_L=T\\otimes g_R，T_R=T\\otimes g_L。\n并且 T_L 只需要保留前 m 项，T_R 只需要保留前 n-m 项。\ng=g_Lg_R 是不变的，因为是常量。实际上这个应该是预处理的。 算法在叶子处的值就是对应的点值。\n该算法的时间复杂度仍是 O(n\\log_2^2n)，但不用每次都多项式求逆，常数大大减小。\n参考文献QY 为什么可以 5e5 多点求值 (详细揭秘) - rqy\n题解 P5050 【模板】多项式多点求值 - EI","title":"转置原理与多点求值","updated":"2025-04-23T04:07:19.270Z"},{"categories":[],"path":"Math/Polynomial/Polynomial-Pro/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"},{"name":"Polynomial","slug":"Polynomial","permalink":"https://notes.sshwy.name/tags/Polynomial/"}],"text":"洛必达法则若函数 f 和 g 满足以下条件： \\displaystyle\\lim_{x\\to x_0}f(x)=\\lim_{x\\to x_0}g(x)=0；\n在 x 的某空邻域 U^{\\circ}(x_0) 内两者均可导，且 g'(x)\\ne 0；\n\\displaystyle\\lim_{x\\to x_0}\\frac{f'(x)}{g'(x)}=A，其中 A 可为非正常极限。 则 \\lim_{x\\to x_0}\\frac{f(x)}{g(x)}=\\lim_{x\\to x_0}\\frac{f'(x)}{g'(x)}=A通俗地说，如果 f(x),g(x) 在 x_0 处的极限都是 0，那么 \\frac{f(x)}{g(x)} 在 x_0 处的极限可以通过他们的导数来求。\n多项式除法给出多项式 A(x),B(x)，求出 D(x),R(x)，满足 A(x)=B(x)Q(x)+R(x)，且 \\deg R&lt;\\deg B。注意这里不是模意义下。\\deg A 表示多项式最高次项的次数。\n定义一个变换 F^R(x)=x^{\\deg F}F\\left(\\frac{1}{x}\\right)该变换的实质是把多项式的系数翻转过来了。代入 \\dfrac{1}{x} 得到 A\\left(\\frac{1}{x}\\right)=B\\left(\\frac{1}{x}\\right)Q\\left(\\frac{1}{x}\\right)+R\\left(\\frac{1}{x}\\right)由于 \\deg Q=\\deg A-\\deg B，那么不妨设 \\deg R=\\deg B-1。稍作变换得到 \\begin{aligned}\nx^{\\deg A}A\\left(\\frac{1}{x}\\right)&=x^{\\deg B}B\\left(\\frac{1}{x}\\right)x^{\\deg Q}Q\\left(\\frac{1}{x}\\right)+x^{\\deg A}R\\left(\\frac{1}{x}\\right)\\\\\nA^R(x)&=B^R(x)Q^R(x)+R^R(x)x^{\\deg A-\\deg B+1}\n\\end{aligned}那么容易发现，在模 x^{\\deg A-\\deg B+1} 意义下，R^R 就没了： A^R(x)=B^R(x)Q^R(x)\\pmod{x^{\\deg A-\\deg B+1}}这样我们可以求出 Q^R\\bmod{x^{\\deg A-\\deg B+1}}。\n由于 \\deg Q&lt;\\deg A-\\deg B+1，因此 Q^R\\bmod x^{\\deg A-\\deg B+1}=Q^R。于是 Q^R(x)=\\frac{A^R(x)}{B^R(x)}\\pmod{x^{\\deg A-\\deg B+1}}这样使用多项式求逆即可得到 Q^R，反代回去可求出 R。\n时间复杂度 O(n\\log_2n)。\n多点求值给出 F(x)，求 F(a_1),F(a_2),\\cdots,F(a_m)，其中 m 与 \\deg F 同阶。\n考虑分治。设 L(x)=\\prod_{i=1}^{\\lfloor\\frac{m}{2}\\rfloor}(x-a_i)，R(x)=\\prod_{i=\\lfloor\\frac{m}{2}\\rfloor+1}^n(x-a_i)。\n容易发现 L(a_1)=L(a_2)=\\cdots =L(a_{\\lfloor\\frac{m}{2}\\rfloor})=0。那么构造 F_L(x)=F(x)\\bmod L(x)。显然有 F_L(a_i)=F(a_i),i\\in[1,\\lfloor\\frac{m}{2}\\rfloor] 满足。因此左边递归下去求值。右边同理。\n时间复杂度 O(m\\log_2^2m)。在实现的过程中需要预先把所有的 \\prod (x-a_i) 函数都存下来，因此空间复杂度是 O(m\\log_2m)。\n快速插值给出 (x_1,y_1),(x_2,y_2),\\cdots,(x_n,y_n)。那么我们可以唯一确定一个 n-1 次多项式。求出这个多项式。\n用拉格朗日插值可以得到 \\begin{aligned}\nF(x)&=\\sum_{i=1}^n\\prod_{j\\ne i}\\frac{(x-x_j)}{(x_i-x_j)}y_i\\\\\n&=\\sum_{i=1}^n\\frac{\\prod_{j\\ne i}(x-x_j)}{\\prod_{j\\ne i}(x_i-x_j)}y_i\n\\end{aligned}分上下两部分处理。\n第一部分考虑对于每个 i 求出 V_i=\\prod_{j\\ne i}(x_i-x_j)。\n设 M(x)=\\prod_{i=1}^n (x-x_i)。那么 M(x) 可以分治 NTT 计算出来，时间复杂度 O(n\\log_2n)。\n容易发现 V_i=\\dfrac{M(x)}{x-x_i}。但是如果我们直接做 n 次多项式求逆的话复杂度就不对了。\n利用洛必达法则，设 Q(x)=x-x_i。因为 M(x_i)=Q(x_i)=0，且两个函数都在邻域内可导，因此得到 V_i=\\frac{M(x)}{Q(x)}(x_i)=\\frac{M'(x)}{Q'(x)}(x_i)=M'(x_i)那么对 M'(x) 求出在 x_1,x_2,\\cdots,x_n 处的点值即可。这样就求出了所有 V_i。时间复杂度 O(n\\log_2^2n)。\n第二部分求出 V_i 后，原式可以表示为 F(x)=\\sum_{i=1}^n\\frac{y_i}{V_i}\\prod_{j\\ne i}(x-x_j)同样考虑分治，设 \\begin{aligned}\nM_L&=\\prod_{i=1}^{n/2}(x-x_i)\\\\\nM_R&=\\prod_{i=n/2+1}^n(x-x_i)\\\\\nF_L&=\\sum_{i=1}^{n/2}\\frac{y_i}{V_i}\\prod_{j=1,j\\ne i}^{n/2}(x-x_j)\\\\\nF_R&=\\sum_{i=n/2+1}^{n}\\frac{y_i}{V_i}\\prod_{j=n/2+1,j\\ne i}^{n}(x-x_j)\n\\end{aligned}那么如果我们求出了这 4 个多项式，那么可以得到 F=F_LM_R+F_RM_L。两边递归求解即可。\n时间复杂度 O(n\\log_2^2n)，空间复杂度 O(n\\log_2n)，因为多点求值带一个 O(n\\log_2n) 的空间复杂度。而第二部分的计算是可以把空间减小到 O(n) 的，不过直接动态开空间也只增大了空间常数，没有改变空间复杂度。\n多项式复合逆对于两个多项式函数 F(x),G(x)，如果 F(G(x))=x，称 F,G 互为复合逆。\n容易证明 G(F(x))=F(G(x))=x。但是多项式复合逆没有时间复杂度 O(n\\log_2n) 的做法。但可以使用拉格朗日反演在 O(n\\log_2n) 的时间内计算出某一项。\n拉格朗日反演对于两个多项式函数 F(x),G(x)，如果 F(G(x))=x，那么 [x^n]G(x)=\\frac{1}{n}[x^{n-1}]\\left( \\frac{x}{F(x)} \\right)^n还有一个扩展形式： [x^n]H(G(x))=\\frac{1}{n}[x^{n-1}]H'(x)\\left( \\frac{x}{F(x)} \\right)^n其中 H(x) 是另一个多项式函数。\n大朋友与多叉树题意：求有多少棵有根树，满足有 s 个叶子结点，内部结点的儿子数都属于集合 D，且 1\\notin D。注意，儿子之间是有顺序的。\n例如当 s=4,D=\\{2,3\\} 时： 定义两个普通生成函数 F(x)=\\sum_{n\\in D}x^n\\\\\nG(x)=\\sum_{n\\ge 1}g_nx^n其中 g_n 是 s=n 的答案。考虑根结点的孩子数为 a，此时方案数的生成函数显然为 G^a(x)。从这个思路出发，可以得到 F(G(x))+x=G(x)加上一个 x 是考虑 s=1 的情况。可以得到 G(x)-F(G(x))=x，因此 x-F(x) 与 G(x) 互为复合逆。\n使用拉格朗日反演得到 [x^s]G(x)=\\frac{1}{s}[x^{s-1}]\\left(\\frac{x}{x-F(x)}\\right)^s在模 x^{s+1} 意义下直接求值即可。一个技巧是把后面的式子转化为 (1-\\frac{F(x)}{x})^{-s} 的形式，这样常数项为 1，可以多项式 \\ln 来求幂。\n时间复杂度 O(n\\log_2n)。\n仙人掌计数仙人掌：如果一个简单无向连通图的任意一条边最多属于一个简单环，我们就称之为仙人掌。所谓简单环即不经过重复的结点的环。\n求 n 个点带标号的仙人掌数量。\n考虑有根仙人掌的指数生成函数为 F(x)。那么求出来后把方案数除以 n 就是答案。我们可以将仙人掌的构成分成两种部分： 从根结点连出去的独立边，相当于接一个仙人掌出去。一条边连出去的生成函数是 F(x)，多条边之间不区分顺序，因此方案数是 \\exp F(x)。\n包含根结点的一个简单环，环上除了根结点之外的每个结点都挂一个仙人掌。由于我们要考虑环上结点之间的顺序，因此假设环长为 i+1，那么 i 个仙人掌按序排列的生成函数是 F^i(x)。考虑到是一个环，因此每个排列被正着反着各算了一次，因此长度为 i+1 的环的生成函数是 \\dfrac{F^i(x)}{2}。那么一个环的生成函数就是 \\displaystyle\\sum_{i\\ge 2}\\frac{F^i(x)}{2}。多个环之间是不区分顺序的，因此多个环的方案数是 \\exp \\left(\\displaystyle\\sum_{i\\ge 2}\\frac{F^i(x)}{2}\\right)。 综上，环和独立边互不相关，总方案数是 \\exp \\left(F(x)+\\displaystyle\\sum_{i\\ge 2}\\frac{F^i(x)}{2}\\right)，再加上根结点本身得到 F(x)=x\\exp \\left(F(x)+\\sum_{i\\ge 2}\\frac{F^i(x)}{2}\\right)稍作整理得到 F(x)=x\\exp \\left(\\frac{2F(x)-F^2(x)}{2-2F(x)}\\right)考虑牛顿迭代法。\n方法一设 G(F(x))=x\\exp \\left(\\frac{2F(x)-F^2(x)}{2-2F(x)}\\right)-F(x)那么显然我们要求 G(F(x))=0\\pmod{x^{n+1}}。应用牛顿迭代得到 F(x)=F_0(x)-\\frac{G(F_0(x))}{G'(F_0(x))} \\pmod {x^n}对 G 求导得到 \\begin{aligned}\nG'(F(x))&=\\left(x\\exp \\left(\\frac{2F(x)-F^2(x)}{2-2F(x)}\\right)\\right)'-1\\\\\n&=x\\left(\\exp \\left(\\frac{2F(x)-F^2(x)}{2-2F(x)}\\right)\\right)'-1\\\\\n&=x\\exp \\left(\\frac{2F(x)-F^2(x)}{2-2F(x)}\\right)\\left(\\frac{2F(x)-F^2(x)}{2-2F(x)}\\right)'-1\\\\\n&=x\\exp \\left(\\frac{2F(x)-F^2(x)}{2-2F(x)}\\right)\n\\left(1+\\frac{2(2F(x)-F^2(x))}{(2-2F(x))^2}\\right)-1\n\\end{aligned}如何理解式子中的 x？我们把它理解为与 F(x) 不相关的一个常量即可。常量的导数是 0。\n最后得到 F(x)=F_0(x)-\n\\frac{x\\exp \\left(\\frac{2F_0(x)-F_0^2(x)}{2-2F_0(x)}\\right)-F_0(x)}{x\\exp \\left(\\frac{2F_0(x)-F_0^2(x)}{2-2F_0(x)}\\right)\n\\left(1+\\frac{2(2F_0(x)-F_0^2(x))}{(2-2F_0(x))^2}\\right)-1}\n\\pmod {x^n}方法二方才 F(x) 的式子可以变换为 F(x)=x\\exp \\left(\\frac{2F(x)-F^2(x)}{2-2F(x)}\\right)\\\\\nF(x)\\exp \\left(\\frac{2F(x)-F^2(x)}{2F(x)-2}\\right)-x=0因此设 G(F(x))=F(x)\\exp \\left(\\frac{2F(x)-F^2(x)}{2F(x)-2}\\right)-x同样的方法，对 G 求导得到 G'(F(x))=\n\\exp\\left( \\frac{2F(x)-F(x)^2}{2F(x)-2} \\right)\n\\left(1-F(x)\\left(1+\\frac{2(2F(x)-F(x)^2)}{(2F(x)-2)^2}\\right)\\right)因此可以得到 \\begin{aligned}\nF(x)&=F_0(x)-\n\\frac{F_0(x)\\exp \\left(\\frac{2F_0(x)-F_0^2(x)}{2F_0(x)-2}\\right)-x}\n{\\exp\\left( \\frac{2F_0(x)-F_0(x)^2}{2F_0(x)-2} \\right)\n\\left(1-F_0(x)\\left(1+\\frac{2(2F_0(x)-F_0(x)^2)}{(2F_0(x)-2)^2}\\right)\\right)}\\\\\n&=F_0(x)-\n\\frac{F_0(x)-x\\exp \\left(\\frac{2F_0(x)-F_0^2(x)}{2-2F_0(x)}\\right)}\n{1-F_0(x)\\left(1+\\frac{2(2F_0(x)-F_0(x)^2)}{(2-2F_0(x))^2}\\right)}\n\\end{aligned}\\pmod{x^n}两种迭代方式是等价的。由于是 EGF 最后别忘了乘上 n!。\n代码\n点双连通图计数如果一个无向连通图删去任意一个点都仍然是连通的，我们就称为点双连通图。\n求 n 个点带标号点双连通图的个数。\n同样地，设 F(x)=\\sum_{n\\ge 1}f_n\\frac{x^n}{n!} 表示 n 个点的点双连通图的 EGF。设 G(x) 表示 n 个点有根连通图的 EGF。\n设 H(x)=\\sum_{n\\ge 0}2^{\\binom{n}{2}}\\frac{x^n}{n!} 表示带标号无向图数的生成函数，那么得到 G(x) = x(\\ln H(x))'。\n我们考虑用 F 表示 G。考虑有根无向图的包含根结点的点双连通分量。假设大小为 i+1，那么除了根结点之外的点都可以挂一个有根连通图，因此方案数是 \\sum_{i\\ge 1}\\frac{G^i(x)}{i!}。对于 i 个不区分顺序的有根连通图的根结点，再加上根结点，因此一个点双连通分量的方案数是 \\sum_{i\\ge 1}\\frac{f_{i+1}G^i(x)}{i!}。多个点双连通分量之间不区分顺序，因此总方案数是 \\exp \\left(\\sum_{i\\ge 1}\\frac{f_{i+1}G^i(x)}{i!}\\right)。再加上根结点本身得到 G(x)=x\\exp \\left(\\sum_{i\\ge 1}\\frac{f_{i+1}G^i(x)}{i!}\\right)=x\\exp F'(G(x))然而这个方程无法牛顿迭代。设 G 的复合逆是 G^{I}，那么得到 \\begin{aligned}\nG(G^I(x))&=G^I(x)\\exp F'(G(G^I(x)))\\\\\nx&=G^I(x)\\exp F'(x)\\\\\nF'(x)&=\\ln \\frac{x}{G^I(x)}\n\\end{aligned}据说使用扩展拉格朗日反演可以解决。","title":"多项式进阶","updated":"2025-04-23T04:07:19.270Z"},{"categories":[],"path":"Math/Quadratic-Residue/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"勒让德符号对于一个奇质数 p 且 n\\perp p，定义勒让德符号为 (\\frac np)，其中 \\left( \\frac{n}{p} \\right)=\\begin{cases}\n1 & n\\text{ is a quadratic residue}\\\\\n-1 & \\text{Otherwise}\n\\end{cases}如何计算勒让德符号？ n^{\\frac{p-1}{2}}=\\left( \\frac{n}{p} \\right) \\mod p这样就可以快速幂计算了。\nCipolla 算法简要描述要求解方程 x^2\\equiv n\\pmod p，首先判断 n 是否是二次剩余。\n然后随机一个 a 使得 a^2-n 不是二次剩余，那么设 w=\\sqrt{a^2-n} 并扩域，则 x=(a+w)^{\\frac{p+1}{2}}。 勒让德符号只能判断一个数是否是二次剩余。接下来我们介绍 Cipolla 算法以用于具体计算二次剩余。\n考虑方程 x^2\\equiv n\\pmod p。首先判断它是不是二次剩余。如果不是就不用求了。\n考虑随机一个 a 使得 a^2-n 不是\\bmod p 意义下的二次剩余。那么设 w=\\sqrt{a^2-n}。显然 w 在 \\bmod p 域（\\mathbf{F}_p）下是不存在的，我们称它是虚数单位元。我们对其扩域，这样得到一个新的域 \\mathbf{F}_{p^2}。也就是说 \\mathbf{F}_{p^2}=\\left\\{ x+y\\sqrt{a^2-n}: x,y\\in \\mathbf{F}_p \\right\\}我们类比复数域，定义它的加法和乘法运算。那么 \\mathbf{F}_{p^2} 是否满足域的所有性质呢？容易证明是满足的。这其中可能乘法逆元要难证一点。考虑 (x_1+y_1w)(x_2+y_2w)=1，则变成 (x_1x_2+y_1y_2(a^2-n))+(x_1y_2+x_2y_1)w=1然后发现这个方程在 \\mathbf{F}_{p} 域下是有解的。因此就证明了乘法逆元的存在。\n此外，我们还可以知道\n定理 1：w^{p}=-w\\pmod p。\n证明：因为 a^2-n 不是二次剩余，所以 w^{p+1}=(a^2-n)^{\\frac{p+1}{2}}=-1\\pmod p。\n定理 2：(a+b)^p=a^p+b^p\\pmod p（p 是质数）。\n证明：二项式定理。\n那么一通操作猛如虎： \\begin{aligned}\n(a+w)^{p+1}&=(a+w)^p(a+w)\\\\\n&=(a^p+w^p)(a+w)\\\\\n&=(a-w)(a+w)\\\\\n&=a^2-w^2\\\\\n&=n\n\\end{aligned}\n\\pmod p因此 x=(a+w)^{\\frac{p+1}{2}}。-x 是另一个解。并且算出来虚部的系数一定是 0。\n时间复杂度 O(\\log_2p)。随机的复杂度就忽略不计了。\n代码","title":"二次剩余学习笔记","updated":"2025-04-23T04:07:19.270Z"},{"categories":[],"path":"Probset/Contest-0518/","tags":[],"text":"便宜，货海星。\nA\n定义一个数字串是字符集为0123456789的串。给出 m 个总长度 \\le 50 的数字串 s_1,\\cdots,s_m，给出 n。求长度为 n，且 m 个数字串在其中都至少出现一次的数字串的个数。\nn\\le 10^9,m\\le 4。 建 AC 自动机，先枚举一下 m 个字符串中强制哪些不出现。然后矩阵快速幂。\nO(2^m(\\sum s_i)^3\\log_2n)。\nB\n给出一个长度为 n 的整数序列 A，要求将其分成若干段，每一段的长度在 [L,R] 之间，且每一段的价值为：设这一段的权值和为 x，那么价值为 ax^2+bx+c。\n求最大价值。\n1\\le L\\le R\\le n\\le 2\\times 10^5,|A_i|,|a|,|b|,|c|\\le 10^4,a&lt;0。 斜率优化，那么转移区间是单调的。那么实际上可以线段树维护区间凸包。插入点的时候如果这个区间满了再构建这个区间的凸包。\nO(n\\log_2^2n)。\n对于这种转移区间单调的，还可以考虑双栈，左边的栈只能删除（撤消），右边的只能插入。这样也可以转化为动态凸包问题。\nC\n给出一棵 n 个点边带非负权的树，求一条路径使得： 最大边和最小边之差不超过 m。\n路径总长度乘上最小边的长度最大。 n\\le 1\\times 10^5。 可以把边权理解为插入时间。那么按时间分治（线段树分治），然后只有插入。那么维护直径即可。当递归到单点的时候，就知道了最小边的长度，更新答案即可。\nO(n\\log_2^2n)（可撤消并查集）。","title":"又一套 Free 题","updated":"2025-04-23T04:07:19.273Z"},{"categories":[],"path":"Probset/Contest-0515/","tags":[],"text":"便宜没好货。\nA\n给一棵 n 个点带边权 w_i 的树，每次可以把一条路径的权值都异或 x。问最少多少次操作可以把所有边权变成 0。\nn\\le 10^5,0\\le w_i\\le 15。 emmmm\nB\n给一个 n 个点简单无向图，要求把点集分成 S,T 两部分，使得两个部分都是团，最小化两个团的边数，即 \\frac{|S|(|S|-1)+|T|(|T|-1)}{2}。\nn\\le 700。 二分图，背包。\nC\n给出 n,k，求长度为 k 的满足 1\\le a_i\\le n，且 a_i|a_{i+1} 的序列的个数。\nn,k\\le 10^6。 差分，插板法。","title":"一套 Free 题","updated":"2025-04-23T04:07:19.273Z"},{"categories":[],"path":"Math/Br-Intro-to-Abstract-Algebra/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"本文主要梳理和原根有关的群论基础知识。\n以后学的抽代知识也会往这里填。\n2020.5.8：为了学二次剩余，又来补充内容了。\n阶阶（order）在群中有两个相关含义。一是指群的元素个数——这不是我们今天要讨论的。\n群中一个元素 a 的阶（有时称为周期）是指使得 a^m=\\varepsilon 的最小正整数 m。\\varepsilon 是这个群的单位元。若不存在这样的 m，称 a 有无限阶。有限群的所有元素均有有限阶。\n一个元素 a 的阶被记为 \\text{ord}(a) 或者 |a|。\n在剩余系（模意义）下的阶我们也记作 \\text{ord}_pa，表示 \\bmod p 意义下 a 的阶。\n原根原根（primitive root）是数论（域论）中的概念。\n对于两个正整数 a,m，如果 a\\perp m，那么根据欧拉定理，有 a^{\\varphi(m)}\\equiv 1\\pmod m。\n而如果在 \\bmod m 意义下 a 的阶等于 \\varphi(m)，即 \\text{ord}_ma=\\varphi(m)，则称 a 是 \\bmod m 意义下的原根。此时，a^0,a^1,\\cdots,a^{\\varphi(m)-1} 构成 m 的简化剩余系。\n特殊地，当 m 是质数时，\\varphi(m)=m-1，也就是说此时 a^0,a^1,\\cdots,a^{\\varphi(m)-1} 构成 m 的剩余系。\n原根的存在性并不是所有的 \\bmod m 剩余系都有原根。\n\\bmod m 有原根的充要条件是 m=2,4,p^n,2p^n，其中 p 是奇素数，n 是任意正整数。\n如果 p 是一个奇素数且有原根 g，那么 g 或者 g+p 是模 p^2 的一个原根。\n如果 r 是模 p^2 的原根，那么它也是模 p^k 的原根。\n原根的计算考虑枚举 a 使得 a\\perp m。然后我们枚举 \\varphi(m) 的质因子p，判断是否 a^{\\frac{\\varphi(m)}{p}}\\equiv 1\\pmod {m}。如果该等式始终不成立，那么 a 就是原根。\n该算法复杂度为 O(m\\log_2m+\\sqrt{\\varphi(m)}+\\varphi(m)\\log \\varphi(m)\\log_2m)。\n如果 m 是质数那么复杂度就是 O(m+\\sqrt{\\varphi(m)}+\\varphi(m)\\log \\varphi(m)\\log_2m)。\n实际运行过程中原根都不会太大，因此该算法通常比较快。\nint pw(int a,long long m,int P)&#123; int res=1; m%=(P-1); while(m)m&amp;1?res=1ll*res*a%P:0,a=1ll*a*a%P,m>>=1; return res;\n&#125;\nint primitive_root_prime(int p)&#123; vector&lt;int> vd; int pp=p-1; for(int i=2;i*i&lt;=pp;++i)&#123; if(pp%i)continue; vd.pb(i); while(pp%i==0)pp/=i; &#125; if(pp>1)vd.pb(pp); pp=p-1; FOR(i,2,p-1)&#123; bool flag=0; for(auto d:vd)&#123; if(pw(i,pp/d,p)==1)&#123;flag=1;break;&#125; &#125; if(flag==0)return i; &#125; assert(0); // prime must have primitive root return -1;\n&#125;\n域域（Field）是一种可以进行加减乘除（除了除以 0，0 即加法单位元）运算的代数结构。\n非正式地说，域是一个集合且定义了加法和乘法运算。并且每个元素都有加法和乘法的逆元，使得能够定义除法和减法运算。\n确切地说，它需要满足如下性质： 加法和乘法结合律；\n加法和乘法交换律；\n存在加法和乘法的单位元；\n存在加法逆元；\n存在乘法逆元；\n有加法对乘法的分配律。 常见的域有： 有理数域 \\mathbf{Q}。\n复数域 \\mathbf{C}。\nConstructible numbers：可以尺规作图构造的数字（长度、面积）集合。 参考文献Wikipedia - Order (group theory))\nWikipedia - Field)","title":"抽象代数入门","updated":"2025-04-23T04:07:19.267Z"},{"categories":[],"path":"Data-Structure/Centroid-Decomposition/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"一直想总结点分治的一些技巧。结果因为各种原因鸽了。现在补一个。\n点分治与点分树点分治（centroid decomposition）算法的大致流程是，对于 n 个点无根树 T： 首先找到 T 的一个重心 c，然后处理与重心有关的信息。\n然后删掉重心，那么 T 将划分为若干个更小的连通块 T_1,\\cdots,T_k，对于每个连通块递归进行上述算法。 如果我们把 T_1,\\cdots,T_k 的重心当作 c 的 k 个儿子，递归构建，这样可以建出一棵新的树 T_C，我们称之为点分树（centroid decomposition tree）。\n点分树的重要性质：由于 c 是 T 的重心，因此 2|T_i|\\le |T|。也就是说每往下走一层，连通块大小至少减半。因此点分树的树高是 O(\\log n) 的。\n那么点分治和点分树适用于处理什么类型的问题呢？\n路径问题需要求出满足某种条件的路径条数，或者满足某种条件的路径权值和。那么我们可以在点分治的过程中，将路径按照 经过重心（或者以重心为端点）\n不经过重心 分类。如果一条路径不经过重心， 它一定在某个更小的连通块中，这类路径我们递归处理。因此在当前状态下我们只用处理经过重心的路径。也就是说，点分治将任意路径转化为了经过定点的路径。如果我们把重心作为连通块的根结点，那么点分治还可以把无根树路径转化为有根树上经过根结点的路径。\n点集问题有时我们需要求出，满足某种条件的连通块（点集）的个数。这个条件通常是可以转化为点与点之间的条件的。那么我们可以钦定在连通块（点集）深度最低的点上统计这个连通块的信息。\n具体地，我们仍然考虑点分治。那么我们将连通块分成 经过重心（如果是点集，那么就是跨过重心）\n不经过重心 两种。以重心为根，那么相当于我们要求的就是包含根结点的连通块的信息。\n其他类型事实上，点分治可以运用的场景还有很多。但它的主要作用就是钦定一个点，把问题转化为和这个点有关的信息处理。\n记号为了方便表述，我们在这里定义一些记号。\n一棵无根树 T=(V,E)，其中 V 是点集，E 是边集。(u,v) 表示一条无向边。\nP(u,v) 表示 u 到 v 的一条无向路径，P(u \\to v) 表示 u 到 v 的有向路径。\nT 的点分树是 T_C。\n以结点 u 为重心的点分树连通块记作 C_u。u 在点分树上的父亲是 F_u。\n捉迷藏\n给你一棵树 n 个点的树，支持 m 个询问： 改变一个点的颜色（黑白）。\n求黑点构成的虚树的直径。 n\\le 10^5,m\\le 5\\times 10^5。 如果没有修改操作，那么可以点分治或者直接树形 DP 求。\n我们从修改操作的角度考虑。建出点分树。那么修改一个点的颜色，会影响包含这个点的连通块的信息。而点分树树高是 O(\\log n) 的，因此包含这个点的点分树连通块只有 O(\\log n) 个。那么我们只需要思考，如果使用点分树连通块维护信息即可。\n一条路径（直径），一定经过某个点分树连通块的重心。同时，一条路径可以拆分成从重心出发的两条路径，分别通往两个不同的子连通块。\n因此对于点 u，我们使用一个堆 S_u 表示 C_u 中的黑点到 F_u 的直径（不管 F_u 是不是黑点）。然后我们用另一个堆 P_u 维护 u 的点分树儿子 v，且 v 是黑点的 S_v 的堆顶。这样，P_u 的最大值和次大值就是 C_u 中经过 u 的直径。然后对于每个点，我们把它的直径都放在一个大的堆 A 中。那么 A 的堆顶就是整颗树的直径。\n对于一次修改 u 的颜色，我们可能会涉及到包含 u 的点分树连通块的信息改变。那么我们暴力跳父亲，修改对应的 S_u,P_u 以及 A 即可。\n那么我们维护的是带删除的堆。\n还有一个小优化。就是我们预处理 d(i,j) 表示点 i 到 i 的点分树的 j 级父亲的距离。\n总时间复杂度 O(n\\log_2^2n+m\\log_2n)。\n幻想乡战略游戏\n给一棵 n 阶的点边带权的树 T，初始时点权 d_u 为 0。有 q 次操作，每次修改某个点的点权，要求在每次操作后询问 \\min_{u\\in T}\\left\\{ \\sum_{v\\in T}\\text{dist}(u,v)d_v \\right\\}其中 d_v 是点权，\\text{dist} 表示两点的距离（路径长度）。\n特殊性质：每个点度数不超过 D。\nn\\le 10^5,D=20。 设 f(u)=\\sum_{v\\in T}\\text{dist}(u,v)d_v。可以发现，\\text{dist}(u,v)d_v 在固定 v 的条件下，是一个树上凸函数，且以 v 为顶点。\n这里的树上凸函数是指对于每条路径 P(x,y) 上的点，\\text{dist}(u,v)d_v 是一个凸函数。实际上在本题中它是一个绝对值函数，但也满足凸函数的性质。\n因此若干个凸函数的和也是凸函数。也就是说 f(u) 也是树上凸函数。那么我们就可以使用类似找重心的算法来求 f(u)。假设当前结点是 u，那么我们枚举 u 在原树上的邻居 v，然后计算 f(v)。如果 f(v)&lt;f(u)，那么我们就跳到 u 的儿子连通块中包含 v 的那个的重心上，递归下去。\n因此现在的问题是，如何在递归的过程中快速计算 f(u)。\n不方便直接维护 f(u)，我们就维护它的贡献和。当我们从 u 跳到 u'——子连通块的重心的时候，其他连通块就可以缩点，然后接在 u' 的某个叶结点上。因此我们可以统计其他连通块的贡献和，然后把点权和加到这个叶子结点上。因此我们只需要维护 F(u)=\\sum_{v\\in C_u}\\text{dist}(u,v)d_v 即可，当然还有一些其他需要维护的，比如 F_2(u)=\\sum_{v\\in C_u}\\text{dist}(F_u,v)d_v 之类的，但这都是小问题。\n在修改的时候，这些可以暴力跳父亲修改。\n时间复杂度 O(n\\log ^2n+q\\log n(\\log n+D))。\nSCOI Online 树是 SCOI2018 的题。 给出一棵 n 个点的树，第 i 个点有权值 a_i，现在需要支持 m 次操作： 第一种操作格式为 “1 u”，表示询问从 u 出发的简单路径，经过的点权值之和的最大值；\n第二种操作格式为 “2 u v”，表示将 a_u 修改为 v。 1\\le n\\le 10^5,1\\le m\\le 10^5,|a_i|,|v|\\le 10^4。 建出点分树。从 u 出发的路径，一定是经过点分树上 u 的某个父亲 p，然后延伸向另一个与 u 不同的连通块。修改一个点的权值，会修改若干条路径。不过我们已经将问题转化为了点分树连通块里以重心为端点的路径信息问题——也就是定了根。那么修改一个点权，就会修改一个子树的路径的权值。自然想到线段树维护子树 max。再用一个堆维护子连通块的 max 集合即可。修改的时候暴力跳父亲修改即可。\n时间复杂度 O((n+m)\\log ^2n)。\nGiant Penguin\n定义 k 仙人掌为一个简单无向连通图 G，满足其中的任意一个点都被包含在 \\le k 个简单环中。\n给你一个 n 个点 m 条边的 k 仙人掌，操作： 标记一个点；\n问距离点 u 最近的被标记的点的距离。 n\\le 10^5,m\\le 2\\times 10^5,k\\le 10。 考虑在 k 仙人掌上点分治。我们先搞一棵生成树 T。对于当前连通块，我们确定一个点为重心，那么至多有 k 条非边是连接在子连通块之间的。而且我们可以快速找出这 k 条边。那么在删除的时候，我们同时删除重心和这 k 条边，就可以把其他子连通块割裂开来。这样就可以建出 k 仙人掌的点分树。我们称这 k 条边的端点集合是 u 的关键点。\n距离 u 最近的被标记的点，要么经过 u 的点分树上某个父亲，要么经过某个父亲的关键点。因此我们可以对于每个点预处理 f(u,i,j) 表示 u 到点分树的 i 级父亲的第 j 个关键点的距离。然后维护 d(u,j) 表示距离 u 的第 j 个关键点的最小距离（不妨设为 d(u,0)=u）。因为我们只会标记而不需要撤消，因此不需要维护堆。这样一通更新即可。\n时间复杂度 O((n+m)k\\log_2n)。\nAirplane Cliques\n给你一棵 n 个点无根树 T=(V,E)。给出常量 x。\n称一个点集 S 是好的，当前仅当其中任意两个点距离不超过 x（边长为 1）。\n求出大小为 1,2,\\cdots,n 的好的集合的个数。\n1\\le n\\le 3\\times 10^5，对 998244353 取模。 任意两个点距离不超过 x，等价于给树定根后： 设 u 是 S 中深度最深的结点；\n对于任意 v\\in S，v 到 u 的距离不超过 x。 因此我们可以把 S 放在 S 深度最深的点处统计方案数。\n为了防止多个深度相同的最深点重复统计，我们按序给结点标号来统计。也就是说我们给树定根，按照 BFS 序 标记一个结点 u；\n统计有多少个标记过的结点 v 到 u 的距离不超过 x。 由于是 BFS 序，这样就不用考虑深度的问题了。因此给树定根只是为了确定 BFS 序。实际上这个统计是可以看作在无根树上进行的。\n至于统计的部分，我们可以维护点分树连通块中，到重心的标记过的点的距离集合。那么我们查询就暴力跳重心，二分统计即可（要减掉在自己连通块部分的贡献）。可以使用点分树 + 树状数组统计。\n这样统计完之后，设 a_u 表示 u 的统计结果。设 f_i 表示大小为 i 的好的集合的个数。显然 a_u 对 f_i 的贡献是 \\binom{a_u}{i}。不防设 c_i=\\sum_{j=1}^n[a_j=i]。则 c_i 对 f_j 的贡献就是 \\binom{i}{j}c_i。因此 f_j=\\sum_{i=1}^n\\binom{i}{j}c_i可以得到 j!f_j=\\sum_{i=1}^nc_i i!\\frac{1}{(i-j)!}。这是一个卷积的形式，可以简单 reverse 一下就能多项式计算了。\n因此总时间复杂度 O(n\\log^2n)。","title":"点分治总结","updated":"2025-04-23T04:07:19.263Z"},{"categories":[],"path":"Probset/SCOIol/","tags":[],"text":"Day 1 A 树\n给出一棵 n 个点的树，第 i 个点有权值 a_i，现在需要支持 m 次操作： 第一种操作格式为 “1 u”，表示询问从 u 出发的简单路径，经过的点权值之和的最大值；\n第二种操作格式为 “2 u v”，表示将 a_u 修改为 v。 1\\le n\\le 10^5,1\\le m\\le 10^5,|a_i|,|v|\\le 10^4。 如果没有修改操作，那么可以换根 DP。\n如果询问的 u 固定，那么可以求出 DFS 序，然后线段树维护子树距离 max。\n建出点分树。从 u 出发的路径，一定是经过点分树上 u 的某个父亲 p，然后延伸向另一个与 u 不同的连通块。修改一个点的权值，会修改若干条路径。不过我们已经将问题转化为了点分树连通块里以重心为端点的路径信息问题——也就是定了根。那么修改一个点权，就会修改一个子树的路径的权值。自然想到线段树维护子树 max。再用一个堆维护子连通块的 max 集合即可。修改的时候暴力跳父亲修改即可。\n时间复杂度 O((n+m)\\log ^2n)。\nDay 1 B Numazu 的蜜柑\n给出一棵 n 个点的树，u 的点权是 a_u。给出常数 p,A,B，求有多少对 (u,v) 满足 v 是 u 的祖先。\na_u^2+Aa_ua_v+Ba_v^2\\equiv 0\\pmod p。 n\\le 10^5,3\\le p\\le 10^{16},0\\le A&lt;p,0&lt;B&lt;p,0&lt;a_i&lt;p。p 是质数。 当时谁写的 nt 题面，不告诉我 p 是质数。后来才改的。\n既然 p 是质数，就可以随便折腾了。变换一下得到 \\frac{a_u}{a_v}+A+B\\frac{a_v}{a_u}=0\\pmod p令 x=\\frac{a_u}{a_v}，则原式化为 x+A+\\frac{B}{x}=0\\pmod p解得 x=\\frac{-A\\pm \\sqrt{A^2-4B}}{2} \\pmod p首先 A^2-4B 得是二次剩余，不然无解。然后就 DFS 记个 map 就行了。\nDay1 C 星际迷航\n在一个 m 维空间中，给你 n 个点 p_i=(p_{i,1},p_{i,2},\\cdots,p_{i,m})。初始时你在原点。每次你可以选择 n 个点中的一个，然后跳到关于它的对称点上去。给你一个模数 P。有 Q 次询问。\n每次询问给出一个点 u=(u_1,\\cdots,u_m)。问你能否跳到一个点 v=(v_1,\\cdots,v_m) 使得 \\forall 1\\le i\\le m, v_i=u_i\\pmod P，也就是每一维都与 u 在模 P 意义下同余。\nn,q\\le 10^5,m\\le 10,P\\le 10^8。\n注意，原点不一定可以用于跳转。","title":"SCOI Online","updated":"2025-04-23T04:07:19.274Z"},{"categories":[],"path":"Data-Structure/Blue-Red-Chain/","tags":[],"text":"没想到居然可以有第二篇。似乎是投给某个比赛了，应该不久后可以解封。","title":"高爸出题 2","updated":"2025-04-23T04:07:19.262Z"},{"categories":[],"path":"Math/Unit-Root-Inversion/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"单位根（unit root）：k 次单位根记做 \\omega_k=e^{\\frac{2\\pi i}{k}}。\n单位根反演如同大多数反演一样，单位根反演（unit root inversion）也是基于一个恒等式： [d|n]=\\frac{1}{d}\\sum_{i=0}^{d-1}\\omega_d^{ni}证明若 d|n，则上式显然等于 1。\n否则，根据等比数列求和公式可以得到 \\sum_{i=0}^{d-1}\\omega_d^{ni}=\\frac{1-\\omega_d^{dn}}{1-\\omega_d^n}=0证毕。\n数论中的单位根上午中的单位根需要满足什么性质吗？k 次单位根需要满足，\\omega_k^i\\ne 1（1&lt;i&lt;k），\\omega_k^k=1。并不需要其他的条件。因此如果你担心浮点数运算的速度和精度问题，可以考虑在模 P 意义下找到 k 次单位根——也就是阶为 k 的数。\n生成函数与单位根反演考虑一个 OGF F(x)=\\sum_{i=0}^n a_ix^i。我们想求所有指数是 k 的倍数的项的系数和，也就是 \\sum_{i=0}^n a_i[k|i]。单位根反演一波得到 \\begin{aligned}\n&\\sum_{i=0}^n a_i[k|i]\\\\\n=&\\sum_{i=0}^na_i\\frac{1}{k}\\sum_{j=0}^{k-1}\\omega_{k}^{ij}\\\\\n=&\\frac{1}{k}\\sum_{j=0}^{k-1}\\sum_{i=0}^na_i\\left(\\omega_{k}^{j}\\right)^i\\\\\n=&\\frac{1}{k}\\sum_{j=0}^{k-1}F(\\omega_k^j)\n\\end{aligned}那么只要我们能快速计算 F 函数的点值，就可以快速计算上述的系数和。\nLJJ 学二项式定理\n给定 n,s,a_0,a_1,a_2,a_3，求 \\sum_{i=0}^n\\binom{n}{i}s^ia_{i\\bmod 4}\\pmod {998244353}n\\le 10^{18},s,a_0,a_1,a_2,a_3\\le 10^8。 构造 OGF F(x)=\\sum_{i=0}^n\\binom{n}{i}s^ix^i。那么我们只需要知道下标 \\bmod4 的四种余数的系数和，就可以求出答案了。\n对于 i\\bmod 4=0，即 4|i，我们可以直接反演。如果余数非零，那么我们可以给 F(x) 乘 x^t 来右移 t 位，然后也可以反演。因此接下来的问题是： 单位根 \\omega_4 是多少。\nF 的点值如何快速计算。 由于模数特殊，容易发现 \\omega_4=3^{\\frac{P-1}{4}}\\bmod 998244353。\n根据二项式定义，容易得到 F(x)=(sx+1)^n。\n因此时间复杂度 O(\\log_2n)。\n代码\nPYXFIB\n给定 n,k,p，求 \\sum_{i=0}^{\\lfloor\\frac{n}{k}\\rfloor}\\binom{n}{ik}F_{ik}\\pmod {p}其中 F 是斐波那契数列，F_0=F_1=1,F_i=F_{i-1}+F_{i-2}。\nn\\le 10^{18},k\\le 20000,p\\le 10^9,p\\bmod k=1，p 是质数。 容易发现我们要求是 \\sum_{i=0}^{n}\\binom{n}{i}F_{i}[k|i]到这里有两种算法。\n算法一单位根反演的结论在矩阵意义上也是成立的。设 M^i 表示 F_i 对应的矩阵。因此我们要求是 \\sum_{i=0}^{n}\\binom{n}{i}M^i[k|i]那么构造 OGF F(x)=\\sum_{i=0}^n\\binom{n}{i}M^ix^i=(Mx+I)^n。由于 p 是质数且 p\\bmod k=1，因此我们找到 p 的一个原根 g，就可以得到 \\omega_k=g^{\\frac{p-1}{k}}。这样就可以单位根反演了。\n时间复杂度 O(k\\log_2n)。\n算法二其实斐波那契数列本身就可以表示成等比数列的和的形式。使用特征根或者生成函数法可以得到 F_n=\\frac{1}{\\sqrt{5}}\\left(\\frac{1+\\sqrt{5}}{2}\\right)^{n+1}-\\frac{1}{\\sqrt{5}}\\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n+1}那么我们求两次即可。单位根还是按照算法一的方式求出。使用类似的方法构造生成函数。\n然后还是对 \\sqrt{5} 扩域再计算。\n时间复杂度 O(k\\log_2n)。","title":"单位根反演入门","updated":"2025-04-23T04:07:19.271Z"},{"categories":[],"path":"Gao/Mope/","tags":[],"text":"高爸出的神仙题。由于是高爸的题，所以版权给高爸。于是稍微加密一下～","title":"有趣的 MOPE 题","updated":"2025-04-23T04:07:19.264Z"},{"categories":[],"path":"Math/Minkowski/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Geometry","slug":"Geometry","permalink":"https://notes.sshwy.name/tags/Geometry/"}],"text":"极坐标系对于直角坐标系的点 (x,y)，它可以用极坐标系 (r,\\theta) 表示，其中 r=\\sqrt{x^2+y^2}\\\\\n\\theta = \\text{atan2}(y,x)atan2 是已将象限纳入考量的反正切函数，或者 \\theta = \\begin{cases}\n\\arctan(\\frac{y}{x}) & x&gt;0\\\\\n\\arctan(\\frac{y}{x})+\\pi & x&lt;0 \\operatorname{and} y\\ge 0\\\\\n\\arctan(\\frac{y}{x})-\\pi & x&lt;0 \\operatorname{and} y&lt;0 \\\\\n\\frac{\\pi}{2} & x=0 \\operatorname{and} y&gt;0 \\\\\n-\\frac{\\pi}{2} & x=0 \\operatorname{and}y&lt;0 \\\\\n0 & x=0 \\operatorname{and} y=0\n\\end{cases}也就是向量 (x,y) 与 x 轴正半轴的夹角。atan2 的值域为 (-\\pi,\\pi]。\n\\theta 是所谓的极角。按极角排序也就是按 \\theta 排序。\n半平面交、凸包和凸多边形三者其实没有太大区别。只是半平面交是用直线方程表示，而凸包是用顶点集表示，多边形则是由边的向量表示。\n半平面交和凸包的对偶并不是单纯的表示方式的变化，这一点要注意。除非你用半平面交的交点集表示它，这才是单纯的表示方式的变化。\n像闵可夫斯基和之类的，三者其实都可以经过简单的转化后使用。\n半平面交对偶凸包考虑 n 条直线 y=k_ix+b_i，我们要求 y\\le k_ix+b_i 形成的半平面交。\n显然这是上凸的半平面交。\n首先将直线按斜率从大到小排序。然后依次加入直线。假设当前末尾的直线和倒数第二的直线分别是 f',f''。\n则新加入一条 y=kx+b 则要一直删除末尾直线，直到 -\\frac{b'-b''}{k'-k''} &lt; -\\frac{b-b''}{k-k''}也就是交点的横坐标关系。\n不妨设 p=(k,b),p'=(k',b'),p''=(k'',b'')，那么上述算法就转化为，将点按照横坐标从大到小排序，算法过程中删除末尾点，直到 \\frac{b'-b''}{k'-k''} &gt; \\frac{b-b''}{k-k''}稍作化简： (k-k'')(b'-b'') &gt; (k'-k'')(b-b'')\\\\\n\\det(p-p'',p'-p'')&gt;0如果我们把从大到小排序改为从小到大排序，那么该式就变成了 \\det(p-p'',p'-p'')&lt;0，也就是下凸壳。\n因此上凸的半平面交对偶后为下凸壳。\n同理可得，下凸的半平面交对偶后为上凸壳。\n不过要注意的是，这对偶关系只是考虑了半平面交上的点的情况。对于半平面交里和外的点则没有对偶（也可能是我没有分析出来的原因）。换言之这个对偶只描述了半平面交的形态。\n闵可夫斯基和定义两个点 p_1(x_1,y_1) 和 p_2(x_2,y_2) 的闵可夫斯基加法是向量加法，即 p_1+p_2=(x_1+x_2,y_1+y_2)。\n对于二维平面上两个图形 A 和 B，定义 A 和 B 的闵可夫斯基和为 A+B=C=\\{a+b|a\\in A,b\\in B\\}特殊地，对于两个凸多边形A,B，他们 的闵可夫斯基和有特殊的性质： A+B 仍是凸多边形。\nA+B 的顶点数等于这两个凸多边形每条有向边向量角的种类数。\nA+B 的周长总等于这两个凸多边形的周长之和。 换句话说，A+B 等价于，把 A 的边向量和 B 的边向量放在一起按极角序排序，取两个图形的第一个点作为闵可夫斯基和的起点，然后按顺序一个一个首尾相接形成的图形（假设两个图形的顶点都按照极角序排好了）。 （这图也被盗了一万次了）","title":"闵可夫斯基和入门","updated":"2025-04-23T04:07:19.269Z"},{"categories":[],"path":"Codeforces/part-2/","tags":[],"text":"Present\n给出长度为 n 的序列 a，求 \\begin{aligned}\n\\bigoplus_{1\\le i&lt;j\\le n}(a_i+a_j)\n=&(a_1 + a_2) \\oplus (a_1 + a_3) \\oplus \\ldots \\oplus (a_1 + a_n) \\\\\n&\\oplus (a_2 + a_3) \\oplus \\cdots \\oplus (a_2 + a_n) \\\\\n&\\cdots \\\\\n&\\oplus (a_{n-1} + a_n) \\\\\n\\end{aligned}n\\le 4\\times 10^5,1\\le a_i\\le 10^7。 摘要：逐位计算。\n考虑按位计算答案。考虑计算答案的二进制第 k 位是否为 1（k 从 0 计数）。由于高于 k 的位不影响第 k 位的数，不妨设 a_i&lt;2^{k+1}。因此 a_i+a_j&lt;2^{k+2}。那么我们要计算的就是 \\sum_{1\\le i&lt;j\\le n}[2^k\\le a_i+a_j&lt;2^{k+1}]\\text{ or }[2^{k+1}+2^k\\le a_i+a_j&lt;2^{k+2}]的奇偶性。\n不妨将 a 排序。枚举 j，在序列上二分查找即可。\n时间复杂度 O(n\\log_2^2n)。\n可以使用双指针 + 归并排序优化到 O(n\\log_2n)。\n代码\nInstant Noodles\n给你一个 2n 个点的二分图，左部右部各 n 个点。有 m 条边。右部的点点权为 c_i。\n定义 f(S) 表示左部点集 S 的邻居集合（显然都是右部的点）定义 g(S) 表示 f(S) 中的点的点权和。\n求 \\gcd_{S\\subseteq[n]}\\{g(S)\\}。\nn,m\\le 5\\times 10^5,c_i\\le 10^{12}。 摘要：哈希判邻居集合是否相等。\n由于是和的 GCD，因此我们关系的是：对于两个右部点 u,v，他们是否同步出现（要么同时出现，要么同时不出现）。\n如果两个点同步出现，那么我们就只用考虑它们的和。\n推广之。若右部点集合 S 中的点均同步出现，则我们只用考虑 S 的点权和。\n因此答案就是所有同步点集合的点权和的 GCD。\n要判断右部点两个点是否同步出现，只需要判断它们的邻居集合是否相同即可。\n若两个点的邻居集合不同，那么一定存在一个左部点集合使得这两个点没有同步出现。\n使用哈希，时间复杂度 O(n+m)。\n代码\nReality Show\n给出长度为 n 的序列 s 和 l，给出一个长度为 n+m 的序列 c。\n你可以构造一个长度为 k(k\\le n) 的序列 p 满足： 1\\le p_i&lt;p_{i+1}\\le n（单增）；\nl_{p_i}\\ge l_{p_{i+1}}（非严格单减）。 然后你需要对 p 和一个集合 S 做这样的操作：以 i=1,2,\\cdots,k 的顺序考虑 x=l_{p_i}： 你会获得 c_x 的奖励；\n若 x\\notin S，把 x 加入 S 并结束这次操作；否则把 x 从 S 中删除，并令 x\\gets x+1。 你的得分是奖励之和减去 \\sum_{i=1}^k s_{p_i}。\n请构造满足条件的 p 并最大化得分。输出得分。\n1\\le n,m\\le 2000,1\\le l_i\\le m,0\\le s_i\\le 5000,|c_i|\\le 5000。 摘要：倒序 DP。\n首先注意到在第二步操作的时候，你以任意顺序操作 l_{p_i}，得分不变。\n而我们操作的过程实际上可以看做是二进制的进位过程。\n那么我们考虑倒着构造 p。那么我们每次构造的就是当前序列中 l_{p_i} 最大的元素。\n考虑 DP。设 f(i,j) 表示 l_{p_x} 最大值为 i，且 l_{p_x}=i 的人有 j 个时的最大得分。\n若我们在 p 的开头插入 i（即新的 p_1=i），那么就可以对 f(l_i,j) 做一次背包： f(l_i,j)\\gets f(l_i,j-1)-s_i+c_{l_i}另一方面，f(x,j) 在 j&gt;1 的时候可以进位到 f(x+1,\\lfloor\\frac{j}{2}\\rfloor)。但是不是所有 f(x,j) 都需要进位。因为我们只改变了 f(l_i,j)，因此只需要对 x\\ge l_i 的部分进位即可。另一个事情是，f(l_i,j) 会贡献到 f(l_i+1,\\lfloor\\frac{j}{2}\\rfloor)，则 j 的范围每次除以 2。因此 DP 转移的复杂度是 O(n+m) 的。\n总复杂度 O(n(n+m))。\n代码\nAND Segments\n给出 n,k,m 和 m 个限制 (l_i,r_i,x_i)。问有多少长度为 n 的序列 a 满足 0\\le a_i&lt;2^k；\n\\forall1\\le i\\le m, a_{l_i}\\operatorname{bitand} a_{l_i+1}\\operatorname{bitand}\\cdots\\operatorname{bitand}a_{r_i}=x_i； 1\\le n\\le 5\\times 10^5,1\\le k\\le 30,0\\le m\\le 5\\times 10^5。 按位考虑。限制转化为，一段区间全 1，一段区间至少有一个 0。设 f(i) 表示前 i 个数且满足与前 i 个位置相交的限制的方案数。转移时枚举上一个 0 的位置即可。可以前缀和优化。复杂度 O(nk)。\n然而要注意的是，有关区间包含的去重问题一定要三思。千万记住：不要只比相邻的！不要 ban 掉前面的，应该是 ban 掉你当前的这个区间。注意枚举顺序。\n代码\nBombs\n你有一个排列 p_i。你有一个 01 序列 v_i。对 (p,v) 进行一次操作为：考虑 i=1,2,\\cdots,n： 把 p_i 插入到集合中；\n如果 v_i=1，就把集合中最大的数删除。 最后集合中剩下的数就是操作结果（如果有）。\n现在给出排列 p 和 q。设序列 v_i 初始为 0，要求你对 i=1,2,\\cdots,n： 求出 (p,v) 操作的结果并输出；\n令 v_{q_{i}}\\gets 1（増加一个 bomb）。 n\\le 3\\times 10^5,1\\le p_i,q_i\\le n。 随着 bomb 的增加，答案是不会增加的（不可能有数字复活）。\n考虑排列中一个数 x，假设 p_u=x。那么在什么条件下答案 &lt;x？\n所有大于等于 x 的数都被删。也就说，p 中最靠右的 \\ge x 的数的右边至少有一个 bomb，第二靠右的 \\ge x 的数右边至少有 2 个 bomb，以此类推。\n可以把 \\ge x 的数的位置 +1，bomb 出现的位置 -1。那么条件就转化为，所有的后缀和都小于等于 0。\n如果答案 &lt;x，那么我们就把 x 减 1 并继续检查答案是否小于 x。\n线段树维护后缀和即可。\n时间复杂度 O(n\\log_2n)。\n代码\nWise Men\n给一个 n 个点简单无向图 G=(V,E)。\n对于长度为 n 的排列 p，我们可以构造一个长度为 n-1 的 01 串 s(p)：\\forall 1\\le i&lt;n,s_i=[(p_i,p_{i+1})\\in E]。\n现在对于所有 2^{n-1} 个长度为 n-1 的 01 串 S，求 s(p)=S 的排列 p 的个数。\n2\\le n\\le 18。 考虑容斥。容斥 01 串中的 0，用无限制减去强制为 1 的情况。也就是说，f(S) 表示答案，则 g(S)=\\sum_{S\\subseteq T}f(T)。我们考虑求 g(S)。\ng(S) 可以理解为是，用若干条路径覆盖 n 个点的方案数。其中每条路径的长度的给定的。比如 g(11001011) 表示用长度分别为 1,2,3,3 的路径覆盖 n 个点的方案数（换一种说法，就是 g(11001011)=g(11010011)，因为他们对应的路径长度集合都是 \\{1,2,3,3\\}）。\n因此 g(S)=G(A)，其中 A 表示路径长度集合。我们可以考虑求 G(A)。A 的个数是拆分数，而 P(18)=385，复杂度可以接受。\n不妨先求出 f(x,S)，表示用长度为 x 的路径精确覆盖点集 S 的方案数（哈密尔顿路径）。这个可以 DP 求出。那么 G(A) 可以理解为是 \\prod f(x,S_i)，其中 x\\in A，且 S_i(1\\le i\\le |A|) 精确覆盖全集 [n]。由于的精确覆盖，因此本能地想到是不相交的或卷积。然而注意到我们只需要知道 2^n-1 处的点值，因此普通的或卷积也是足够的（如果集合出现交集，则这种方案无法对 2^n-1 的点值做贡献）。\n因此 G(A) 就是 f(x)(x\\in A) 的或卷积的 2^n-1 处的点值。这样我们对于每个路径长度集合 A 都可以计算出答案。\n然后我们再枚举 01 串，求出它的路径集合即可。\n最后容斥（FMT）回去。\n时间复杂度 O((?\\times P(n)+n^2)2^n)。? 表示拆分出的部分的个数。能过。当然，也是可以优化的。优化就是在 DFS 枚举集合的时候顺便 FMT。\n代码\nSum of Prefix Sums\n给你一棵带点权无根树 T=(G,E)。点权为 a_i。定义一条路径 P(u,v)=\\{i_1=u,i_2,\\cdots,i_k=v\\} 的权值为 \\sum_{j=1}^k a_{i_j}j。求权值最大的路径的权值。\n2\\le n\\le 150000,1\\le a_i\\le 10^6。 摘要：点分治，李超树。\n考虑点分治。\n容易想到把路径 i_1,\\cdots,i_k 分成前后两部分：i_1,\\cdots,i_m 和 i_{m+1},\\cdots,i_k。那么两部分的权值分别为 \\sum_{j=1}^ma_{i_j}j 和 m\\cdot \\sum_{j=1}^{k-m}a_{i_{m+j}}+\\sum_{j=1}^{k-m}a_{i_{m+j}}j。前者可以用 (x_1=\\sum_{j=1}^ma_{i_j}j,y_1=m) 表示，后者可以用 (x_2=\\sum_{j=1}^{k-m}a_{i_{m+j}},y_2=\\sum_{j=1}^{k-m}a_{i_{m+j}}j) 表示。因此整条路径的权值为 x_1+y_1x_2+y_2。\n对于每个结点我们都可以计算出它到分治中心的路径对应的 (x_1,y_1) 和 (x_2,y_2)。因此我们要选择两个不同子树的 (x_1,y_1) 和 (x_2,y_2) 来更新答案。\n考虑用数据结构维护 (x_2,y_2) 的集合。然后用 y_1 查询。那么这就是维护若干个一次函数，查询单点最大值的问题。可以使用李超树。可以标记永久化。\n同时我们要求是不同子树。因此对于一个子树，先查再插入即可。然后再倒着做一遍处理反向的情况。\n时间复杂度 O(n\\log_2^2n)。\n李超树的复杂度：在一个线段树区间上插入一条直线的复杂度是 O(\\log_2n) 的。但是我们每次都是在根结点的区间上插入。因此总复杂度是 O(n\\log_2^2n) 的。\n代码\nNo Monotone Triples\n对于一个序列 a，如果 \\forall 1\\le i&lt;|a|, a_i\\le a_{i+1} 或者 \\forall 1\\le i&lt;|a|, a_i\\ge a_{i+1}，那么称 a 是单调序列。\n若序列 a 不含长度大于等于 3 的单调子序列，则称 a 是 no-triple 序列。\n给出长度为 n 的序列 a。q 次询问 (L,R)，询问区间 [L,R] 的最长 no-triple 子序列。\nn\\le 2\\times 10^5,q\\le 2\\times 10^5。 手玩一下可以发现，no-triple 的长度最大为 4。\n考虑对于每个 i（1\\le i\\le n），求出最小的 j 使得 [i,j] 里有长度为 4 的 no-triple（长度为 3 的 no-triple 是类似的）。\n那么条件可以转化为，求出最小的 j 使得 [i,j] 中存在 i&lt;x,y&lt;j,x\\ne y 使得 a_x&gt;\\max(a_i,a_j)，a_y&lt;\\min(a_i,a_j)。\n首先我们找到 a_i 右边第一个比 i 大的数。记为 a_p。\n并且找到 a_i 右边第一个比 i 小的数。记为 a_q。\n那么显然，j&gt;\\max(p,q)。\n另一方面，我们维护 i 的两个非严格单调栈。设 P_i 表示 a_i 右边第一个大于等于 a_i 的位置（即 P_i = \\min \\{j\\mid a_j\\ge a_i,j\\ge i\\}）。Q_i 表示第一个小于等于。那么第一个栈中存储的就是 \\{i,P_i,P_{P_i},\\cdots,P^{\\circ k}_i \\}，第二个栈中存的就是 \\{i,Q_i,Q_{Q_i},\\cdots,Q^{\\circ k}_i \\}。\n显然 j 不能在任何一个栈中。不然就找不到比 a_j 大的（或者找不到比 a_j 小的）数了。\n上面的这两个条件，是否是 j 的充分条件？是的。\n也就是说只要满足这两个条件，就一定能在 [i,j] 中找到 x,y 满足 no-triple 的条件。\n因此我们只需要找到满足这两个条件的最小的 j 即可。\n构造方案：容易发现，一定存在方案使得 x,y 分别在两个栈中。因此在栈上二分即可。\n长度的 3 的 no-triple 是类似的。\n然后我们离线，后缀 \\min 即可。\n时间复杂度 O(n\\log_2n)。\n代码\nDreamoon Likes Strings\n你有一个字符串 s。每次你可以删除 s 的一个子串 t，满足 t 中不存在相邻相同字符。删完后两边自动拼在一起。问最少多少次可以把 s 删完。并输出方案。\n|s|\\le 2\\times 10^5。 考虑把 s 中相邻相同字符都写下来。比如abbccddacdbbb可以写出bcdbb，记为 s'。那么你删一个子串肯定是删一个极长的子串。于是可以发现，你的删除操作等价于： 在 s' 中删除开头或者末位一个字符；\n在 s' 中删除两个相邻但不同的字符；\n在 s' 中删除一个字符，且这个字符旁边存在与它相同的字符。 如果 s'=\\varnothing，那么我们就可以再删一次把 s 删光。\n那么我们肯定会先尽量使用 2 操作，多删几个字符。然后使用 1 操作。这就转化为一个经典问题：每次匹配两个不同类型的元素。问最多匹配多少个。设总数为 x，同类的最大数量为 y。则答案显然为 \\max(\\lfloor\\frac{x}{2}\\rfloor,y)。而现在的问题是我们还需要构造出方案。 如果 2y\\ge x，那么很容易构造方案。我们把其他的都往 y 上“贴”就行。\n如果 2y&lt;x。那么我们可以先随便搞。即遍历一遍，遇到相邻不同字符就双双删除。直到 2y=x 或者 2y=x-1 的时候就 break。这时就转化为了情况 1 了，于是再构造一下剩余的方案即可（当然在删除过程中，可能有别的类会变成 y）。 要注意细节的处理。\n代码\nOn the Bench\n给你一个长度为 n 的序列 a。问有多少个长度为 n 的排列 p 满足 \\forall 1\\le i&lt;n，a_{p_i}a_{p_{i+1}} 不是完全平方数。\nn\\le 300,a_i\\le 10^9。 首先注意到，若 ab 和 bc 都是完全平方数，则 ac 也是完全平方数（传递性）。\n因此问题转化为：有 n 个带标号的球，每个球有一个颜色。你要把他们排成一排且相邻的球颜色不同。求方案数。\n考虑容斥。同色不相邻 = 无限制 - 同色相邻。而同色相邻，可以理解为是把两个球捆在一起。\n考虑 DP。设 f(i,j) 表示前 i 种球，有 j 个同色相邻的方案数。答案就是 \\sum f(m,i)(-1)^i（假设一共 m 种颜色）。\n设第 i 种球有 x 个。那么我们可以枚举颜色 i 的相邻的个数，假设是 k。那么这样的方案数是 \\binom{x-1}{k}x!。然后考虑背包的合并，相当于把 x 个球插板。\n时间复杂度 O(n^2)。\n代码\nKate and imperfection\n设 S=\\{1,2,\\cdots,n\\}。\n对于 S 的子集 T，设 f(T)=\\max \\{\\gcd(x,y)\\mid x,y\\in T,x\\ne y\\}。\n对于 i（1&lt;i\\le n），求出 S 的所有大小为 i 的子集 T 中，f(T) 的最大值。\nn\\le 5\\times 10^5。 考虑 f(T)\\ne x 的条件是什么？必要条件：x,2x,\\cdots,\\lfloor\\frac{n}{x}\\rfloor x 中至多有一个数在 T 中。如果要选一个数，显然我们会贪心地保留 x，删掉 x 的倍数。\n因此如果我们想删掉尽量少的数使得 f(T)\\ne x，则 x 的倍数必须全部被删。\n因此如果要求 f(T)&lt;x，则 x,x+1,\\cdots,n 的倍数都要被删。不妨计算出 b_i 表示要让 f(T)&lt;i，至少要删掉多少个数。即，要让 f(T)&lt;i，最多存在多少个数。\n充分性：另一方面，如果存在 x 和 x 的倍数，那么 f(T) 至少是 x。\n然后就简单遍历一遍统计答案即可。\n时间复杂度 O(n\\log n)。\n代码\nRoad to 1600\n把 1,2,\\cdots,n^2 依次填入 n\\times n 的方格中。然后你需要访问每个格子恰好一次。有两种访问方式。\nRook 式： 从 1 所在方格开始；\n如果与它同行 / 同列中存在未被访问过的格子，选择一数字最小的格子走过去；\n否则，从未访问过的方格中选择一个数字最小的方格并走过去。花费 1 个代价。 Queen 式： 从 1 所在方格开始；\n如果与它同行 / 同列 / 同对角线（两个方向）中存在未被访问过的格子，选择一数字最小的格子走过去；\n否则，从未访问过的方格中选择一个数字最小的方格并走过去。花费 1 个代价。 现在要求你构造一种填数方案，使得 Rook 式的代价严格小于 Queen 式的代价。\nn\\le 500。 考虑暴搜出小方格的情况。然后其他地方你构造成 Queen 和 Rook 走一样的路线。最后引导到这个小方格即可。\n暴搜就随机一个 n^2 的排列然后 check。\n暴搜代码\n代码","title":"Codeforces 题目选讲 2","updated":"2025-04-23T04:07:19.261Z"},{"categories":[],"path":"Math/Rolling-Hash-and-Hack/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"},{"name":"Hash","slug":"Hash","permalink":"https://notes.sshwy.name/tags/Hash/"}],"text":"translate from The Mathematics Behind Rolling Hashes and Anti-hash Tests\n设计难卡的滚动哈希滚动哈希我们使用二元组 (p,a) 来描述滚动哈希。其中 p 是模数（modulo），a 是基数（base）。\n对于长度为 n 的字符串 s，它的滚动哈希函数为 h(S)=\\sum_{i=1}^{n}a^{n-i}s_i \\mod p对于等长的两个字符串 S,T，若 S\\ne T 且 h(S)=h(T)，则称这是等长冲突（equal-length collision）。\n随机基数考虑我们固定一个质数模数 p，在 [1,p) 中随机一个整数作为基数 a 来做滚动哈希。\n对于两个长度为 n 的串 S,T(S\\ne T)，考虑计算他们等长冲突的概率： \\begin{aligned}\n&h(S)=h(T) \\\\\n\\Leftrightarrow &\\sum_{i=1}^na^{n-i}S_i=\\sum_{i=1}^na^{n-i}T_i \\mod p\\\\\n\\Leftrightarrow & P(a)=\\sum_{i=1}^na^{n-i}(S_i-T_i)=0\\mod p\n\\end{aligned}在这里 P(a) 是一个关于 a 的 n-1 度的多项式。那么 h(S)=h(T) 的概率就是 P(a)=0\\pmod p 的概率，即 a 是 P 的根的概率。\n由于 p 是质数，因此这构成一个域。在域中，任何 \\le n-1 度的多项式最多有 n-1 个根。因此 \\Pr[h(S)=h(T)]=\\Pr[P(a)=0]\\le \\frac{n-1}{p}对于 n=10^5,p=10^9+7，这个概率是 10^{-4} 级别的。\n\\frac{n-1}{p} 的范围其实比较紧的。如果 (n-1)\\mid (p-1)。考虑 S=\\text{ba...aa},T=\\text{aa...ab}，则 P(a)=A^{n-1}-1\\pmod p。根据一些群论知识，这个方程有 n-1 个根。\n随机模数考虑固定基数 a(|\\Sigma|\\le a &lt;N)，然后在 [N,2N-1] 的范围内随机选择一个整数作为模数 p。\n同样地，对于两个长度为 n 的串 S,T(S\\ne T)，考虑计算他们等长冲突的概率： \\begin{aligned}\nh(S)=h(T)\n\\Leftrightarrow X=\\sum_{i=1}^na^{n-i}(S_i-T_i)=0\\mod p\n\\end{aligned}则可以通过一些数学知识得到 \\Pr[h(S)=h(T)]=\\Pr[p\\mid X]\\le \\sim\\frac{n\\ln(a)}{N}对于 n=10^5,a=26,N=10^9，这个概率是 3\\times 10^{-4} 级别的。\n如何随机以下三种可以考虑：\n//by Sshwy\n//#define DEBUGGER\n#include&lt;chrono>\n#include&lt;iostream>\nusing namespace std; int main()&#123; cout&lt;&lt;chrono::duration_cast&lt;chrono::nanoseconds>(chrono::high_resolution_clock::now().time_since_epoch()).count()&lt;&lt;endl; cout&lt;&lt;chrono::duration_cast&lt;chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count()&lt;&lt;endl; cout&lt;&lt;__builtin_ia32_rdtsc()&lt;&lt;endl; return 0;\n&#125;\n多重哈希我们可以使用多重的随机滚动哈希。如果 k 重哈希的冲突概率分别是 \\alpha_1,\\alpha_2,\\cdots,\\alpha_k，则你哈希碰撞的概率就是 \\prod_{i=1}^k \\alpha_i。\n更大的模数你哈希的模数越大，冲突的概率就越小。但是更大的模数在计算过程中会很吃力。使用__int128会降低计算速度。不过有一个质数例外，那就是梅森质数 p=2^{61}-1，我们可以通过位运算来计算 a\\times b\\mod p：\nconstexpr uint64_t mod = (1ull&lt;&lt;61) - 1;\nuint64_t mul(uint64_t a, uint64_t b)&#123; uint64_t l1 = (uint32_t)a, h1 = a>>32, l2 = (uint32_t)b, h2 = b>>32; uint64_t l = l1*l2, m = l1*h2 + l2*h1, h = h1*h2; uint64_t ret = (l&amp;mod) + (l>>61) + (h &lt;&lt; 3) + (m >> 29) + (m &lt;&lt; 35 >> 3) + 1; ret = (ret &amp; mod) + (ret>>61); ret = (ret &amp; mod) + (ret>>61); return ret-1;\n&#125;\n卡哈希接下来就是关于如何卡哈希的教程了。\n如何卡哈希在介绍具体的方法之前，先思考一下，面对一道哈希问题，如果去卡它？\n本质上，分为两个步骤： 对于该哈希方式找一个等长冲突；\n利用这个等长冲突来造数据卡他。 单哈希Thue–Morse 序列攻击：ULL 自然溢出考虑 p=2^{64}，a 任意的情况。我们可以使用 Thue–Morse 序列来卡。它的生成方式如下：\nconst int Q = 10;\nconst int N = 1 &lt;&lt; Q;\nstd::string S(N, ' '), T(N, ' '); for (int i = 0; i &lt; N; i++) S[i] = 'A' + __builtin_popcount(i) % 2;\nfor (int i = 0; i &lt; N; i++) T[i] = 'B' - __builtin_popcount(i) % 2;\n这时 S,T 就发生了等长冲突（不论 a 的值）。具体参见 这篇文章。\n生日攻击：32 位模数，固定模数和基数考虑使用生日攻击。固定长度 l，令 k=1+\\sqrt{(2\\ln 2)p}。并且等概率随机（uniformly at random）生成 k 个长度为 l 的字符串。\n如果 l 的值不是特别小，则这 k 个串的哈希值可以近似看作等概率随机分布，使用生日悖论，则这 k 个数全部两两不同的概率是 \\prod_{i=0}^{k-1}\\left(1-\\frac{i}{p} \\right)&lt;\\prod_{i=0}^{k-1}e^{-\\frac{i}{p}}&lt;e^{-\\ln 2}=\\frac{1}{2}因此我们重复这个过程，可以在 O(\\sqrt{p}) 的时间内找到等长冲突。\n生日攻击不依赖于哈希函数（异或哈希也可以）。但它不能卡回文串。\n代码\n树攻击：更大模数，固定模数和基数对于更大的模数，生日攻击将会变得很慢。\n考虑树攻击（tree-attack）。\n对于两个长度为 n 的的字符串 S,T，我们知道 h(S)=h(T)\\Leftrightarrow \\sum_{i=1}^n(a^{n-i}\\bmod p)(S_i-T_i)=0\\mod p不妨设 A_i=S_i-T_i。显然 -|\\Sigma|\\le A_i\\le |\\Sigma|。树攻击会尝试寻找一个 A_i\\in\\{-1,0,1\\} 的序列使得 \\sum_{i=1}^n(a^{n-i}\\bmod p)A_i=0考虑维护 k 个集合 C_1,\\cdots,C_k。定义 S(C)=\\sum_{i\\in C}(a^{n-i}\\bmod p)A_i。\n如果我们合并两个集合 C_1,C_2 为 C_3，则我们可以： 直接合并，则 S(C_3)=S(C_2)+S(C_1)；\n把 \\forall i\\in C_1,A_i 都乘 -1 再合并，则 S(C_3)=S(C_2)-S(C_1)；\n类似 2，可以令 S(C_3)=S(C_1)-S(C_2)；\n把 \\forall i\\in C_1,A_i 都变成 0，则 S(C_3)=S(C_2)；\n类似 4，可以令 S(C_3)=S(C_1)。 一开始我们有 n 个集合，设每个集合的 A_i 都是 1。不妨设 n=2^k。则我们每个阶段，都把集合按 S(C) 排序，然后使用 2 或者 3 方法来合并相邻两个集合（要保证合并完后 S(C) 非负）。一轮完成后，集合数量减半。如果出现了一个 S(C)=0 的集合，那么我们把其他集合的 A_i 都置为 0 即可。这样会最多做 k 轮。如果没有找到，那么就对更大的 k 继续这个过程。\n如果一开始 n 个集合的 S(C) 是等概率随机分布于 [0,p-1]，则 k 期望为 \\sqrt{2\\lg p}+1 时可以找到。那么我们就可以 \\Theta(n) 地构造长度为 n=2^{\\sqrt{2\\lg p}+1} 的等长冲突的串了。\n注意，树攻击是依赖于哈希函数的，即你的哈希函数必须是多项式函数。\n卡回文串树攻击可以卡回文串。以偶回文串为例，具体地说，我们要构造一个长度为偶数的串 S，使得 S\\ne S^R,h(S)=h(S^R)。S^R 表示反串。\n那么这等价于 \\begin{aligned}\n&h(S)=h(S^R)\\\\\n\\Leftrightarrow& \\sum_{i=1}^n(a^{n-i}\\bmod p)(S_i-S_{n+1-i})=0\\mod p\\\\\n\\Leftrightarrow& \\sum_{i=1}^{\\frac{n}{2}}((a^{n-i}-a^{i-1})\\bmod p)(S_i-S_{n+1-i})=0\n\\end{aligned}因此我们设 A_i=S_i-S_{n+1-i}，得到 \\sum_{i=1}^{\\frac{n}{2}}((a^{n-i}-a^{i-1})\\bmod p)A_i=0那么我们对这个做一次正常的树攻击，就可以构造出一组 S_i-S_{n+1-i} 的值。\n那么用字符 \\text{a} 和 \\text{b} 来构造串 S 即可。\n代码\n多重树攻击尽管树攻击速度很快，生成的字符串可能会过长（对于 p=2^{61}-1，通常 n=2048）。实际上我们可以花更多的计算时间来生成一个尽量短的等长冲突。对于每个集合，我们可以维护 m 个最小的可能的和（单树攻击是 m=1 的情况）。合并两个集合可以使用堆在 O(m\\log_2m) 的时间内完成。\n一通鬼畜分析后，我们得到 k=\\sqrt{2\\frac{\\lg p}{\\lg m}}+\\log_2(m)。\n这个东西 Dls 也没写过，所以不知道好不好使。\n多重哈希卡多重哈希的方式有两种。\n逐个击破以双哈希为例，考虑 (a_1,p_1),(a_2,p_2) 双哈希。首先我们使用生日攻击或者树攻击找到 (a_1,p_1) 的一个等长冲突 S,T。然后我们以 \\{S,T\\} 作为字符集对 (a_2^{|S|},p_2) 求出等长冲突（以 \\{S,T\\} 作为字符集的意思是，我们用 S 和 T 拼接出一个更大的串）。这样就可以把两个哈希都冲突掉。\n使用这个方法，时间复杂度是每次攻击的复杂度之和。但生成的串长会随着哈希的重数而指数级增长。\n不过这个方法不用考虑模数的大小。\n中国剩余定理（CRT）对于树攻击，我们可以使用中国剩余定理来卡哈希。本质上，我们要求 \\begin{cases}\n\\sum_{i=1}^n({a_1}^{n-i}\\bmod {p_1})A_i=0\\\\\n\\sum_{i=1}^n({a_2}^{n-i}\\bmod {p_2})A_i=0\n\\end{cases}设 x_i=a_1^{n-i},y_i=a_2^{n-i}。然后我们使用 CRT 求出一个 z_i(0\\le z_i &lt;[p_1,p_2])，使得 \\begin{cases}\nz_i=x_i \\mod p_1\\\\\nz_i=y_i \\mod p_2\n\\end{cases}那么我们就只需要 \\sum_{i=1}^n(z_i\\bmod [p_1,p_2])A_i=0即可。 那么我们对此做一次树攻击即可。\n这个方法的要求模数的 LCM 不能太大。不过它的优点是，双哈希的回文串它也能卡。","title":"滚动哈希和卡哈希的数学原理","updated":"2025-04-23T04:07:19.271Z"},{"categories":[],"path":"Probset/NOIo-day1/","tags":[{"name":"Complete-Solution","slug":"Complete-Solution","permalink":"https://notes.sshwy.name/tags/Complete-Solution/"}],"text":"A 序列\n给出长度为 n 的序列 a 和 b，有 m 个操作方式，表示为三元组形如 (t_i,u_i,v_i)： 若 t_i=1，则可以使 a_{u_i} 和 a_{v_i} 同时加 1 或减 1（如果 u_i=v_i，相当于把 a_{u_i} 加 2 或减 2）；\n若 t_i=2，则可以使 a_{u_i} 和 a_{v_i} 一个加 1，一个减 1。 你可以使用每种方法无数次。问能否把 a 变成 b（yes or no）。\nn,m\\le 10^5,a_i,b_i\\le 10^9,t_i\\in\\{1,2\\},1\\le u_i,v_i\\le n。 摘要：挖掘性质，缩点，判二分图。\n设点权 c_i=b_i-a_i，则我们的目标变成：让每个点点权变成 0。\n操作 2 可以改变点权，但点权和不变。\n把操作当作连边。我们考虑操作 2 的边构成的连通块。那么我们在这个连通块上进行操作的时候，点权和是始终不变的。\n因此我们把操作 2 的连通块缩点。剩下的就只有操作 1 的边。\n由于两个操作 1 可以构成一个操作 2，因此对于新的图上，考虑操作 1 的边构成的连通块： 如果是一个二分图，那么左部（右部）在点权和不变的情况下可以任意变换点权。因此要让左部和右部的点权都变成 0，等价于，左部和右部的点权和变成 0。由于操作 1 只能同加同减，因此等价于，坐标和右部点权和相等。\n如果不是二分图，那么我们可以把这个连通块点权和加 2 或者减 2。因此要把点权都变成 0，等价于把点权和变成 0，等价于，点权是 2 的倍数。 综上，缩点后 DFS 即可。时间复杂度 O(n\\log_2n) 或者 O(n\\alpha(n))。\n代码\nB 冒泡排序\n对 p 进行一次冒泡排序的伪代码为 \\begin{array}{r|l}\n\\hline\n1 & \\textbf{for }i=1\\textbf{ to }n-1\\\\\n2 & \\qquad \\textbf{if }p_i&gt;p_{i+1}\\\\\n3 & \\qquad \\qquad \\text{swap}(p_i,p_{i+1}) \\\\\n\\hline\n\\end{array}给出一个排列 p，有 m 次操作： 交换 p_x 和 p_{x+1}；\n询问当前排列经过 k 次冒泡排序后的逆序对数。 n,m\\le 10^5,1\\le x&lt;n,0\\le k&lt;2^{31}。 摘要：挖掘性质，树状数组。\n首先要发现冒泡排序的性质。\n我们称二元组 (x,y) 满足 x&lt;y,p_x&gt;p_y 是关于 y 的逆序对，记其集合为 S_y。\n性质 1：进行一次冒泡排序，则 \\forall y，与 y 有关的逆序对数最多减少 1 个。\n性质 2：进行一次冒泡排序，若存在 x(x&lt;y) 使得 p_x&gt;p_y，与 y 有关的逆序对数一定减少 1 个。\n推论：进行 k 次冒泡排序，对于任意 y\\in[1,n]，关于 y 的逆序对会减少 \\min(|S_y|,k) 个。\n因此我们维护 b_y=|S_y|。则一次交换操作最多影响两个数的 b_y。对于询问 k，我们要求的就是 \\sum_{i=1}^n\\min(b_i,k)使用几个树状数组维护即可。\n时间复杂度 O((n+m)\\log_2n)。\n代码\nC 最小环\n给定⻓度为 n 的序列 a_i，我们将该序列视为⼀个⾸尾相邻的环，更具体地，对于下标为 i,j(i \\le j) 的两个数 a_i,a_j，它们的距离为 \\min(j-i,i+n-j)。\n现在再给定 m 个整数 k_1,k_2,\\cdots,k_m，对每个 k_i，你需要将上⾯的序列 a_i 重新排列，使得环上任意两个距离为 k_i 的数字的乘积之和最⼤（二元环的乘积之和要算成 a_1a_2+a_2a_1=2a_1a_2）。求出最大的乘积之和。\nn,m\\le 2\\times 10^5,1\\le a_i\\le 10^5,k\\le \\frac{n}{2}。 摘要：结论题。\n考虑四个数 a,b,c,d，交换 b,c，则代价的变化是 ac+bc+bd-(ab+bc+cd)=(a-d)(c-b)。\n因此我们得到，当 [a\\ge d]=[b\\ge c] 时 ab+bc+cd 是最优的。\n于是我们的最优方案一定满足，对于环上任意四个相邻的数 a,b,c,d，[a\\ge d]=[b\\ge c]。\n考虑 k=1 的情况。全排列打表发现： 对于长度为 2x 的序列 c，且满足 c_i\\le c_{i+1}，则最优方案（环）是 c_2,c_4,\\cdots,c_{2x},c_{2x-1},c_{2x-3},\\cdots,c_5,c_3,c_1。\n对于长度为 2x+1 的序列且 c_i\\le c_{i+1}，最优方案是 c_2,c_4,\\cdots,c_{2x},c_{2x+1},c_{2x-1},\\cdots,c_5,c_3,c_1。 另一方面，对于一次询问，我们把距离为 k 的点连边（这是真的环），则会构成 \\gcd(n,k) 个真环，环长 L=\\frac{n}{\\gcd(n,k)}。易证（可以通过交换证明，或者打表发现），用 a[1,L] 序列构造第一个真环，a[L+1,2L] 构造第二个真环，a[(x-1)L+1,xL] 构造第 x 个真环，这样的总和的最大的。真环的构造方法就是 k=1 的情况。\n那么对于 n 的每个约数 d 计算 \\gcd(n,k)=d 时的答案即可。\n时间复杂度 O(n\\sqrt{n}+m\\log_2n)。\n代码","title":"NOI Online 提高组 Day1","updated":"2025-04-23T04:07:19.274Z"},{"categories":[],"path":"Codeforces/part-1/","tags":[],"text":"本文主要讲解一些近期遇到的一些有启发意义的 Codeforces 题目。不定时更新。\nAnu Has a Function\n定义 f(x,y)=(x\\operatorname{bitor}y)-y。\n给你一个长度为 n 的序列 A，你可以随意安排顺序，最小化 F(A)=f(f(\\cdots f(f(A_1,A_2),A_3)\\cdots)A_n)n\\le 10^5,A_i\\le 10^9。 摘要：理解位运算。\n容易发现 f(x,y)=x\\operatorname{bitand}(\\operatorname{not}y)。相当于在 x 中把属于 y 的部分挖掉。\n因此 F(A) 的值只和 A_1 的值有关。\n把复杂度做到 O(n\\log_2n) 即可。\n代码\nAerodynamic\n给你一个凸多边形 A。\n定义凸多边形函数 P(A)： 随便固定一个点 (x_0,y_0)。\n在保证 (x_0,y_0)\\in A（即在 A 的边界或内部）的情况下 A 随便平移，尽可能经过多的点（覆盖多的面积）。所经过的点的集合构成多边形 P(A)。 问 A 与 P(A) 是否相似。\nn\\le 10^5。 摘要：大力猜结论。\n如果 A 是正三角形的话，P(A) 就是正六边形。\n容易发现，当 n 是奇数时 P(A) 有 2n 条边，与 A 不相似。\n为了不产生多余的边，就要求 A 的对边平行且相等（第 i 条边和第 i+\\frac{n}{2} 条边平行且相等）。感性理解不难。\n大力猜想这是重要条件。\n复杂度 O(n)。\n代码\nWater Balance\n给你一个长度为 n 的序列 A。每次你可以把 A[l,r] 的元素都变成 \\frac{1}{r-l+1}\\sum_{i=l}^r A_i（变成平均数）。\n问能操作出的字典序最小的 A 序列是啥。\nn\\le 10^6,a_i\\le 10^6。 摘要：贪心，复杂度均摊。\n由于是字典序最小，因此我们从前往后依次考虑。\n如果 A_i\\le A_{i+1} 就不管。\n如果 A_i&gt;A_{i+1}，显然我们一定会以 A_i 为左端点做一次操作。但是这次操作的区间有多长？我们可以一直向右延伸，如果平均值变小就延伸，如果变大就停止延伸，然后把这段区间给操作一次。\n操作完之后，我们还可以找到 A_{i-1}，如果 A_{i-1}&gt;A_i，就把左端点往左延伸一点然后进行一次操作。毕竟我们要求字典序最小。直到不存在 A_{i-1}&gt;A_i 的情况位置。\n然后我们跳过这一段区间做后面的事。\n但事实上这么做了一轮之后不一定字典序就最小了。还可以做第二轮第三轮。\n可以使用链表缩点优化。\n稍作感知，认为做的次数不会很多。\n代码\nAnimal Observation\n题面较长。但样例的图十分可读。 摘要：DP 优化。\n设 f(i,j) 表示前 i 行，其中第 i 行选择从第 j 列开始的矩形（占据 i,i+1 两行）的最大值。\nf(i) 从 f(i-1) 转移。\nf(i,j) 从 f(i-1,k) 转移。根据 |j-k| 的关系可以分类讨论。\n容易发现，使用前缀 \\max，后缀 \\max 和单调队列就可以分别优化了。\n时间复杂度 O(nm)。\n代码\nCow and Fields\n给你一个 n 个点 m 条边的无向简单图。有 k 个关键点。要求你必须在 k 个关键点中选择两个点连一条边。\n最大化 1 到 n 的最短路。\nn\\le 2\\times 10^5,n-1\\le m\\le 2\\times 10^5,2\\le k\\le n。 摘要：转化为数学模型。\n设 p_u 表示 1 到 u 的最短路，q_u 表示 u 到 n 的最短路。\n对于两个关键点 x,y，如果加入并强制走 (x,y) 这条边，则最短路是 \\min(p_x+q_y,p_y+q_x)。\n因此我们要求的是 \\max_{x,y}\\min(p_x+q_y,p_y+q_x)不妨设 p_x+q_y\\le p_y+q_x，即 p_x-q_x\\le p_y-q_y，则我们要求的是 \\max_{p_x-q_x\\le p_y-q_y}\\{p_x+q_y\\}可以前缀后缀 \\max 在 O(k\\log_2k) 的时间统计出来（算上了排序的时间）\n然后再和 p_n 比较一下即可。\n时间复杂度 O(n+k\\log_2k)。\n代码\nCow and Treats\n题面较长 摘要：观察，分析，发现左边和右边不能相交。于是枚举分割位置然后计算。\n观察发现： 同一种颜色（sweetness）最多选 2 头牛（分别从左右两个方向出发）。\n左边走的最远的牛和右边走的最远的牛不能碰面。\n一但安排好了两个集合，只要满足上面两个条件，那么一定可以按要求使得所有牛都睡觉。 于是我们枚举左边的牛走的最远的走到哪里。然后对每个颜色统计放的最多的方案数并更新答案即可。\n代码\nCow and Vacation\n给一个 n 个点的树，有 r 个休息点（关键点）。你在不休息的情况下最多连续走 k 条边。你走到一个休息点后就可以休息好，继续走最多 k 条边。q 次询问，能否从 a_i 走到 b_i。 摘要：两边 BFS，并查集。\n一开始想了一个虚树 + 并查集 + 点分治的思路，难想又难写。所以就不讲了。\n基本的思路是：我们把距离休息点 \\frac{k}{2} 以内的点和休息点 merge。那么如果两个休息点距离小于等于 k，他们就会 merge 到一起。询问的时候先判距离以及是否在同一个集合。否则就相向而行各走 \\frac{k}{2} 步。如果走到这里了都不能走到一个集合里，说明不行（注意，我们是把距离休息点 \\frac{k}{2} 以内的点和休息点 merge 过的，因此如果走 \\frac{k}{2} 步后不能走到一个休息点上，就说明不行）。\nmerge 就用并查集做。我们事先把每条边中间加一个二度点（距离乘 2），这样就不用考虑 k 的奇偶性了。然后走 k 步的时候相当于倍增跳祖先。\n时间复杂度 O((n+q)\\log n)。\n代码\nReachable Strings\n对于一个 01 串你可以进行以下两种操作： 选择一个110并将其替换为011；\n选择一个011并将其替换为110； 给你一个串 S，有 q 次询问 (l_1,l_2,len)，问你 S[l_1,l_1+len-1] 能否通过若干次操作变成 S[l_2,l_2+len-1]。\nn\\le 2\\times 10^5。 摘要：根据一段 1 个数的奇偶性给 0 分段。然后做字符串匹配（哈希或者 SA）。\n上面的操作可以理解为是，一段偶数个 1 可以随意穿梭在 0 之中。因此我们把连续的偶数个 1 可以直接删掉。那么就剩下了一个 01 串使得每一段连续的 1 只有一个 1。\n那么我们把每段 0 的个数写成一个序列，这就等价于问你两个序列是否相等。\n可以使用 SA 或者哈希计算。\n时间复杂度 O(n\\log_2n) 或 O(n)。\n考场上抽风，写了一个线段树 + 哈希，最后还没交上去，不知道在想啥。\n代码 仅供对拍，不建议学习。\nTreeland and Viruses\n题面较长。 摘要：建虚树，跑多源最短路。\n注意，最短路以到达时间（不是路程）为第一关键字，病毒编号为第二关键字。\n代码\nKuroni and the Score Distribution\n给出 n,m。构造长度为 n 的序列 a 满足： 1\\le a_1&lt;a_2&lt;\\cdots&lt;a_n\\le 10^9。\n(\\sum_{i=1}^n\\sum_{j=i+1}^n\\sum_{k=j+1}^n [a_i+a_j=a_k]) = m。 n\\le 5000,m\\le 10^9。 摘要：构造。\n当时做这题时，读错题了，以为是求构造的方案数。把我自闭了半小时。\n首先思考，如何构造使得最大化 \\sum_{i=1}^n\\sum_{j=i+1}^n\\sum_{k=j+1}^n [a_i+a_j=a_k]？构造 \\{1,2,\\cdots,n\\} 即可。\n因此我们依次构造，让 a_i+a_j=a_k 的数量接近 m。然后把下一个数字稍微改一下使得刚好凑出 m。然后我们要求剩下的数字不能有任何 a_i+a_j=a_k 的情况出现。那么构造 a_i=10^9-5000n+5000i 即可。乘 5000 的原因是避免与前面构造的产生 a_i+a_j=a_k。\n无解的情况稍微判一下。\n代码\nKuroni and the Punishment\n给出长度为 n 的序列 a，要求你构造长度为 n 的正整数序列 b 使得 \\gcd_{i=1}^n\\{b_i\\} &gt;1，且最小化 C=\\sum_{i=1}^n |a_i-b_i|。\n求出这个最小化的 C。\n1\\le a_i\\le 10^{12},n\\le 2\\times 10^5。 摘要：乱搞。\n如果确定了 g=\\gcd_{i=1}^n\\{b_i\\}，那么我们可以 O(n) 求出最小的 C。\n令 g=2，易得 C\\le n。因此若 g&gt;2，g 一定是某个 a_i 的约数。同时易证，存在 g 是质数（质因子）的最优解。\n好接下来开始乱搞。我们的大致思路是随机几个质数 g 出来更新答案。但是不能乱随。\n由于 C\\le n，因此我们就随机几个 a_i，把 a_i-1,a_i,a_i+1 的质因子都拿出来更新答案。\n可以证明，错误的概率是指数级减小的（2^{-k}）。\n要去重后再更新。\n代码\nKuroni and Antihype\n有 n 个数 a_i 和一个集合 S。你可以进行两种操作： 把 x （1\\le x\\le n）加入 S，没有奖励；\n选择 S 中的一个数 x 和不在 S 中的一个数 y，且 a_x\\operatorname{and}a_y=0，把 y 加入 S，奖励为 a_x。 要求你把 \\{1,2,\\cdots,n\\} 都加入到 S 中，求出最大化的奖励的和。\n1\\le n\\le 2\\times 10^5,0\\le a_i\\le 2\\times 10^5。 设 a_0=0，一开始 S 中有 0。那么所有的 1 操作可以转化为 x=0 的 2 操作。\n容易发现，所有的 2 操作构成一个以 0 为根的有根树。\n设树上结点的度为 d_i。那么我们的奖励显然为 \\sum_{i=0}^n(d_i-1)a_i。\n注意到 \\sum_{i=0}^n(d_i-1)a_i=\\sum_{i=0}^nd_ia_i-\\sum_{i=0}^na_i。\n考虑最大化 \\sum_{i=0}^nd_ia_i。这等价于加权无向图 \\begin{aligned}\nG &= (V,E)\\\\\nV &=\\{0,1,\\cdots,n\\}\\\\\nE &=\\{(i,j) | 0\\le i&lt;j\\le n,a_i\\operatorname{bitand}a_j=0 \\}\\\\\nw(i,j) &=a_i+a_j\n\\end{aligned}中的最大生成树的边权和（注意，这和上文中的有根树没有任何关系，因为我们已经把问题转化为最大化 \\sum_{i=0}^nd_ia_i 了）。\n考虑使用 Boruvka 算法 求最大生成树。\n那么我们的问题转化为，如何求与 i 相邻的权值最大的边 (i,j) 且 i,j 不在同一连通块。可以使用子集前缀和解决，记 c_x 表示满足 y_1\\operatorname{and}x=y_1 且 a_{y_1} 最大的 y_1，d_x 表示次大的，记作 y_2，且 y_1,y_2 不在同一连通块。这个可以 FMT 求出。然后我们就可以 O(1) 求出与 i 相邻的权值最大的边 (i,j) 了。\n时间复杂度 O(W\\log_2W\\log n)，其中 W=2^{18}，表示值域。\n代码","title":"Codeforces 题目选讲 1","updated":"2025-04-23T04:07:19.261Z"},{"categories":[],"path":"String/String-Basics/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"本文将讲述关于字符串的基本概念以及延伸的推论。\n注：如无特殊说明，通常情况下 [l,r] 表示整数区间（即 \\{l,l+1,\\cdots,r\\}）而不是实数区间。类似地，[l,r)=\\{l,l+1,\\cdots,r-1\\}。\n基本定义与符号表示字符串：字符串通常使用单个字母表示，如 S，s，t。\n长度：字符串 S 的长度（Length）表示为 |S|。\n字符：字符串 S 从左到右第 i 个字符记为 S[i]。如果没有特殊说明，通常是 1 作为起始下标。\n子串：S 中第 l 个字符到第 r 个字符构成的串称作 S 的子串（Substring），记作 S[l,r]。其中 1\\le l,r\\le |S|。\n前缀：如果 l=1，那么这个子串也被称作 S 的前缀（Prefix）。\n后缀：如果 r=|S|，那么这个子串也被称为 S 的后缀（Suffix）。\n周期与 BorderBorder：若对于 x(1\\le x&lt; |S|) 满足 S[1,x]=S[|S|-x+1,|S|]，那么称 S[1,x] 是 S 的Border（也称 x 是 S 的 Border）。\n周期：若对于 x(1\\le x\\le |S|)，使得 \\forall i\\in[1,|S|-x],S[i]=S[i+x]，那么称 S[1,x] 是 S 的周期（Period），也称 x 是 S 的周期。\n记 S 的最小周期为 \\text{per}(S)。 每个周期（除了 x=|S| 的周期）都对应了一个 Border。具体地，周期 x 对应了 Border|S|-x。\n求所有 Border：KMP 算法不停跳 Fail 指针即可。\n周期引理弱周期引理（Weak Periodicity Lemma）：若 p,q 都是 S 的周期且 p+q\\le |S|，则 \\gcd(p,q) 也是 S 的周期。\n证明：不妨设 p&lt;q。设 d=q-p。\\forall i\\in[1,|S|-d]，发现 i+q\\le |S| 和 i-p\\ge 1 一定满足其中一个。因此可以退出 S[i]=S[i+d]。即 d 是 S 的周期。那么辗转相减即可证明。\n周期引理（Periodicity Lemma）：若 p,q 都是 S 的周期且 p+q-\\gcd(p,q)\\le |S|，则 \\gcd(p,q) 也是 S 的周期。\n字符串匹配引理 1（等差数列引理）：字符串 S,T 满足 2|S|\\ge |T|，则 S 在 T 中的所有匹配位置构成一个等差数列。\n证明： 考虑其中的 3 次匹配：第 1 次，第 2 次和最后一次。设它们的间距分别是 d,q。\n根据周期的定义得，d,q 都是 S 的周期。\n由于 2|S|\\ge |T|，因此 d+q\\le |S|。因此根据周期引理，\\gcd(d,q) 也是 |S| 的周期。\n因此不难证明，（设第一次匹配的位置是 x_0）x_0,x_0+\\gcd(d,q),\\cdots,x_0+d+q 都是匹配位置。即构成一个公差为 \\gcd(d,q) 的等差数列。更严格地说，是构成一个公差为 d 的等差数列。\n引理 2（公差引理）：字符串 S,T 满足 2|S|\\ge |T|，则 S 在 T 中的所有匹配位置构成一个等差数列。若等差数列至少有 3 项，则其公差 d 等于 S 的最小周期\\text{per}(S)。此时易知 2d\\le |S|。\n仅含两项时不一定成立，如 S=\\text{aabaa},T=\\text{aabaaabaa}。\nBorder 的结构引理（等差数列引理）：字符串 S 的所有长度不小于 \\frac{|S|}{2} 的 Border 的长度构成等差数列。\n证明： 我们知道每个周期都对应一个 Border。而长度不小于 \\frac{|S|}{2} 的 Border 对应的周期满足周期引理。因此周期是等差数列，则得证。\n上述引理刻画了长度不小于 \\frac{|S|}{2} 的 Border 的结构。那么对于长度更小的 Border 呢？\n我们将 S 的所有 Border 按长度 x 分类，有两种情况： x\\in[2^{i-1},2^i)，其中 2^i-1&lt;|S|；\nx\\in[2^k,|S|)，其中 2^k\\ge \\frac{|S|}{2}。 对于第二种情况，我们使用上述引理即可。那么考虑第一种情况： 容易证明，如果存在 Border 的长度在 [2^{i-1},2^i)，那么对于 S[1,2^i] 使用上述引理即可证明，[2^{i-1},2^i) 中的 Border 也构成等差数列。\n推论：字符串 S 的所有 Border 按长度排序后可以分成 O(\\log_2|S|) 段，使得每一段都是等差数列。\n子串 Border 查询\n给出长度为 n 的字符串 S，q 次询问形如 (l,r)，求 S[l,r] 的子串的所有 Border（等价于周期），用 O(\\log_2n) 个等差数列的形式表示。 对于询问 S[l,r]，设 t=S[l,r],m=|t|。仍然按照 Border 长度分成两类： x\\in[2^{i-1},2^i)，其中 2^i-1&lt;m。\nx\\in[2^i,m)，其中 2^{i}\\ge \\frac{m}{2}。 Case 1x\\in[2^{i-1},2^i)，其中 2^i-1&lt;m。 如图的 x 是一个满足要求的 Border。那么容易发现 t[1,2^{i-1}] 是 x 的前缀，而 t[m-2^{i-1}+1,m] 是 x 的后缀。\n因此，不妨求出 t[1,2^{i-1}] 在 t[m-2^i+1,m] 中匹配的位置的集合 A，以及 t[m-2^{i-1}+1,m] 在 t[1,2^i] 中匹配的位置的集合 B。把 A 做一下翻转和移位之后与 B 取交集就是我们要求的了（事实上也是等差数列的交）。\n因此我们的问题转化为： 询问子串 S[a,a+2^{j-1}-1] 在 S[b,b+2^j-1] 中匹配的位置集合（等差数列形式）。 显然我们只需要求出它匹配的第一次，第二次和最后一次即可。换言之问题转化为 询问子串 S[a,a+2^{j-1}-1] 在位置 x 后匹配的第一个位置 / 在 x 前匹配的最后一个位置。 用 R(a,j) 表示子串 S[a,a+2^{j}-1]，即长度为 2 的幂的子串。这类子串的个数是 O(n\\log_2n) 的。因此我们求出它们的字典序排名，把排名相同的放一起按照出现位置排序。然后询问的时候在这个序列上二分即可。排序的过程和后缀数组构建的过程类似。\n而且由于长度不同的子串排名一定不同，因此我们可以构建 O(\\log_2n) 个序列（相当于是把后缀数组的构建过程记录下来）来处理询问。\n那么求出了 A 和 B，如何求 A 和 B 的交集？也就是求两个等差数列的交集。\n如果公差相等那么容易 O(1) 求交集。\n引理：四个字符串 x_1,x_2,y_1,y_2 满足 |x_1|=|y_1|\\ge |x_2|=|y_2|，且 x_1 在 y_2y_1 中匹配至少 3 次，y_1 在 x_1x_2 中匹配至少 3 次，则 \\text{per}(x_1)=\\text{per}(y_1)，即最小周期相等。 反证：不妨设 \\text{per}(x_1)&gt;\\text{per}(y_1)。\n设 x_1 的最后一次匹配与 y_1 的交是 z。则 \\text{per}(z)=\\text{per}(x_1)。\n由字符串匹配的公差引理，|z|\\ge 2\\text{per}(z)&gt;\\text{per}(x_1)+\\text{per}(y_1)。\n因此 \\gcd(\\text{per}(x_1),\\text{per}(y_1)) 也是 z 的周期。但 \\gcd(\\text{per}(x_1),\\text{per}(y_1))&lt;\\text{per}(z)，矛盾。\n因此我们证明了 A 和 B 如果是两个等差数列且长度超过 3，那么公差一定相等。因此求交集的复杂度是 O(1) 的。\n综上，我们可以在 O(\\log_2n) 的时间内处理 x\\in[2^{i-1},2^i) 的情况。\nCase 2x\\in[2^i,n)，其中 2^{i}\\ge \\frac{m}{2}。\n即求长度不小于 2^i 的 Border 集合。与 Case 1 做法相同。\n综上，该算法空间复杂度 O(n\\log_2n)，时间复杂度 O(n\\log_2n+q\\log_2^2n)。\n习题：2015-2016 Petrozavodsk Winter Training Camp, Moscow SU Trinity Contest : D Deep Purple 代码\n参考文献字符串算法选讲，金策，清华大学交叉信息研究院，February 3, 2017","title":"字符串导论","updated":"2025-04-23T04:07:19.276Z"},{"categories":[],"path":"Gao/part-2/","tags":[],"text":"AHOI2013 作业\n给你长度为 n 的序列 A，有 m 个询问 (l,r,a,b)，求 \\sum_{i\\in[l,r]}[a\\le A_i\\le b]。即求元素个数。\n|\\{A_i|i\\in[l,r],a\\le A_i\\le b\\}|。即求数值个数。 n,m\\le 10^5。 摘要：莫队，离散化，树状数组。\n代码\nSDOI2016 模式字符串\n给你一棵 n 个点的树，每个点上有一个字符。给你一个串 |S|。\n求有多少个有序点对 (u,v)，使得 u 到 v 的路径组成的字符串以 S 为循环节。\nn,|S|\\le 10^5。 摘要：点分治，哈希。\n考虑点分治，那么我们考虑有多少经过当前重心的合法路径。\n以当前重心为根，设 f(i) 表示 i 子树内以 i 结束的 S 的循环串路径个数（向上的路径），g(i) 表示子树内以 i 开始的 S 的循环串路径个数（向下的路径）。然后我们求出 i 到根路径的字符串的哈希值以及其反串的哈希值，在哈希表里查一下匹配之类的就可以计算出经过当前重心的方案数了。\n细节写炸，弃坑了……\n时间复杂度 O(n\\log_2n)。\nZJOI2007 捉迷藏\n给你一棵树 n 个点的树，支持 m 个询问： 改变一个点的颜色（黑白）\n求黑点构成的虚树的直径 n\\le 10^5,m\\le 5\\times 10^5。 摘要：点分树，堆。\n点分树上，每个点维护两个堆 A_u,B_u，A_u 是到点分树上父亲的距离集合，B_u 是点分树上儿子的 A_u 的堆顶集合。这样的话每个点的答案就可以用 B_u 的最大值和次大值求出。\n对答案开一个堆。然后修改的时候在路径上删除再加入即可。\n堆要支持删除。\n时间复杂度 O(n\\log_2^2n+m\\log_2n)（可以先预处理距离免得倍增）。\n代码\nZJOI2015 幻想乡战略游戏\n给一棵 n 阶的点边带权的树 T，初始时点权 d_u 为 0。有 q 次操作，每次修改某个点的点权，要求在每次操作后询问 \\min_{u\\in T}\\left\\{ \\sum_{v\\in T}\\text{dist}(u,v)d_v \\right\\}其中 d_v 是点权，\\text{dist} 表示两点的距离（路径长度）。\n特殊性质：每个点度数不超过 D。\nn\\le 10^5,D=20。 摘要：点分树上递归查询。把舍弃的部分缩点，也就是做一个点权修改的操作。查完了撤消修改。\n从特殊条件入手。既然它限定每个点的度数，说明可以枚举儿子。\n从某个点 u 开始，我们尝试找到最小化答案的点 ans。容易发现，这个寻找的过程类似带权重心。每次我们选择相邻连通块中权值和大于总和一半的连通块并前进。如果没有权值和大于总和一半的连通块，说明当前点就是 ans。\n考虑在点分树上做类似的过程。那么就要求我们支持： 快速查询某个连通块的权值和\n快速统计其他连通块的答案贡献和。 这个可以直接用变量维护。\n当你选择了一个连通块后，其他连通块的权值和也得考虑进来。即，我们把其他连通块缩点，然后连接到这个连通块上。所谓的缩点，实际上就是把其他连通块的权值和加到这个连通块的（与当前重心相邻的）某个叶子结点上。这样就是一个递归子问题，可以继续做了。查询完了撤消修改即可。\n因此我们发现，查询也依赖修改。\n而修改也是容易做的，点分树上暴力跳父亲即可。\n要预处理一下做到 O(1) 查询两点距离。\n修改的复杂度是 O(\\log n)，查询的复杂度是 O(\\log^2 n+\\log nD)。\n总复杂度 O(n\\log_2^2n+q(\\log^2n+\\log nD))。\n代码\n数颜色\n给你一个 n 阶序列，支持 m 个操作： 单点修改；\n查询区间里出现的值的个数（多少个不同的数字） n,m\\le 13333,a_i\\le 10^6。 摘要：带修莫队：加一维时间，块大小 O((nt)^{\\frac{1}{3}})（如果 O(n)=O(t) 就是 O(n^{\\frac{2}{3}})）。复杂度 O(n^{\\frac{4}{3}}t^{\\frac{1}{3}})。\n如果不带修改可以莫队。\n带修改就加一维时间，排序的时候按照左端点块编号升序、右端点块编号升序、时间升序这样依次排序即可。\n记得要卡一下常，比如块大小乘 2 什么的。\n代码\nLogistical Questions\n给一棵点边带权树 T，点权为 w_u，边权为 w(u,v)。求 \\min_{u\\in T}\\left\\{ \\sum_{v\\in T}w(u,v)^{\\frac{3}{2}}w_v \\right\\}并输出使得最小化的结点。\nn\\le 2\\times 10^5。 摘要：凸函数，点分治。树高不超过 O(\\log n)，因此复杂度保证。\n这道题展示了有关树上凸函数的一些性质。\n第一部分如果树是一条链，那么每个点的代价一定是先递减后递增。假设我们允许在边上选择点（实数范围），假设选择的点记作 v，那么 f(u,v)=w(u,v)^{\\frac{3}{2}} 在 v 变化的过程中是一个凸函数（实际上是一个类似绝对值和凸函数的混合物）。\n众所周知，凸函数的和仍是凸函数（因为凸函数的导数是单调的，而两个单调函数的和仍是单调的）。\n于是我们就证明了如果树是一条链，那么每个点的代价一定是凸函数。\n那么如果不是一条链呢？\n容易发现，当点 v 在路径 (x,y) 上从 x 移动到 y 的过程中，对于任意结点 u（不论 u 在不在 (x,y) 上），f(u,v) 都是凸函数。因此对于每条路径而言，从一端到另一端的每个点的代价一定是凸函数。\n而这些路径的凸函数的顶点一定是同一个点（可能在某条边上）。如果存在两个顶点的话，我把这两个连起来就不是凸函数了，与上文矛盾。\n如果顶点在边上，那么答案就是这条边的两个端点之一。\n第二部分因此说了这么多，我们得到了一个有助于解题的重要信息：从一个点 u 出发，至多存在一条邻边 (u,v)，满足你沿着 (u,v) 走时代价会减小（导数为负）。如果不存在这样的邻边，那么 u 就是最优解。\n因此我们就每次找到这个邻边并移动即可。这样的算法复杂度是 O(n^2) 的。\n容易发现，这个过程就是在点分树上查询的过程。点分树树高不超过 O(\\log n)。因此使用点分治即可。在寻找邻边的时候，我们可以想办法在 O(n) 的总时间内求出，从 u 往 v 走一个单位后的代价和（对于所有 u 的邻居 v）。这样就可以找出代价变小的邻边了。\n时间复杂度 O(n\\log n)。\n代码\nChef and Churu\n有一个长度为 n 的序列 A 和 n 个函数 (L_i,R_i):f(L_i,R_i)=\\sum_{j=L_i}^{R_i}A_j。有 Q 次操作： 单点修改；\n询问第 l 个函数到第 r 个函数的值的和。 n,q\\le 10^5,A_i\\le 10^9。 摘要：分块，树状数组\n对函数分块。假设分块大小为 T，则有 O(\\frac{n}{T}) 块。\n对于整块，预处理 f(i,j) 表示第 i 块里 A_j 出现的次数。维护 s_i 表示第 i 块的函数值的和。单点修改和询问的复杂度都是 O(\\frac{n}{T})。\n对于零散部分，用树状数组维护 A 序列。修改是 O(\\log_2n) 的，查询是 O(T\\log_2n) 的。\n取 T=\\sqrt{\\frac{n}{\\log_2n}} 为最优时间复杂度，但空间复杂度过高。\n把 T 调大一点，能过。\n实测 T=\\sqrt{n} 时能过。\n代码\nYunna 的礼物\n给一个长度为 n 的序列 A。\n设 f(S,v)=\\sum_{x\\in S}[x=v]（出现次数）。\n设 g(S,c)=\\{v\\in S | f(S,v)=c\\}（出现次数为 c 的数的集合）。\n设 h(S)=\\{f(S,v)| v\\in S\\}。\n有 Q 次询问形如 (l,r,x,y)：设 h([l,r]) 中第 x 小的数为 z，求 g([l,r],z) 中第 y 小的数。说白话就是，询问区间中出现次数第 x 小的数中第 y 小的数。\nn,q,A_i\\le 40000。 摘要：莫队，线段树维护数集。\n提示：维护 S_i 表示出现次数为 i 的数的集合。其他细节显而易见。\n时间复杂度 O(n\\sqrt{n}\\log_2 n)。\n代码","title":"高爸的杂题练习 2","updated":"2025-04-23T04:07:19.264Z"},{"categories":[],"path":"String/Suffix-Array/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"鉴于后缀数组太难复习的原因，特从老博客把本文搬过来。当然有所更新。\n后缀数组后缀数组（Suffix Array）是一个串的所有后缀按照字典序排列形成的指针数组。\n约定\nIndex of strings start with 1.字符串以 1 为起点。\nLet suf[i] denotes the suffix of S start with S[i]. i. e. S[i,|S|].suf[i] 表示以第 i 个元素开头的后缀，即 Suf[i]=S[i,|S|]。\nLet sa[i] denotes the index of the i-th lexicographically smallest suffix among suf[1],suf[2],\\cdots,suf[|S|].sa[i] 表示字典序从小到大排名为 i 的后缀的标号。\nLet rk[i] denotes the lexicographical order of suf[i]. i. e. rank of the i-th suffix.rk[i]\\Leftrightarrow rank[i] 表达第 i 个后缀的排名。 举一个例子吧。\n考虑字符串 banana：\ni : 1 2 3 4 5 6\ns[i] : b a n a n a\n它的后缀数组为\ni : 1 2 3 4 5 6\nsa[i]:6 4 2 1 5 3\n表示字典序排第 i 个的后缀的首字母下标。\n则每一个后缀对应排序后的位置为：\ni :1 2 3 4 5 6\nrk[i]:4 3 6 2 5 1\n表示下标为 i 的后缀的排名。\n构造朴素算法：对后缀排序。O(n) 比较两个字符串的字典序大小。时间复杂度 O(n^2\\log_2n).\n哈希算法：二分 + 哈希在 O(\\log_2n) 的时间内比较两个字符串的字典序大小。时间复杂度 O(n\\log_2^2n).\n接下来介绍倍增算法，通过倍增 + 排序的方式在 O(n\\log_2n) 的时间内求出后缀数组。\n算法过程中，我们通过 O(\\log_2n) 轮桶排序来得到每个后缀的排名。在第 j 轮排序中，我们考虑的是所有 \\forall i\\in[1,|S|],S[i,\\min(i+2^j-1,|S|)] 的串的排名，并记录在 rk 中。在这一阶段，rk 中可能有相同的数值。而当 O(\\log_2n) 轮排序结束后，rk 中的数必然互不相同。\n在每一轮排序中，我们会用这一轮的 rk 求出下一轮的 sa，再由下一轮的 sa 求出它对应的 rk。然后重复这个过程。一开始，rk 可以设置为字符对应的 ASCII 的值。\n第一部分假设 rk[i] 表示的是 S[i,\\min(i+2^j-1,|S|)] 的排名，那如何得到进行第下一轮的排序？对于 x,y： 如果 rk[x]&lt;rk[y]，那么在下一轮排序后，仍然满足 rk[x]&lt;rk[y]。因为前缀的字典序已经小于，即使延伸一段后缀也不会有影响。大于同理。\n如果 rk[x]=rk[y]，那么我们就比较 rk[x+2^j] 和 rk[y+2^j] 即可。 也就是说，下一轮排序实际上是二元组 (rk[i],rk[i+2^j]) 的排序（如果 i+2^j&gt;|S|, 记 rk[i+2^j]=0）。直观地说 sort 传进去的比较函数就是\nbool cmp(int x,int y)&#123; return rk[x]!=rk[y]?rk[x]&lt;rk[y]:rk[x+(1&lt;&lt;j)]&lt;rk[y+(1&lt;&lt;j)];\n&#125;\n利用这个将 1,2,\\cdots,n 排序后得到的便是下一轮的 sa。\n第二部分那么如何通过 sa 求出 rk？我们不能直接 rk[sa[i]]=i。因为在这其中还会有相等字符串的存在。首先，rk[sa[1]]=1。然后对于 i\\in[2,|S|]，我们比较 sa[i-1] 和 sa[i] 的二元组是否相等。如果相等那么排名加 1，否则排名不变。\n实现在实现的时候显然我们不能调用 sort，而必须手写桶排序。而我们也没必要写二元组的桶排序。由于桶排序是稳定排序，因此我们先按照第二关键字排序，再按照第一关键字排序，就能得到下一轮的 sa。而我们甚至可以直接从这一轮的 sa 得到第二关键字排序后的结果。因此实际上我们只需要按照第一关键字桶排即可。\n#include&lt;bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+6; namespace SA&#123; int l;// 字符串长度，1 起点 int sa[N],rk[N]; int t[N],bin[N],sz;//sz: 桶的大小 void qsort()&#123;// 桶排序 for(int i=0;i&lt;=sz;i++)bin[i]=0; for(int i=1;i&lt;=l;i++)bin[rk[i]]++;// 等价于 bin[rk[t[i]]++ for(int i=1;i&lt;=sz;i++)bin[i]+=bin[i-1]; for(int i=l;i>=1;i--)sa[bin[rk[t[i]]]--]=t[i]; &#125; void make(char *s)&#123; l=strlen(s+1),sz=max(l,'z'-'0'+1);// 初始化 l,sz for(int i=1;i&lt;=l;i++)t[i]=i,rk[i]=s[i]-'0'+1;// 初始化 t,rk(1 为最高排名） qsort();// 对 t 排序，结果转移到 sa 中 for(int j=1;j&lt;=l;j&lt;&lt;=1)&#123;// 开始倍增 int tot=0; for(int i=l-j+1;i&lt;=l;i++)t[++tot]=i;// 这些后缀没有第二关键字，因此排在最前面 for(int i=1;i&lt;=l;i++)if(sa[i]-j>0)t[++tot]=sa[i]-j;//&#123;sa[i]-j&#125; 按照第二关键字排列 qsort(); swap(t,rk);//t 变成上一次的 rk rk[sa[1]]=tot=1; for(int i=2;i&lt;=l;i++) rk[sa[i]]=t[sa[i-1]]==t[sa[i]]&amp;&amp;t[sa[i-1]+j]==t[sa[i]+j]?tot:++tot; &#125; &#125;\n&#125;\nchar s[N];\nint main()&#123; scanf(\"%s\",s+1); SA::make(s); for(int i=1;i&lt;=SA::l;i++)printf(\"%d\",SA::sa[i]); return 0;\n&#125;\n模板题 LuoguP3809\nH 数组利用后缀数组维护信息，需要一些辅助数组。\n定义 h[i] 表示 sa[i] 与 sa[i-1] 的 LCP 的长度。\n容易发现 \\text{LCP}(sa[i],sa[j])=\\min_{i&lt;k\\le j}h[k].\n举个例子吧 结论一则：h[rk[i]]\\geq h[rk[i-1]]-1 (1&lt;i\\le |S|).\n证明很显然，直接用 h[i-1] 的⽅案去掉头上的元素。因此我们只需要求 h'[i]=h[rk[i]] 即可求出 h[i]。\nint calc(int x,int y,int len)&#123; while(x+len&lt;=l&amp;&amp;y+len&lt;=l&amp;&amp;s[x+len]==s[y+len])++len; return len;\n&#125;\nvoid calc_h_rk()&#123;//h[rk[i]] for(int i=1;i&lt;=l;i++)h[i]=(rk[i]==1)?0:calc(i,sa[rk[i]-1],max(h[i-1]-1,0));\n&#125;\n均摊复杂度 O(n).\n应用两个后缀的 LCP\n\\text{LCP}(sa[i],sa[j])=\\min_{i&lt;k\\le j}h[k]使用 ST 表预处理 h，可以做到 O(n\\log_2n)-O(1) 的时间复杂度。\n子串出现次数S[L,R] 的出现次数：即 H 数组下标 rk[L] 左右，使得 h 值大于等于 R-L+1 的区间。二分即可。O(\\log_2n).\n本质不同的子串个数总数减掉 height 的和。因为两个相同的串 S[L_1,R_1],S[L_2,R_2] 会在 suf[L_1] 和 suf[L_2] 的 H 数组中被算一次。\n最小循环表示对 SS 建后缀数组即可。\n最长公共子串对于 S,T，求 \\text{LCS}(S,T)：对 S\\#T 建 H 数组，然后判一下下标就行了。\n字典序第 K 小子串在 H[rk] 数组上预处理一下差分等等的东西，然后二分即可。\n模板#include&lt;bits/stdc++.h>\nusing namespace std;\nconst int N=3e4+5; struct SA&#123; char s[N]; int l; int sa[N],rk[N]; int t[N],bin[N],sz; int h[N],he[N];//h,height void qsort()&#123; for(int i=0;i&lt;=sz;i++)bin[i]=0; for(int i=1;i&lt;=l;i++)bin[rk[t[i]]]++; for(int i=1;i&lt;=sz;i++)bin[i]+=bin[i-1]; for(int i=l;i>=1;i--)sa[bin[rk[t[i]]]--]=t[i]; &#125; void make()&#123; l=strlen(s+1),sz=max(l,26); for(int i=1;i&lt;=l;i++)t[i]=i,rk[i]=s[i]-'a'+1; qsort(); for(int j=1;j&lt;=l;j&lt;&lt;=1)&#123; int tot=0; for(int i=l-j+1;i&lt;=l;i++)t[++tot]=i; for(int i=1;i&lt;=l;i++)if(sa[i]-j>0)t[++tot]=sa[i]-j; qsort(); swap(t,rk); rk[sa[1]]=tot=1; for(int i=2;i&lt;=l;i++) rk[sa[i]]=t[sa[i-1]]==t[sa[i]]&amp;&amp;t[sa[i-1]+j]==t[sa[i]+j]?tot:++tot; &#125; &#125; int move(int x,int y,int len)&#123; while(x+len&lt;=l&amp;&amp;y+len&lt;=l&amp;&amp;s[x+len]==s[y+len])++len; return len; &#125; void calc_h()&#123; for(int i=1;i&lt;=l;i++) h[i]=rk[i]==1?0:move(i,sa[rk[i]-1],max(h[i-1]-1,0)); &#125; int st[N][16];//h[sa[i]]~h[sa[i+2^j]] 中的最小值 void make_st()&#123; for(int i=1;i&lt;=l;i++)st[i][0]=h[sa[i]],printf(\"st[%d,0]:%d\\n\",i,st[i][0]); for(int j=1;(1&lt;&lt;j)&lt;=l;j++)&#123; int step=1&lt;&lt;(j-1); for(int i=1;i+step&lt;=l;i++)&#123; st[i][j]=min(st[i][j-1],st[i+step][j-1]); printf(\"st[%d,%d]:%d\\n\",i,j,st[i][j]); &#125; &#125; &#125; int lcp(int x,int y)&#123;// 返回长度 if(x==y)return l-x+1; x=rk[x],y=rk[y]; if(x>y)swap(x,y); x++;// 取不到 x int step=log(y-x+1)/log(2); return min(st[x][step],st[y-(1&lt;&lt;step)+1][step]); &#125;\n&#125;;\nSA sa;\nint main()&#123; scanf(\"%s\",sa.s+1); sa.make(); sa.calc_h(); sa.make_st(); for(int i=1;i&lt;=sa.l;i++)&#123; for(int j=1;j&lt;=sa.l;j++)&#123; if(i!=j&amp;&amp;sa.lcp(i,j))printf(\"%d %d %d\\n\",i,j,sa.lcp(i,j)); &#125; &#125; return 0;\n&#125;\n/* * BUG#1: bin[i-1] 写成 bin[i+1] * 求后缀 (i,j)(rk[i]&lt;rk[j]) 的 LCP，就是求 j in (rk[i],rk[j]] 的 height[j] 的最小值，即 RMQ. */","title":"后缀数组","updated":"2025-04-23T04:07:19.276Z"},{"categories":[],"path":"Data-Structure/Virtual-Tree/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"虚树虚树是指对一棵树 T=(V,E)，取其点集的子集 S\\subseteq V 作为关键点集，将关键点以及他们两两之间的 LCA 构成的点集 S' 拿出来建立一棵树，这棵树称为 T 的关于 S 的虚树。\n虚树的意义是它只包含了关键点以及 LCA，但也维护了原树的结构特征，方便我们对信息的处理。 虚树的构建我们对原树先做一次 DFS，求出每个点的 DFS 序。然后把关键点按照 DFS 序排序。考虑增量构造。我们用栈维护当前虚树的右链。添加一个结点相当于删掉末端的一些点，再把这个点加入到右链上。\n在弹栈的时候就把这条边加到虚树上。最后把栈里所有的点依次连边加到虚树上即可。\nint s[N],tp;\nvoid build_virtual_tree(vector&lt;int> &amp; V)&#123; int root=V[0]; for(int u:V)root=lca(root,u); s[tp=1]=root; for(int u:V)&#123; int y=lca(s[tp],u); while(tp>1&amp;&amp;dep[y]&lt;dep[s[tp-1]]) Vadd(s[tp-1],s[tp],W(s[tp-1],s[tp])), --tp; if(y==s[tp]); else &#123; assert(tp>1); if(y==s[tp-1]) Vadd(y,s[tp],W(y,s[tp])), --tp; else Vadd(y,s[tp],W(y,s[tp])), s[tp]=y; &#125; s[++tp]=u; &#125; while(tp>1) Vadd(s[tp-1],s[tp],W(s[tp-1],s[tp])), --tp;\n&#125;\n// s 和 tp 是栈\n// V 表示关键点集，并且已经排好序。\n// Vadd 表示在虚树上加上这条边，W 表示边权\n// root 在特殊情况也可能是 T 的根\n考虑到排序的复杂度，虚树的构建复杂度是 O(|S|\\log_2|S|) 的。\n小性质：虚树的规模是 \\Theta(|S|) 的。\n「例 1」 SDOI2011 消耗战\n给出一棵边带权的树 T=(V,E)，多次询问，每次给出一个点集 S\\subseteq V，1\\notin S，要求删掉权值和最小的边使得 1 与 S 中任意一个点都不连通。求这个最小权值和。\n|V|\\le 2.5\\times 10^5,|E|=|V|-1,\\sum |S|\\le 5\\times 10^5。 显然的虚树题。每次询问，对 S\\cup\\{1\\} 建虚树，边权置为两点间边权最小值。那么我们就只需要在这个虚树做原问题即可。由于虚树的规模是 O(|S|)，考虑到排序的复杂度，则总复杂度为 O(\\sum |S|\\log_2|V|)。\n代码\n「例 2」 ZR982 黄队\n有一棵 n 个节点的树，其中所有的树边 1 到 n−1 标号。定义 \\delta(v,r) 为 v 经过由标号不超过 r 的边构成的路径到达的点集。\n现在有 q 个询问，每个询问给你一组点 v_1,v_2,\\cdots,v_k，求 (r_1,r_2,\\cdots ,r_k) 这样的 k 元组个数，满足 0\\le r_i\\le n−1 且 δ(v_i,r_i) 这些点集两两不交。\n由于答案很大，请输出对 10^9+7 取模的值。\n1\\leq n, q, \\sum k\\leq 2\\times 10^5. 首先思考 \\delta(u,x) 和 \\delta(v,y) 不相交的条件是什么。设 w(u,v) 表示 u 到 v 的边的编号最大值，那么充要条件就是 x&lt;w(u,v) 且 y&lt;w(u,v)。\n题目中要求的是两两不交，那么意味着 r_i&lt;\\min_{1\\le j\\le k,j\\ne i} w(v_i,v_j)。\n考虑离线并查集。把边权从小到大排序。那么考虑当前 (u,v,w) 这条边，则 u 的连通块和 v 的连通块边权都小于 w，因此如果 u 中只有一个关键点，v 中有至少一个关键点，那么 u 的关键点对应的 r 的限制就是 w。对称情况是一样的。其他情况，是不能确定限制的值的。\n最后把限制都乘起来就是答案。\n这个过程显然是可以在虚树上做的。\n总复杂度 O(n+\\sum k\\log_2n)。","title":"虚树入门","updated":"2025-04-23T04:07:19.263Z"},{"categories":[],"path":"Math/Fomula-of-Sphere/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"柱体体积柱体的体积为底面积乘高，记作 V=Sh锥体体积锥体的体积为同底等高的柱体体积的 \\frac{1}{3}。\n特殊情况：三棱锥。对于三棱柱 ABC-A_1B_1C_1，我们可以将其分成三个三棱锥：A_1-ABC、B-A_1B_1C_1 和 A_1-BCC_1。这三个棱锥的体积是相等的。\n对于任意一个不规则底面的锥体，建立在平行面投影的相似理论基础上，我们可以证明它的体积公式。设锥体的底面积为 S，底面所在平面为 \\alpha，顶点为 P，高为 h。\n引理 1：用平行于 \\alpha 的平面 \\beta 切割锥体的中间部分得到的切面积为 S_2。那么锥体顶点 P 到 \\alpha 与到 \\beta 的距离比的平方等于 \\frac{S}{S_2}。\n理解性证明：对于底面是三角形的情况，是容易证明相似的，不再赘述。而一个不规则的底面可以被分成无数个三角形来拟合，这样就证明了。\n于是定义一个函数 f(x),x\\in[0,1] 表示用平行于 \\alpha，且与 P 的距离是 xh 的平面 \\beta，切割锥体的中间部分的切面积。显然 f(x)=Sx^2那么锥体的体积为 \\begin{aligned}\nV&=h\\int_{0}^1f(x)\\text{d}x\\\\\n&=Sh\\int_{0}^1x^2\\text{d}x\\\\\n&=\\frac{1}{3}Sh\n\\end{aligned}不使用积分，使用幂级数来求极限也是可以推导出来的。\n球体体积要求一个球体的体积，不妨求一个半球体的体积。对于一个半球体，设其半径为 R。设其底面所在平面为 \\alpha，半球体的高等于半径。\n类似地，定义函数 f(x),x\\in[0,R] 表示用平行于 \\alpha 的距离 \\alpha 为 x 的平面去切割球体得到的切面积。那么 f(x)=\\pi(R^2-x^2)那么半球体的体积就为 \\begin{aligned}\nV&=\\int_0^Rf(x)\\text{d}x\\\\\n&=\\pi\\int_0^R(R^2-x^2)\\text{d}x\\\\\n&=\\pi\\left.\\left(R^2x-\\frac{1}{3}x^3\\right)\\right|_{0}^R\\\\\n&=\\frac{2}{3}\\pi R^3\n\\end{aligned}怎么去理解这个积分？其实可以把 \\int f(x) 理解为是一个柱体的体积减掉一个锥体的体积。\n那么球体的体积就是 \\frac{4}{3}\\pi R^3。\n球体的表面积同样可以用积分推导： S=R\\int_{0}^\\pi2\\pi R\\sin\\theta\\text{d}\\theta=4\\pi R^2","title":"球体积公式推导","updated":"2025-04-23T04:07:19.268Z"},{"categories":[],"path":"Math/Arturia-Course-1/","tags":[{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"},{"name":"English","slug":"English","permalink":"https://notes.sshwy.name/tags/English/"}],"text":"Ex 1 (The Unique Factorization Theorem) Prove that a\\times b=(a,b)\\times [a,b], a,b\\in \\mathbf{N}. (P5) First, to be obvious, for all a,b\\in N, we have a+b=\\min(a,b)+\\max(a,b).\nLet f(x,p) denotes the largest c\\in \\mathbf{N} that p^c|x. According to the unique factorization theorem, we have x=\\prod_{p\\text{ is prime}}p^{f(x,p)}Let’s consider a prime factor p of ab.\nTo be exactly, f(ab,p)=f(a,p)+f(b,p).\nLet d=(a,b), so we have p^{\\min(f(a,p),f(b,p))}|d,p^{\\min(f(a,p),f(b,p))+1}\\nmid d, because a and b should both be divisible by d. Also we want to maximize d, so we try to maximize the power of p in d. That is equal to f(d,p)=\\min(f(a,p),f(b,p)).\nSimilarly, Let m=[a,b], so we have f(m,p)=\\max(f(a,p),f(b,p)).\nSo when we multiply d and m, we will get \\begin{aligned}\nf(dm,p)\n&=f(d,p)+f(m,p)\\\\\n&=\\min(f(a,p),f(b,p))+\\max(f(a,p),f(b,p))\\\\\n&=f(a,p)+f(b,p)\\\\\n&=f(ab,p)\n\\end{aligned}Finally ab=\\prod_{p\\text{ is prime}}p^{f(ab,p)}=\\prod_{p\\text{ is prime}}p^{f(dm,p)}=dm.\nQ. E. D.\nEx 2 (Diophantine Equation)\nGiven that a,b,c,x,y,z\\in \\mathbf{Z}^+,(a,b)=(b,c)=(a,c)=1, a,b,c&gt;0, find the largest n(n\\in \\mathbf{N}) that makes abx+bcy+acz=n unsolvable. (P6) Answer: 2abc-ab-bc-ac.\nEx 3 (Module)\nEuler Function: Prove that \\sum_{d|m}\\varphi(d)=mthrough direct calculation or combination meanings. (P13) Solve using Direct CalculationLet M(S)=\\prod_{x\\in S}x.\nUse the unique factorization theorem, Let m={p_1}^{a_1}{p_2}^{a_2}\\cdots{p_n}^{a_n}. We further define P(m)=\\{p_1,\\cdots,p_n\\}.Use inclusion-exclusion principle we get \\begin{aligned}\n\\varphi(m)&=m\\left(1-\\frac{1}{p_1}\\right)\\left(1-\\frac{1}{p_2}\\right)\\cdots\\left(1-\\frac{1}{p_n}\\right)\\\\\n&=\\sum_{S\\subseteq P(m)}(-1)^{|S|}\\frac{m}{M(S)}\n\\end{aligned}As \\frac{m}{M(S)} is factor of m, let’s change the way we calculate \\sum_{d|m}\\varphi(d) to calculate the coefficient of factors of m.\nLet d be one of factors of m. Then the coefficient of it will be \\sum_{S\\subseteq P(\\frac{m}{d})}(-1)^{|S|}=\\left[P\\left(\\frac{m}{d}\\right)=\\varnothing\\right]So we have \\sum_{d|m}\\varphi(d)=\\sum_{d|m}\\left[P\\left(\\frac{m}{d}\\right)=\\varnothing\\right]dSince only when d=m satisfies [P(\\frac{m}{d})=\\varnothing]=1, otherwise it will be 0. Thus we get \\sum_{d|m}\\varphi(d)=m.\nQ. E. D.\nSolve using Combination MeaningsLet d be one of factors of m, consider the number of x that (x,m)=d. This is equal to the number of x that d|x and (\\frac{x}{d},\\frac{m}{d})=1. Replace the \\frac{x}{d} by x', we get (x',\\frac{m}{d})=1. That just means the number of x that x and \\frac{m}{d}is coprime, aka \\varphi(\\frac{m}{d}).\nOn the other hand, \\sum_{d|m}[(x,m)=d]=1, thus we have m=\\sum_{i=1}^m\\sum_{d|m}[(i,m)=d]=\\sum_{d|m}\\varphi\\left(\\frac{m}{d}\\right)=\\sum_{d|m}\\varphi(d)Q. E. D.\nEx 4 (Quadratic Equation)\n(2017ICPC) Given T&lt;10^{16}, solve positive integer solution for n(n+1)=2m(m+1)with n&gt;T. (P21) To solve this problem we first learn the concept of Pell’s Equation.\nPell’s Equation IWe define x^2-Dy^2=1 as the Pell I equation. D is a positive integer.\nTheorem: The solution of Pell I equation exists. If the smallest solution is (x_0,y_0), then the equation can be expressed as x_n+\\sqrt{D}y_n=(x_0+\\sqrt{D}y_0)^nSo we can use recurrence to solve it.\nPell’s Equation IISimilarly, we define x^2-Dy^2=-1 as the Pell II equation. D is also a positive integer.\nTheorem: The solution of Pell II equation exists. If the smallest solution is (x_0,y_0), then the equation can be expressed as x_n+\\sqrt{D}y_n=(x_0+\\sqrt{D}y_0)^{2n+1}Now let’s go back to the original problem.\nDo some modification we can get (2n+1)^2-2(2m+1)^2=-1That is just a Pell II equation. So we can simply use binary search and algorithm similar to quick power to solve it.\nTime complexity is O(\\log_2^2T).\nEx 5 (Legendre Theorem)\nCount the number of zeros at the end of n!. (P24) Let f(n,p)=\\sum_{i\\ge 1}\\lfloor\\frac{n}{p^i}\\rfloor denotes the power of p in n. The answer is \\min(f(n,2),f(n,5)) exactly. Design an algorithm calculate the last nonzero digit of n!. (P24) Let’s define F(n) denotes the last nonzero digit of n!. Consider recursion.\nFirst we compute 1\\times 2\\times 3\\times 4\\bmod 10=4 and 6\\times 7\\times 8\\times 9\\bmod 10=4. Thus we can divide the number into multiple of 5 or not.\nAnother observation is that F(n)=F(n-n\\bmod 10)F(n\\bmod 10), it means we make the last a few numbers modulo to 10 so we get F(n\\bmod 10). Now we have F(n)=4^{2\\lfloor\\frac{n}{10}\\rfloor}F(n\\bmod 10)F\\left(\\left\\lfloor\\frac{n}{5}\\right\\rfloor\\right)\\frac{1+[(n\\bmod 10)\\ge 5]}{2^{\\lfloor\\frac{n}{5}\\rfloor}}\\\\\n=4^{\\lfloor\\frac{n}{10}\\rfloor}F(n\\bmod 10)F\\left(\\left\\lfloor\\frac{n}{5}\\right\\rfloor\\right)Notice that F(x)=2F(x-5) for x\\in[5,9], so we can make it.\nF0 = [1,1,2,6,4,2,2,4,2,8]\ndef F(x): return F0[x] if x&lt;10 else F0[x%10]*F(x//5)%10*(4 if(x//10%2)else 6)%10 print(F(int(input())))\nTime complexity is O(\\log_5n).\nEx 6 (Lucas Theorem)\nCalculate G^{\\sum_{d|n}\\binom{n}{d}}\\bmod 999911659. (P26) As we know the Euler Theorem we have G^{\\sum_{d|n}\\binom{n}{d}}\\equiv G^{\\sum_{d|n}\\binom{n}{d}\\bmod 999911658} \\pmod {999911659}Because 999911658=2\\times 3\\times 4679\\times 35617, so we can simply apply Lucas Theorem and the Chinese Remainder Theorem to compute the answer.\nLet p=35617,P=999911659, so the time complexity is O(p+\\log_pn+\\log_2P).\nCode\nBZOJ2111: Too simple to solve it …\nEx 7 (Mobius Function)\nProve that \\sum_{d|n}\\mu(d)=[n=1]. (P29) When n=1, the equation is absolutely satisfied. Let’s say n&gt;1.\nAccording to the unique factorization theorem, we have n={p_1}^{a_1}{p_2}^{a_2}\\cdots{p_m}^{a_m}So we have \\begin{aligned}\n\\sum_{d|n}\\mu(d)&=\\sum_{S\\subseteq\\{p_1,p_2,\\cdots,p_n\\}}\\mu\\left(\\prod_{x\\in S}x\\right)\\\\\n&=\\sum_{S\\subseteq\\{p_1,p_2,\\cdots,p_n\\}}(-1)^{|S|}\\\\\n&=0\n\\end{aligned}Q. E. D.\nEx 8 (Prefix Sum Compute) Let f(n) denotes the sum of all the factors of n, design an algorithm to calculate \\sum_{i=1}^n f(i), n\\le 10^{12}. (P29) We have \\sum_{i=1}^nf(i)=\\sum_{i=1}^n\\sum_{j|i}j=\\sum_{j=1}^nj\\left\\lfloor\\frac{n}{j}\\right\\rfloorBy number theory partition, we can compute it in O(\\sqrt{n}).\nEx 9 (Quadratic Residue)Before starting solving problems, we learn the concept of Legendre symbol.\nLegendre symbolGiven (m,n)=1, if there exists x solves x^2=m\\mod mthen we define n as a quadratic residue.\nGiven p as a odd prime, n isn’t divisible by p. Then \\left( \\frac{n}{p} \\right)=\\begin{cases}\n1 & n\\text{ is a quadratic residue}\\\\\n-1 & \\text{Otherwise}\n\\end{cases}The \\left( \\frac{n}{p} \\right) is what we called Legendre symbol.\nThere’s a theorem given by Euler to help compute Legendre symbol: n^{\\frac{p-1}{2}}=\\left( \\frac{n}{p} \\right) \\mod pObviously, Legendre symbol is a multiplicative function.\nQuadratic Reciprocal LawIt’s such a magic low: \\left( \\frac{p}{q} \\right)\\left( \\frac{q}{p} \\right)=(-1)^{\\frac{(p-1)(q-1)}{4}}Now let’s do some exercises. Find p such that \\left( \\frac{3}{p}\\right)=1. (P36) According to quadratic reciprocal law we have \\left( \\frac{p}{3}\\right)=(-1)^{\\frac{p-1}{2}}As we know \\left(\\frac{1}{3}\\right)=1,\\left(\\frac{2}{3}\\right)=-1, so we get \\begin{cases}\np\\bmod 3=1\\\\\np\\bmod 2=1\\\\\n\\frac{p-1}{2}\\bmod 2=0\n\\end{cases}\n\\text{ or }\n\\begin{cases}\np\\bmod 3=2\\\\\np\\bmod 2=1\\\\\n\\frac{p-1}{2}\\bmod 2=1\n\\end{cases}p=12k+1,12k+11. p should be a prime. Find p such that \\left( \\frac{5}{p}\\right)=1. (P36) Similar to above. Skip. Calculate \\left( \\frac{74}{101}\\right). (P36) def Legendre(p,q): p%=q if p==0 : return 0 ans=-1 for i in range(1,q): if(i*i%q==p): ans=1 return ans\nJust a joke. Obviously we should use quadratic reciprocal law to solve it. Python code:\ndef sig(x): return 1-2*(x%2) def Legendre(p,q): # q should be a prime p1=p q1=q if p==2: return sig((q*q-1)//8) if p==0: return 0 x=2 res=1 while x*x&lt;=p: if p%x==0: t=Legendre(x,q) if x==2 else Legendre(q%x,x)*sig((x-1)*(q-1)//4) while p%x==0: res*=t p//=x if res==0: return 0 x += 1 if p>1: res*=Legendre(p,q) if p==2 else Legendre(q%p,p)*sig((p-1)*(q-1)//4) return res print(Legendre(int(input()),int(input())))\nEx 10 (Exponential Congruence Equation)First let’s learn some conclusion of exponential congruence equation.\nTheorem: If n is not divisible by odd prime p, then the number of solutions of x^2=n\\mod p^lis (\\frac{n}{p})+1.\nThe number of solutions of x^k=1\\mod pis (k,p-1) or 1.\nx^k takes \\frac{p-1}{(p-1,k)} different values when x goes through a reduced residue system of p. (MU training 2017) Let p be a prime number, f(i) be the number of solutions of (x+y)^i=x^i\\mod pwhere 0&lt;x&lt;p,0&lt;y&lt;m+1. Calculate \\sum_{i=1}^{p-1}i\\times f(i) \\mod {10^9+7}(P38) First we have (1+x^{-1}y)^i=1\\mod pif p|y, the equation always satisfies.\nOtherwise p\\nmid y, for a fixed y, (1+x^{-1}y) can goes through a reduced residue system of p. The number of solutions is (i,p-1). So we have f(i)=\\left\\lfloor\\frac{m}{p}\\right\\rfloor(p-1)+\\left(m-\\left\\lfloor\\frac{m}{p}\\right\\rfloor\\right)(i,p-1)Thus \\sum_{i=1}^{p-1}i\\times f(i)\n=\\frac{p(p-1)}{2}\\left\\lfloor\\frac{m}{p}\\right\\rfloor(p-1) + \\left(m-\\left\\lfloor\\frac{m}{p}\\right\\rfloor\\right)\\sum_{i=1}^{p-1}i (i,p-1)Let’s define the last sum as g: \\begin{aligned}\ng(n)&=\\sum_{i=1}^ni(i,n)\\\\\n&=n^2+\\frac{1}{2}\\sum_{i=1}^{n-1}i(i,n)+(n-i)(n-i,n)\\\\\n&=n^2+\\frac{1}{2}n\\sum_{i=1}^{n-1}(i,n)\\\\\n&=n^2+\\frac{1}{2}n\\sum_{i=1}^{n-1}\\sum_{d|i,d|n}\\varphi(d)\n\\end{aligned}Concentrate on the latter part: \\begin{aligned}\n&\\sum_{i=1}^{n-1}\\sum_{d|i,d|n}\\varphi(d)\\\\\n=&\\sum_{d|n}\\varphi (d) \\left(\\frac{n}{d}-1\\right)\\\\\n=&\\sum_{d|n}\\varphi (d) \\frac{n}{d}-n\n\\end{aligned}Thus \\begin{aligned}\ng(n)&=n^2+\\frac{1}{2}n\\sum_{i=1}^{n-1}\\sum_{d|i,d|n}\\varphi(d)\\\\\n&=\\frac{1}{2}n^2+\\frac{1}{2}n\\sum_{d|n}\\varphi (d) \\frac{n}{d}\n\\end{aligned}So we can use Min_25’s Sieve Method to compute g(n) in O(\\frac{n^{\\frac{3}{4}}}{\\log n}).","title":"Arturia's Math Lesson Day 1","updated":"2025-04-23T04:07:19.266Z"},{"categories":[],"path":"Probset/APIO2019/","tags":[{"name":"Complete-Solution","slug":"Complete-Solution","permalink":"https://notes.sshwy.name/tags/Complete-Solution/"}],"text":"路灯\n一条长度为 n 的 n+1 个点的链。在时刻 0 时给你每条边的出现 / 不出现的状态。接下来的 q 个时刻会 切换某条边的状态\n询问到目前为止，(a,b) 连通的时间的总和。 n,q\\le 3\\times 10^5。 摘要：区间问题转化为二维数点。\n对于每个点对 (a,b)，先转化为边对。设 b'=b-1（允许 a=b'）。我们记录它到结束时的时间总和，设为 T(a,b')。\n那么对于时刻 i 的一次修改操作，假设修改的边是 x，相当于 x 左右两边的点的连通性发生了变化。设与 x 连通的极大区间是 [L,R]，那么相当于是 a\\in[L,x],b\\in[x,R] 的 T(a,b) 都被加上一个 q-i（如果这条边出现）或者减掉 q-i（如果这条边消失）。\n对于一次查询操作，如果 a,b+1 当前是不连通的，那么答案就是 T(a,b)。否则答案是 T(a,b)-(q-i)。你要把预支的部分减掉。\n上述过程实际上就是矩阵加，单点求值。把矩阵加写成 4 个前缀矩阵的形式。可以二维数点。\n时间复杂度 O(n\\log_2n)。\n代码\n奇怪装置\n给出 A,B。定义映射 f:x\\in N\\to(x+\\left\\lfloor\\frac{x}{B}\\right\\rfloor\\bmod A,x\\bmod B)。给出 n 个区间 [l_i,r_i]，求 |\\{f(x)|x\\in[l_i,r_i]\\}|（即有多少个互不相同的元素）。\nn\\le 10^6,A,B,l_i,r_i\\le 10^{18}。 摘要：解同余方程。\n解一个方程 f(x)=f(x+T)，得 T=\\frac{AB}{\\gcd(A,B+1)}。因此映射是有周期性的。\n如果存在 l_i+T\\le r_i，那么答案就是 T。否则可以把区间都放到 [0,T-1] 的范围，求区间并即可。\n代码\n桥梁\n给一个 n 个点 m 条边的加权无向图，以及每条边的初始权值 (u_i,v_i,w_i). 有 q 个操作： 把第 x 条边的边权改为 y。\n问从编号为 x 的点出发，经过边权大于等于 y 的边能到达的点的个数。 n\\le 5\\times 10^4,m\\le 10^5,q\\le 10^5,w_i\\le 10^9. 摘要：分块，离线，按权值从大到小排序，可撤消并查集，卡常。\n这种数据范围的题，想不到 log 的做法，就考虑分块。将操作序列分块，每 T 个为一块。用并查集回答询问。\n对于一个操作序列规模为 T 的问题，我们考虑离线处理。我们将 m 条边和操作序列分别按权值从大到小排序。按权值从大到小考虑每个操作。在操作之前我们先考虑权值大于等于当前权值的边。如果当前这条边在这 T 个操作中始终没有被修改，我们就直接把它加到并查集里。否则我们暂时忽略这条边。然后考虑当前这个操作，如果是修改操作我们也忽略，如果是询问操作，我们就想办法在 O(T) 的时间内回答询问。\n回答询问：把操作序列里那些有用的（时间最晚）的修改操作找出来，如果权值比询问大就加到并查集里。然后就可以回答询问了。回答完了撤消这部分的修改即可。时间复杂度 O(T)。注意这里并查集的复杂度是均摊 O(\\log_2n) 的（吧）\n这样的话，复杂度为 O(T^2+m\\log_2m+T\\log_2T)=O(T^2+m\\log_2m)。\n总的复杂度是 O(\\frac{q}{T}(T^2+m\\log_2m))=O(qT+\\frac{q}{T}m\\log_2m)。由于 n,m 同阶，于是当 T=\\sqrt{m\\log_2m} 时取得最优复杂度 O(q\\sqrt{m\\log_2m})。\n代码","title":"APIO 2019","updated":"2025-04-23T04:07:19.273Z"},{"categories":[],"path":"IOI2020hw/AGC-part-5/","tags":[],"text":"AGC030 D Inversion Sum设 f(x,i,j) 表示在第 x 次操作后，A_i 大于 A_j 的概率（即第 i 个位置大于第 j 个位置的概率）。每次我们有一半的概率执行这个操作。\n转移的时候只修改 (i,j),(i,k),(j,k),(k,i),(k,j),k\\in[1,n] 的 dp 值即可，因此不需要第一维，转移的复杂度是 O(n) 的。\n总复杂度 O(n^2+nq)。\n代码\nAGC031 D A Sequence of Permutations首先，我们定义两个置换的乘法运算： pq=\\{p_{q_i}\\}那么可以发现 f(p,q)=qp^{-1}。\n另外，(abc)^{-1}=c^{-1}b^{-1}a^{-1}。置换的乘法是有结合律的。 这里是 abcd 的乘法运算过程。结果为 (3,2,1,4)。\n那么来找一些规律吧： \\begin{aligned}\na_1&=p\\\\\na_2&=q\\\\\na_3&=qp^{-1}\\\\\na_4&=qp^{-1}q^{-1}\\\\\na_5&=qp^{-1}q^{-1}pq^{-1}\n\\end{aligned}相信聪明的你已经找到规律了。我们把 a_i 写成 A_iB_iA_i^{-1} 的形式。那么 \\begin{aligned}\n(A_1,B_1)&=(\\varepsilon,p)\\\\\n(A_2,B_2)&=(\\varepsilon,q)\\\\\n(A_3,B_3)&=(\\varepsilon,qp^{-1})\\\\\n(A_4,B_4)&=(q,p^{-1})\\\\\n(A_5,B_5)&=(qp^{-1},q^{-1})\\\\\n(A_6,B_6)&=(qp^{-1},q^{-1}p)\\\\\n(A_7,B_7)&=(qp^{-1}q^{-1}p,p)\\\\\n(A_8,B_8)&=(qp^{-1}q^{-1}p,q)\n\\end{aligned}所以有一个 6 的循环。一个 (A,p) 在过 6 轮后会变成 (Aqp^{-1}q^{-1}p,p)。第一维转化为置换的幂，然后就可以 O(n) 做了。\n代码\nAGC030 E Less than 3我们考虑在 10 中间放一个蓝线，01 中间放一个红线。那么我们可以把变化过程描述为线的移动过程： 当然，移动的时候有一些规则限制。但是不难证明，初始局面一定能通过合理的移动方式来得到最终局面，移动的距离是每条线移动距离的绝对值之和： 那么我们枚举第一条线和哪条匹配，然后 O(n) 计算总代价即可。总时间复杂度 O(n^2)。\n代码\nAGC030 F Permutation and Minimum首先考虑分类，我们将 (A_{2i-1},A_{2i}) 可以分三类：(-1,-1)、(-1,x),(x,-1) 和 (x,y)。\n对于第三类可以直接不管。对于第二类，我们可以把 (x,-1) 统一为 (-1,x)，这样不影响答案。\n对于第一类，设集合 S 表示满足 (A_{2i-1},A_{2i})=(-1,-1) 的 i 的集合。那么我们强制所有 (-1,-1) 在填完后的 \\min 是单减的。算出这个方案数后乘上 |S|! 就是答案。\n我们考虑 DP。考虑按照值域从大到小 DP，这样我们当前的数总是最小的。\n设 f(i,j,k) 表示填了权值 [i,2n] 的数，目前剩下 j 个天生的 (-1,x)，k 个后天的 (-1,x) 的方案数。天生就是第二类，后天就是第三类填了一个数上去。\n考虑数值 i 所在的位置的二元组 (A_{2x-1},A_{2x})： 第三类：那么这个 i 就是混子，f(i,j,k)\\gets f(i+1,j,k)。\n第二类：那么这个 i 可以选择新加一个天生的 (-1,x) 上去（因为它本来就是天生的），也可以选择与某个后天的 (-1,x) 合并（相当于你把 x 放在 (-1,i) 上）。但是它不能选择新加一个后天的 (-1,i)。因为它的命运是已经被安排的。\n第一类：它的选择最多。它可以新加一个后天的 (-1,x)，或者合并一个后天的 (-1,x)，或者合并一个先天的 (-1,x)。但是它不能新加一个先天的 (-1,x)。因为它不是第二类。 注意，在合并后天的 (-1,x) 的时候我们不考虑它选择的是哪一个 (-1,x)。因为我们强制了 (-1,-1) 是填完后是单减的，因此它理所当然选择最考前的那个后天的 (-1,x)。但是在合并先天的 (-1,x) 的时候我们就要考虑它的选择了，乘上一个 j 的系数即可。\n也可以用括号序列计数的方式理解这个 DP，相当于左右括号的匹配过程。时间复杂度 O(n^3)。\n更 多 题 解\n代码\nAGC031 E Snuke the Phantom Thief考虑枚举拿到的宝石数为 k。假设这些宝石的横坐标排序后为 x_1,x_2\\cdots,x_k。对于一个限制L a b，相当于 x_{b+1}\\ge a+1；对于R a b，相当于 x_{k-b}\\le a-1。纵坐标序列同理。\n那么我们就可以预处理出 k 个位置的横纵坐标的取值范围。这样就可以建模了。 源点连向 k 个 x 限制；\n每个 x 限制向可行的物品连边；\n每个物品拆点为边；\n物品连向可行的 y 限制；\nk 个 y 限制连向汇点。 相当于把横纵坐标的限制分开处理。合理设置容量和费用后计算费用流即可。\n时间复杂度 O(n^4)。\n代码\nAGC031 F Walk on Graph考虑倒着走。相当于我们 (u,x) 可以通过 (u,v,c) 转移到 (v,2x+c)。问 (s,0) 与 (t,r) 是否连通。\n考虑到 (u,x)\\to (v,2x+c)\\to (u,4x+3c)\\to (v,8x+7c)\\to \\cdots，发现 u,v 的状态是一个双射。即 (u,x)\\leftrightarrow (v,2x+c)。那么就转化为了无向图。\n然后考虑到 (u,v,a),(u,w,b)，我们可以交替走两条边使得 (u,4x+3b)\\leftrightarrow (u,4x+3a)。因此有 (u,x)\\leftrightarrow (u,x+3(a-b))。\n那么我们把两两边权差取一个 gcd，设为 g。那么显然 (u,x)\\leftrightarrow (u,x+3g)。\n咕咕咕","title":"IOI2020 国家集训队作业小结 5","updated":"2025-04-23T04:07:19.265Z"},{"categories":[{"name":"字符串","slug":"字符串","permalink":"https://notes.sshwy.name/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"path":"String/String-Improved/","tags":[],"text":"JSOI2007 字符加密把字符串倍长，求后缀数组后把前一半后缀对应的位置按序输出即可。\n即使字符串有循环节也是不要紧的。\n代码\nLuogu2870 Best Cow Line如果首尾字符不同就可以直接选择；如果相同，我们就比较这个前缀和后缀的字典序大小。可以证明这样是最优的。\n那么把这个串反过来在后面接上，然后中间插入一个分隔符，建立后缀数组即可。\n代码\nCF30 E Tricky and Clever Password我们考虑枚举中间点，manacher 计算最长回文串，那么整个串就划分为了 A+B+C，其中 B 是回文串。那么问题就转化为了 A 的前缀与 R(C) 的 LCP。R(S) 表示 S 的反串。那么我们就把原串倒过来，求出每个前缀与反串前缀的匹配长度（KMP），然后做前缀 Max 即可。\n时间复杂度 O(n)。\n代码\nCF873 F Forbidden Indices建立 SAM 后，把没有被禁止的点加 1 的贡献，然后 fail 树上做前缀和就可以统计答案了。\n代码\nCF547 E Mike and Friends题意：有 n 个串 s_1,\\cdots,s_i。定义 f(i,j) 表示 s_i 在 s_j 里出现的次数。有 q 次询问，每次询问 l,r,k，问 \\sum_{i=l}^r f(k,i)。\nn\\le 2\\times 10^5,q\\le 5\\times 10^5,\\sum |s_i|\\le 2\\times 10^5。\n考虑建立广义 sam，在插入一个串的时候在经过的所有结点上打上这个串的标记，表示这些状态以及它们在 fail 树上的祖先状态是这个串的子串。\n那么在 fail 树上向上合并后，我们就得到了每个状态是哪些串的子串。那么询问就可以处理了。\n使用线段树维护标记，线段树合并。复杂度 O(|\\Sigma|\\sum |s_i|\\log_2n+q\\log_2n)。\n代码\nNOI2018 你的名字\n给出一个字符串 S，每次询问 (T,l,r)，问所有 T 的本质不同的子串中，不在 S[l,r] 中出现的子串有多少个。\n|S|\\le 5\\times 10^5,\\sum |T|\\le 10^6。 第一部分首先考虑 l=1,r=|S| 怎么做。\n我们建立 T 的 SAM 来将相同的子串归到一个状态里。\n记 l(i) 表示 T[1,i] 的后缀与 S 的子串匹配的最长长度。对于 T 的 SAM 中的状态 x，记录 pos(x) 表示这个状态在 T 中结尾的位置（可能有多个位置，选择任意即可）。记 L(x) 表示 x 这个状态的长度（即 len(x)）。\n那么 l(pos(x)) 得到就是 x 这个状态与 S 匹配的最长长度。那么这个状态中不与 S 匹配的部分就是 L(x)-\\max(L(fail(x)),l(pos(x)))。于是答案就是 \\sum_x \\max(L(x)-\\max(L(fail(x)),l(pos(x))),0)第二部分接下来考虑 l,r 任意的情况。那么 l(i) 表示的就是 T[1,i] 的后缀与 S[l,r] 的子串匹配的最长长度。如果求出了 l(i) 那么我们就可以根据上面的式子求答案了。\n我们考虑在 S 的 SAM 接受 T 的时候计算 l(i)。具体地，记录一个 cur 表示当前与 S[l,r] 匹配的长度。每次我们尝试接受 T[i]： 如果当前状态的后继状态 tr(x,T_i) 中存在与 T[i-cur,i] 匹配且包含于 S[l,r] 的状态，那么就接受 T_i 并转移到后继状态，让 cur 自増，且 l(i)\\gets cur。\n否则我们让 cur 自减并再次检查是否存在匹配的状态。\n如果 cur=L(fail(x)) 那么就跳转到 fail(x) 状态。 如何判断当前状态的后继状态 tr(x,T_i) 中是否存在与 T[i-cur,i] 匹配且包含于 S[l,r] 的状态？对于每一个 SAM 上的状态 x 记录一个集合 Q(x) 表示 x 所代表的子串在 S 中出现的位置右端点的集合（即 Right 集合）。那么我们查询 Q(x) 中是否存在区间 [l+cur,r] 里的元素，就可以判断是否存在与 T[i-cur,i] 匹配且包含于 S[l,r] 的状态。\n使用线段树维护 Q(x) 即可，合并的时候使用线段树合并即可。\n时间复杂度 O(|S|(|\\Sigma|+\\log_2|S|)+\\sum |T||\\Sigma|)。\n代码","title":"字符串复习与进阶","updated":"2025-04-23T04:07:19.276Z"},{"categories":[],"path":"Math/Game-Theory/","tags":[{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"},{"name":"Game-Theory","slug":"Game-Theory","permalink":"https://notes.sshwy.name/tags/Game-Theory/"}],"text":"历时 4 天补完这部分内容。\nAGC002 E Candy Piles打表，发现对角线上的 DP 值是一样的。\n代码\nPE306 Paper-strip Game打表，有循环节。\n代码\nSPOJ COT3 - Combat on a tree暴力求 SG 是 O(n^3) 的。把贡献累计一下可以优化到 O(n^2)。\n我们考虑维护子树的策略集，然后向上合并。合并的时候需要做集合异或，合并，线段树（01TRIE）合并即可。复杂度 O(n\\log_2n)。\n题解详见 Sshwy’s Blog 博奕论。\n代码\nCF388 C Fox and Card Game我们考虑先手的上界。如果后手模仿先手的行为，那么先手可以把每一堆前一半拿走，后手可以把后一半拿走。如果是奇数个数的堆那么中间会剩下一个，这个由谁拿走，我们不好说。但是下界是可以确定的，就是每一堆拿一半。\n另一方面，如果先手可以通过某种方式拿到比一半还多的分，那么后手显然会模仿先手的行为来制止这种情况发生。\n因此，每个人都会各拿一半。至于个数为奇数的堆，在拿完这一堆后，主动权会转移。因此先手显然会贪心地拿奇数堆中中间数最大的那个，然后后手拿第二大的，然后先手拿第三大的……\n于是，我们每一堆各拿一半，把奇数中间的数拿出来排序，然后轮流分给先后手即可。\n代码\nCF494 E Sharti根据翻硬币的套路，我们只需要求每个格子单独为白色时的 SG 值的异或和即可。那么打表可以发现： sg(i,j)=\\min(\\operatorname{lowbit}(i),\\operatorname{lowbit}(j),\\operatorname{highbit}(k))于是，我们可以每次把 k 除以 2，矩形的边界也除以 2 并向“内”取整。然后做 O(\\log_2k) 次矩形面积并即可，根据需要来更新答案。\n时间复杂度 O(m\\log_2n\\log_2k)。\n代码\nCF794 E Choosing Carrot首先可以区间 DP，设 f(i,j) 表示区间 [i,j]，先手最大化，后手最小化，最终的值；g(i,j) 表示先手最小化，后手最大化，最终的值： f(i,j)=\\max(g(i,j-1),g(i+1,j))\\\\\ng(i,j)=\\min(f(i,j-1),f(i+1,j))打个表，发现对角线上的数相等，这样是可以做的。\n更严谨地，我们证明当 n 是偶数时整个序列的答案是 \\max(a_{\\frac{n}{2}},a_{\\frac{n}{2}+1})。那么先手只需要根据需要选择一个拿走，然后模仿后手的行为即可。\n当 n 是奇数的时候，我们相当于做一次 DP 转移，把 [1,n-1],[2,n] 的结果转移过来。\n这样就证明了对角线相同的结论是对的。然后查询区间 max 即可。\n时间复杂度 O(n)。\n代码\nAGC010 F Tree Game我们把先手选择的第一个点做为根，那么我们可以证明对于结点 u： 如果存在它的儿子结点 v 满足 a_u&gt;a_v 且 v 是必败态，那么 u 就是必胜态。证明很简单，如果后手想移到 u，你把它扔回 v 即可。\n其他情况，u 是必败态。并且当 u 是叶子时也是必败态。我们可以理解为是先手把后手逼下来的，那么往上走是不优的。如果往下走到 w，有两种情况：w 是必胜态，或者 a_v\\le a_w。两种情况都是先手必败，因此得证。 时间复杂度 O(n^2)。\n代码\nCF1110 G Tree-Tac-Toe首先考虑，把一个预先放有白点的结点变成一个人字结构： 变成 这样与原图是等价的。\n考虑先手在 B 放一个白子，那么后手一定会在 D 放。留下的 E 和 F 不会改变先后手的顺序，因此等价。并且先手肯定在一开始就会在 B 放白子。因为不放白不放啊。不然被后手抢了 B，显然对先手不优。于是我们就证明了它与原图是等价的。\n现在就变成了初始时没有白点的树结构。首先，如果存在一个 4 度以上的点，那么先手必胜： 另外，如果存在一个 3 度点，它的至少两个邻居都是非叶子结点，那么也先手必胜： 排除上述两种情况，可以发现这个图不可能有超过 2 个 3 度点。在这种情况下考虑一个骨头图： 这个骨头图可以理解为 这种状态显然是先手必胜。推广得到，如果骨头图中间的链长度为奇数，那么先手必胜。否则就是和局。\n如果整个图只有一个 3 度点或者没有 3 度点，那么显然也是和局。\n代码\nZR967 银我们把整个游戏左右翻转，最左边是黑子的条件就变成了最右边是黑子。根据翻硬币的套路，我们只需要求每个棋子单独是黑色时的 SG 值就是答案。\n打表发现，sg(i)=2^{\\operatorname{lowbit}(i)}。\n那么我们再构造一个函数 f(x)，表示把 x 的每一位变成它的高位异或和。即 f((0001001101)_2)=(0001110110)_2。相当于把 x 当成一个长度为 30 的数组，然后做后缀异或和。\n不加证明地，有 f(0)=0,f(i\\oplus j)=f(i)\\oplus f(j)，且 f 可逆（即构建了一个双射）。并且 \\bigoplus_{i=1}^nf(sg(i))=n那么有了这些结论，再来看题目。设当前局面的 SG 值是 X。相当于我们需要找到一个区间 [l,r]，满足位置 r 上的是黑子，且 \\bigoplus_{i=l}^rsg(i)=X这个条件等价于 \\bigoplus_{i=l}^rf(sg(i))=f(X)稍作化简就变成了 r\\oplus(l-1)=f(X)\\\\\nl-1=f(X)\\oplus r即对于一个固定的 f(X) 和 r，l-1 是唯一的（也可能不存在，因为我们要求 l\\le r）。思考发现，当且仅当 f(X) 的最高位在 r 的二进制下也为 1 的时候，才存在合法的 l。\n因此我们的问题变成了： 插入一个数\n删除一个数\n询问第 i 位为 1 的数的个数 数组维护即可。f(X) 可以在插入删除的时候顺便维护。\n时间复杂度 O((n+m)\\log_2n)。\n打表代码\n代码\nCF1033G取模为什么是对的？首先，新游戏 G’的获胜策略在老游戏下也成立（加一个模仿）。而如果老游戏的获胜策略在新游戏失败，那么在老游戏中后手也可以让它失败。因此新老游戏等价。\n我们强制 a&lt;b，那么对于一堆 v： v&lt;a：垃圾\na\\le v&lt;b：Alice 胜利\nb\\le v&lt;2a：一次性用品。\n\\max(2a,b)\\le v&lt;a+b：Alice 先手的大胜利；Bob 的一次性用品。 考虑只统计先后手获胜的方案数，因为 Alice 获胜与 Bob 获胜是对偶的。我们把上述决策树稍加整理，化简得到 我们要求不存在 2，设 s=a+b。那么 v&lt;a 或者 v\\ge s-a。得到 a\\ge \\min(s-v,v+1)我们要记录 3 的个数，即 s-a\\le v&lt;2a： a\\ge \\max\\left(s-v,\\left\\lfloor\\frac{v}{2}\\right\\rfloor+1\\right)存在 4： s-v\\le a\\le \\left\\lfloor\\frac{v}{2}\\right\\rfloor考虑把 v_i 从小到大排序。那么每次我们只需要统计 a\\in(v_{i-1},v_i] 时的获胜情况。\n首先不存在 2。因此 a\\ge v_{i-1}+1 且 a\\ge s-v_i。这两个条件把所有 v_i 是 2 的情况都 ban 掉了。\n在满足上述两个条件后，容易发现 v_1\\cdots v_{i-1} 都是垃圾，不用考虑。\n由于 4 最多出现 1 次，观察 4 的判定条件，发现 s-v\\le a 的条件已经满足了。因此满足 a\\le \\left\\lfloor\\dfrac{v}{2}\\right\\rfloor 的最多只有一个——由于 v_n 最大，因此只有 v_n 有选择权。\n这样，相当于 v_i\\cdots v_{n-1} 都满足 \\left\\lfloor\\dfrac{v}{2}\\right\\rfloor+1\\le a。结合 3 的判定条件，发现它们都是 3。这样就可以根据 i 的奇偶性判断当前是先手胜还是后手胜，然后进行统计。\n对于 v_n 是否选择 4，分情况讨论即可。在实现的时候也可不必，因为 3,4 的个数和都是奇数，可以直接统计到先手获胜的情况上。\n代码","title":"博弈论习题集","updated":"2025-04-23T04:07:19.268Z"},{"categories":[],"path":"IOI2020hw/AGC-part-4/","tags":[],"text":"AGC029 C Lexicographic constraints相当于要求我们建一个 TRIE。那么二分答案，然后用数组维护 TRIE 的右链即可。\n数组开不下，改成 map 即可。\n复杂度 O(n\\log_2^2n)。\nAGC030 C Coloring Torus\n对于一个 n \\times n 的网格，称 (r, c) 为处于第 r + 1 行，第 c + 1 列的格子。一个对网格的好的 k 染色是满足下述条件的染色方案： 每个格子被染成 1, 2, 3, \\cdots , k 这 k 种颜色之一。\nk 种中的每种颜色都被至少一个格子使用。\n对于任意颜色 i, j(1\\le i\\le k, 1 \\le j \\le k)，满足所有颜色为 i 的格子，其相邻的颜色 j 的格子个数相同。这里，与 (r, c) 相邻的格子为 ((r − 1) \\bmod n, c)，((r + 1) \\bmod n, c)，(r, (c − 1) \\bmod n)，(r, (c + 1) \\bmod n)（如果一个格子多次出现，那么会算多次）。 给出 k(1 \\le k \\le 1000)，选择一个 1 \\le n \\le 500，任意构造一个对 n \\times n 的网格的好的 k 染色。 当 k\\le 500 时，每行一个颜色。\n对于 n 是偶数：\nvoid make(int n)&#123; FOR(i,0,n-1)FOR(j,0,n-1)a[i][j]=(i+j)%n; FOR(i,0,n-1)if(i&amp;1)FOR(j,0,n-1)a[i][j]+=n;\n&#125;\n这样构造出来的矩阵是 k=2n 时的答案。\n观察发现，把矩阵中所有 n+i 的颜色替换为 i，矩阵的性质是不会被破坏的。那么我们可以用这个方法删掉一个颜色。\n因此直接构造一个 n=500 时的矩阵，然后删掉 1000-k 个颜色即可。\n时间复杂度 O(n^2)。\nAGC029 E Wandering TKHS考虑结点 u 比父亲多走到了哪些点。设 p_u 表示 u 的父亲。m(u) 表示路径 1\\sim p_u 中结点编号的最大值。令 Q(u,x) 表示 u 只经过 \\le x 的点能走到的后代结点数量（u 自己不算）。那么对于所有 u&gt;1，我们有 ans(u)-ans(p_u)=\n\\begin{cases}\nQ(u,m(u))+1 & (u&gt;m(p_u))\\\\\nQ(u,m(u))-Q(u,m(p_u)) & (u&lt;m(p_u))\n\\end{cases}原因是如果 u&gt;m(p_u)，那么以 p_u 为起点时就不会访问到 u，我们就要新加入 u 以及它子树中的信息。否则一定会访问到 u。但是从 p_u 出发只会经过 \\le m(p_u) 的点，而从 u 出发为经过 \\le m(u) 个点，所以要进行一定的修改。那么现在我们只要求出 Q(u,m(u)),Q(u,m(p_u)) 即可。\nQ 的转移式如下： Q(u,x)=\\sum_{v\\in Son(u),v\\le x} Q(v,x)+1直接递归记忆化，复杂度是对的。因为对于 Q(u,m(u))，我们找到所有它后代中第一次 &gt;m(u) 的点并剪掉它这棵子树，之后 u 的子树中点 v 的询问就只剩下 Q(v,m(u)) 了。同理 Q(u,m(p_u)) 递归到每个点也只有常数种询问。\n时间复杂度 O(n\\log_2n) 或 O(n)。\nAGC029 F Construction of a tree这题 sb 了。读题度锅了导致自闭。\n假设 1 是根，先网络流从每个集合里选一个数形成一个 2\\sim n 的排列，把它们看作每个集合的关键点。接下来从 {1} 开始贪心能找到父节点就接上去。相当于我们把每个集合的每个点与它的关键点连有向边，在图上 DFS。一个 DFS 生成树就是答案。\n显然能构造出来一定是对的，考虑中途一步不能构造出来的时候，说明无论如何与已经确定的 k 个点相关的边数都达不到 k 条，显然这在树中是不可能的，因此是无解的。","title":"IOI2020 国家集训队作业小结 4","updated":"2025-04-23T04:07:19.265Z"},{"categories":[],"path":"IOI2020hw/AGC-part-3/","tags":[],"text":"AGC028 C Min Cost Cycle首先，我们把这个 \\min(A_x,B_y) 改成，从 x 到 y 连两条边，一条是 A_x，一条是 B_y。那么我们选一条边连即可。这个问题与原问题等价。\n对于每个点 u，我们根据它的边被选择的状态分类。它的入边的边权可能是 B_u，也可能不是；出边边权可能是 A_u，也可能不是。这样就分成了 4 类点。我们记 0 表示不是，1 表示是，那么每个点的状态可以表示为二元组 (0/1,0/1) 的形式。\n对于所有点的二元组，显然 0 和 1 的总个数的相等的，都等于 n。有了这些二元组我们显然可以方便地求出答案。\n如果二元组中没有 (0,0) 和 (1,1)，那么必然所有的二元组要么是 (0,1)，要么是 (1,0)。如果同时出现 (0,1),(1,0) 显然会在某个点冲突。\n否则，二元组中必然存在相等数量的 (0,0) 和 (1,1)。剩下的就是若干个 (0,1) 和 (1,0)。注意到我们可以这样构造一个方案：(0,0),(1,1),(0,0),(1,0)\\cdots (1,0),(1,1),(0,1)\\cdots(0,1) 因此我们钦定了一个 (1,1) 的状态后，其他的就可以随便选了。\n于是我们分以上两种情况统计最小值即可。\n时间复杂度 O(n\\log_2n)。\n代码\nAGC028 D Chords考虑计算每一种连通块的贡献。设 f(i,j) 表示只考虑 [i,j] 中的点的所有连接情况，满足最大编号为 j，最小编号为 i 的连通块出现的次数。\n显然，只有在 [i,j] 长度为偶数，且不存在从 [i,j] 连出去的边的时候，DP 值才不为 0。\n设 g(i) 表示 2i 个点连 i 条边的方案数。显然有 g(i)=\\sum_{j=1}^i(2j-1)那么我们假设 [i,j] 中仍未匹配的点有 x 个。如果 x 是奇数那么 f(i,j)=0。否则区间 [i,j] 总共就有 g\\left(\\dfrac{x}{2}\\right) 种连边方案。但是我们要减掉不合法的。\n不合法的相当于存在一个 k，使得 [i,k] 与 [k+1,j] 不相交。那么设 [k+1,j] 里未匹配的点数为 z（显然 z 是偶数），那么减掉的方案就是 f(i,k)g\\left(\\dfrac{z}{2}\\right)。\n一个 DP 值对答案的贡献就是 f(i,j)g\\left(\\dfrac{y}{2}\\right)，其中 y 表示不在 [i,j] 的未匹配点的个数。\n时间复杂度 O(n^3)。\n代码\nAGC027 D Modulo Matrix\n构造一个 n \\times n 的矩阵 a，满足如下性质： 1 \\le a_{i,j} \\le 10^{15}；\n所有的 a_{i,j} 互不相同；\n存在一个正整数 m，满足对于任意两个行相邻或列相邻的元素 x,y，有 \\max(x, y) \\bmod \\min(x, y) 都是 m。 2 \\le n \\le 500，保证有解。 我们贪心地让 m=1。\n我们考虑把矩阵黑白染色。那么黑色的格子是互不相关的。我们把白色的格子填成四周的格子的 lcm 加 1 即可。\n考虑怎么把黑色格子填成互不相同的数？我们把黑色格子分两个方向的对角线。每一条对角线上我们乘一个质数上去。这样每个格子就是两个质数的积，且互不相同。第 1000 大的质数是 7919，因此可以过。\n注意 n=2 的时候要特判。\n时间复杂度 O(n^2)。\n代码\nAGC027 E ABBreviate设 a=1,b=2，那么我们证明，一个字符串 s 能变成字符 c，仅当以下任一条件满足： s=c。\ns 的权值和与 c 的权值在模 3 意义下同余，且 s 中存在两个相邻相同字符。 显然可以归纳法证明。\n那么考虑第二个推论：一个字符串 s 能变成字符串 t，仅当我们可以贪心地把 s 的一个前缀划分成 |t| 段使得每一段都能变成 t 的一个字符，且 s 剩余的那段后缀的权值和模 3 余 0。那么我们把这个剩下的一段并到第 |t| 段后面即可。\n因此我们贪心地在当前串后面构造 a,b，设 f(i) 表示贪心匹配能转移到 i 的方案数。答案显然是合法的 f(i) 的和。对于 s=ababab\\cdots 的情况要特判。其他的情况都无所谓。\n可能会关心当第 |t| 段和剩下的一段里都没有连续相同字符的时候，我们咋办？其实分析可以发现，我们可以合理安排合并的顺序使得 s 能变成 t。只要 s 中有两个相邻相同字符就行。\n时间复杂度 O(n)。\n代码\nAGC026 F Manju Game我们把一行黑白染色，假设黑色是奇数的格子，分值和为 B，白色是偶数的格子，分值和为 W。\n考虑 n 是偶数。\n那么我们可以证明，先手得分的上界和下界都是 \\max(B,W)。\n证明下界：先手可以选择左端点或者右端点，得到所有的黑色分值或者所有的白色分值。\n证明上界：后手显然会让先手尽可能得到少的分值。由于先手的下界是 \\max(B,W)，因此后手的上界是 \\min(B,W)。我们因此可以证明，后手一定能达到上界。当先手选择一个格子后，后手会选择一个方向来获得主动权，然后就可以选择与先手反色的格子，来得到所有白 / 黑色格子的分值，因此后手可以达到上界。\n于是 n 是偶数就可以直接输出 \\max(B,W) 和 \\min(B,W)。\n考虑 n 是奇数。\n容易证明，如果先手第一次选择了黑色的格子，那么后手的下界就是 W，那么先手的上界就是 B。另一方面，先手的下界也是 W（直接选择一个端点），于是这样的答案就是 (B,W)。\n那么如果先手第一次选择了一个白色格子呢？\n先手第一次选择了一个白色格子，那么后手在选择左边或者右边的格子后，主动权仍在先手。先手可以继续选择白色格子，然后后手 ban 掉左边或者右边的部分，继续做。而如果先手打算转而选择黑色格子，根据刚才的证明，先手的得分就加上当前剩下的所有黑色格子值，后手得分就加上剩下的白色格子值。\n你发现，先手决定了每次的决策点，而 ban 掉哪一边则由后手决定。换言之，我们设先手的基础分值是 W。那么最后会出现一个区间，先手的基础分值就减掉这个区间的白色分值，加上这个区间的黑色分值。\n假设我们确定了每次的决策点（假设先手选了 k 次白色格子），这 k 个决策点把整个序列就分成了 k+1 部分。在做了 k 次博弈后会剩下一个区间，而这个剩下的区间是由后手决定的！换言之，后手会找到一个区间，使得这个区间的白色分值减黑色分值尽可能大。这样先手就会减掉尽可能多的分值。\n这是一个可二分的问题。我们二分这个最大的分值，那么为了让先手赢，我们就要这个最大值尽可能小。于是相当于判定是否存在一种划分方案，使得划分后每一段的白色减黑色的分值都小于等于这个答案。这里的段数是没有规定的，只要你能划分出来即可（因为权值可能是负数，因此不要把它想成一个傻逼问题）。\n思考发现，我们记录一个前缀最大值即可在 O(n) 的时间内判定。\n因此总复杂度 O(n\\log_2n)。\n代码\nAGC027 F Grafting首先我们可以钦定一个点不动，让这个点当作根，变成有根树。\n然后一次 DFS 可以求出哪些点不用动。\n剩下的点我们要动，那么有动的先后关系。在 A 树上父亲比儿子后动，在 B 树上父亲比儿子先动。那么拓扑排序检查关系是否有环即可判断是否合法。\n还有一种情况，就是所有点都要动。那么我们 O(n^2) 枚举第一个动的点的方案，然后把这个点当作根即可。\n总时间复杂度 O(n^3)。\n代码\nAGC025 F Addition and Andition考虑做一次 and 的加法操作，我们实际上是从高位到低位循环，遇到 (1,1)（即两个数的这一位都是 1），就把这两位置为 (0,0)，然后再正序循环进位。进位的状态也是一个二元组，表示第一个数的进位，第二个数的进位。我们可以通过二元组的进位与否来完成这个过程。\n然后我们把这个过程做 k 次。但其实我们直接考虑每个进位进了多少次即可。具体地，在上述过程中，我们在正序循环进位的时候，如果又遇到了 (1,1) 的状态，我们就又把它置为 (0,0)，然后做进位的操作。这样做 k 次，如果第 k+1 次遇到了 (1,1) 的状态就不去动它，直接退出循环。因为我们的进位次数最多为 k。\n为啥这样是对的？主要原因是，前一个进位肯定追不上后一个进位。\n那么我们显然可以优化这个过程。我们把一段连续的相同二元组缩成一段。这样在进位的时候就可以快速转移。比如一个 (1,1) 的进位状态加在 (0,1,x) 的状态上，相当于我们分出一个 (1,0,1) 的状态，然后变成了把 (0,1) 的进位加在 (0,1,x-1) 上，那么相当于把 (0,1,x-1) 变成 (0,0,x-1)，然后把 (0,1 的进位加载下一个三元组上。\n我们用链表维护上述过程，每次在表头插入，如果遇到 (1,1) 就维护进位的过程即可。注意进位的次数不超过 k。\n复杂度使用势能分析，为 O(n+m+k)。\n代码","title":"IOI2020 国家集训队作业小结 3","updated":"2025-04-23T04:07:19.265Z"},{"categories":[],"path":"IOI2020hw/AGC-part-2/","tags":[],"text":"AGC 的题\nAGC025 D Choosing Points对于一个 d，我们把距离为 \\sqrt{d} 的点连边。考虑证明这是一个二分图。\n如果 d 是奇数，那么显然，做一个黑白染色即可。\n如果 d 是偶数，就把图旋转 45 度，变成两个错开的图，把单位设为 \\sqrt{2}，即把距离除以 \\sqrt{2}。那么相当于 d 除以 2。由于这两个错开的图互不相关（因为两个图之间的点距离为奇数），因此递归下去直到 d 为奇数，就完成了证明。\n那么我们对每个点开一个 pair，分别记录两个距离下的颜色。根据抽屉原理，一定存在一个 pair 的出现次数大于 n^2。那么就求出答案了。\n时间复杂度 O(n^2)。\n代码\nAGC024 F Simple Subsequence Problem定义标记 [s] 表示 s 的子序列集合。考虑构建一个子序列自动机。设二元组状态 (s,t) 表示 s[t]，那么我们找到 t 中 0 和 1 第一次出现的位置，可以贪心地转移到 s0[t_0] 和 s1[t_1]。其中 t_1 和 t_2 分别是 t 去掉第一个 0 的前缀、去掉第一个 1 的前缀得到的字符串。这样建出来的是一个 DAG。\n于是我们设 f(i,j,k) 表示长度为 i 的字符串 j，以第 k 位为分界，右边是中括号的走到这个状态的方案数。显然，把所有 x\\in S,[x] 的 DP 值设成 1，然后在 DAG 上转移一下，那么就可以得到 s 是多少个串的子序列了，即 s[\\varnothing] 的 DP 值。\n时间复杂度 O(n2^n)。\n代码\nAGC026 D Histogram Coloring注意到，如果第一列里有两个相邻同色方格，那么第二列之后的一定只有一种填色方法。而如果第一列是红蓝交错，那么第二列就有两种填色方法，之后同理。\n因此我们考虑一个类似删行的思路。设 f_0(l,r,h),f_1(l,r,h) 表示只考虑区间 [l,r] 的高度大于等于 h 的部分（即把高度减掉 h-1），填色的方案数。f_0 表示无限制，而 f_1 表示最底下的一行必须红蓝交错。\n转移的时候枚举第一列下两行的方格是否同色，那么可以得到 f_0(l,r,h)=2f_1(l,r,h+2)+f_0(l,r,h+1)\\\\\nf_1(l,r,h)=2f_1(l,r,h+2)+f_1(l,r,h+1)在边界情况（比如第一列的高度为 1）的时候可以缩短区间的长度，如果中间的有一个高度为 1 的，那么分两边求，然后乘起来即可。\n由于不同的高度差只有 O(n^2) 种，因此对于高度相同的一段可以矩乘优化。这样就做完了，但是难写。\n另一个做法是考虑横着做。设 f(i,j) 表示考虑前 i 列，其中后 j 列的最底下一行是一段极长的红蓝交错段，这样的方案数。\n转移的时候，考虑 [i-j+1,i] 内有几个完整的以 i 结尾的极长段，假设有 c(i-j+1,i) 个。\n每一段都有两种填色方案，因此有 f(i,j)=f(i-1,j-1)c(i-j+1,i)。\n另一方面，考虑 j=1 的情况。这时 i 和 i-1 同色，由于 i 上面部分的颜色我们还未确定，因此我们强制 i,i-1 同色后可以直接枚举 f(i-1,j),j\\in[1,i-1] 的和，再乘上 c(i,i) 来转移。\n时间复杂度 O(n^2\\log_2h)，c(i,j) 可以预处理。\n代码\nAGC026 E Synchronized Subsequence我们考虑将序列分成若干个 a,b 个数相等的段。对每一段分别考虑。\n如果这一段的第一个字符是 a，那么我们可以贪心地选择最长的形如ababab的串。\n如果第一个字符是 b，那么假设我们选了一对 (b,a)，那么我们选择这一对 ba 的下一对一定不会变劣。因此我们枚举一个后缀 pair 的方案，取字典序最大即可。\n对于每一段的最优解，显然我们是要么选要么不选。因此倒着取最优即可。\n时间复杂度 O(n^2)。\n代码\nAGC025 E Walking on a Tree首先猜结论：限制都可以达到。\n考虑我们用归纳法证明这个结论。对于一个叶子结点 u，如果经过它的边数小于 2，我们显然可以直接删掉这个点。因为它的贡献一定是 1。如果有大于等于 2 条边经过它，那我们就随便选两条边，假设为 (x,u),(y,u)，那么我们把 (x,u),(y,u) 删掉，加入一个 (x,y) 进去，把路径交上的限制都减 2，然后删掉这个 u 即可。这样我们就归约到了一个更小的问题。因此根据数学归纳法，就证明了这个结论。\n难点在于方案的构造。思考可以发现，上述过程实际上是规定了这两条边的方向状态。两条边中要改变一条的方向，或者说两条边要么都不改变，要么同时改变。因此我们想办法这些规定建成一个图，然后做一个类似染色的事情即可。\n具体地，我们类似删叶子的过程，我们在 DFS 的过程中先建立子树的规定，然后考虑当前 u 的父边的限制。如果限制小于 2 就不用管了。否则我们需要找到两条不冲突的边来规定状态。\n如果是子树延伸上的两条边，我们显然可以选。因对于这组边，为我们建立的规定始终是一样的，不会冲突。\n否则，我们可以选择两个不同子树的边。两个不同子树的边是互不相关的，因此也可以选。\n选完了就规定一下状态，然后记录一下当前结点有没有选，选了哪两条边，然后回溯即可。\n时间复杂度 O(nm)。\n代码","title":"IOI2020 国家集训队作业小结 2","updated":"2025-04-23T04:07:19.265Z"},{"categories":[],"path":"Math/Mobius-prob/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"莫比乌斯反演推论如果 f(d)=\\sum_{d|i,i\\le n}g(i)那么 g(d)=\\sum_{d|i,i\\le n}f(i)\\mu\\left(\\frac{i}{d}\\right)YY 的 GCD\n设 f(i) 表示 i 是否是质数。求 \\sum_{i=1}^n\\sum_{j=1}^mf(\\gcd(i,j))多组询问，n,m\\le 10^7,T\\le 10000。 原式为 \\begin{aligned}\n&\\sum_{i=1}^n\\sum_{j=1}^mf(\\gcd(i,j))\\\\\n=&\\sum_{d=1}^{\\min(n,m)}f(d)\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{j=1}^{\\left\\lfloor\\frac{m}{d}\\right\\rfloor}\\sum_{p|i,p|j}\\mu(p)\\\\\n=&\\sum_{d=1}^{\\min(n,m)}f(d)\\sum_{p=1}^{\\left\\lfloor\\frac{\\min(n,m)}{d}\\right\\rfloor}\\mu(p)\n\\left\\lfloor\\frac{n}{dp}\\right\\rfloor\\left\\lfloor\\frac{m}{dp}\\right\\rfloor\\\\\n=&\\sum_{T=1}^{\\min(n,m)}\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\left\\lfloor\\frac{m}{T}\\right\\rfloor\\sum_{d|T}f(d)\\mu\\left(\\frac{T}{d}\\right)\n\\end{aligned}设 h(T)=\\sum_{d|T}f(d)\\mu\\left(\\frac{T}{d}\\right)由于 h 大多数项都是 0，因此只需要预处理不是 0 的项，再做一个前缀和即可。\n代码\nLOJ6686 Stupid GCD\n求 \\sum_{i=1}^n\\gcd(\\left\\lfloor \\sqrt[3]{i} \\right\\rfloor,i)n\\le 10^{30}。 首先可以转化为枚举 \\left\\lfloor \\sqrt[3]{i} \\right\\rfloor： \\begin{aligned}\n&\\sum_{i=1}^n\\gcd(\\left\\lfloor \\sqrt[3]{i} \\right\\rfloor,i)\\\\\n=&\\sum_{i=1}^{\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor-1}\\sum_{j=i^3}^{(i+1)^3-1}\\gcd(i,j) + \\sum_{i=\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor^3}^n\\gcd(\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor,i)\\\\ \\end{aligned}第一部分\n\\begin{aligned}\n&\\sum_{i=1}^{\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor-1}\\sum_{j=i^3}^{(i+1)^3-1}\\gcd(i,j) \\\\\n=&\\sum_{i=1}^{\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor-1}\\sum_{j=0}^{3i^2+3i}\\gcd(i,j) \\\\\n=&\\sum_{i=1}^{\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor-1}i+(3i+3)\\sum_{j=1}^{i}\\gcd(i,j)\n\\end{aligned}化简后面的部分： \\begin{aligned}\n&\\sum_{j=1}^{i}\\gcd(i,j)\\\\\n=&\\sum_{d|i}d\\sum_{j=1}^{\\frac{i}{d}}\\left[\\gcd\\left(\\frac{i}{d},j\\right)=1\\right]\\\\\n=&\\sum_{d|i}d\\cdot \\varphi\\left(\\frac{i}{d}\\right)\n\\end{aligned}那么可以得到 \\begin{aligned}\n&\\sum_{i=1}^{\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor-1}i+(3i+3)\\sum_{j=1}^{i}\\gcd(i,j)\\\\\n=&\\sum_{i=1}^{\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor-1}(3i+3)\\sum_{d|i}d\\cdot \\varphi\\left(\\frac{i}{d}\\right)\n+\\sum_{i=1}^{\\left\\lfloor \\sqrt[3]{n}-1 \\right\\rfloor}i\\\\\n=&\\sum_{d=1}^{\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor-1} d\n\\sum_{i=1}^{\\left\\lfloor\\frac{\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor-1}{d}\\right\\rfloor}\n(3id+3)\\varphi(i)\n\\end{aligned}这显然可以分块了。\n第二部分\n\\begin{aligned}\n&\\sum_{i=\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor^3}^n\\gcd(\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor,i)\\\\\n=&\\sum_{i=0}^{n-\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor^3}\\gcd(\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor,i)\\\\\n\\end{aligned}那么可以得到 \\begin{aligned}\ng(x,n)=&\\sum_{i=1}^n\\gcd(x,i)\\\\\n=&\\sum_{d|x}d\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\left[\\gcd\\left(\\frac{x}{d},i\\right)=1\\right]\\\\\n=&\\sum_{d|x}d\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\sum_{p|\\frac{x}{d},p|i}\\mu(p)\\\\\n=&\\sum_{T|x}\\sum_{d|T}d\\sum_{i=1}^{\\left\\lfloor\\frac{n}{T}\\right\\rfloor}\\mu\\left(\\frac{T}{d}\\right)\\\\\n=&\\sum_{T|x}\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\varphi(T)\n\\end{aligned}于是原式即为 g(\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor,n-\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor^3)+\\left\\lfloor \\sqrt[3]{n} \\right\\rfloor。\n两个部分使用杜教筛处理 \\varphi,\\varphi\\cdot ID 的前缀和即可。时间复杂度 O(n^{\\frac{2}{9}})。\n代码\nNOI2016 循环之美\n\\begin{aligned}\n&\\sum_{i=1}^n\\sum_{j=1}^m[i\\perp j][j\\perp k]\\\\\n=&\\sum_{j=1}^m[j\\perp k]\\sum_{i=1}^n[i\\perp j]\\\\\n=& \\sum_{j=1}^m[j\\perp k]\\sum_{i=1}^n\\sum_{d|i,d|j}\\mu(d)\\\\\n=& \\sum_{j=1}^m[j\\perp k]\\sum_{d|j,d\\le n}\\left\\lfloor\\frac{n}{d}\\right\\rfloor\\mu(d)\\\\\n=& \\sum_{d=1}^n\\mu(d)\\left\\lfloor\\frac{n}{d}\\right\\rfloor\\sum_{j=1}^{\\left\\lfloor\\frac{m}{d}\\right\\rfloor}[jd\\perp k]\\\\\n=& \\sum_{d=1}^n\\mu(d)\\left\\lfloor\\frac{n}{d}\\right\\rfloor\\sum_{j=1}^{\\left\\lfloor\\frac{m}{d}\\right\\rfloor}[j\\perp k][d\\perp k]\\\\\n=& \\sum_{d=1}^n\\mu(d)\\left\\lfloor\\frac{n}{d}\\right\\rfloor[d\\perp k]\\sum_{j=1}^{\\left\\lfloor\\frac{m}{d}\\right\\rfloor}[j\\perp k]\\\\\n\\end{aligned}第一部分设 f(x)=\\sum_{j=1}^x[j\\perp k]则 f(x)=\\varphi(k)\\left\\lfloor\\frac{x}{k}\\right\\rfloor+f(x\\bmod k)对于 f(x),x\\in[0,k-1]，我们暴力求一下即可。\n原式化为 \\sum_{i=1}^n\\mu(i)[i\\perp k] \\left\\lfloor\\frac{n}{i}\\right\\rfloor f\\left(\\left\\lfloor\\frac{m}{i}\\right\\rfloor\\right)第二部分后面的做分块，考虑算前面的前缀和。设 \\begin{aligned}\ng(n,k)=&\\sum_{i=1}^n\\mu(i)[i\\perp k]\\\\\n=&\\sum_{i=1}^n\\mu(i)\\sum_{d|i,d|k}\\mu(d)\\\\\n=&\\sum_{d|k}\\mu(d)\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\mu(id)\\\\\n=&\\sum_{d|k}\\mu(d)\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\mu(i)\\mu(d)[i\\perp d]\\\\\n=&\\sum_{d|k}\\mu^2(d)\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\mu(i)[i\\perp d]\\\\\n=&\\sum_{d|k}\\mu^2(d)g\\left(\\left\\lfloor\\frac{n}{d}\\right\\rfloor,d\\right)\n\\end{aligned}递归下去即可，边界 g(n,1)=\\sum_{i=1}^n\\mu(i)。\n代码\nLuogu5348 密码解锁\n已知 \\sum_{d|x,x\\le n}f(x)=\\mu(d)求 f(m)。m\\le 10^9,\\frac{n}{m}\\le 10^9。 第一部分由莫比乌斯反演推论可以得到 \\begin{aligned}\nf(m)=&\\sum_{m|i,i\\le n}\\mu(i)\\mu\\left(\\frac{i}{m}\\right)\\\\\n=&\\sum_{i=1}^{\\left\\lfloor\\frac{n}{m}\\right\\rfloor}\\mu(im)\\mu\\left(i\\right)\\\\\n=&\\sum_{i=1}^{\\left\\lfloor\\frac{n}{m}\\right\\rfloor}\\mu^2(i)\\mu(m)[i\\perp m]\\\\\n=&\\mu(m)\\sum_{i=1}^{\\left\\lfloor\\frac{n}{m}\\right\\rfloor}\\mu^2(i)[i\\perp m]\n\\end{aligned}第二部分考虑把这个和式做一个递归： \\begin{aligned}\ng(n,k)=&\\sum_{i=1}^n\\mu^2(i)[i\\perp k]\\\\\n=&\\sum_{i=1}^n\\mu^2(i)\\sum_{d|i,d|k}\\mu(d)\\\\\n=&\\sum_{d|k}\\mu(d)\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\mu^2(id)\\\\\n=&\\sum_{d|k}\\mu^3(d)\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\mu^2(i)[i\\perp d]\\\\\n=&\\sum_{d|k}\\mu(d)g\\left(\\left\\lfloor\\frac{n}{d}\\right\\rfloor,d\\right)\n\\end{aligned}第三部分边界为 g(n,1)=\\sum_{i=1}^n\\mu^2(i)。\n我们考虑 \\mu^2(i) 的贡献。当且仅当 i 不含平方及以上的因子时，\\mu^2(i)=1，否则 \\mu^2(i)=0。\n因此我们要求 1\\sim n 中无平方因子的数的个数。那么考虑容斥，用整体减掉含有平方因子的数： \\sum_{i=1}^n\\mu^2(i)=n+\\sum_{i=2}^n\\mu(i)\\left\\lfloor \\frac{n}{i^2} \\right\\rfloor\\\\=\\sum_{i=1}^n\\mu(i)\\left\\lfloor \\frac{n}{i^2} \\right\\rfloor=\\sum_{i=1}^{\\sqrt{n}}\\mu(i)\\left\\lfloor \\frac{n}{i^2} \\right\\rfloor\\mu(i) 是容斥系数。注意在实现的时候不一定要直接前缀和。因为 \\mu(i) 只有在无重复因子的时候才有值，因此可以 DFS。\n原式为 \\mu(m)g\\left(\\left\\lfloor\\dfrac{n}{m}\\right\\rfloor,m\\right)。计算即可。复杂度能过。\n代码\nHDU4944 FSF’s game\n求 \\sum_{i=1}^n\\sum_{j=i}^n\\sum_{k|i,k|j}\\frac{ij}{\\gcd\\left(\\frac{i}{k},\\frac{j}{k}\\right)}多组数据，T,n\\le 5\\times 10^5。 第一部分\n\\begin{aligned}\n&\\sum_{i=1}^n\\sum_{j=i}^n\\sum_{k|i,k|j}\\frac{ij}{\\gcd\\left(\\frac{i}{k},\\frac{j}{k}\\right)}\\\\\n=&\\sum_{k=1}^nk^2\\sum_{i=1}^{\\lfloor\\frac{n}{k}\\rfloor}\\sum_{j=i}^{\\lfloor\\frac{n}{k}\\rfloor}\\operatorname{lcm}(i,j)\n\\end{aligned}设 f(n)=\\sum_{i=1}^n\\sum_{j=i}^n\\operatorname{lcm}(i,j)=\\sum_{j=1}^n\\sum_{i=1}^j\\operatorname{lcm}(i,j)。\n设 g(n)=\\sum_{i=1}^n\\gcd(n,i)。那么可以套路反演得到 g(n)=\\frac{1}{2}n\\left[\\left(\\sum_{d|n}d\\cdot \\varphi(d)\\right)-1\\right]+n那么我们做一个 g(n) 的前缀和就得到了 f(n)。现在原式化简为了 F(n)=\\sum_{k=1}^nk^2f\\left(\\left\\lfloor\\frac{n}{k}\\right\\rfloor\\right)直接计算可以做到 O(n+T\\sqrt{n}) 的复杂度，但不够快。\n第二部分我们考虑计算 F(i),i\\in[1,n]。考虑枚举 k，然后枚举 n，计算 k^2f\\left(\\left\\lfloor\\dfrac{n}{k}\\right\\rfloor\\right) 对哪些 F(i) 有贡献。对于 \\left\\lfloor\\dfrac{n}{k}\\right\\rfloor 相同的贡献，显然有贡献的是一段长度为 k 的区间（在末端长度小于等于 k）。因此差分一下，把区间加转化为单点加。然后做完后前缀和回来即可。\n预处理的时间是调和级数。因此总复杂度 O(n\\ln n+T)。\n代码","title":"莫比乌斯反演 - 进阶","updated":"2025-04-23T04:07:19.269Z"},{"categories":[],"path":"IOI2020hw/AGC-part-1/","tags":[],"text":"主要是 AGC 的题。\nAGC022 E Median Replace 给一个长度为奇数的含有 01? 的字符串 S，每次可以把一个长度为 3 的子串变成它们的中位数。你可以在? 处填 0 或 1。问有多少种填法，使得填完后我们可以通过若干次操作把整个字符串变成 1。\n|S|\\le 3\\times 10^5。 摘要：将合并的过程理解为是在遍历字符串的时候进行。构建自动机并 DP 计算方案数。\n考虑如何判断一个给定的 01 串是否美丽。我们尝试建立一个自动机： 我们可以把自动机的状态转移理解为在当前字符串的末位添加一个字符转移到的状态。举个例子，在 01 后接一个 1，我们可以合并 011 为 1 来得到 1 这个状态。当然，有时候我们并不需要合并操作。\n显然，1 和 11 是好的状态。\n考虑在自动机上 DP，f(i,j) 表示考虑字符串前 i 个字符，走到状态 j 的方案数。答案就是 f(n,1)+f(n,11)。\n代码\nAGC022 F Checkers\n题意：有 n 个棋子在数轴上，第 i 个棋子的坐标是 10^{100i}。每次你可以选择两个棋子，设坐标分别为 A,B。你可以以 B 为中心，将 A 对称过去，然后删掉 B。即 A 的坐标变成 2B-A。一直操作到只剩下一个棋子。问这个棋子有多少种可能的坐标。\nn\\le 50。 摘要：对称转化为连边，坐标方案数转化为多项式的系数方案数，转化为树的模型。树的形态确定了系数的绝对值，再按层 DP 来同时对树的形态与系数符号的方案计数。\n考虑一个初步转化。如果 A 对 B 做对称，相当于删掉 A,B，产生一个 2B-A 的点。我们可以理解为 A 向 B 连一条边（B 是 A 的儿子）。这样一个操作序列可以转化为一棵树。当然，同一棵树可能对应多个不同的操作序列。\n容易发现，最后一个棋子的坐标可以写成 n 元的多项式。式子里每个元素的系数一定是 \\pm 2^{dep(i)} 的形式，其中 dep(i) 表示 i 在树上的深度。因此我们只需要考虑每个元素的系数的符号对答案的贡献。\n考虑儿子对父亲的贡献：对于树上的一个点 u，如果 u 有奇数个儿子，那么等 u 合并了它的所有儿子后，u 的系数的符号会改变。也就是说如果一个点有奇数个儿子，那么它的系数符号就会受到 1 的贡献。\n考虑兄弟的贡献：如果一个点有偶数个儿子，那么这些儿子中有一半会受到 1 的贡献（即乘一个 -1），另一半则不会受到贡献；如果一个点有奇数个儿子，假设为 k，就有 \\left\\lfloor \\dfrac{k}{2} \\right\\rfloor 个点会受到 1 的贡献，其他点不会。\n因此一个点的系数符号，可以转化为它的儿子结点对它的贡献以及它的兄弟结点对它的贡献的方案数。现在问题转化为了在树的模型上进行方案数统计。\n考虑 DP。设 f(i,j) 表示一共有 i 个结点的树，且最后一层的结点上预支 j 个结点有奇数个儿子的方案数： 这里的方案数不是树的形态数，而是不同系数构成的序列的方案数；\n最后一层不是指所有叶结点，是深度最深的那些叶结点；\n预支的意思是不一定存在，但是我们假设它有奇数个儿子。 考虑边界，显然有 f(1,0)=f(1,1)=n。第一个点有 n 种选择。而这个点我们可以预支一个奇数点（奇数点指有奇数个儿子的结点），也可以预支一个偶数点。两者方案数都为 1。\n答案显然为 f(n,0)。\n考虑转移。首先我们枚举最后一层的下一层有 k 个结点，并且这 k 个点的父亲都在最后一层上。由于最后一层上有 j 个奇数点，因此 k\\ge j，并且 k,j 同奇偶。在这一层上，有 \\left\\lfloor \\dfrac{k-j}{2} \\right\\rfloor 个点会受到贡献（乘一个 -1）。即兄弟结点之间的贡献。\n但实际上这 k 个结点的贡献是啥我们并不知道，因为我们没有考虑这 k 个点的儿子结点的贡献。因此枚举这 k 个点中有 x 个点实际上受到了 1 的贡献（即系数为 -1）。由于我们已知有 \\left\\lfloor \\dfrac{k-j}{2} \\right\\rfloor 个点受到 1 的贡献，因此我们需要更改 \\left| x-\\left\\lfloor \\dfrac{k-j}{2} \\right\\rfloor \\right| 个点的贡献状态（如果 \\left\\lfloor \\dfrac{k-j}{2} \\right\\rfloor &lt; x 就要让一些点从 1 变成 -1，否则就要让一些点从 -1 变成 1）。因此我们预支这些点有奇数个儿子，这样就可以达到 x 这个数量了。\n转移的时候要计算一下组合数，相当于从 n-i 个点中选 k 个，再从 k 个中选 x 个。\n时间复杂度 O(n^4)。\n代码\nAGC023 F 01 on Tree\n题意：一个 n 个点的有根树，每个点上写了 0 或 1。现在求一个拓扑序使得点权序列的逆序对数最少。\nn\\le 2\\times 10^5。 摘要：树上贪心套路，每次将最优策略点与父节点合并（绑定）。\n假设一个点上有多个 01。设 u_0,u_1 表示这个结点里 0,1 的个数。我们考虑贪心地把结点合并到它的父节点上，合并的含义是一旦选择了这个父节点，我们就立刻选这个结点。那么对于结点 A 的两个儿子结点 B,C，我们考虑先合并 A,B 再合并 A,C 与先合并 A,C 再合并 A,B 的代价差： A_1B_0+(A_1+B_1)C_0 &lt; A_1C_0+(A_1+C_1)B_0\\\\\nB_1C_0 &lt; C_1B_0\\\\\n\\frac{B_0}{B_1} &gt; \\frac{C_0}{C_1}因此我们每次选择当前结点中 \\dfrac{u_0}{u_1} 最大的结点，把这个点和它的父节点合并即可。\n时间复杂度 O(n\\log_2n)。\n代码\nAGC023 D Go Home\n题意：有 n 个公寓在数轴上，坐标为 X_i。每个公寓有 P_i 个人。有一辆初始时位于坐标 S 的公交车，一开始所有人都在车上。车上的人都很聪明（带有博弈性质），每个人会投票选择一个方向（左或右），使得自己能尽可能早地到公寓。哪个方向的票数多，车就往哪个方向走一个单位。如果票数相同就走左边。问公交车把所有人都送达公寓的时间。\nn\\le 10^5,S\\le 10^9,X_i&lt;X_{i+1}\\le 10^9,X_i\\ne S,1\\le P_i\\le 10^9。坐标都是整数。 摘要：从规模小的问题推广到原问题。\n假设 P_1\\ge P_n，那么 1 号公寓一定比 n 号公寓先到。因为考虑到你往右走，最多走到 n-1 的位置后，就会开始往 1 走。\n于是聪明的 n 号公寓的人就会想方设法帮 1 号公寓的人投票。因为只有到了 1 号公寓后才会到 n 号公寓，即 P_1\\gets P_1+P_n，那么我们就可以删掉 n 号公寓。\n如果 P_1&lt;P_n 同理。这样可以递归求出我们找公寓的顺序。注意边界，当当前所有的公寓都在 s 的一边的时候，我们就直接顺着走过去即可。\n时间复杂度 O(n)。\n代码\nAGC024 D Isomorphism Freak\n题意：给一棵无根树。你可以任意给这棵树加点加边，只要保证它是棵树。另外，你需要给这棵树的结点染色，使得对于同色的结点 u,v，以 u 为根的树与以 v 为根的树同构（存在一个置换使得每条边一一对应）。你需要求出最少颜色数，以及在满足前者的条件下最少的叶子数。\nn\\le 100。 摘要：按层分类，补满来保证同构。枚举根或者一对根（即以边为根），统计最优解。\n我们考虑找一个类似中心的东西。那么我们以这个中心为根，把这棵树补满。这里补满的含义是，每一层结点的度数都相同。补满后我们让每一层的颜色都相同，显然满足题目的条件。这样颜色数就是深度。叶子数就是每一层的单点度数积。（这里的度数指除了父边的度）\n当然，中心也不一定为点，可能是一条边，那么这时就相当于是我们让这两棵树同构，那么同样的方法把两棵树补满即可。叶子数就是每一层的单点度数积再乘 2。\n因此我们没必要求出中心。直接枚举每个点和每个边，统计最小值即可。\n时间复杂度 O(n^2)。\n代码\nAGC024 E Sequence Growing Hard\n题意：求满足以下条件的 n+1 元组 (A_0,\\cdots,A_n) 的个数： A_i 是一个长度为 i 的整数序列，且元素的值在 [1,K] 内；\nA_{i-1} 是 A_i 的子序列；\nA_{i-1} 的字典序严格小于 A_i 的字典序。 n,K\\le 300。 摘要：A_{i-1} 里插入一个数得到 A_i，合理枚举插入的位置来防止算重，并转化为带权树的计数问题，通过 DP 计算。\n考虑我们在一个序列里插入一个数，如何让它的字典序变大？假设我们在数字 x 前插入 y，那么有两种情况： y&gt;x。\nx=y。然后在之后第一个不等于 x 的位置，这个数比 x 小。 仔细想想，我们不用考虑第二种情况。因为你可以直接在这个比 x 小的数前插入 y，转化为第一种情况。这样我们也防止了算重的问题。因此我们只考虑第一种情况。\n我们可以把这个 n+1 元组转化为 n+1 个二元组 (id,val)。第 i 个二元组表示第 i 次插入操作，表示我们在第 id 次操作插入的数前面插入一个 val。特殊地，当 id=0 时表示在序列末尾插入一个 val。\n这个操作可以转化为树的构建，即我们把 i 向 id 连边。这样就构成了一棵有根树，0 为根结点。因此我们的 n+1 元组最终转化为了一个 n+1 个结点的有根树。那么我们考虑树的计数。总结一下，这棵树满足以下条件： 结点总数为 n+1。\n每个点有一个二元组 (id,val)。\n父节点的 id,val 比子节点的 id,val 分别严格小。\n结点 val 的范围为 [0,K]，id 的范围为 [0,n] 且互不相同。\n根结点 val=0。（注意在此条件下根结点的 id 必为 0） 考虑 DP。设 f(i,j) 表示有 i 个结点，根结点的 val=j 的树的方案数。严格来说是满足以下条件的树方案数： 结点总数为 i。\n每个点有一个二元组 (id,val)。\n父节点的 id,val 分别比子节点的 id,val 严格小。\n结点 val 的范围为 [0,K]，id 的范围为 [0,n] 且互不相同。\n根结点 val=j。 转移的时候枚举 id=1 的点（是根结点的儿子）的子树的大小和 val 值。然后从剩下 i-2 个 id 中选择若干个 id 作为这个子树的 id 即可： f(i,j)=\\sum_{k=1}^{i-1}\\sum_{l=j+1}^K f(k,l)f(i-k,j)\\binom{i-2}{k-1}代码","title":"IOI2020 国家集训队作业小结 1","updated":"2025-04-23T04:07:19.265Z"},{"categories":[],"path":"Data-Structure/Line-Tree/","tags":[{"name":"English","slug":"English","permalink":"https://notes.sshwy.name/tags/English/"}],"text":"From neal’s blog\nby Kaban-5\nThere is the following nice technique called “line tree”. I do not know the exact origin of this trick: I learned it from editorial of a recent contest by 300iq.\nFormally, a line tree L_T of a tree T with weighted edges is such a tree with weighted edges, that: L_T and T have the same set of vertices.\nThe maximum weight on the path between vertices vv and uu is the same for trees T and L_T.\nL_T is, well, a line (so we can choose the order of the vertices on the line and the weights of edges between neighbouring vertices, but nothing else). If we already have a line tree, answering “maximum weight on a path” queries for T boils down to asking maximum on a subsegment of an array, which can be done with a sparse table.\nHow to construct a line tree efficiently (even its existence is not obvious)? We can do it recursively: pick an edge in T with the largest weight w, remove it, build line trees of two remaining connected components and connect them with an edge with weight w. This can be done in O(n\\log_2⁡n) with some small-to-large tricks and even in O(n) after sorting with linked list merging. The second property is easy to prove by induction over such construction.","title":"Line Tree","updated":"2025-04-23T04:07:19.263Z"},{"categories":[],"path":"DP/Interesting-DP-prob/","tags":[],"text":"杜老师给我讲的一道 DP 题～\n题目描述某省省选，共 n 个参赛选手，来自 m 所学校，省队名额为 a 人，每个学校最多进入 \\left\\lfloor\\frac{a}{k}\\right\\rfloor 个省队。决定省队名单的方案如下：将所有选手按成绩从高到低排序，如果加上这一位选手后，名单中的人数不超过 a 人，并且每个学校在名单中的人数不超过 \\left\\lfloor\\frac{a}{k}\\right\\rfloor，就让这位选手进队，否则就不让。\n给定 n,m,k，以及按照成绩从高到低排序后（可以认为不会出现相同分数），每个人是否进入了省队，你需要求出在省队总名额与进入省队人数相等的前提下，每个人所在学校的可能状态数。两个状态不同当且仅当存在一个人两个状态中所在的学校不同。答案可能很大，输出答案 \\bmod 998244353 即可。\n当然，你无法保证名单的正确性，所以答案可能为 0。\n输入格式：\n第一行包含三个正整数 n,m,k，表示参加省选的人数，学校的个数，名额限制的比例。\n第二行包含了一个长度为 n 的 01 串，第 i 位为 0 表示第 i 个人没有进省队，否则进了省队。\n输出格式：\n一行，表示可能的状态数 \\bmod 998244353。 这题的做法很抽象，将两个抽象方案的统计合在一起才能完成对原问题方案的统计。\n设 L=\\left\\lfloor\\frac{a}{k}\\right\\rfloor，同时设 c_i 表示前 i 个人中进省队的人数： c_i=\\sum_{j=1}^{i}[s_j=1]思路的出发点是这样的。如果 s_x=0，意味着第 x 个人被学校杀了，也就是说前 x-1 个人中恰有 L 个人和这个人属于一所强校。于是我们设 f(i,j) 表示考虑前 i 个人，恰好有 j 所强校，这些强校皆有 L 个人进省队，剩下 i-jL 个是不属于强校的杂鱼，这样的不同强校与杂鱼选手的位置的方案数。\n形式化地，设长度为 i 的序列 A 表示第 j 个人属于第 A_j 个学校（1\\le A_j\\le m）的方案，同时我们设一个布尔函数 C(A,x) 表示在方案 A 中，x 是否是强校： C(A,x)=\\left[\\left(\\sum_{j=1}^i[s_j=1\\wedge A_j=x]\\right)=L\\right]（注意，一个学校不可能有多于 L 个人进队）则我们认为两个方案 A,B 等价当且仅当： 对于任意 j\\in[1,i]，存在 C(A,A_j)=C(B,B_j)。即两个方案同一个位置上的人要么都属于强校，要么都是杂鱼；\n对于任意 p\\ne q\\in[1,i],C(A,A_p)=C(A,A_q)=1，存在 [A_p=A_q]=[B_p=B_q]。即方案中的两个人如果都属于强校，那么这两个人要么在两种方案中都属于同一个学校，要么都不属于同一个学校。 换句话说两个方案相同当且仅当任意选手的关系是相同的。这里的关系指是否是强校 / 杂鱼，强校还要区分是否是同一所强校。\n于是 f(i,j) 表示使用上述规则的不同的方案数。转移时枚举第 i 个人是否进省队： 进省队，则枚举是强校选手 / 杂鱼；如果是强校选手就枚举它属于哪一个强校（枚举 L-1 个人和他组一个强校）；如果是杂鱼就直接用 i-1 的方案转移。\n学校杀，则他一定是强校选手，枚举是哪一个强校。 综上得到： f(i,j)=\\begin{cases}\nf(i-1,j-1)\\dbinom{c_i-1-(j-1)L}{L-1}+f(i-1,j) & s_i=1\\\\\nf(i-1,j)j & s_i=0\n\\end{cases}边界 f(0,0)=1。 接下来我们考虑杂鱼的学校选择的方案统计。\n设 g(j,i) 表示恰好有 j 所强校满 L 人进队，剩下 i 个杂鱼进队的学校选择（但不考虑强校是哪所学校）的方案数。相当于总共有 t=jL+i 个人进队。注意这里指的是所有人进队！相当于把进队的人方案计算出来，最后乘上一个 f。\n我们同样用形式化的语言描述。设长度为 t 的序列 A 为第 j 个人属于第 A_j 个学校（1\\le A_j\\le m）的方案。关于 C(A,x) 的定义与上文相似，表示前 t 个人中 x 是否是强校。则两个方案 A,B 等价当且仅当 对于任意 j\\in[1,t]，存在 C(A,A_j)=C(B,B_j)。\n对于任意 j\\in[1,t],C(A,A_j)=0，存在 A_j=B_j。即杂鱼选的学校要一样。 通俗地说，g 就是把杂鱼的学校的具体选择考虑进去了。但这里不要求区分不同强校选手之间的位置关系（因为这个关系已经在 f 中被讨论过了），但会考虑强校与杂鱼选手之间的位置关系。\n转移的时候枚举最后一个人是哪个杂鱼学校，他只能在 m-j 所学校中选择。但这样有一个 Bug，就是可能他选了一个之后使得另一个学校刚好满 L 个人进队，成为强校（即 g(j+1,i-L) 的状态），因此要减掉这种不合法的状态： g(j,i)=g(j,i-1)(m-j)-g(j+1,i-L)\\binom{i-1}{L-1}(m-j)边界 g(j,0)=1。转移的时候 j 倒着转移即可。 最后统计答案，设 k'=\\left\\lfloor\\frac{a}{\\lfloor\\frac{a}{k}\\rfloor}\\right\\rfloor： \\sum_{j=0}^{\\min(k',\\frac{a}{L})}f(n,j)g(j,a-jL)m^{\\underline{j}}其中 m^{\\underline{j}}=m(m-1)\\cdots(m-j+1)，即 m 的 j 次下降幂。这个式子可以理解为，枚举强校个数，f(n,j) 枚举不同强校与杂鱼之间的位置关系，g(j,a-jL) 枚举杂鱼的学校选择方案，m^{\\underline{j}} 枚举强校的学校选择方案，这样统计方案数。\n总复杂度 O(nk)。","title":"「DP 趣题」进省队","updated":"2025-04-23T04:07:19.262Z"},{"categories":[],"path":"DP/ZROI1015-ISN/","tags":[],"text":"","title":"普转提 Day5 ISN","updated":"2025-04-23T04:07:19.262Z"},{"categories":[],"path":"Data-Structure/Block-List/","tags":[],"text":"给一个序列，初始时为空，要求支持两种操作： 在某个位置之前插入一个数；\n求某个区间中的数异或 x 的最大值。 这题如果平衡树的话会涉及到 Trie 的合并，复杂度 O(n\\log_2^3n)。于是可以勇一波块链上去。在经过精细调参之后成功比暴力快了。加了快读后就更快了。\n这次是采用动态分配内存的方式实现的，似乎常数挺大。\n以后写分块算法的题要留一些时间调参。\n#include&lt;algorithm>/*&#123;&#123;&#123;*/\n#include&lt;cctype>\n#include&lt;cassert>\n#include&lt;cmath>\n#include&lt;cstdio>\n#include&lt;cstring>\n#include&lt;cstdlib>\n#include&lt;ctime>\n#include&lt;iostream>\n#include&lt;map>\n#include&lt;queue>\n#include&lt;set>\n#include&lt;vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair&lt;int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i&lt;=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA&#123; int r(int p)&#123;return 1ll*rand()*rand()%p;&#125; int r(int L,int R)&#123;return r(R-L+1)+L;&#125;\n&#125;/*&#125;&#125;&#125;*/\n/******************heading******************/\nchar nc()&#123; static char bf[100000],*p1=bf,*p2=bf; return p1==p2&amp;&amp;(p2=(p1=bf)+ fread(bf,1,100000,stdin),p1==p2)?EOF:*p1++;\n&#125;\nint rd()&#123; int res=0; char c=getchar(); while(!isdigit(c))c=getchar(); while(isdigit(c))res=res*10+c-'0',c=getchar(); return res;\n&#125;\nint tmp[20],lt;\nchar OBF[100000],*OBP=OBF;\nvoid flush()&#123; fwrite(OBF,1,OBP-OBF,stdout),OBP=OBF;\n&#125;\nvoid wrch(char x)&#123; if(OBP==OBF+99999)flush(); *OBP=x,++OBP;\n&#125;\nvoid wr(int x)&#123; lt=0; while(x)tmp[++lt]=x%10,x/=10; while(lt > 0) wrch(tmp[lt]+'0'), --lt;\n&#125;\nvoid wr(long long x)&#123; lt=0; while(x)tmp[++lt]=x%10,x/=10; while(lt > 0) wrch(tmp[lt]+'0'), --lt;\n&#125;\nvoid wr(const char * s)&#123; while(*s)wrch(*s),++s; &#125;\nvoid wr(char x)&#123; wrch(x); &#125;\nint max(int x,int y)&#123; return x>y?x:y; &#125;\ntypedef vector&lt;int> Vi;\nstruct list&#123; list * nex, * pre; Vi v; struct trnode&#123; bool e; trnode *g[2]; trnode()&#123; g[0]=g[1]=NULL, e=0; &#125; &#125; * tr; void trie_insert(const int&amp; x)&#123; trnode * u=tr; ROF(j,20,0)&#123; int c=x>>j&amp;1; if(u->g[c]==NULL)u->g[c]=new trnode; u=u->g[c]; &#125; u->e=1; &#125; int query(const int&amp; k)&#123; int res=0; trnode * u=tr; ROF(j,20,0)&#123; int c=k>>j&amp;1; if(u->g[!c]!=NULL)u=u->g[!c],res|=1&lt;&lt;j; else u=u->g[c]; &#125; return res; &#125; list()&#123; tr=new trnode;nex=pre=NULL;&#125; Vi::iterator insert(Vi::iterator it,const int &amp;x)&#123; trie_insert(x); return v.insert(it,x); &#125; Vi::iterator insert(int pos,const int &amp;x)&#123; return insert(v.begin()+pos,x); &#125; int &amp; operator[](int x)&#123; return v[x]; &#125; int size()&#123; return v.size(); &#125; void split()&#123; int sz=size(),mid=sz/2; if(sz==1)return; list * u = new list; u->pre=this,u->nex=this->nex,this->nex=u; FOR(i,mid,sz-1)u->insert(i-mid,v[i]); v.erase(v.begin()+mid,v.end()); tr->g[0]=tr->g[1]=NULL; for(int i:v)trie_insert(i); &#125;\n&#125;*L; int T,Lim,typ,lans;\nvoid insert(int pos,const int&amp; x)&#123; list * cur=L; while(cur->size()&lt;=pos&amp;&amp;cur->nex!=NULL)pos-=cur->size(),cur=cur->nex; cur->insert(pos,x); if(cur->size()>=Lim*2)cur->split();\n&#125;\nint query(int l,int r,const int&amp; k)&#123; int res=0; for(list * cur=L;cur!=NULL;cur=cur->nex)&#123; int sz=cur->size(); if(r&lt;0)break; if(l&lt;=0&amp;&amp;sz-1&lt;=r)res=max(res,cur->query(k)); else &#123; int X=max(l,0),Y=min(r,sz-1); FOR(i,X,Y) res=max(res,cur->v[i]^k); &#125; l-=sz,r-=sz; &#125; return res;\n&#125;\nint main()&#123; L=new list; T=rd(),typ=rd(); Lim=sqrt(T)*8; FOR(i,1,T)&#123; int op,x,y,z; op=rd(); if(op==0)&#123; x=rd(),y=rd(); if(typ)x^=lans,y^=lans; insert(x-1,y); &#125;else&#123; x=rd(),y=rd(),z=rd(); if(typ)x^=lans,y^=lans,z^=lans; int ans=query(x-1,y-1,z); wr(ans),wr('\\n'); lans=ans; &#125; &#125; flush(); return 0;\n&#125;","title":"一道块状链表题","updated":"2025-04-23T04:07:19.262Z"},{"categories":[],"path":"DP/Backpack-DP-on-tree/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"可能大家都知道树上背包合并 O(n^3) 对子树大小取 \\min 可以优化到 O (n^2)。但是对于树上依赖背包问题，背包合并的复杂度仍不能接受。考虑形式化的问题： 一棵 n 个结点有根树，每个结点 i 有 s_i 个价格为 c_i，价值为 v_i 的物品。除了根结点，要购买某个结点的物品必须在它的父节点购买至少一件。求总费用为 x 时的最大化价值。x,v_i\\le m。 一个朴素的 DP 是 f(i,j) 表示在结点 i 的子树中购买费用不超过 j 的物品的最大价值。转移时 O(m^2) 进行背包合并，总复杂度 O(nm^2)。\n我们考虑换一种 DP 的顺序。朴素 DP 是以递归子结构的形式进行 DP。考虑按照 DFS 序 DP。\n我们以后序遍历（先按序遍历子节点，再遍历根结点）的方式求出结点的 DFS 序。则对于结点 u，设其 DFS 序为 D_u，记它的子树大小为 S_u。同时我们记 DFS 序为 i 的结点为 V(i)。\n通俗地说，我们设 f(i,j) 表示在 DFS 序小于等于 i 的结点构成的连通块中选物品，总费用不超过 j 时的最大价值。转移的时候枚举 V(i) 上选不选物品，从 f(i-1),f(i-S_{V(i)}) 转移。\n如果上述状态定义不能理解，我们接下来做一些严谨的描述。首先给出后序遍历 DFS 序的一些性质： 如果 u 不是叶子结点，则 V(D_u-1) 是 u 的儿子（儿子序列中的最后一个儿子）\n对于树中的任意结点 u，如果 D_u\\ge S_u，则 V(D_u-S_u) 是离 u 最近的，存在前兄弟结点的祖先结点（也可能是 u 自己）的前兄弟结点。说的很绕口，可以自己画图理解一下。 知道这个以后，我们定义 P(i)=i-S_{V(i)}，即 DFS 序为 i 的结点由性质 2 导出的结点；如果 D_u&lt;S_u 则令 P(u)=0。\n因此更严谨地说，我们设 f(i,j) 表示在子树 V(i),V(P(i)),V(P(P(i))),V(P(P(P(i)))),\\cdots 构成的森林中按依赖关系选物品，总费用不超过 j 的最大价值。\n转移的时候，如果 V(i) 上选物品才能从 f(i-1) 转移（要选子节点必须选父节点上的东西）。此外在任何时候都可以从 f(P(i)) 转移。\n对于上述多重依赖背包问题，我们首先可以从 f(P(i)) 转移到 f(i)（直接复制）。然后我们强制选一个物品，可以从 f(i-1) 转移过来。然后对于剩下的 s_{V(i)}-1 个物品，使用单调队列优化多重背包或者二进制分组来更新 f(i) 即可。复杂度 O(nm) 或 O(nm\\log_2m)。\n//ZR 309\n#include&lt;algorithm>/*&#123;&#123;&#123;*/\n#include&lt;cctype>\n#include&lt;cassert>\n#include&lt;cmath>\n#include&lt;cstdio>\n#include&lt;cstring>\n#include&lt;cstdlib>\n#include&lt;ctime>\n#include&lt;iostream>\n#include&lt;map>\n#include&lt;queue>\n#include&lt;set>\n#include&lt;vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair&lt;int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i&lt;=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA&#123; int r(int p)&#123;return 1ll*rand()*rand()%p;&#125; int r(int L,int R)&#123;return r(R-L+1)+L;&#125;\n&#125;/*&#125;&#125;&#125;*/\n/******************heading******************/\nconst int N=5000,M=5000; struct qxx&#123;int nex,t;&#125;;\nqxx e[N*2];\nint h[N],le;\nvoid add_path(int f,int t)&#123;e[++le]=(qxx)&#123;h[f],t&#125;,h[f]=le;&#125;\n#define FORe(i,u,v) for(int i=h[u],v;v=e[i].t,i;i=e[i].nex) int n,m;\nint w[N],s[N],c[N]; int totdfn,sz[N];\nint f[N][M];\nint dfs(int u)&#123; sz[u]=1; FORe(i,u,v)sz[u]+=dfs(v); int i=++totdfn; int lim=s[u]; f[i][0]=0; // f[i,j] &lt;- f[i-sz[u],j] , f[i-1,j] for(int j=m;j>=0;j--)&#123; if(j>=c[u]) f[i][j]=max(f[i][j],f[i-1][j-c[u]]+w[u]);// 至少选一个物品，才能从 i-1 转移 f[i][j]=max(f[i][j],f[i-sz[u]][j]); &#125; --lim; for(int k=1;k&lt;=lim;lim-=k,k&lt;&lt;=1)&#123;// 在之前 i-1 和 i-sz 转移的基础上，加入多个物品（二进制） for(int j=m;j>=k*c[u];j--)&#123; f[i][j]=max(f[i][j],f[i][j-k*c[u]]+k*w[u]); &#125; &#125; if(lim)&#123;// 剩下一个二进制余项 for(int j=m;j>=lim*c[u];j--)&#123; f[i][j]=max(f[i][j],f[i][j-lim*c[u]]+lim*w[u]); &#125; &#125; return sz[u];\n&#125; int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); FOR(i,2,n)&#123; int x; scanf(\"%d\",&amp;x); add_path(x,i); &#125; FOR(i,1,n)&#123; scanf(\"%d%d%d\",&amp;w[i],&amp;c[i],&amp;s[i]); &#125; dfs(1); FOR(i,1,m)printf(\"%d%c\",f[totdfn][i],\" \\n\"[i==m]); return 0;\n&#125;","title":"树上背包 / 依赖背包的小技巧","updated":"2025-04-23T04:07:19.262Z"},{"categories":[],"path":"Math/Characteristic-Root-Method/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"特征方程特征方程可以用于求解线性递推数列的通项公式。其方法是将数列假设为一个等比数列并求出特征根，再代入初始数列的值求出特征根的系数得到通项公式。\n斐波那契数列我们以一个广为人知的数列举例。考虑斐波那契数列： F_0=0,\\\\\nF_1=1,\\\\\nF_n=F_{n-1}+F_{n-2}设 F_n=\\lambda^n，则可以得到 \\lambda^n=\\lambda^{n-1}+\\lambda^{n-2}令 n=2： \\lambda^2=\\lambda+1解方程得到 \\lambda_1=\\frac{1+\\sqrt{5}}{2},\\lambda_2=\\frac{1-\\sqrt{5}}{2}于是数列的通项公式可以表示为（特征根法的结论） F_n=p\\lambda_1^n+q\\lambda_2^n把 n=0,n=1 代入上式得到 p\\lambda_1+q\\lambda_2=1\\\\\np+q=0\np=\\frac{1}{\\sqrt{5}},q=-\\frac{1}{\\sqrt{5}}于是得到 F_n=\\frac{1}{\\sqrt{5}}\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n-\\frac{1}{\\sqrt{5}}\\left(\\frac{1-\\sqrt{5}}{2}\\right)^n","title":"特征根法小结","updated":"2025-04-23T04:07:19.267Z"},{"categories":[],"path":"DP/Dynamic-dp/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"DDP","slug":"DDP","permalink":"https://notes.sshwy.name/tags/DDP/"}],"text":"问题一考虑带修改最大子段和的问题： 给一个序列 a_i，支持 求最大子段和\n单点修改 求最大子段和有这样一个贪心做法，即遍历序列，令 cur=\\max(cur+a_i,a_i),ans=\\max(ans,cur)。\n让我们定义一种新的矩阵运算方式：(\\oplus,\\otimes)[AB]_{i,j}=\\bigoplus_{k}(A_{i,k}\\otimes B_{k,j})。因此我们可以得到 (\\max,+)\n\\begin{bmatrix}\na_i & -\\infty & a_i\\\\\n0 & 0 & -\\infty\\\\\n-\\infty & -\\infty & 0\n\\end{bmatrix} \\begin{bmatrix}\ncur\\\\\nans\\\\\n0\n\\end{bmatrix}=\n\\begin{bmatrix}\n\\max(cur+a_i,a_i)\\\\\n\\max(ans,cur)\\\\\n0\n\\end{bmatrix}这样最后的答案其实是 \\max(ans,cur)（不是直接取 ans，因为 cur 比 ans 多算了一次），初始矩阵 \\begin{bmatrix}\n-\\infty\\\\\n-\\infty\\\\\n0\n\\end{bmatrix}由于矩阵运算具有结合律，因此线段树维护矩阵快速幂同样可以解决本问题。\n问题二考虑带修改带点权树上最大权独立集问题： 给出一棵带点权有根树，支持： 修改点权；\n询问一棵子树的最大权独立集。 考虑暴力 DP，f(i,j) 表示以 i 为根的子树，i 是（j=1）否（j=0）在独立集中，的最大权独立集。容易得到 f(u,0)=\\sum_{v\\in Son(u)}\\max(f(v,0),f(v,1))\\\\\nf(u,1)=a_u+\\sum_{v\\in Son(u)}f(v,0)可以将转移式等价地写作 f(u,c)=a_u\\cdot c+\\sum_{v\\in Son(u)}\\max(f(v,0),f(v,1)-c\\cdot\\infty)将树链剖分，转化为链上的问题。假设重链上从浅到深第 i 个结点的编号是 i，且令 g(i,c)=a_i\\cdot c+\\sum_{j\\in Son(i)-\\{i+1\\}}\\max(f(j,0),f(j,1)-c\\cdot\\infty)表示它的轻儿子的 DP 值，则有 f(i,c)=g(i,c)+\\max(f(i+1,0),f(i+1,1)-c\\cdot\\infty)把 g(i,c) 丢到 \\max 里面去就能写成矩乘的形式了： (\\max,+)\n\\begin{bmatrix}\ng(i,0) & g(i,0)\\\\\ng(i,1) & -\\infty\n\\end{bmatrix}\n\\begin{bmatrix}\nf(i+1,0)\\\\\nf(i+1,1)\\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf(i,0)\\\\\nf(i,1)\\\\\n\\end{bmatrix}这样，这条重链的矩阵就是它轻儿子的 DP 值了。单点修改的时候，沿着链往上跳，并修改对应的 g(i,c)。\n#include&lt;algorithm>\n#include&lt;cctype>\n#include&lt;cassert>\n#include&lt;cmath>\n#include&lt;cstdio>\n#include&lt;cstring>\n#include&lt;cstdlib>\n#include&lt;ctime>\n#include&lt;iostream>\n#include&lt;map>\n#include&lt;queue>\n#include&lt;set>\n#include&lt;vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair&lt;int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i&lt;=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\n/******************heading******************/\n#define int lld\nconst int N=1e5+5,MTX=2,INF=0x3f3f3f3f,LST=N&lt;&lt;2; int n,m;\nint val[N]; struct qxx&#123;int nex,t;&#125;;\nqxx e[N*2];\nint h[N],le;\nvoid add_path(int f,int t)&#123;e[++le]=(qxx)&#123;h[f],t&#125;,h[f]=le;&#125; struct mtx&#123;/*&#123;&#123;&#123;*/ int r,c; int w[MTX][MTX]; mtx()&#123; r=c=0; &#125; mtx(int _r,int _c)&#123; r=_r,c=_c; FOR(i,0,r-1)FOR(j,0,c-1)w[i][j]=-INF; &#125; mtx(int _r)&#123; r=c=_r; FOR(i,0,r-1)FOR(j,0,c-1)w[i][j]=i==j?0:-INF; &#125; mtx(int _r,int _c,int _w[MTX][MTX])&#123; r=_r,c=_c; FOR(i,0,r-1)FOR(j,0,c-1)w[i][j]=_w[i][j]; &#125; mtx operator*(mtx m)&#123; //assert(c==m.r); mtx res(r,m.c); FOR(i,0,r-1)FOR(j,0,m.c-1)FOR(k,0,c-1) res.w[i][j]=max(res.w[i][j],w[i][k]+m.w[k][j]); return res; &#125; mtx operator*=(mtx m)&#123; return *this=*this*m; &#125; void print()&#123; FOR(i,0,r-1)&#123; printf(\"|\"); FOR(j,0,c-1)if(w[i][j]==-INF)printf(\"-INF\");else printf(\"%3lld \",w[i][j]); printf(\"|\"); puts(\"\"); &#125; puts(\"\"); &#125;\n&#125;;/*&#125;&#125;&#125;*/ mtx tree_mt[N];\nint totdfn; namespace seg&#123; mtx mt[LST]; void pushup(int u)&#123; mt[u]=mt[u&lt;&lt;1]*mt[u&lt;&lt;1|1];//left multiply &#125; void build(int u=1,int l=1,int r=totdfn)&#123; if(l==r)return mt[u]=tree_mt[l],void(); int mid=(l+r)>>1; build(u&lt;&lt;1,l,mid),build(u&lt;&lt;1|1,mid+1,r); pushup(u); &#125; mtx query(int L,int R,int u=1,int l=1,int r=totdfn)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return mt[u]; int mid=(l+r)>>1; mtx res(MTX); if(L&lt;=mid)res*=query(L,R,u&lt;&lt;1,l,mid); if(mid&lt;R)res*=query(L,R,u&lt;&lt;1|1,mid+1,r); return res; &#125; void assign(int p,mtx matrix,int u=1,int l=1,int r=totdfn)&#123; if(l==r)return mt[u]=matrix,void(); int mid=(l+r)>>1; if(p&lt;=mid)assign(p,matrix,u&lt;&lt;1,l,mid); else assign(p,matrix,u&lt;&lt;1|1,mid+1,r); pushup(u); &#125;\n&#125; int dep[N],hvs[N],sz[N],tp[N],bt[N],fa[N],dfn[N];\nint f[N][2],g[N][2];\nint dfs1(int u,int p)&#123;/*&#123;&#123;&#123;*/ dep[u]=dep[p]+1,sz[u]=1; fa[u]=p; for(int i=h[u];i;i=e[i].nex)&#123; const int v=e[i].t; if(v==p)continue; sz[u]+=dfs1(v,u); &#125; return sz[u];\n&#125;/*&#125;&#125;&#125;*/\nvoid dfs2(int u,int p,int to)&#123;/*&#123;&#123;&#123;*/ tp[u]=to,bt[u]=u,dfn[u]=++totdfn; int mx=0; for(int i=h[u];i;i=e[i].nex)&#123; const int v=e[i].t; if(v==p)continue; if(sz[v]>mx)mx=sz[v],hvs[u]=v; &#125; if(hvs[u])dfs2(hvs[u],u,to),bt[u]=bt[hvs[u]]; for(int i=h[u];i;i=e[i].nex)&#123; const int v=e[i].t; if(v==p||v==hvs[u])continue; dfs2(v,u,v); &#125; //printf(\"u=%lld,hvs=%lld,tp=%lld,bt=%lld\\n\",u,hvs[u],tp[u],bt[u]);\n&#125;/*&#125;&#125;&#125;*/\nvoid dfs3(int u,int p)&#123; for(int i=h[u];i;i=e[i].nex)&#123; const int v=e[i].t; if(v==p)continue; dfs3(v,u); if(v!=hvs[u]) g[u][0]+=max(f[v][0],f[v][1]), g[u][1]+=f[v][0]; else f[u][0]=max(f[v][0],f[v][1]), f[u][1]=f[v][0]; &#125; g[u][1]+=val[u]; f[u][0]+=g[u][0],f[u][1]+=g[u][1]; //printf(\"u=%-2d,f0=%-3d,f1=%-4d,g0=%-3d,g1=%-3d\\n\",u,f[u][0],f[u][1],g[u][0],g[u][1]); int t[MTX][MTX]=&#123;g[u][0],g[u][0],g[u][1],-INF&#125;; tree_mt[dfn[u]]=mtx(2,2,t); //tree_mt[dfn[u]].print();\n&#125; mtx f_mtx(int u)&#123;//calculate f[u][0],f[u][1] -> g_mtx[0][0],g_mtx[1][0] return seg::query(dfn[u],dfn[bt[u]]);\n&#125;\nvoid assign(int u,int v)&#123;//val[u]=v //printf(\"assign(%lld,%lld)\\n\",u,v); g[u][1]=g[u][1]-val[u]+v,val[u]=v; while(u)&#123; //printf(\"u=%lld\\n\",u); int t[MTX][MTX]=&#123;g[u][0],g[u][0],g[u][1],-INF&#125;; seg::assign(dfn[u],mtx(2,2,t)); u=tp[u]; mtx a=f_mtx(u);// 当前链顶的 f if(fa[u])&#123; g[fa[u]][1]=g[fa[u]][1]-f[u][0]+a.w[0][0]; g[fa[u]][0]=g[fa[u]][0]-max(f[u][0],f[u][1])+max(a.w[0][0],a.w[1][0]); &#125; f[u][0]=a.w[0][0],f[u][1]=a.w[1][0]; u=fa[u]; &#125;\n&#125;\nsigned main()&#123; scanf(\"%lld%lld\",&amp;n,&amp;m); FOR(i,1,n)scanf(\"%lld\",&amp;val[i]); FOR(i,1,n-1)&#123; int x,y; scanf(\"%lld%lld\",&amp;x,&amp;y); add_path(x,y),add_path(y,x); &#125; dfs1(1,0); dfs2(1,0,1); dfs3(1,0); seg::build(); FOR(i,1,m)&#123; int x,y; scanf(\"%lld%lld\",&amp;x,&amp;y); assign(x,y); mtx ans=f_mtx(1); printf(\"%lld\\n\",max(ans.w[0][0],ans.w[1][0])); &#125; return 0;\n&#125;\n/* * g[u,0]=sum_&#123;v!=hvs[u]&#125; max(f[v,0],f[v,1]) * g[u,1]=a[u] + sum_&#123;v!=hvs[u]&#125; f[v,0] * f[u,0]=g[u,0]+max(f[u+1,0],f[u+1,1]) * f[u,1]=g[u,1]+f[u+1,0] * f[leaf,0]=g[leaf,0]=0 * f[leaf,1]=g[leaf,1]=a[leaf] */\n问题三\n带点权 a_i 的有根树上，选择一个点可以覆盖它子树的叶子结点。问覆盖某个子树的叶子结点的最小代价。单点修改 朴素的 DP 是 f(u)=\\min\\left(a_u,\\sum_{v\\in Son(u)}f(v)\\right)设 g(u)=\\sum_{v\\in Son(u),v\\ne u\\text{'s heaviest son}}f(v)则得到 f(i)=\\min\\left(a_i,g(i)+f(i+1)\\right)于是得到 \\begin{bmatrix}\ng(i) & a_i\\\\\n\\infty & 0\n\\end{bmatrix}\n\\begin{bmatrix}\nf(i+1)\\\\\n0\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf(i)\\\\\n0\n\\end{bmatrix}问题四\nn 个人进行 n 轮游戏，第 i 轮第 i 个人可以选择让 x=(x+a_i)\\bmod n。初始时 x=0，游戏从编号为 0 的人开始。游戏结束后第 x 个人获胜。对于第 i 个人，只有当 x 变了后必胜，不变不必胜的时候才会选择变，并且这是一个 Common Knowledge。支持单点修改，问谁获胜。 手玩发现，只有当 x=(i-a_i)\\bmod n 时，第 i 个人才可能会动。因为每个人都只会想自己赢，不会把别人送赢。因此不能指望后面的人帮他把 x 变成 i。由此可以推出，如果 (i-a_i)\\bmod n&gt; i，则 i 不可能获胜。因为前面的 0\\sim i-1 只会把 x 变成自己，不会变得比自己大。于是我们想到 i-a_i 向 i 连边，这样可以构成一棵树，显然编号为 0 的点是根结点。\n沿着树边走到结点 u，相当于 u 选择变，把 x 从上一个结点编号变成了 u。于是我们定义 f_u 表示最优策略下 u 是否会动。则显然当 u 的儿子结点都不动时，u 选择动是必胜的： f_u=1-\\max_{v\\in Son(u)}f(v)\\\\\nf_{leaf}=1若根结点为 1 则根结点获胜。否则沿着它编号最小的儿子往下走，第一个 f_u=1 的点获胜。如果整颗树的 DP 值都是 0 则根结点也获胜。单点修改相当于修改某个点的父亲，则 LCT 维护动态 DP 即可。","title":"动态 DP 入门","updated":"2025-04-23T04:07:19.262Z"},{"categories":[],"path":"Data-Structure/Circle-Square/","tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"}],"text":"点双连通分量对于无向图 G=(V,E)，如果删掉它的任意一个结点，整个图仍连通，图 G 是点双连通图。\n如果图 G 的子图 G' 是点双连通图，则 G' 是 G 的点双连通分量。\n同一个点可能属于多个点双连通分量，但一条边只属于一个点双连通分量。\n可以在 Tarjan 求割点的时候顺便求点双连通分量。\n割点的邻边中必有割边，但邻边有割边的点不一定是割点。\n圆方树求出原图的所有极大点双连通分量，并给每个分量新建一个结点（方点），这个分量的其他点都连接这个方点。容易证明这样构造的结构是一个树形结构（因为有环的话可以合并成一个大的点双），称其为圆方树。\n显然，圆方树可以在 Tarjan 求点双的过程中构建。\n简单的性质圆方树上度数大于 1 的圆点是割点。\n例题\n给定 n 个点 m 条边的无向图, 每次操作将 u,v 之间所有必须经过的点权值加一，求操作完了之后每个点的权值。 n \\le 10^5 ,m, q \\le 2 \\times 10^6 。 显然，建出圆方树后就是树上的一条路径，则树上差分即可。\n由于是例题因此给出完整代码\n#include&lt;algorithm>/*&#123;&#123;&#123;*/\n#include&lt;cctype>\n#include&lt;cassert>\n#include&lt;cmath>\n#include&lt;cstdio>\n#include&lt;cstring>\n#include&lt;cstdlib>\n#include&lt;ctime>\n#include&lt;iostream>\n#include&lt;map>\n#include&lt;queue>\n#include&lt;set>\n#include&lt;vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair&lt;int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i&lt;=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA&#123; int r(int p)&#123;return 1ll*rand()*rand()%p;&#125; int r(int L,int R)&#123;return r(R-L+1)+L;&#125;\n&#125;/*&#125;&#125;&#125;*/\n/******************heading******************/\nconst int N=5e5+5,M=N; struct qxx&#123;int nex,t;&#125;;\nqxx e[M];\nint h[N],le=1;\nvoid add_path(int f,int t)&#123;e[++le]=(qxx)&#123;h[f],t&#125;,h[f]=le;&#125; int n,m,q; int dfn[N],low[N],totdfn;\nint s[N],tp;\nint vcc;\nnamespace G&#123; qxx G_e[N*2]; int G_h[M*2],G_le=1; int dep[N*2],fa[N*2][20],val[N*2]; void G_add_path(int f,int t)&#123;G_e[++G_le]=(qxx)&#123;G_h[f],t&#125;,G_h[f]=G_le;&#125; void G_add_both(int f,int t)&#123;G_add_path(f,t),G_add_path(t,f);&#125; void dfs(int u,int p)&#123; dep[u]=dep[p]+1,fa[u][0]=p; FOR(i,1,19)&#123; fa[u][i]=fa[fa[u][i-1]][i-1]; if(!fa[u][i])break; &#125; for(int i=G_h[u];i;i=G_e[i].nex)&#123; const int v=G_e[i].t; if(v!=p)dfs(v,u); &#125; &#125; void make(int u,int v)&#123; if(dep[u]&lt;dep[v])swap(u,v); int u1=u,v1=v; ROF(i,19,0) if(dep[u]-(1&lt;&lt;i)>dep[v])u=fa[u][i]; if(fa[u][0]==v)return val[u1]++,val[fa[v][0]]--,void(); if(dep[u]>dep[v])u=fa[u][0]; ROF(i,19,0) if(fa[u][i]!=fa[v][i])u=fa[u][i],v=fa[v][i]; u=fa[u][0]; val[u1]++,val[v1]++,val[u]--,val[fa[u][0]]--; &#125; void dfs2(int u,int p)&#123; for(int i=G_h[u];i;i=G_e[i].nex)&#123; const int v=G_e[i].t; if(v==p)continue; dfs2(v,u); val[u]+=val[v]; &#125; &#125;\n&#125;\nvoid tarjan(int u,int p)&#123; dfn[u]=low[u]=++totdfn; s[++tp]=u; for(int i=h[u];i;i=e[i].nex)&#123; const int v=e[i].t; if(!dfn[v])&#123; tarjan(v,u); low[u]=min(low[u],low[v]); if(dfn[u]&lt;=low[v])&#123; ++vcc, G::G_add_both(u,vcc+n); do &#123; G::G_add_both(s[tp],vcc+n); &#125;while(s[tp--]!=v); &#125; &#125; else low[u]=min(low[u],dfn[v]); &#125;\n&#125; int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q); FOR(i,1,m)&#123; int u,v; scanf(\"%d%d\",&amp;u,&amp;v); add_path(u,v); add_path(v,u); &#125; tarjan(1,0); G::dfs(1,0); FOR(i,1,q)&#123; int u,v; scanf(\"%d%d\",&amp;u,&amp;v); G::make(u,v); &#125; G::dfs2(1,0); FOR(i,1,n)printf(\"%d\\n\",G::val[i]); return 0;\n&#125;","title":"圆方树简介","updated":"2025-04-23T04:07:19.263Z"},{"categories":[],"path":"Math/Counting/","tags":[{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"}],"text":"A\n一个 n\\times m 的网格，每步只能向下或者向右走。有 k 个被 ban 掉的点，不能经过。问左上走到右下的方案数。n,m\\le 10^6,k\\le 10^3。 考虑容斥。设 f_i 表示经过第 i 个 banned 点，在这之前不走 banned 点，之后随便走的方案数。\n求 f_i 也可以对前半部分使用容斥，即第一次走到第 k 个 banned 点，在这之前不走 banned 点，然后随便走，走到第 i 个 banned 点，然后随便走的方案数。这样用经过 i 的总方案数减就能求 f_i。\n总复杂度 O(k^2)。\nBBZOJ 2287 有 n 个体积为 w_i 的物品，对于每一个 x，求出没有第 x 个物品的情况下剩下 n-1 个物品填满容积为 x 的背包的方案数。 整体的生成函数是 \\prod_{i=1}^n(1+x^{w_i})那么我们要求的就是 \\frac{\\prod_{i=1}^n(1+x^{w_i})}{(1+x^{w_k})}可以直接大除法，从低位往高位除。\n从它的组合意义去理解的话，设 f 表示所有物品的方案数背包，而 g 表示缺失第 k 个物品的方案数背包。则显然有 f_i=g_i+g_{i-w_k}。现在我们知道 f，要求 g，于是直接 g_i=f_i-g_{i-a_k} 即可。\n大除法也可以看成是从小到大的 DP 转移。\n代码\nCSRM 684 Medium\n一个长度为 n 的序列，满足每个元素都是 [1,k] 内的整数, 且对于相邻的两个元素 a=S_i ,b=S_{i+1} , 有 a\\le b 或 a \\bmod b \\ne 0。求这样的序列的个数模 10^9+7。 n,k\\le 50000。\n考虑容斥，转化为无限制减去 a&gt;b,b|a。这可以 DP，f_i 表示长度为 i 的序列的方案数，则转移的时候枚举 [j+1,i] 这一段是整除序列，然后 j,j+1 是无限制关系。由于 [j+1,i] 的长度是 O(\\log_2k) 的，因此预处理一下，直接转移就行了。\n二项式反演\nf_n=\\sum\\binom{n}{x}g_x\\\\\n\\Leftrightarrow g_n=\\sum\\binom{n}{x}(-1)^xf_x几道计数题Exercise 1\n给一棵有根树 T=(V,E)，求拓扑序方案数。 设 f(u) 表示 T_u 的拓扑序方案数。那么我们可以发现，它的儿子之间的顺序是无所谓的。于是这就是一个多重集的排列问题。|T_u| 表示子树 u 的大小。于是 f(u)=\\frac{(|T_u|-1)!}{\\prod_{(u\\to v)\\in E}|T_v|!}\\prod_{(u\\to v)\\in E}f(v)\\\\\nAns=n!\\prod_{u=1}^n\\frac{1}{|T_u|}算概率去理解。\n注：|T_u|-1 相当于 u 的儿子子树大小之和。\nExercise 2\n带标号无向连通图计数。 设带标号的无向图个数为 h，无向不连通图个数为 g，无向连通图个数为 f。 h(n)=2^{\\frac{n(n+1)}{2}}\\\\\nf(n)=h(n)-g(n)现在考虑求 g(n)。枚举 1 所在的连通块即可。枚举连通块大小，点的标号，剩下的点的连法可得 g(n)=\\sum_{i=1}^{n-1}\\binom{n-1}{i-1}f(i)h(n-i)如果你把 f 代换成 g 就发现，其实这只是一个关于 g 的递归式。所以为了减小常数可以只算 g 和 h，最后就能得到 f\nExercise 3\n一个串并联网络具有如下特征： 有一个起点和终点，至少一条边\n把两个网络的起点终点首位相接得到是仍是串并联网络\n把两个网络的起点终点并起来得到的仍是串并联网络\n并联时不考虑并联线路之间的顺序（即他们都是相同的） 现在给定边的数量，问串并联网络的个数。 这是一道小清新的题。事实上你发现，一个串并联网络具有树形结构。一个串联的整体下有若干个并联的线路，一个并联的整体下有若干个串联的线路。因此这就是一个树的结构，且奇偶层分别为串联和并联的结点。于是你根本不用管串联并联的问题，直接对树计数然后答案乘 2 即可。\n一个串联或者并联结构至少有两条线路。因此我们要求的是每个内部结点的儿子数大于 1的树的个数。设 f(n) 表示叶子结点总数为 n 的树的个数。\n由于你不考虑兄弟结点间的顺序，因此就要有一个单调性的限制。于是再定义 g(i,j) 表示叶结点数为 i，根结点的每颗子树最多包含 j 个叶子的树的方案数。显然，可以枚举包含 j 个叶子的子树数量求 g。假设有 k 个子树包含 j 个叶子，于是就相当于在 f(j) 个方案中选 k 个，可重复。这就是一个不定方程非负整数解的问题，答案为 \\dbinom{f(j)+k-1}{f(j)-1}=\\dbinom{f(j)+k-1}{k}： g(i,j)=\\sum_{k=0}^{\\left\\lfloor\\frac{i}{j}\\right\\rfloor}g(i-kj,j-1)\\binom{f(j)+k-1}{k}\\\\因为儿子数大于 1，因此 f(i)=g(i,i-1)","title":"计数题小结","updated":"2025-04-23T04:07:19.267Z"},{"categories":[],"path":"Data-Structure/Dsu/","tags":[],"text":"A\n加边，维护连通性 使用路径压缩，时间复杂度 O(n\\log_2n)。\n使用按秩合并，时间复杂度 O(n\\log_2n)。\n两个都用，时间复杂度 O(n\\alpha(n))。\nB\n加边，撤消上次加边，维护连通性 使用按秩合并，记录上次加的边对应的树边。这样在撤消的时候是 O(1) 的。\n时间复杂度 O(n\\log_2n)。\n可撤消并查集：\nstruct dsu&#123; int f[M],g[M]; void init(int n)&#123; FOR(i,0,n)f[i]=i,g[i]=1; &#125; dsu()&#123;&#125; dsu(int n)&#123;init(n);&#125; typedef pair&lt;pair&lt;int*,int>,int> ppi;//f[],val,time stack&lt;ppi> s; int current_time()&#123; return s.empty()?0:s.top().se; &#125; int get(int u)&#123; return f[u]==u?u:get(f[u]); &#125; bool find(int u,int v)&#123; return get(u)==get(v); &#125; void merge(int u,int v)&#123; int cur=current_time()+1; u=get(u),v=get(v); if(u==v)return; if(g[u]==g[v])&#123; s.push(mk(mk(f+u,f[u]),cur)), f[u]=v; s.push(mk(mk(g+v,g[v]),cur)), g[v]++; &#125; else &#123; if(g[u]>g[v])swap(u,v); s.push(mk(mk(f+u,f[u]),cur)), f[u]=v; &#125; &#125; void undo()&#123; int cur=current_time(); while(current_time()==cur)&#123; ppi u=s.top();s.pop(); *u.fi.fi = u.fi.se; &#125; &#125; void undo(int untiltime)&#123; while(current_time()>untiltime)undo(); &#125;\n&#125;;\nC\n支持加边，询问 \\sum_{i=1}^n\\sum_{j=i+1}^nL(i,j)L(i,j) 表示 i 和 j 最早在什么时候连通。 维护每个连通块的大小，加边的时候统计一下即可。\n时间复杂度 O(n\\alpha(n))。\nD\n支持加边，求两个点在什么时候连通。 路径权值为它被添加的时间，显然可以建树，倍增求路径最小值。时间复杂度 O(n\\log_2n)。\nE\n支持加边，询问第 x 个点在第 i 时刻所在连通块的大小。 显然可以离线，按时刻排序后可以顺着做一遍。\n还有一个在线的思路，就是每一条边的权值为它的出现时间，那么建一个 kruskal 重构树（就是在加边的时候新建虚点）。然后每个子树记录它非虚点的个数。显然，祖先路径上边的权值显然是从下到上递增的。这样问题就转化为求祖先路径上第一个权值大于 t 的边对应的结点，倍增搞一下就行。\nF\n给一个数组 \\left\\langle a_i \\right\\rangle_{i=1}^n，一开始全是 0，每次两种操作： 令 a_x=1；\n输出 \\left\\langle a_i \\right\\rangle_{i=x}^n 中第一个 0 的位置。 建立一个并查集，指向它右边第一个 0 的位置。初始时都指向自己。赋值相当于 f_x=get(x+1)。\nG\n给一个数组 \\left\\langle a_i \\right\\rangle_{i=1}^n, 一开始全是 0, 每次操作会将 \\left\\langle a_i \\right\\rangle_{i=l}^r 中还是 0 的全部变成 k。求最后的数组⻓什么样。 仍然是并查集指向下一个 0 的位置，直接暴力改就行，均摊并查集复杂度。\nH\n一个序列，支持区间开根，区间求和。 并查集指向右边第一个大于 1 的数，然后暴力改就行。\n均摊复杂度 O(n\\log_2n\\alpha(n))。\nI\n给定 \\left\\langle a_i \\right\\rangle_{i=1}^n,\\left\\langle b_i \\right\\rangle_{i=1}^n,\\left\\langle c_i \\right\\rangle_{i=1}^n，求 a_ib_j\\min_{k=i}^jc_k 的最大值。 把 c_i 按照从大到小排序，每次加入一个点，连接两边相邻点所在连通块。显然可以每个连通块维护 a_i,b_i 的最大值，然后在合并的时候更新答案。有一些细节需要考虑。\n复杂度 O(n\\log_2n)。\nJ\n给定一棵树，每次加边或者询问两个点之间是否有至少两条边不相交的路径。 即询问两个点是否在一个环上。手玩一下可以发现，每添加一条边相当于覆盖一条路径，当两个覆盖有重叠部分时它们就“连通”了，两个路径上的点都可以互达。于是就可以并查集，每次指向祖先路径上还没被覆盖的点。每个点记一个深度，然后就可以愉快并查集了。","title":"并查集的应用","updated":"2025-04-23T04:07:19.263Z"}],"categories":[{"name":"字符串","slug":"字符串","permalink":"https://notes.sshwy.name/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://notes.sshwy.name/tags/Notes/"},{"name":"Math","slug":"Math","permalink":"https://notes.sshwy.name/tags/Math/"},{"name":"Stirling-Number","slug":"Stirling-Number","permalink":"https://notes.sshwy.name/tags/Stirling-Number/"},{"name":"Automaton","slug":"Automaton","permalink":"https://notes.sshwy.name/tags/Automaton/"},{"name":"PAM","slug":"PAM","permalink":"https://notes.sshwy.name/tags/PAM/"},{"name":"Palindrome","slug":"Palindrome","permalink":"https://notes.sshwy.name/tags/Palindrome/"},{"name":"Tarjan","slug":"Tarjan","permalink":"https://notes.sshwy.name/tags/Tarjan/"},{"name":"Constructive","slug":"Constructive","permalink":"https://notes.sshwy.name/tags/Constructive/"},{"name":"Complete-Solution","slug":"Complete-Solution","permalink":"https://notes.sshwy.name/tags/Complete-Solution/"},{"name":"Expectation","slug":"Expectation","permalink":"https://notes.sshwy.name/tags/Expectation/"},{"name":"FWT","slug":"FWT","permalink":"https://notes.sshwy.name/tags/FWT/"},{"name":"FMT","slug":"FMT","permalink":"https://notes.sshwy.name/tags/FMT/"},{"name":"Original","slug":"Original","permalink":"https://notes.sshwy.name/tags/Original/"},{"name":"OI","slug":"OI","permalink":"https://notes.sshwy.name/tags/OI/"},{"name":"EGF","slug":"EGF","permalink":"https://notes.sshwy.name/tags/EGF/"},{"name":"Generating-Function","slug":"Generating-Function","permalink":"https://notes.sshwy.name/tags/Generating-Function/"},{"name":"Life","slug":"Life","permalink":"https://notes.sshwy.name/tags/Life/"},{"name":"DP","slug":"DP","permalink":"https://notes.sshwy.name/tags/DP/"},{"name":"Quadrangle-Inequality","slug":"Quadrangle-Inequality","permalink":"https://notes.sshwy.name/tags/Quadrangle-Inequality/"},{"name":"dysyn1314","slug":"dysyn1314","permalink":"https://notes.sshwy.name/tags/dysyn1314/"},{"name":"LP","slug":"LP","permalink":"https://notes.sshwy.name/tags/LP/"},{"name":"Linear-Programming","slug":"Linear-Programming","permalink":"https://notes.sshwy.name/tags/Linear-Programming/"},{"name":"Network-Flow","slug":"Network-Flow","permalink":"https://notes.sshwy.name/tags/Network-Flow/"},{"name":"Interactive","slug":"Interactive","permalink":"https://notes.sshwy.name/tags/Interactive/"},{"name":"Directed-MST","slug":"Directed-MST","permalink":"https://notes.sshwy.name/tags/Directed-MST/"},{"name":"DSU","slug":"DSU","permalink":"https://notes.sshwy.name/tags/DSU/"},{"name":"Graph","slug":"Graph","permalink":"https://notes.sshwy.name/tags/Graph/"},{"name":"KM","slug":"KM","permalink":"https://notes.sshwy.name/tags/KM/"},{"name":"Sieve","slug":"Sieve","permalink":"https://notes.sshwy.name/tags/Sieve/"},{"name":"Polynomial","slug":"Polynomial","permalink":"https://notes.sshwy.name/tags/Polynomial/"},{"name":"OGF","slug":"OGF","permalink":"https://notes.sshwy.name/tags/OGF/"},{"name":"Combinatorial","slug":"Combinatorial","permalink":"https://notes.sshwy.name/tags/Combinatorial/"},{"name":"WC2021","slug":"WC2021","permalink":"https://notes.sshwy.name/tags/WC2021/"},{"name":"数据结构","slug":"数据结构","permalink":"https://notes.sshwy.name/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"圆方树","slug":"圆方树","permalink":"https://notes.sshwy.name/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"},{"name":"CSP2020","slug":"CSP2020","permalink":"https://notes.sshwy.name/tags/CSP2020/"},{"name":"Provincial-selection","slug":"Provincial-selection","permalink":"https://notes.sshwy.name/tags/Provincial-selection/"},{"name":"SAM","slug":"SAM","permalink":"https://notes.sshwy.name/tags/SAM/"},{"name":"Suffix-Tree","slug":"Suffix-Tree","permalink":"https://notes.sshwy.name/tags/Suffix-Tree/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://notes.sshwy.name/tags/Codeforces/"},{"name":"Convex","slug":"Convex","permalink":"https://notes.sshwy.name/tags/Convex/"},{"name":"Geometry","slug":"Geometry","permalink":"https://notes.sshwy.name/tags/Geometry/"},{"name":"Hash","slug":"Hash","permalink":"https://notes.sshwy.name/tags/Hash/"},{"name":"English","slug":"English","permalink":"https://notes.sshwy.name/tags/English/"},{"name":"Game-Theory","slug":"Game-Theory","permalink":"https://notes.sshwy.name/tags/Game-Theory/"},{"name":"DDP","slug":"DDP","permalink":"https://notes.sshwy.name/tags/DDP/"}]}