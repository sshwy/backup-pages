<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>浅谈 Monad - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">浅谈 Monad</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2022年10月31日星期一下午3点35分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2022年10月31日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 4,383 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> 当前文章</div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#多态、泛型"><span class="toc-number">1.</span> <span class="toc-text">多态、泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类簇"><span class="toc-number">2.</span> <span class="toc-text">类簇</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functor"><span class="toc-number">3.</span> <span class="toc-text">Functor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Applicative"><span class="toc-number">4.</span> <span class="toc-text">Applicative</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Monad"><span class="toc-number">5.</span> <span class="toc-text">Monad</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算律探究"><span class="toc-number">6.</span> <span class="toc-text">运算律探究</span></a></li></ol></div><hr></div><div class="post-content"><p>Haskell 的学习曲线和 Vim 完全是反的。后者前期是一个竖直上升的难度，后来就平了。然而 haskell 看起来人畜无害，但是学了几节课后突然就进入了未知领域。笔者认为是有写一点东西的必要了。</p><h2><a id="多态、泛型" href="#多态、泛型" class="headerlink" title="多态、泛型"></a>多态、泛型</h2><p>首先我们从最普通的函数开始。比如说</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Int</span> <span class="token operator">-></span> <span class="token constant">Int</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是一个 map 函数，可以根据它的类型推断出它大概是接受一个修改 Int 类型值的函数与一个初始数组，然后它可以返回将这个函数应用于初始数组的每一个元素得到的最终数组。</p><p>这东西可以等价地理解为</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Int</span> <span class="token operator">-></span> <span class="token constant">Int</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时 map 的含义就变成了把一个 <code class="inline-code">Int -&gt; Int</code> 的函数变换为一个 <code class="inline-code">[Int] -&gt; [Int]</code> 类型的函数。</p><p>由此我们再做抽象，首先可以把底层类型多态化：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token builtin">map</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样对于任意一个 <code class="inline-code">a -&gt; b</code> 的函数我们都可以定义它对数组的 map 操作。</p><p>然后我们可以将外层类型泛型化：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">f</span> <span class="token hvariable">b</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样对于任何一个类型构造符 <code class="inline-code">f</code> 和底层类型变换函数 <code class="inline-code">a -&gt; b</code>，我们就都可以完成从 <code class="inline-code">f a</code> 到 <code class="inline-code">f b</code> 的变换。</p><p>听起来很简单，但是这个过程省略了很多东西：</p><ol><li><code class="inline-code">map&#39;</code> 中 <code class="inline-code">[a]</code> 是如何构造的？对于任意的类型 <code class="inline-code">a</code> 我们均可以构造关于此类型的列表。这是因为类型构造符 <code class="inline-code">[]</code> 提供了多态的支持。也就是说 <code class="inline-code">fmap</code> 中的 <code class="inline-code">f</code> 也应当是支持多态的。</li><li><code class="inline-code">map&#39;</code> 的具体实现我们没有给出，但是显然这无法由编译器自动完成。也就是说 <code class="inline-code">fmap</code> 的实现也需要我们自己给出。</li></ol><p>这样以来就出现了一些迷惑的地方。<code class="inline-code">map&#39;</code> 尚且是有用的，因为它可以避免我们对不同类型的列表定义不同类型的 <code class="inline-code">map</code>。但是这个 <code class="inline-code">fmap</code> 就有点无用了。对不同的类型构造符，他们的构造方式各不相同，因此我们得各自声明一个针对该类型的 <code class="inline-code">fmap</code> 函数。这有什么意义呢？</p><h2><a id="类簇" href="#类簇" class="headerlink" title="类簇"></a>类簇</h2><p>为了解释上文提到的问题，我们需要理解 Haskell 中类簇的意义。Haskell 不是面向对象语言，因此它的 class 和通常意义的 class 有本质的区别。简单来说 Haskell 的 class 更接近于一种性质集合。具有公共性质的一些类型可以抽象出一个共同的 class。比如说</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token keyword">class</span> <span class="token constant">Plusable</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
	<span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也就是说我们认为一个“可加”的类型应当具有一个加法运输符。class 中可以只声明运算符的类型，而其定义则在具体的类型中分别给出。</p><p>这样做的好处是可以将类型的性质划分到不同的 class 中，形成性质的依赖，这样就可以通过一些基本性质导出其他的性质。比如一个经典的例子</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token keyword">class</span> <span class="token constant">Eq</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
	<span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Bool</span>
	
	<span class="token punctuation">(</span><span class="token operator">/=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Bool</span>
	<span class="token hvariable">a</span> <span class="token operator">/=</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">==</span> <span class="token hvariable">b</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于具有“可判等”性质的类型，我们可以定义它们的“不等于”运算符。</p><h2><a id="Functor" href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><p>回到上文。对于具有 <code class="inline-code">fmap</code> 函数的类型，我们可以抽象出它们的 <code class="inline-code">fmap</code> 作为一个性质，得到一个 class：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>
	<span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
	
	<span class="token punctuation">(</span><span class="token operator">&lt;$</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">f</span> <span class="token hvariable">b</span> <span class="token operator">-></span> <span class="token hvariable">f</span> <span class="token hvariable">a</span>
	<span class="token punctuation">(</span><span class="token operator">&lt;$</span><span class="token punctuation">)</span> <span class="token operator">=</span>  <span class="token builtin">fmap</span> <span class="token operator">.</span> <span class="token builtin">const</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Functor（函子）类型不仅是 “可 fmap” 的，而且具有一个导出的运算符 <code class="inline-code">&lt;&#36;</code>。从它的定义我们可以推测它的作用是将第二个参数 <code class="inline-code">f b</code> 的类型构造符 <code class="inline-code">f</code> 应用在第一个参数 <code class="inline-code">a</code> 上。也就是说如果只给我们一个 <code class="inline-code">f b</code> 类型的变量（而且我们不知道 <code class="inline-code">f</code> 怎么用），让我们把 <code class="inline-code">a</code> 变成 <code class="inline-code">f a</code>，我们可以直接利用 <code class="inline-code">&lt;&#36;</code> 运算符完成同化。</p><p>除此以外我们可以将 <code class="inline-code">fmap</code> 理解为一个变种 <code class="inline-code">&#36;</code>：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token punctuation">(</span><span class="token operator">$</span><span class="token punctuation">)</span>   <span class="token operator">::</span>              <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-></span>   <span class="token hvariable">a</span> <span class="token operator">-></span>   <span class="token hvariable">b</span>
<span class="token punctuation">(</span><span class="token operator">&lt;$></span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
<span class="token punctuation">(</span><span class="token operator">&lt;$></span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">fmap</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也就是说对于一个具有 Functor 性质的类型 <code class="inline-code">f a</code>，我们可以将任意 <code class="inline-code">a -&gt; b</code> 的函数应用其上。</p><p>这时根据 Haskell 柯里化函数的特点，不难想到如下操作：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token hvariable">add</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">a</span>
<span class="token hvariable">add</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token hvariable">b</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么问题来了：我们有两个 <code class="inline-code">f a</code> 类型的变量 <code class="inline-code">fa</code> 和 <code class="inline-code">fb</code>，我们想将他们利用 <code class="inline-code">add</code> 函数都加起来，怎么做？</p><p><code class="inline-code">fmap add</code> 的类型为 <code class="inline-code">f a -&gt; f (a -&gt; a)</code>，也就说传入第一个参数后就会得到一个 <code class="inline-code">f (a -&gt; a)</code> 类型的函数，怎么样把剩下的参数传进去？</p><p>直觉上你可能回想把 <code class="inline-code">a -&gt; a</code> 从 <code class="inline-code">f</code> 中 “拿出来”。但是仔细一想就会发现这是拿不出来的。比如说当 <code class="inline-code">f</code> 是 <code class="inline-code">[]</code> 的时候。<code class="inline-code">[a -&gt; a]</code> 代表的是一系列的函数，你无法取出一个函数代表其中所有。更本质地说，类型构造符不是可逆的。所以“拿出来”和“放进去”的过程是不能等价变换的。</p><h2><a id="Applicative" href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h2><p>Functor 做不了的事，我们就让别人来做：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token operator">=></span> <span class="token constant">Applicative</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>
	<span class="token hvariable">pure</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">f</span> <span class="token hvariable">a</span>
	<span class="token punctuation">(</span><span class="token operator">&lt;*></span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">f</span> <span class="token hvariable">b</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Applicative（可应用的）具有的性质是，首先它可以将一个任意类型 <code class="inline-code">a</code> 的变量同化为 <code class="inline-code">f a</code>，也称为纯化。</p><p>然后它可以将 <code class="inline-code">f (a -&gt; b)</code> 类型的函数变量应用于 <code class="inline-code">f a</code> 和 <code class="inline-code">f b</code>。</p><p>这样也就解答了上文的疑惑。如果 <code class="inline-code">f</code> 也是 Applicative 的一个实例，那么我们可以</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token hvariable">add</span> <span class="token operator">&lt;$></span> <span class="token hvariable">fa</span> <span class="token operator">&lt;*></span> <span class="token hvariable">fb</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来实现函数的调用。当然我们可以直接使用 <code class="inline-code">pure</code> 将所有的计算全部放在 <code class="inline-code">f</code> 中进行：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token hvariable">pure</span> <span class="token hvariable">add</span> <span class="token operator">&lt;*></span> <span class="token hvariable">fa</span> <span class="token operator">&lt;*></span> <span class="token hvariable">fb</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然为了不干碎直觉，我们要求你实现的 <code class="inline-code">pure</code> 和 <code class="inline-code">&lt;*&gt;</code> 满足一些性质（其实 Functor <code class="inline-code">fmap</code> 也有要求）。这样上述两种写法才能等价。</p><p>于是你会发现，<code class="inline-code">add</code> 的作用效果还取决于 <code class="inline-code">&lt;*&gt;</code> 的定义。而 <code class="inline-code">pure</code> 和 <code class="inline-code">&lt;&#36;&gt;</code> 是有一定关系的，后者是 <code class="inline-code">fmap</code> 的一种快捷写法。</p><p>于是我们可以理解为，要把 <code class="inline-code">add</code> 函数“拿进” <code class="inline-code">f</code> 当中，需要经过 <code class="inline-code">fmap</code> 的过程，或者说 <code class="inline-code">pure</code> 的纯化。即便如此在应用 <code class="inline-code">fmap add</code> 的时候还是有 <code class="inline-code">&lt;*&gt;</code> 来时不时插一脚。因为 <code class="inline-code">add</code> 描述的是 <code class="inline-code">a -&gt; a -&gt; a</code> 的变换，而 <code class="inline-code">f (a -&gt; a -&gt; a)</code> 与 <code class="inline-code">f a</code> 的组合过程中还是需要一些粘合剂，来引导 <code class="inline-code">f a</code> 变成 <code class="inline-code">a</code> （如果能）再应用函数 <code class="inline-code">a -&gt; (a -&gt; a)</code> 然后变回 <code class="inline-code">f (a -&gt; a)</code> 的过程。第二个参数的计算过程同理。</p><p>当然 Applicative 还提供了一些有用的函数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token punctuation">(</span><span class="token operator">*></span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">f</span> <span class="token hvariable">b</span> <span class="token operator">-></span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
<span class="token punctuation">(</span><span class="token operator">&lt;*</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">f</span> <span class="token hvariable">b</span> <span class="token operator">-></span> <span class="token hvariable">f</span> <span class="token hvariable">a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>分别是取右和取左。</p><h2><a id="Monad" href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>在 Applicative 的基础上我们引入 Monad：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token keyword">class</span> <span class="token constant">Applicative</span> <span class="token hvariable">m</span> <span class="token operator">=></span> <span class="token constant">Monad</span> <span class="token hvariable">m</span> <span class="token keyword">where</span>
	<span class="token punctuation">(</span><span class="token operator">>>=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">m</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token hvariable">m</span> <span class="token hvariable">b</span> 
	
	<span class="token builtin">return</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
	<span class="token builtin">return</span> <span class="token operator">=</span> <span class="token hvariable">pure</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Monad 定义了一个新的运算符 <code class="inline-code">&gt;&gt;=</code> 来描述对 <code class="inline-code">m a</code> 应用一个 <code class="inline-code">a -&gt; m b</code> 的操作。然后把 <code class="inline-code">pure</code> 改写为了 <code class="inline-code">return</code>。</p><p>事实上 <code class="inline-code">&gt;&gt;=</code> 并不是任意定义的，它与 Applicative 的运算符 <code class="inline-code">&lt;*&gt;</code> 也得满足一些性质，但是这个性质比较不可读。我们可以从另一个推论来理解：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token hvariable">f</span> <span class="token operator">&lt;$></span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span>  <span class="token operator">=</span>  <span class="token hvariable">xs</span> <span class="token operator">>>=</span> <span class="token builtin">return</span> <span class="token operator">.</span> <span class="token hvariable">f</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也就是说 <code class="inline-code">&gt;&gt;=</code> 和 <code class="inline-code">fmap</code> 其实作用相似。要理解 <code class="inline-code">&gt;&gt;=</code> 的意义我们需要思考 <code class="inline-code">a -&gt; m b</code> 与 <code class="inline-code">a -&gt; b</code> 的区别。</p><p>不难发现，<code class="inline-code">a -&gt; m b</code> 的返回值是被包裹在一个 Monad 的类型构造符中，这意味着函数的返回值将不再那么确切，因为我们知道所有关于底层类型的函数如果要放在 Applicative 的类型构造符中应用的话，势必会用到 <code class="inline-code">fmap</code> 和 <code class="inline-code">&lt;*&gt;</code>，这两者将会在你提供的函数的基础上做进一步的包装和变换。</p><p>但是为什么我们需要一个返回值不那么确切的函数？要对 <code class="inline-code">m b</code> 类型做变换的成本显然比 <code class="inline-code">b</code> 更高。</p><p>这是因为很多计算方式并不具备非常好的函数式编程的特点，如果要将返回值清楚地写出来的话，将会有许多无用的信息（比如，返回值可能是一个巨大的元组）。而且这会增加我们理解它的成本。有了 Monad，相当于我们只需要提供一个 <code class="inline-code">a -&gt; m b</code> 的函数。从一个确切的 <code class="inline-code">a</code> 类型变换到 <code class="inline-code">m b</code> 我们是会的，因为 Monad 会提供 <code class="inline-code">return</code>，Applicative 也有 <code class="inline-code">pure</code> 函数可以使用。其他的部分（如何调用 <code class="inline-code">a -&gt; m b</code> 的函数）则交给 <code class="inline-code">&lt;&#36;&gt;</code> 和 <code class="inline-code">&lt;*&gt;</code> 完成。它的返回值究竟是不是确切的那个数已经不重要了。因为我们所有要做的事都写成了一个 <code class="inline-code">a -&gt; m b</code> 的函数。</p><p>换言之，不要去向怎么把 <code class="inline-code">b</code> 从 <code class="inline-code">m b</code> 中取出来（因为 Monad 会帮我们做）。不妨直接写我们要把取出来的 <code class="inline-code">b</code> 做怎样的变换。</p><p>当然，Monad 也提供了一些其他的运算符来帮助我们变换：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token punctuation">(</span><span class="token operator">>></span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">m</span> <span class="token hvariable">b</span> <span class="token operator">-></span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
<span class="token punctuation">(</span><span class="token operator">>></span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个操作相当于忽略前一个 Monad 的值，取后一个 Monad 的值。</p><p>另外，Haskell 为 Monad 设计了专门的语法糖，也就是 <code class="inline-code">do</code>：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token hvariable">eval</span> <span class="token operator">::</span> <span class="token constant">Expr</span> <span class="token operator">-></span> <span class="token constant">Maybe</span> <span class="token constant">Int</span>
<span class="token hvariable">eval</span> <span class="token punctuation">(</span><span class="token constant">Val</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">n</span>
<span class="token hvariable">eval</span> <span class="token punctuation">(</span><span class="token constant">Div</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">=</span> 
	<span class="token hvariable">eval</span> <span class="token hvariable">x</span> <span class="token operator">>>=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">n</span> <span class="token operator">-></span> 
	<span class="token punctuation">(</span><span class="token hvariable">eval</span> <span class="token hvariable">y</span> <span class="token operator">>>=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">m</span> <span class="token operator">-></span> 
	<span class="token hvariable">safediv</span> <span class="token hvariable">n</span> <span class="token hvariable">m</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">-- 等价于</span>
<span class="token hvariable">eval'</span> <span class="token operator">::</span> <span class="token constant">Expr</span> <span class="token operator">-></span> <span class="token constant">Maybe</span> <span class="token constant">Int</span>
<span class="token hvariable">eval'</span> <span class="token punctuation">(</span><span class="token constant">Val</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">n</span>
<span class="token hvariable">eval'</span> <span class="token punctuation">(</span><span class="token constant">Div</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">=</span> 
	<span class="token keyword">do</span>  <span class="token hvariable">n</span> <span class="token operator">&lt;-</span> <span class="token hvariable">eval</span> <span class="token hvariable">x</span>
		<span class="token hvariable">m</span> <span class="token operator">&lt;-</span> <span class="token hvariable">eval</span> <span class="token hvariable">y</span>
		<span class="token hvariable">safediv</span> <span class="token hvariable">n</span> <span class="token hvariable">m</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code class="inline-code">&lt;-</code> 可以理解为把上一个 Monad 的返回值取出来继续用。当然如果两个普通的 Monad 在 <code class="inline-code">do</code> 中相邻的话连接符就是 <code class="inline-code">&gt;&gt;</code>。</p><p>另外，每一个 <code class="inline-code">a -&gt; m b</code> 都可以被视作一个状态更新器。函数传入的 <code class="inline-code">a</code> 指代上一个状态，而返回的 <code class="inline-code">m b</code> 显然是下一个状态。</p><p>但是在这里还得扯几句。也许目前咱们已经对 <code class="inline-code">Maybe a</code> 这种 Monad 比较懂了，但是对于 Monad 到底是怎么做到辅助状态转移，将纯函数包装成“有状态的函数”，可能还是不太能上手。</p><p>为此我们需要思考 Haskell 状态保存的本质——通过函数传参实现。也就是说根本就没有全局变量，只不过是函数多加了一万个参数。</p><p>因此我们将 <code class="inline-code">m a</code> 的类型理解为 <code class="inline-code">state -&gt; (a, state)</code>。那么 <code class="inline-code">a -&gt; m b</code> 本质上是要求你根据捕获的 <code class="inline-code">a</code> 类型的值来返回一个 state 修改器，这个修改器还得顺便将 <code class="inline-code">a</code> 转换为 <code class="inline-code">b</code> 类型。</p><p>这个设计的妙处在于，你只需要写出 state 将会发生什么样的变化，而不需要关系 state 怎么被捕获的，和上文的地方也有相似之处。</p><h2><a id="运算律探究" href="#运算律探究" class="headerlink" title="运算律探究"></a>运算律探究</h2><p>接下来我们来分析一下 Functor、Applicative、Monad 各自满足怎样的运算律。这可以更好地帮助我们了解和阅读相关代码。</p><p>对于 Functor，它最基本的运算符是<code class="inline-code">fmap</code>，也就是 <code class="inline-code">&lt;&#36;&gt;</code>，首先它是有（左）单位元的：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token builtin">id</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">a</span>
<span class="token builtin">id</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token hvariable">a</span>
<span class="token comment">-- identity law</span>
<span class="token builtin">id</span> <span class="token operator">&lt;$></span> <span class="token hvariable">a</span> <span class="token operator">==</span> <span class="token hvariable">a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>另外它有复合律：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token comment">-- composition law</span>
<span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token operator">.</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token operator">&lt;$></span> <span class="token hvariable">a</span> <span class="token operator">==</span> <span class="token hvariable">f</span> <span class="token operator">&lt;$></span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token operator">&lt;$></span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token comment">-- or</span>
<span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token operator">.</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token operator">.</span> <span class="token builtin">fmap</span> <span class="token hvariable">g</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不过阅读 <a target="_blank" rel="noopener" href="https://github.com/quchen/articles/blob/master/second_functor_law.md">link</a> 可以知道，在 Haskell 中只要 <code class="inline-code">fmap</code> 的单位元性质成立，那么复合律自动成立。</p><p>Applicative 的运算律会更有意思。首先 <code class="inline-code">&lt;*&gt;</code> 有（左）单位元：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token comment">-- identity law</span>
<span class="token hvariable">pure</span> <span class="token builtin">id</span> <span class="token operator">&lt;*></span> <span class="token hvariable">a</span> <span class="token operator">==</span> <span class="token hvariable">a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>它也有复合律，不过这里的复合不再是 <code class="inline-code">.</code>，得用 <code class="inline-code">pure (.)</code>：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token comment">-- composition law</span>
<span class="token hvariable">pure</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">&lt;*></span> <span class="token hvariable">u</span> <span class="token operator">&lt;*></span> <span class="token hvariable">v</span> <span class="token operator">&lt;*></span> <span class="token hvariable">w</span> <span class="token operator">==</span> <span class="token hvariable">u</span> <span class="token operator">&lt;*></span> <span class="token punctuation">(</span><span class="token hvariable">v</span> <span class="token operator">&lt;*></span> <span class="token hvariable">w</span><span class="token punctuation">)</span>
<span class="token comment">-- or</span>
<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">&lt;$></span> <span class="token hvariable">u</span> <span class="token operator">&lt;*></span> <span class="token hvariable">v</span> <span class="token operator">&lt;*></span> <span class="token hvariable">w</span> <span class="token operator">==</span> <span class="token hvariable">u</span> <span class="token operator">&lt;*></span> <span class="token punctuation">(</span><span class="token hvariable">v</span> <span class="token operator">&lt;*></span> <span class="token hvariable">w</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>关于 <code class="inline-code">pure</code> 函数它还有同构律：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token comment">-- homomorphism law</span>
<span class="token hvariable">pure</span> <span class="token hvariable">f</span> <span class="token operator">&lt;*></span> <span class="token hvariable">pure</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">pure</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也就是说先纯化再应用等价于先应用再纯化。接下来是交换律：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token comment">-- interchange law</span>
<span class="token hvariable">u</span> <span class="token operator">&lt;*></span> <span class="token hvariable">pure</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">pure</span> <span class="token punctuation">(</span><span class="token operator">$</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">&lt;*></span> <span class="token hvariable">u</span>
<span class="token comment">-- or</span>
<span class="token punctuation">(</span><span class="token operator">&lt;*></span> <span class="token hvariable">pure</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token hvariable">u</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;*></span> <span class="token hvariable">u</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">pure</span> <span class="token punctuation">(</span><span class="token operator">$</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说先给你一个函数再告诉你传入的参数等价于先给你参数再告诉你应用到的那个函数。</p><p>Monad 的运算律就比较抽象了。为此我们先引入 Monad 复合运算：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token comment">-- The monad-composition operator</span>
<span class="token comment">-- defined in Control.Monad</span>
<span class="token punctuation">(</span><span class="token operator">>=></span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Monad</span> <span class="token hvariable">m</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">m</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">-></span> <span class="token hvariable">m</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token hvariable">m</span> <span class="token hvariable">c</span><span class="token punctuation">)</span>
<span class="token hvariable">f</span> <span class="token operator">>=></span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-></span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">>>=</span> <span class="token hvariable">g</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们就可以发现 <code class="inline-code">return</code> 是它的单位元：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token comment">-- identity law</span>
<span class="token builtin">return</span> <span class="token operator">>=></span> <span class="token hvariable">h</span> <span class="token operator">==</span> <span class="token hvariable">h</span>
<span class="token hvariable">h</span> <span class="token operator">>=></span> <span class="token builtin">return</span> <span class="token operator">==</span> <span class="token hvariable">h</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同时 <code class="inline-code">&gt;=&gt;</code> 具有结合律：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token comment">-- associativity law</span>
<span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">>=></span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">>=></span> <span class="token hvariable">c</span> <span class="token operator">==</span> <span class="token hvariable">a</span> <span class="token operator">>=></span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">>=></span> <span class="token hvariable">c</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2022年10月31日 第2次修订</li><li class="post-history-item">2022年10月17日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/Probset/21-March-2/">2021 省选三轮跟训日志 2</a></div><div class="prev-post"><a href="/Graph/Connected-components-algorithm/">连通分量相关算法 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>