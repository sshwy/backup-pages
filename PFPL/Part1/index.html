<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>「PFPL」 Judgements and Rules 学习笔记 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">「PFPL」 Judgements and Rules 学习笔记</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2022年12月6日星期二下午1点14分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2022年12月6日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 5,427 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> <a class="directory" href="/directory/PFPL/">PFPL </a><span class="icon smallarrow"></span> 当前文章</div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象语法树（Abstract-Syntax-Trees）"><span class="toc-number">1.</span> <span class="toc-text">抽象语法树（Abstract Syntax Trees）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象语法限定树（Abstract-Binding-Trees）"><span class="toc-number">2.</span> <span class="toc-text">抽象语法限定树（Abstract Binding Trees）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#归纳（Inductive-Definitions）"><span class="toc-number">3.</span> <span class="toc-text">归纳（Inductive Definitions）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条件判断（Hypothetical-Judgments）"><span class="toc-number">4.</span> <span class="toc-text">条件判断（Hypothetical Judgments）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条件归纳（Hypothetical-Inductive-Definitions）"><span class="toc-number">5.</span> <span class="toc-text">条件归纳（Hypothetical Inductive Definitions）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛化判断（General-judgements）"><span class="toc-number">6.</span> <span class="toc-text">泛化判断（General judgements）</span></a></li></ol></div><hr></div><div class="post-content"><script type="math/tex;mode=display">\gdef\Op{\mathcal{O}}
\gdef\So{\mathcal{S}}
\gdef\X{\mathcal{X}}
\gdef\Ast{\mathcal{A}}
\gdef\Abt{\mathcal{B}}
\gdef\imply{\Rightarrow}</script><p>本文是 Practical Foundations for Programming Languages 的学习笔记。</p><h2><a id="抽象语法树（Abstract-Syntax-Trees）" href="#抽象语法树（Abstract-Syntax-Trees）" class="headerlink" title="抽象语法树（Abstract Syntax Trees）"></a>抽象语法树（Abstract Syntax Trees）</h2><p>这里我们直接给出形式化定义：</p><ol><li>设<script type="math/tex">\So</script>为一有限类型集合。</li><li>设<script type="math/tex">\Op = \{\Op_s\}_{s\in \So}</script>表示每一个类型<script type="math/tex">s</script>拥有的运算符构成集合<script type="math/tex">\Op_s</script>，所有的<script type="math/tex">\Op_s</script>构成<script type="math/tex">\{\Op_s\}_{s\in\So}</script>，称作类型索引的运算符集合族（sort-indexed family of operators）。<script type="math/tex">n</script>元运算符<script type="math/tex">o\in \Op_s</script>，的元数（计算所需参数个数，arity）记作<script type="math/tex">ar(o) = (s_1, \ldots, s_n)</script>，其中<script type="math/tex">s_1, \ldots, s_n\in\So</script>，而<script type="math/tex">o</script>的运算结果类型为<script type="math/tex">s</script>。</li><li>类似地，定义<script type="math/tex">\X = \{\X_s\}_{s\in\So}</script>表示类型索引的变量集合族。</li></ol><p>这样，我们就可以定义 AST 的集合族<script type="math/tex">\Ast [\X] = \{ \Ast [\X]_s \}_{s\in\So}</script>为最小非空集合族满足：</p><ol><li>一个变量构成一个 AST：<script type="math/tex">x\in \X_s \imply x\in\Ast[\X]_s</script>。变量可以理解为类型为<script type="math/tex">s</script>的未知 AST。</li><li>一个运算符可以构造 AST：对于<script type="math/tex">o\in\Op_s</script>，<script type="math/tex">ar(o) = (s_1, \ldots, s_n)</script>，若<script type="math/tex">a_1\in\Ast[\X]_{s_1}, \ldots, a_n\in\Ast[\X]_{s_n}</script>，那么<script type="math/tex">o(a_1, \ldots, a_n)\in \Ast[\X]_s</script>。</li></ol><p><script type="math/tex">\Ast[\X]_s</script>可以理解为返回值类型为<script type="math/tex">s</script>的表达式。</p><p>有了这个定义，那么我们可以有一个类似的归纳推导性质的做法。比如我们要证明性质<script type="math/tex">P</script>对所有<script type="math/tex">a\in \Ast[\X]</script>成立，就可以按照 AST 的两条构造规则一一证明。</p><p>如果上下文里隐含了<script type="math/tex">x</script>的类型为<script type="math/tex">s</script>，那么我们就记<script type="math/tex">\X, x</script>表示把<script type="math/tex">x</script>插入到<script type="math/tex">\X_s</script>构成的新的变量集合族。</p><p>变量的替换：将<script type="math/tex">x = b</script>作用于 AST 记作<script type="math/tex">[b/x]</script>。也就是说</p><ol><li><script type="math/tex">[b / x] x = b</script>，<script type="math/tex">[b/x]y = y\, (y\ne x)</script>。</li><li><script type="math/tex">[b/x]o(a_1, \ldots, a_n) = o([b/x]a_1, \ldots, [b/x]a_n)</script>。</li></ol><p>显然这个替换的结果是唯一的。</p><p>但是我们知道在编程语言中还存在一种现象：某些语法/运算符只能在特定的上下文使用。这催生了作用域（scope）的概念。</p><p>举例来说，<code class="inline-code">let x = x * x in x + x</code> 展开之后就会变成 <code class="inline-code">x * x + x * x</code>。通常来说，这里的 <code class="inline-code">let x</code> 中的 <code class="inline-code">x</code> 作用于 <code class="inline-code">x + x</code>，而 <code class="inline-code">x * x</code> 中的 <code class="inline-code">x</code> 只是恰好与其名字相同，实质是另一个变量。类似 C++ 里局部变量和同名全局变量的关系。不过这个东西的行为因语言而异，比如 haskell 是允许循环定义的。</p><h2><a id="抽象语法限定树（Abstract-Binding-Trees）" href="#抽象语法限定树（Abstract-Binding-Trees）" class="headerlink" title="抽象语法限定树（Abstract Binding Trees）"></a>抽象语法限定树（Abstract Binding Trees）</h2><p>ABT 是 AST 的扩展。它给出了变量作用域的限定方式。比如我们想声明一系列的变量<script type="math/tex">x_1, \ldots, x_t</script>只作用于语法树<script type="math/tex">a</script>，我们记作<script type="math/tex">x_1, \ldots, x_t. a</script>。其中<script type="math/tex">x_1, \ldots, x_t</script>类型各异。为了方便，我们记为<script type="math/tex">\vec{x}.a</script>。</p><p>我们称<script type="math/tex">\vec{x}</script>的类型为<script type="math/tex">\vec{s}</script>当且仅当对任意<script type="math/tex">i</script>有<script type="math/tex">x_i</script>的类型是<script type="math/tex">s_i</script>。</p><p>在 ABT 中，运算符的类型表示为<script type="math/tex">ar(o) = ((\vec{s_1})s_1, \ldots, (\vec{s_n})s_n)</script>。<script type="math/tex">s_i</script>表示该语法树的类型，而<script type="math/tex">\vec{s_i}</script>表示该语法树的作用域下用到的各个变量的类型。</p><p>形式化地：</p><ol><li>设<script type="math/tex">\Op</script>为一个类型索引的运算符集合族。</li><li>设<script type="math/tex">\X</script>为一个类型索引的变量集合族。</li><li>为了处理不同作用域的变量名字相同，对于<script type="math/tex">\vec{x}</script>我们定义它的一个重命名（双射）<script type="math/tex">\pi : \vec{x} \leftrightarrow \vec{x}'</script>，对于类型为<script type="math/tex">(\vec{s})s</script>的语法树<script type="math/tex">a</script>，<script type="math/tex">\pi(a)</script>的含义就是对所有<script type="math/tex">j</script>将<script type="math/tex">a</script>中出现的所有<script type="math/tex">(\vec{x_i})_j</script>替换为<script type="math/tex">(\vec{x_i}')_j</script>。</li></ol><p>那么定义关于<script type="math/tex">\X</script>的 ABT<script type="math/tex">\Abt[\X]</script>为</p><ol><li><script type="math/tex">x\in \X_s \imply x\in \Abt[\X]_s</script>。</li><li>对于<script type="math/tex">o\in \Op_s</script>，且<script type="math/tex">ar(o) = ((\vec{s_1})s_1, \ldots, (\vec{s_n})s_n)</script>，设<script type="math/tex">\vec{x_i}</script>的类型是<script type="math/tex">\vec{s_i}</script>。对于<script type="math/tex">\vec{x_i}</script>我们定义它的重命名<script type="math/tex">\pi_i : \vec{x_i} \leftrightarrow \vec{x_i}'</script>，其中<script type="math/tex">(\vec{x_i}')_j \notin \X</script>。则对满足<script type="math/tex">\pi_i (a_i)\in \Abt[\X, \vec{x_i}']</script>的<script type="math/tex">a_i</script>，有<script type="math/tex">o(\vec{x_1}.a_1, \ldots, \vec{x_n}.a_n) \in B[\X]_s</script>。</li></ol><p><script type="math/tex">\X, \vec{x}</script>的含义与<script type="math/tex">\X, x</script>类似，就是把<script type="math/tex">\vec{x}</script>里的变量插入到<script type="math/tex">\X</script>对应类型的集合里。</p><p>这里的重命名起到的作用其实是与父节点中的参数取消绑定关系（freshness condition on binders）。</p><p>于是我们就会发现，在 ABT 中两个参数名字（变量）一样不代表他们真的一样，这得看他们是不是在一个作用域里面。相关判断非常符合经验直觉。如果两个 ABT 本质相同，称作<script type="math/tex">\alpha</script>-equivalence，互相称作<script type="math/tex">\alpha</script>-variants。它的说法是 fresh renaming（也就是重命名成原来没有的）不影响相等性。</p><p>变量的替换：这里要注意如果子树中有同名的参数得停止替换（capture avoidance），即</p><ol><li><script type="math/tex">[b / x] x = b</script>，<script type="math/tex">[b/x]y = y\, (y\ne x)</script>。</li><li><script type="math/tex">[b/x]o(\vec{x_1}.a_1, \ldots,\vec{x_n}.a_n)</script>的情况，对于<script type="math/tex">x\in\vec{x_i}</script>的情况我们设<script type="math/tex">a_i' = a_i</script>，否则<script type="math/tex">a'_i = [b/x]a_i</script>，这样有<script type="math/tex">[b/x]o(\vec{x_1}.a_1, \ldots,\vec{x_n}.a_n) = o(\vec{x_1}.a'_1, \ldots, \vec{x_n}.a'_n)</script>。</li></ol><p>但其实还可以换一种定义，就是我们先随便把子树里的参数做 fresh rename，这个时候直接替换<script type="math/tex">[b/x]</script>就没有任何问题了，即<script type="math/tex">[b/x]o(\vec{x_1}.a_1, \ldots,\vec{x_n}.a_n) = o(\vec{x_1'}.[b/x]\pi_1(a_1), \ldots, \vec{x_n'}.[b/x]\pi_n(a_n))</script>。</p><h2><a id="归纳（Inductive-Definitions）" href="#归纳（Inductive-Definitions）" class="headerlink" title="归纳（Inductive Definitions）"></a>归纳（Inductive Definitions）</h2><p>下面是一点数理逻辑的基础知识。</p><p>讲了一堆 Haskell 和 Agda 的东西，想必大家都会。</p><p>一个 judgement form 可以理解为 Haskell 里的 type constructor，或者 Agda 里的 data constructor。judgement form 也可以理解为一个函数定义。</p><p>规则集合<script type="math/tex">R</script>以若干个公理/定理的形式给出，而它代表所有遵循且仅遵循<script type="math/tex">R</script>的 judgement 构成的集合。也就是说对于其中的 judgement<script type="math/tex">J</script>，它能够从<script type="math/tex">R</script>中推导出来（closed under<script type="math/tex">R</script>），并且<script type="math/tex">R</script>蕴含推导出<script type="math/tex">J</script>的必要前提（strongest），如果<script type="math/tex">J</script>无法从<script type="math/tex">R</script>中推导那它就被视为不成立（vacuously true）。</p><p>这其中有一个有意思的叫做 mode specification，是指一个函数对其参数的限定关系。例如</p><script type="math/tex;mode=display">R = \left\{ \frac{a \in\mathbb{N}}{\sum(0, a, a)},  \frac{\sum(a, b, c)}{\sum(\text{suc}(a), b, \text{suc}(c))} \right\}</script><p>这两条规则定义了一个 judgement，<script type="math/tex">\sum(a, b, c)</script>指<script type="math/tex">a + b = c</script>成立。这时你会发现，对于任意<script type="math/tex">a, b\in \mathbb{N}</script>都存在<script type="math/tex">c</script>满足它，记作<script type="math/tex">(\forall, \forall, \exist)</script>。当然它甚至其实是存在唯一，可以记作<script type="math/tex">(\forall, \forall, \exists!)</script>。而<script type="math/tex">\forall b, c\in \mathbb{N}</script>，存在至多一个<script type="math/tex">a</script>满足它，这个可以记作<script type="math/tex">(\exists^{\le 1}, \forall, \forall)</script>。这些被称作 mode specifications。</p><p>一般来说，<script type="math/tex">\forall</script>对应的是函数的输入，而<script type="math/tex">\exists</script>对应函数的输出。这样我们就可以用若干条规则定义函数了。当然为了写出来方便也会直接在上下使用<script type="math/tex">=</script>符号来代表函数的输入输出归纳关系。</p><h2><a id="条件判断（Hypothetical-Judgments）" href="#条件判断（Hypothetical-Judgments）" class="headerlink" title="条件判断（Hypothetical Judgments）"></a>条件判断（Hypothetical Judgments）</h2><p>对于一个规则集合<script type="math/tex">R</script>，记<script type="math/tex">J_1, \ldots, J_k \vdash_R K</script>表示，在假设<script type="math/tex">J_1, \ldots, J_k</script>成立（公理）后可以借助<script type="math/tex">R</script>中的规则推导得到<script type="math/tex">K</script>。常用<script type="math/tex">\Gamma</script>或者<script type="math/tex">\Delta</script>表示 judgement 集合，记<script type="math/tex">R[\Gamma]</script>表示<script type="math/tex">R</script>由<script type="math/tex">\Gamma</script>拓展得到的规则集合，上式亦可表示为<script type="math/tex">\Gamma \vdash_R K</script>，<script type="math/tex">\Gamma</script>为空时可省略。<script type="math/tex">\Gamma \vdash _R \Delta</script>指<script type="math/tex">\Delta</script>中每一个 judgement 都可以由<script type="math/tex">R[\Gamma]</script>推导。<script type="math/tex">\vdash</script>满足以下性质：</p><ol><li>稳定性（stability）：<script type="math/tex">\Gamma\vdash_R K \imply \Gamma\vdash_{R\cup R'} K</script>。</li><li>自反性（reflexivity）：<script type="math/tex">\Gamma, J\vdash_R J</script>。写成<script type="math/tex">J\vdash_{R[\Gamma]} J</script>更清楚。</li><li>传递性（transitivity）：若<script type="math/tex">\vdash_{R[\Gamma]}K</script>且<script type="math/tex">K\vdash_{R[\Gamma]} J</script>，则<script type="math/tex">\vdash_{R[\Gamma]}J</script>。</li></ol><p>另一方面，记<script type="math/tex">\Gamma \models_R J</script>表示<script type="math/tex">\vdash_R\Gamma\imply\; \vdash_R J</script>。这个的意思是说只要你能用<script type="math/tex">R</script>推导出<script type="math/tex">\Gamma</script>（其中的全部 judgement），你就可以推导出<script type="math/tex">J</script>。</p><p><script type="math/tex">\models</script>不稳定。因为你往<script type="math/tex">R</script>里面随便加一点公理（记为<script type="math/tex">R'</script>），就能使<script type="math/tex">J</script>不能被<script type="math/tex">R'</script>推导。</p><p>举个例子。我们搞两个规则定义自然数：<script type="math/tex">R = \{\frac{}{\text{zero nat}}, \frac{\text{a nat}}{\text{suc(a) nat}} \}</script>。那么显然有<script type="math/tex">\text{suc(a) nat} \models_R \text{a nat}</script>，这个可以归纳证明。然后我们往<script type="math/tex">R</script>里面加一条垃圾公理<script type="math/tex">\vdash \text{suc(juck) nat}</script>，记作<script type="math/tex">R'</script>。那么如果<script type="math/tex">\models</script>稳定，则有<script type="math/tex">\vdash_{R'}\text{suc(juck) nat} \imply\; \vdash_{R'} \text{junk nat}</script>，但是这里的<script type="math/tex">\text{junk}</script>很可能不是自然数（比如说<script type="math/tex">-1</script>），也就是说它没法被<script type="math/tex">R'</script>里的规则推导出来，即<script type="math/tex">\nvdash_{R'}\text{junk nat}</script>。故<script type="math/tex">\text{suc(a) nat}\not\models_{R'} \text{a nat}</script>。</p><p>注：这里说<script type="math/tex">\text{junk nat}</script>没法被推导其实并不是说非得举出一个<script type="math/tex">-1</script>的反例，主要想表达的意思是它没有证据（vacuously true）。</p><p>在<script type="math/tex">\Gamma \vdash_R J</script>中，<script type="math/tex">\Gamma</script>是你推导出<script type="math/tex">J</script>的前提之一，<script type="math/tex">R</script>是辅助的推导规则集合。因此该命题体现的是在<script type="math/tex">R</script>辅助下，<script type="math/tex">\Gamma</script>到<script type="math/tex">J</script>的可推导性（derivable）。</p><p>在<script type="math/tex">\Gamma\models_R J</script>（<script type="math/tex">\vdash_R\Gamma\imply\; \vdash_R J</script>）中，究竟能不能推导出<script type="math/tex">J</script>其实与<script type="math/tex">\Gamma</script>无关，与<script type="math/tex">R</script>有关。命题的前提<script type="math/tex">\vdash_R \Gamma</script>描述的是<script type="math/tex">R</script>具有某种性质（使得它能推导出<script type="math/tex">\Gamma</script>），而这种性质提供了推导出<script type="math/tex">J</script>的充分条件。所以说如果<script type="math/tex">\Gamma\models J</script>在<script type="math/tex">R</script>下成立，意味着<script type="math/tex">R</script>具有这种性质，称作可接受的（admissible）。当然，也可以反客为主，称在<script type="math/tex">R</script>下<script type="math/tex">\Gamma\models J</script>是可接受的。</p><p><script type="math/tex">\vdash</script>明确指出了要推导出<script type="math/tex">J</script>的充分前提；而<script type="math/tex">\models</script>只是指出，你要推导出<script type="math/tex">J</script>需要使得<script type="math/tex">R</script>具有某种性质。故也称<script type="math/tex">\models</script>是<script type="math/tex">\vdash</script>的一个 weaker form。<script type="math/tex">\models</script>满足以下性质：</p><ol><li>自反性：<script type="math/tex">J \models_R J</script>，这个很显然。</li><li>传递性：若<script type="math/tex">\Gamma \models_R K</script>且<script type="math/tex">\Gamma, K\models_R J</script>，那么<script type="math/tex">\Gamma \models_R J</script>。</li></ol><h2><a id="条件归纳（Hypothetical-Inductive-Definitions）" href="#条件归纳（Hypothetical-Inductive-Definitions）" class="headerlink" title="条件归纳（Hypothetical Inductive Definitions）"></a>条件归纳（Hypothetical Inductive Definitions）</h2><p>我们可以用<script type="math/tex">\vdash</script>来拓展规则的定义。条件规则（hypothetical rules）的形式如下：</p><script type="math/tex;mode=display">\frac{\Gamma\Gamma_1\vdash J_1, \ldots, \Gamma\Gamma_n \vdash J_n}{\Gamma \vdash J}</script><p>其中<script type="math/tex">\Gamma</script>为大前提（global hypotheses）。而<script type="math/tex">\Gamma_i</script>为<script type="math/tex">J_i</script>的前提假设。</p><p>如果一个条件规则不需要大前提，称作一致（uniform）条件规则，可以简写为</p><script type="math/tex;mode=display">\frac{\Gamma_1\vdash J_1, \ldots, \Gamma_n \vdash J_n}{J}</script><p>条件归纳定义为形式可推导的 judgement（formal derivability judgment）<script type="math/tex">\Gamma\vdash J</script>，其中<script type="math/tex">\Gamma</script>是一个有限的基本 judgement 集合，<script type="math/tex">J</script>是一个基本的 judgement。</p><p>而条件规则集合<script type="math/tex">R</script>代表了一个可从<script type="math/tex">R</script>中推导（closed under<script type="math/tex">R</script>）的且必须从<script type="math/tex">R</script>中推导（strongest）的结构化（structural）的 formal derivability judgment 集合。可推导和必须推导前面已经解释过了。结构化的意思其中的 judgement 满足<script type="math/tex">\vdash</script>的三个性质：</p><ol><li>自反性：<script type="math/tex">\dfrac{}{\Gamma, J\vdash J}</script>。</li><li>稳定性：<script type="math/tex">\dfrac{\Gamma\vdash J}{\Gamma, K\vdash J}</script>。</li><li>传递性：<script type="math/tex">\dfrac{\Gamma\vdash K\quad \Gamma, K\vdash J}{\Gamma \vdash J}</script>。</li></ol><p>同样地，这里可以用<script type="math/tex">\Gamma\vdash_R J</script>表示借用<script type="math/tex">R</script>的规则，从<script type="math/tex">\Gamma</script>出发可以推导出<script type="math/tex">J</script>。</p><h2><a id="泛化判断（General-judgements）" href="#泛化判断（General-judgements）" class="headerlink" title="泛化判断（General judgements）"></a>泛化判断（General judgements）</h2><p>大概就是在 judgement 里引入变量。设<script type="math/tex">\Gamma, J</script>分别是含有变量<script type="math/tex">\vec{x}</script>的前提集合与目标 judgement，记<script type="math/tex">\vec{x} \mid \Gamma\vdash_{R}^{\X} J</script>表示利用包含变量<script type="math/tex">\X</script>的规则集合<script type="math/tex">R</script>，我们可以从<script type="math/tex">\Gamma</script>推导出<script type="math/tex">J</script>。这里<script type="math/tex">\vec{x}\not \subseteq\X</script>。换句话说对于任何重命名<script type="math/tex">\pi : \vec{x}\leftrightarrow\vec{x'}</script>，有<script type="math/tex">\pi(\Gamma)\vdash_{R}^{\X, \vec{x'}} \pi(J)</script>。</p><p>比如说<script type="math/tex">\text{x nat}\imply \text{(x + 2) nat}</script>可以表示为<script type="math/tex">x \mid \text{x nat}\vdash_{R}^{\X}\text{suc(suc(x)) nat}</script>。</p><p>更准确地说，在<script type="math/tex">\Gamma\vdash_{R}^{\X} J</script>中，我们将所有 judgement 视为对 ABT 的判断。这样才能说清楚含有变量的 judgement、重命名、变量替换是什么。刚才的例子里，<script type="math/tex">\Gamma = \{\text{x nat}\}</script>中的<script type="math/tex">x</script>自己就是一个 ABT。</p><p>泛化判断有几个显然的基本性质：</p><ol><li>扩张性（Proliferation）：<script type="math/tex">\vec{x}\mid \Gamma\vdash_R^{\X} J\imply \vec{x}, x\mid \Gamma\vdash_{R}^{\X} J</script>。</li><li>重命名-等价性（Renaming）：<script type="math/tex">\vec{x}, x\mid \Gamma\vdash_R^{\X} J\imply \vec{x}, x'\mid [x\leftrightarrow x'](\Gamma)\vdash_R^{\X}[x\leftrightarrow x'](J)</script>，对于任意<script type="math/tex">x'\notin\X, \vec{x}</script>。</li></ol></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2022年12月6日 第2次修订</li><li class="post-history-item">2022年11月24日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/String/PAM/">回文自动机小结</a></div><div class="prev-post"><a href="/BMF-FFT/">使用 Bird-Meertens Formalism 推导 FFT </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>