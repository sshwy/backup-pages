<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>高爸的杂题练习 3 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">高爸的杂题练习 3</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2021年2月11日星期四中午12点26分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2021年2月11日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 4,358 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> <a class="directory" href="/directory/Gao/">高爸的习题 </a><span class="icon smallarrow"></span> 当前文章</div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Cool-Slogans"><span class="toc-number">1.</span> <span class="toc-text">Cool Slogans</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-Many-Substrings"><span class="toc-number">2.</span> <span class="toc-text">How Many Substrings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#历史研究"><span class="toc-number">3.</span> <span class="toc-text">历史研究</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WC2013-糖果公园"><span class="toc-number">4.</span> <span class="toc-text">WC2013 糖果公园</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在线区间众数查询"><span class="toc-number">5.</span> <span class="toc-text">在线区间众数查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Souvenirs"><span class="toc-number">6.</span> <span class="toc-text">Souvenirs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一部分"><span class="toc-number">6.1.</span> <span class="toc-text">第一部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二部分"><span class="toc-number">6.2.</span> <span class="toc-text">第二部分</span></a></li></ol></li></ol></div><hr></div><div class="post-content"><h2><a id="Cool-Slogans" href="#Cool-Slogans" class="headerlink" title="Cool Slogans"></a><a target="_blank" rel="noopener" href="https://codeforces.ml/contest/700/problem/E">Cool Slogans</a></h2><blockquote><p>给出一个字符串<script type="math/tex">S</script>，要求构造一个字符串序列<script type="math/tex">s_1,\cdots,s_k</script>满足：</p><ol><li><script type="math/tex">s_k=S</script>；</li><li><script type="math/tex">s_{i}</script>是<script type="math/tex">s_{i+1}</script>的子串且在<script type="math/tex">s_{i+1}</script>中出现了至少<script type="math/tex">2</script>次（出现的位置可以部分重叠）。</li></ol><p>求出最大的<script type="math/tex">k</script>。</p><p><script type="math/tex">n\le 2\times 10^5</script>。</p></blockquote><p><strong>摘要：Fail 树上双指针，线段树维护 Right 集合。</strong></p><p>我们可以让<script type="math/tex">s_k</script>是<script type="math/tex">S</script>的子串，这样答案不会变劣。</p><p>容易发现，一定存在一种最优方案使得：</p><ol><li><script type="math/tex">s_k</script>是<script type="math/tex">S</script>的子串；</li><li><script type="math/tex">s_i</script>是<script type="math/tex">s_{i+1}</script>的后缀且在<script type="math/tex">s_{i+1}</script>中出现了至少<script type="math/tex">2</script>次（出现的位置可以部分重叠）。</li></ol><p>这样的话<script type="math/tex">s_i,s_{i+1}</script>就是在 Fail 树上的祖先关系。</p><p>考虑建出<script type="math/tex">S</script>的 Fail 树后，记<script type="math/tex">f_u</script>表示<script type="math/tex">s_k</script>为<script type="math/tex">u</script>代表的子串时的<script type="math/tex">k</script>的最大值。我们可以不停跳父亲，直到遇到第一个在<script type="math/tex">u</script>中出现 2 次的状态，然后转移。然后容易发现我们可以用树上双指针（或者倍增、二分）来完成这个过程。因此问题转化为，如何快速判断状态<script type="math/tex">v</script>在状态<script type="math/tex">u</script>中出现了至少 2 次。</p><p>这个问题也不难。使用线段树合并求出每个结点的 Right 集合后，我们只需要在<script type="math/tex">u</script>的 Right 集合中随便找一个位置，然后在<script type="math/tex">v</script>的 Right 集合中求出这个位置的前驱就可以判断了。</p><p>时间复杂度<script type="math/tex">O(n\log_2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/700e.cpp">代码</a></p><h2><a id="How-Many-Substrings" href="#How-Many-Substrings" class="headerlink" title="How Many Substrings"></a><a target="_blank" rel="noopener" href="https://www.hackerrank.com/challenges/how-many-substrings/problem">How Many Substrings</a></h2><blockquote><p>给你一个串<script type="math/tex">S</script>，<script type="math/tex">q</script>次询问<script type="math/tex">(l,r)</script>，问<script type="math/tex">S[l,r]</script>的本质不同子串的个数。</p><p><script type="math/tex">|S|,q\le 10^5</script>。</p></blockquote><p><strong>摘要：离线，线段树按左端点统计子串个数，在 Fail 树链上更新线段树，用 LCT 维护 Fail 树。</strong></p><p>考虑离线，将询问按右端点分类。</p><p>对于 S 的一个前缀<script type="math/tex">S[1,x]</script>，维护序列<script type="math/tex">c_i</script>表示最晚出现位置的左端点为<script type="math/tex">i</script>的本质不同子串数。因此对于<script type="math/tex">r=x</script>的询问，我们可以查询<script type="math/tex">c</script>上的区间和来求出答案。</p><p>当在<script type="math/tex">S[1,x]</script>后面加一个字符，我们就需要更新一部分子串的最晚出现位置。</p><p>容易发现，在 S 的 SAM 增量构造过程中，我们插入了<script type="math/tex">S[x+1]</script>这个字符后，Fail 树上新的 Last 到根的路径上的状态的最晚出现位置都发生了变化。因此我们可以暴力跳 Fail 树的父亲来更新<script type="math/tex">c</script>。由于一个状态<script type="math/tex">u</script>代表了长度为<script type="math/tex">[\text{len}(\text{fail}(u))+1,\text{len}(u)]</script>的若干个子串，因此一次更新操作相当于是做<script type="math/tex">O(1)</script>次区间加（减）。</p><p>使用线段树维护<script type="math/tex">c</script>，则时间复杂度是<script type="math/tex">O(n^2\log_2n)</script>的。</p><p>容易发现，对于 Fail 树上的一条链（端点为祖孙关系的链）<script type="math/tex">P</script>，如果满足<script type="math/tex">P</script>中的所有结点的最晚出现位置相同，那么<script type="math/tex">P</script>这条链所代表的所有子串的左端点也是一段连续的区间。因此对于一条链我们可以在<script type="math/tex">O(\log_2n)</script>的时间内更新<script type="math/tex">c</script>。</p><p>既然可以快速维护一条链的信息，那么我们使用 LCT 维护 Fail 树即可，时间复杂度<script type="math/tex">O(n\log_2^2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/others/hackerrank-how-many-substrings.cpp">代码</a></p><h2><a id="历史研究" href="#历史研究" class="headerlink" title="历史研究"></a><a target="_blank" rel="noopener" href="https://darkbzoj.tk/problem/4241">历史研究</a></h2><blockquote><p>给你一个长度为<script type="math/tex">n</script>的序列<script type="math/tex">A</script>，定义<script type="math/tex">x</script>在区间<script type="math/tex">[L,R]</script>中的权值为<script type="math/tex">x</script>的出现次数乘<script type="math/tex">x</script>。定义区间<script type="math/tex">[L,R]</script>的权值为<script type="math/tex">x\in[L,R]</script>的最大的<script type="math/tex">x</script>的权值。</p><p><script type="math/tex">q</script>次询问区间权值。</p><p><script type="math/tex">n,q\le 10^5</script>。</p></blockquote><p><strong>摘要：分块。</strong></p><p>考虑分块，设块大小为<script type="math/tex">T</script>。预处理<script type="math/tex">f(i,j)</script>表示第<script type="math/tex">i</script>块到第<script type="math/tex">j</script>块的区间的权值。</p><p>预处理<script type="math/tex">v_x</script>表示权值<script type="math/tex">x</script>的出现位置集合。</p><p>查询的时候，整块的部分直接<script type="math/tex">O(1)</script>在<script type="math/tex">f</script>上查询。零散的部分，我们枚举零碎部分的权值<script type="math/tex">x</script>，然后在<script type="math/tex">v_x</script>上查询<script type="math/tex">x</script>在<script type="math/tex">[l,r]</script>中的出现次数来更新答案。</p><p>要离散化。</p><p>预处理复杂度<script type="math/tex">O(n\log_2n+\frac{n^2}{T})</script>。查询复杂度<script type="math/tex">O(qT\log_2n)</script>且在线。取<script type="math/tex">T=\sqrt{n}</script>可过。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/bzoj/4241.cpp">代码</a></p><h2><a id="WC2013-糖果公园" href="#WC2013-糖果公园" class="headerlink" title="WC2013 糖果公园"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problemnew/solution/P4074">WC2013 糖果公园</a></h2><blockquote><p>给出两个序列<script type="math/tex">W,V</script>。定义权值<script type="math/tex">x</script>在可重集合<script type="math/tex">S</script>中的价值：假设<script type="math/tex">x</script>在<script type="math/tex">S</script>中出现了<script type="math/tex">k</script>次，则价值为<script type="math/tex">\sum_{i=1}^kV_xW_i</script>。一个可重集合的价值是其中所有<strong>权值</strong>（不是所有元素）的价值和。</p><p>给你一棵树<script type="math/tex">T</script>，定义其中的点的点权为<script type="math/tex">C_i</script>。有<script type="math/tex">q</script>次操作：</p><ol><li>修改单点点权；</li><li>询问从<script type="math/tex">x</script>到<script type="math/tex">y</script>路径上的点的点权组成的可重集合的价值。</li></ol><p><script type="math/tex">n,q,|W|\le 10^5,C_i\le |W|,n=|V|</script>。</p></blockquote><p><strong>摘要：树上带修莫队。</strong></p><p>考虑一条链且不带修改的情况。容易想到莫队算法。复杂度<script type="math/tex">O(n\sqrt{n})</script>。</p><p>考虑一条链且带修改的情况。那么加一维时间上去，由于加入一个权值和删除一个权值的复杂度都可以做到<script type="math/tex">O(1)</script>，因此复杂度为<script type="math/tex">O(n^{\frac{5}{3}})</script>。</p><p>考虑原问题。不妨求出任意一个 DFS 序。那么从<script type="math/tex">x</script>到<script type="math/tex">y</script>的路径可以在 DFS 序列上表示为一个区间。如果一个点在区间中出现了偶数次，那么它就不在这条路径上。那么我们就在 DFS 序列上做莫队即可。</p><p>更具体地，对于点<script type="math/tex">u</script>，我们记录第一次到达这个点的 DFS 时间戳，以及从这个点回溯时的时间戳，分别为<script type="math/tex">L_u,R_u</script>。显然<script type="math/tex">L_u\le R_u</script>。那么从<script type="math/tex">x</script>到<script type="math/tex">y</script>的路径有两种情况：</p><ol><li><script type="math/tex">x</script>和<script type="math/tex">y</script>是祖孙关系（<script type="math/tex">x=y</script>的情况也包含在这里）；</li><li><script type="math/tex">x</script>和<script type="math/tex">y</script>不是祖孙关系；</li></ol><p><img src="../../images/gals-exercise-part-3-1.png" alt="p1"></p><p>对于第一种情况，设<script type="math/tex">x</script>是<script type="math/tex">y</script>的祖先，显然<script type="math/tex">L_x\le L_y</script>。我们取<script type="math/tex">[L_x,L_y]</script>区间做为路径<script type="math/tex">(x,y)</script>对应的区间。容易发现，路径上的每个点<script type="math/tex">u</script>的<script type="math/tex">L_u</script>都在区间中出现了一次，<script type="math/tex">R_u</script>则没有出现；</p><p>对于第二种情况，设<script type="math/tex">z=\text{lca}(x,y)</script>，不妨设<script type="math/tex">L_x&lt;L_y</script>，显然<script type="math/tex">R_x&lt;L_y</script>。则我们取<script type="math/tex">[R_x,L_y]</script>作为路径<script type="math/tex">(x,y)</script>对应的区间。容易发现，<script type="math/tex">x</script>到<script type="math/tex">z</script>路径上每个点<script type="math/tex">u</script>的<script type="math/tex">R_u</script>都出现了一次；而<script type="math/tex">y</script>到<script type="math/tex">z</script>路径上的每个点<script type="math/tex">u</script>的<script type="math/tex">L_u</script>都出现了一次。但<script type="math/tex">z</script>是个例外，<script type="math/tex">L_z,R_z</script>都没有出现。因此我们在处理这个询问的时候要单独把<script type="math/tex">C_z</script>加上去，统计完了再减掉。</p><p>在莫队移动端点的过程中，通过判断结点出现次数的奇偶性来决定是加入权值还是删除权值即可。</p><p>时间复杂度<script type="math/tex">O(n^{\frac{5}{3}}+n\log_2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/luogu/4074.cpp">代码</a></p><h2><a id="在线区间众数查询" href="#在线区间众数查询" class="headerlink" title="在线区间众数查询"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5048">在线区间众数查询</a></h2><blockquote><p>给出长度为<script type="math/tex">n</script>的序列<script type="math/tex">a</script>，有<script type="math/tex">m</script>次询问，每次查询区间众数的出现次数。强制在线。</p><p><script type="math/tex">n,m\le 5\times 10^5,a_i\le 10^9</script>。（2 秒）</p></blockquote><p><strong>摘要：分块。</strong></p><p>考虑分块。设块大小为<script type="math/tex">T</script>。</p><p>预处理<script type="math/tex">w(l,r)</script>表示第<script type="math/tex">l</script>块到第<script type="math/tex">r</script>块的区间众数的出现次数，时间复杂度<script type="math/tex">O(\frac{n^2}{T})</script>，空间复杂度<script type="math/tex">O(\frac{n^2}{T^2})</script>。</p><p>预处理序列<script type="math/tex">v_{x}</script>表示数值<script type="math/tex">x</script>在<script type="math/tex">a</script>中出现的位置。预处理<script type="math/tex">p_i</script>表示<script type="math/tex">a_i</script>在<script type="math/tex">v_{a_i}</script>中出现的位置。时间复杂度<script type="math/tex">O(n)</script>。</p><p>考虑查询。则区间<script type="math/tex">[L,R]</script>的众数出现次数有两种情况：</p><ol><li>等于整块的众数；</li><li>出现次数大于整块的众数。</li></ol><p>整块的众数可以<script type="math/tex">O(1)</script>查询。考虑零散部分。假设当前的答案是<script type="math/tex">C</script>，考虑判断答案能否为<script type="math/tex">C+1</script>。</p><p>以左边的零碎部分为例。我们枚举其中的数<script type="math/tex">a_x</script>，那么<script type="math/tex">a_x</script>就是第<script type="math/tex">p_x</script>个出现的<script type="math/tex">a_x</script>。我们<script type="math/tex">O(1)</script>求出第<script type="math/tex">p_x+C</script>个<script type="math/tex">a_x</script>出现的位置<script type="math/tex">P</script>，如果<script type="math/tex">P\le R</script>说明<script type="math/tex">a_x</script>在<script type="math/tex">[L,R]</script>中出现的位置至少是<script type="math/tex">C+1</script>。</p><p>右边的类似。</p><p>零碎部分的大小是<script type="math/tex">O(T)</script>的，因此<script type="math/tex">C</script>最多增加<script type="math/tex">O(T)</script>次。查询的复杂度是<script type="math/tex">O(T)</script>。</p><p>因此时间复杂度为<script type="math/tex">O(\frac{n^2}{T}+n+mT)</script>。</p><p>取<script type="math/tex">T=\sqrt{n}</script>。时间复杂度<script type="math/tex">O((n+m)\sqrt{n})</script>，空间复杂度<script type="math/tex">O(n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/luogu/5048.cpp">代码</a></p><h2><a id="Souvenirs" href="#Souvenirs" class="headerlink" title="Souvenirs"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/765/problem/F">Souvenirs</a></h2><blockquote><p>给出长度为<script type="math/tex">n</script>的序列<script type="math/tex">a</script>，有<script type="math/tex">m</script>次询问形如<script type="math/tex">(l,r)</script>，求<script type="math/tex">\min_{l\le x&lt;y\le r}|a_x-a_y|</script>。</p><p><script type="math/tex">n\le 10^5,m\le 3\times 10^5,a_i\le 10^9</script>。</p></blockquote><p><span class="label">离线</span> <span class="label">扫描线</span> <span class="label">权值线段树</span></p><p>考虑离线，我们对每次询问<script type="math/tex">(l,r)</script>求<script type="math/tex">\min_{l\le x&lt;y\le r,a_x\ge a_y}(a_x-a_y)</script>，然后求<script type="math/tex">\min_{l\le x&lt;y\le r,a_x\le a_y}(a_y-a_x)</script>，两者取<script type="math/tex">\min</script>即可。考虑求前者。</p><p>考虑使用扫描线。即我们每次加入<script type="math/tex">a_i</script>并处理所有<script type="math/tex">r=i</script>的询问。我们维护序列<script type="math/tex">c</script>，<script type="math/tex">c_j</script>表示在扫描线的当前状态下，<script type="math/tex">l=j</script>的询问的答案。</p><p>那么当我们加入了<script type="math/tex">a_i</script>之后，显然我们会用<script type="math/tex">a_j-a_i(a_j\ge a_i)</script>的值来更新某些询问的答案。自然想到，我们想办法找到最大的<script type="math/tex">j</script>使得<script type="math/tex">j&lt;i,a_j\ge a_i</script>（<script type="math/tex">a_i</script>往前第一个比它大的数）。那么<script type="math/tex">c[1,j]</script>的值就都要对<script type="math/tex">a_j-a_i</script>取<script type="math/tex">\min</script>。</p><h3><a id="第一部分" href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p>但是只有这一个<script type="math/tex">j</script>是不够的。我们还需要找更多的<script type="math/tex">j'(j'&lt;i,a_{j'}\ge a_i)</script>，并用<script type="math/tex">a_{j'}-a_i</script>来更新答案（关于如何找这些<script type="math/tex">j</script>见第二部分）。</p><p>我们还要求<script type="math/tex">a_{j'}-a_i&lt;a_j-a_i</script>，即<script type="math/tex">a_{j'}&lt;a_j</script>。因为你用<script type="math/tex">a_{j'}-a_i\ge a_j-a_i</script>的<script type="math/tex">j'</script>再去更新答案是没有任何意义的，你已经有了<script type="math/tex">a_j</script>了。</p><p>上述有关<script type="math/tex">j'</script>的条件可以容易地推出<script type="math/tex">j'&lt;j</script>。当然，我们希望<script type="math/tex">j'</script>尽可能大。</p><p>我们还可以加一个条件：<script type="math/tex">a_{j'}-a_i&lt;a_j-a_{j'}</script>。因为区间<script type="math/tex">[j',i]</script>是包含<script type="math/tex">[j',j]</script>的。如果<script type="math/tex">a_{j'}-a_i\ge a_j-a_{j'}</script>也没有更新意义。这是本题的一个<strong>关键点</strong>。有了这个条件我们可以推出<script type="math/tex">a_{j'}&lt;\frac{1}{2}(a_i+a_j)</script>（这个条件比<script type="math/tex">a_{j'}&lt;a_j</script>更强）。</p><p>综上所述，当我们用<script type="math/tex">a_j-a_i</script>更新完<script type="math/tex">c[1,j]</script>的值后，我们尝试找到下一个<script type="math/tex">j'</script>，并用<script type="math/tex">a_{j'}-a_i</script>更新<script type="math/tex">c[1,j']</script>的值。则<script type="math/tex">j'</script>需要满足条件：<script type="math/tex">j' &lt;j,\,a_i\le a_{j'} &lt;\frac{1}{2}(a_i+a_j)</script>。</p><p>当我们用<script type="math/tex">a_{j'}-a_i</script>更新完后，我们可以再如法炮制找到下一个<script type="math/tex">j''</script>，可以类似地发现<script type="math/tex">j''</script>满足<script type="math/tex">j'' &lt;j',\,a_i\le a_{j''} &lt;\frac{1}{2}(a_i+a_{j'})&lt;\frac{3}{4}a_i+\frac{1}{4}a_j</script>。</p><p>以此类推，则<script type="math/tex">j^{(k)}</script>需要满足的条件是</p><script type="math/tex;mode=display">j^{(k)} &lt;j^{(k-1)},\,a_i\le a_{j^{(k)}} &lt;\frac{1}{2}(a_i+a_{j^{(k-1)}})&lt;\frac{2^k-1}{2^k}a_i+\frac{1}{2^k}a_j
=a_i+\frac{1}{2^k}(a_j-a_i)</script><p>因此我们得到<script type="math/tex">a_i\le a_{j^{(k)}}&lt;a_i+\frac{1}{2^k}(a_j-a_i)</script>，因此<script type="math/tex">k\le O(\log_2W)</script>，即我们最多找到<script type="math/tex">\log_2W</script>个有更新价值<script type="math/tex">j</script>来更新。</p><p>如果使用线段树维护<script type="math/tex">c</script>的话，那么做一次更新的复杂度是<script type="math/tex">O(\log_2n)</script>的，更新<script type="math/tex">a_i</script>的复杂度就是<script type="math/tex">O(\log_2n\log_2W)</script>的。</p><h3><a id="第二部分" href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p>那么接下来的问题是：</p><ol><li>如何找到最大的<script type="math/tex">j</script>使得<script type="math/tex">j&lt;i,a_j\ge a_i</script>。</li><li>找到最大的<script type="math/tex">j^{(k)}</script>使得<script type="math/tex">j^{(k)} &lt;j^{(k-1)},\,a_i\le a_{j^{(k)}} &lt;\frac{1}{2}(a_i+a_{j^{(k-1)}})</script>（记<script type="math/tex">j^{(0)}=j</script>）。</li></ol><p>一个直接的思路是对<script type="math/tex">a[1,i-1]</script>建立权值线段树，在对应的权值上存下标。那么上面两个问题就相当于是求区间<script type="math/tex">\max</script>。当然也可以建立离散化的权值线段树。</p><p>那么这部分的查询复杂度就是<script type="math/tex">O(\log_2n\log_2W)</script>。</p><p>总复杂度<script type="math/tex">O(n\log_2n\log_2W)</script>。</p><p>小插曲：在求<script type="math/tex">a_j\le a_i</script>的情况的时候，可以直接把<script type="math/tex">a_i</script>变成相反数再做一次。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/765f.cpp">代码</a></p></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2021年2月11日 第3次修订</li><li class="post-history-item">2021年2月4日 第2次修订</li><li class="post-history-item">2020年3月5日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/Probset/21-WC-Training-2/">WC 赛前训练日志 3</a></div><div class="prev-post"><a href="/Gao/part-1/">高爸的杂题练习 1 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>