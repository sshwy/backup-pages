<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>WC 赛前训练日志 1 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">WC 赛前训练日志 1</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2021年2月11日星期四下午12点32分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2021年2月11日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 8,166 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> <a class="directory" href="/directory/Probset/">训练题单 </a><span class="icon smallarrow"></span> 当前文章</div><div class="post-tags"><span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/WC2021/">WC2021</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/DP/">DP</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/%E5%9C%86%E6%96%B9%E6%A0%91/">圆方树</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/CSP2020/">CSP2020</a></span></div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Yet-Another-DAG-Problem"><span class="toc-number">1.</span> <span class="toc-text">Yet Another DAG Problem</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Roads-and-Ramen"><span class="toc-number">2.</span> <span class="toc-text">Roads and Ramen</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法一"><span class="toc-number">2.1.</span> <span class="toc-text">算法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法二"><span class="toc-number">2.2.</span> <span class="toc-text">算法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#防御工事"><span class="toc-number">3.</span> <span class="toc-text">防御工事</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#微信步数"><span class="toc-number">4.</span> <span class="toc-text">微信步数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一部分"><span class="toc-number">4.1.</span> <span class="toc-text">第一部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二部分"><span class="toc-number">4.2.</span> <span class="toc-text">第二部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#烟花表演"><span class="toc-number">5.</span> <span class="toc-text">烟花表演</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#硬件包管理器"><span class="toc-number">6.</span> <span class="toc-text">硬件包管理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寿司早餐"><span class="toc-number">7.</span> <span class="toc-text">寿司早餐</span></a></li></ol></div><hr></div><div class="post-content"><h2><a id="Yet-Another-DAG-Problem" href="#Yet-Another-DAG-Problem" class="headerlink" title="Yet Another DAG Problem"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1430/problem/G">Yet Another DAG Problem</a></h2><blockquote><p>给出一个<script type="math/tex">n</script>个点<script type="math/tex">m</script>条边边带权 DAG，构造序列<script type="math/tex">a_1,\ldots,a_n</script>使得</p><ul><li><script type="math/tex">a_i&gt; 0</script>。</li><li><script type="math/tex">\forall (u,v,w) \in E, a_u&gt;a_v</script>。</li></ul><p>并最小化<script type="math/tex">\sum_{(u,v,w)\in E}(a_u-a_v)w</script>。</p><p><script type="math/tex">n\le 18,m\le \frac{n(n-1)}{2}</script>。</p></blockquote><p><span class="label">状压</span></p><p>首先这题可以 LP，但鉴于<script type="math/tex">n</script>较小，有点大材小用。考虑状压。</p><p>由于是 DAG，我们将它整理为分层图的形式，相邻层的距离为<script type="math/tex">1</script>。把代价拆分到相邻层上即可。</p><p>设<script type="math/tex">f(S)</script>表示，<script type="math/tex">G[S]</script>（<script type="math/tex">S</script>的导出子图）的最小代价。转移时我们枚举下一层的点集<script type="math/tex">T</script>，使得<script type="math/tex">S,T</script>不相交且</p><ul><li><script type="math/tex">\forall u\in T</script>，要么<script type="math/tex">u</script>是一个入度为<script type="math/tex">0</script>的点，要么<script type="math/tex">\exists\,v\in S,\,(v,u)\in E</script>。</li></ul><p>新增的代价就是跨过<script type="math/tex">S,T</script>的边权的和：</p><script type="math/tex;mode=display">f(S\cup T) \gets f(S) + \sum_{u\in S,v\in T,(u,v,w)\in E}w</script><p>在 DP 的过程中构造方案即可。</p><p>复杂度<script type="math/tex">O(3^n+2^nn^2)</script>，有一些预处理。</p><p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1430/submission/95259936">代码</a></p><h2><a id="Roads-and-Ramen" href="#Roads-and-Ramen" class="headerlink" title="Roads and Ramen"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1434/problem/D">Roads and Ramen</a></h2><blockquote><p>给出一棵<script type="math/tex">n</script>个点的无根树，边有黑白两种颜色。有<script type="math/tex">m</script>次操作，每次操作选择一条边反转它的颜色。每次操作后求黑边个数为偶数的最长简单路径的长度。</p><p><script type="math/tex">n\le 5\times 10^5,m\le 5\times 10^5</script>。</p></blockquote><p><span class="label">直径</span></p><p>有两个做法。一个是性质做法，一个是套路做法。</p><h3><a id="算法一" href="#算法一" class="headerlink" title="算法一"></a>算法一</h3><p><img src="../../images/2020-CSP-Training-1.png" alt="2020-CSP-Training-1"></p><p>假设树的直径是 AB。</p><p>那么若 AC 和 BC 奇偶性相同，则答案就是 AB。</p><p>否则假设最优解是 EF。那么有 CE 和 CF 的奇偶性相同。因为 AC 和 BC 奇偶性不同，不妨假设 AC 和 CE 奇偶性相同。因为 AB 是直径，所以<script type="math/tex">FC\le AC</script>，所以<script type="math/tex">FD\le AD</script>，所以<script type="math/tex">EF\le AE</script>。因此选 AE 不劣。</p><p>另一种<script type="math/tex">A-C_1-C_2-B</script>，然后<script type="math/tex">E-C_1</script>，<script type="math/tex">F-C_2</script>的情况也可以类似地证明。证明的关键点是<script type="math/tex">A-C_1</script>和<script type="math/tex">B - C_2</script>奇偶性相同，而<script type="math/tex">E-C_1</script>，<script type="math/tex">F-C_2</script>奇偶性不同。</p><p>这样我们就证明了，存在端点是直径端点的最优解。那么维护两棵树的到根路径最优解即可。这个很容易维护。</p><p>时间复杂度<script type="math/tex">O((m+n)\log_2n)</script>。</p><h3><a id="算法二" href="#算法二" class="headerlink" title="算法二"></a>算法二</h3><p>如何求直径？设<script type="math/tex">d_u</script>表示深度。那么我们要求的就是<script type="math/tex">\max_{u,v}\{ d_u+d_v-2d_{\text{lca}(u,v)} \}</script>。但是<script type="math/tex">\text{lca}</script>不是一个容易求的东西。考虑欧拉序。那么<script type="math/tex">\text{lca}(u,v)</script>一定在<script type="math/tex">u</script>到<script type="math/tex">v</script>的欧拉序中出现过。因此直径就转化为了<script type="math/tex">\max_{X_u\le w\le X_v}\{ d_u+d_v-2d_w \}</script>。</p><p>考虑线段树。对区间维护<script type="math/tex">\max d_u</script>，<script type="math/tex">\max_{X_u\le w}\{ d_u - 2d_w \}</script>和<script type="math/tex">\max_{w\le X_u}\{ d_u - 2d_w \}</script>。然后两个区间合并一下即可。</p><p>对于本题，加一个奇偶性讨论上去即可。</p><p>时间复杂度<script type="math/tex">O((m+n)\log_2n)</script>。</p><h2><a id="防御工事" href="#防御工事" class="headerlink" title="防御工事"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/problem/1701">防御工事</a></h2><blockquote><p>给出一个<script type="math/tex">n</script>个点<script type="math/tex">m</script>条边的连通图。<script type="math/tex">q</script>次询问：</p><ul><li><p>第<script type="math/tex">i</script>次询问给出<script type="math/tex">k_i</script>个点。要求你在图上选择一个点<script type="math/tex">u</script>使得：等概率随机选择不是<script type="math/tex">u</script>的<script type="math/tex">n-1</script>个点中的一个点<script type="math/tex">v</script>，这<script type="math/tex">k_i</script>个点中存在不经过<script type="math/tex">v</script>到达<script type="math/tex">u</script>的路径的点的个数的期望最大。</p></li><li><p>输出这个最大的期望乘上<script type="math/tex">n-1</script>的值。</p></li></ul><p><script type="math/tex">n\le 2\times 10^5, m\le 5\times 10^5, q\le 5\times 10^5,\sum k_i\le 5\times 10^5</script>。</p></blockquote><p><span class="label">圆方树</span> <span class="label">虚树</span> <span class="label">换根 DP</span></p><p>建出圆方树。<script type="math/tex">x</script>能不经过<script type="math/tex">v</script>到达<script type="math/tex">y</script>等价于圆方树上<script type="math/tex">x</script>能不经过<script type="math/tex">v</script>到达<script type="math/tex">y</script>。</p><p>以<script type="math/tex">u</script>为根。称询问的点是关键点。则不能（不经过<script type="math/tex">v</script>）到达<script type="math/tex">u</script>的点有且仅有<script type="math/tex">v</script>子树中的点。</p><p>因此圆方树上建虚树，虚树上换根即可。</p><p>时间复杂度<script type="math/tex">O(\sum k_i + n+m)</script>。</p><p><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/submission/303983">代码</a></p><h2><a id="微信步数" href="#微信步数" class="headerlink" title="微信步数"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7116">微信步数</a></h2><blockquote><p>考虑<script type="math/tex">k</script>维空间里的一个超立方体空间<script type="math/tex">[1,w_1]\times [1,w_2]\times\cdots \times [1,w_k]</script>（以下简称空间）。给出一个长度为<script type="math/tex">n</script>的二元组序列<script type="math/tex">(c_i,d_i)</script>满足<script type="math/tex">1\le c_i\le k</script>，称为行动序列。</p><p>对于一次从<script type="math/tex">(x_1,\ldots,x_k)</script>出发的行动，我们会循环执行行动序列，第<script type="math/tex">i+nk</script>步我们会执行二元组<script type="math/tex">(c_i, d_i)</script>代表的行动，即<script type="math/tex">x_{c_i} \gets x_{c_i} + d_i</script>，直到走出了空间就停止。</p><p>求以空间中的每个点为起点行动的步数的和。</p><p><script type="math/tex">n\le 5\times 10^5, k\le 10, w_i\le 10^9, d_i\in \{1,-1\}</script>。</p></blockquote><p><span class="label">rounding box</span> <span class="label">高维空间</span> <span class="label">差分</span> <span class="label">自然数幂</span></p><p>对于一个行动序列，定义它的 <strong>rounding box</strong> 是每一维坐标在变化过程中的极差区间构成的超立方体空间，定义它的<strong>行动向量</strong>是每一步行动的向量和。感性理解一下。</p><p>用两个向量<script type="math/tex">(l_1,\ldots,l_k)</script>（减向量）和<script type="math/tex">(r_1,\ldots,r_k)</script>（增向量）表示整个行动序列的 rounding box，其中<script type="math/tex">l_i</script>表示第<script type="math/tex">i</script>维坐标的最大减量，<script type="math/tex">r_i</script>表示最大增量。同时用<script type="math/tex">\textbf{v}</script>表示它的行动向量。</p><p>为了方便叙述和实现，我们先对行动序列处理一下，使得<script type="math/tex">\mathbf{v}</script>的每一维都非负。直观的说，让<script type="math/tex">\mathbf{v}</script>的方向指向“右上角”。这样的变换不影响答案。</p><p>考虑走不超过<script type="math/tex">n</script>步就走出场地的点。可以枚举<script type="math/tex">i</script>，计算走恰好<script type="math/tex">i</script>步走出空间的点数，也就是【前<script type="math/tex">i-1</script>步的 rounding box 在空间内】的点数减去【前<script type="math/tex">i</script>步的 rounding box 在空间内】的点数。</p><p>接下来考虑不属于上述类的点。</p><p>行动的过程可以概括为：从起点<script type="math/tex">x</script>出发，先走若干次（可能为<script type="math/tex">0</script>）行动向量到达一个点<script type="math/tex">y</script>，然后走<script type="math/tex">n+j</script>步（<script type="math/tex">1\le j\le n</script>）走出空间。</p><details><summary>为什么要这么分类</summary><p>如果我们将行动过程概况为：从起点<script type="math/tex">x</script>出发，先走<script type="math/tex">t</script>次（可能为<script type="math/tex">0</script>）行动向量到达一个点<script type="math/tex">y</script>，然后走<script type="math/tex">j</script>步（<script type="math/tex">1\le j\le n</script>）走出空间。</p><p>那么就会发现：当<script type="math/tex">t=0</script>和<script type="math/tex">t=1</script>对应的<script type="math/tex">y</script>的点集之间的关系不能简单地用<script type="math/tex">\mathbf{v}</script>的信息表示，因此难以合并计算。</p></details><p>接下来考虑<script type="math/tex">y</script>的分布。固定<script type="math/tex">j</script>。</p><p>要求从<script type="math/tex">y</script>点恰好在<script type="math/tex">n+j</script>步走出空间，合法的<script type="math/tex">y</script>的个数相当于【前<script type="math/tex">n+j-1</script>步的 rounding box 在空间内】的点数减去【前<script type="math/tex">n+j</script>步的 rounding box 在空间内】的点数。差分<script type="math/tex">y</script>的分布，将问题转化为：<script type="math/tex">y</script>分布在一个超立方体内，求所有<script type="math/tex">y</script>的贡献和。</p><p>考虑分布在【走<script type="math/tex">n+j</script>步的 rounding box】的<script type="math/tex">y</script>的贡献。一个<script type="math/tex">y</script>的贡献可拆分为：</p><ul><li>从<script type="math/tex">y+\mathbf{v}</script>走<script type="math/tex">j</script>步走出边界的贡献和。</li><li>从<script type="math/tex">x</script>走到<script type="math/tex">y+\mathbf{v}</script>的贡献和。</li></ul><p>容易发现，【走<script type="math/tex">n+j</script>步的 rounding box】的减向量与原行动序列的减向量相同，仍是<script type="math/tex">(l_1,\ldots,l_k)</script>。用<script type="math/tex">(r'_1,\ldots,r'_k)</script>表示其增向量。</p><p>则<script type="math/tex">y</script>的限制是<script type="math/tex">l_i&lt; y_i \le w_i - r'_i</script>。</p><h3><a id="第一部分" href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p>为了计算从<script type="math/tex">y+\mathbf{v}</script>走<script type="math/tex">j</script>步走出边界的贡献和，我们要先考虑有多少个<script type="math/tex">x</script>能走到<script type="math/tex">y</script>。</p><p>考虑固定<script type="math/tex">y</script>，计算有多少个可以到达<script type="math/tex">y</script>的起点<script type="math/tex">x</script>。那么<script type="math/tex">x</script>的限制是<script type="math/tex">x_i &gt; l_i</script>（<script type="math/tex">1\le i\le k</script>），此外<script type="math/tex">x+t\mathbf{v} = y</script>（<script type="math/tex">t\ge 0</script>）。这样的<script type="math/tex">x</script>的个数是</p><script type="math/tex;mode=display">f(y) = \min_{1\le i\le k}\left\lfloor \frac{y_i-l_i-1}{\mathbf{v}_i}\right\rfloor+1</script><p>考虑从<script type="math/tex">y+\mathbf{v}</script>走<script type="math/tex">j</script>步走出边界的贡献和，即：</p><script type="math/tex;mode=display">j\times
\sum_{y_1=l_1+1}^{w_1-r'_1}
\sum_{y_2=l_2+1}^{w_2-r'_2}\cdots
\sum_{y_k=l_k+1}^{w_k-r'_k} f(y)</script><p>记<script type="math/tex">p_i = w_i-r'_i-l_i-1</script>。上式可以化简为<script type="math/tex">j\times \sum_{t\ge 0} \prod_{i=1}^k\max(0,p_i-t\mathbf{v}_i+1)</script>。</p><details><summary>化简过程</summary><script type="math/tex;mode=display">\begin{aligned}
&\sum_{y_1=l_1+1}^{w_1-r'_1}
\sum_{y_2=l_2+1}^{w_2-r'_2}\cdots
\sum_{y_k=l_k+1}^{w_k-r'_k}
\min_{1\le i\le k}\left\lfloor \frac{y_i-l_i-1}{\mathbf{v}_i}\right\rfloor+1\\
=& \sum_{y_1=0}^{p_1}
\sum_{y_2=0}^{p_2}\cdots
\sum_{y_k=0}^{p_k}
\min_{1\le i\le k}\left\lfloor \frac{y_i}{\mathbf{v}_i}\right\rfloor+1 \\
=& \sum_{t\ge 1} \sum_{y_1=0}^{p_1}
\sum_{y_2=0}^{p_2}\cdots
\sum_{y_k=0}^{p_k}
\left[\min_{1\le i\le k}\left\lfloor \frac{y_i}{\mathbf{v}_i}\right\rfloor+1\ge t \right] \\
=& \sum_{t\ge 0} \sum_{y_1=0}^{p_1}
\sum_{y_2=0}^{p_2}\cdots
\sum_{y_k=0}^{p_k}
\left[\min_{1\le i\le k}\left\lfloor \frac{y_i}{\mathbf{v}_i}\right\rfloor \ge t \right] \\
=& \sum_{t\ge 0} \sum_{y_1=0}^{p_1} [y_1 \ge t\mathbf{v}_1]
\sum_{y_2=0}^{p_2} [y_2 \ge t\mathbf{v}_2]\cdots
\sum_{y_k=0}^{p_k} [y_k \ge t\mathbf{v}_k] \\
=& \sum_{t\ge 0} \prod_{i=1}^k\max(0,p_i-t\mathbf{v}_i+1)
\end{aligned}</script></details><p>考虑如何计算上式。容易发现当存在<script type="math/tex">p_i-t\mathbf{v_i} &lt; 0</script>时整个式子的值就是<script type="math/tex">0</script>。因此可以把<script type="math/tex">\max</script>去掉。</p><p>设<script type="math/tex">q = \min_{1\le i\le k}\lfloor\frac{p_i+1}{\mathbf{v}_i}\rfloor</script>，则上式可以化简为<script type="math/tex">j \sum_{t = 0}^q \prod_{i=1}^k(p_i-t\mathbf{v}_i+1)</script>。</p><p>连乘积可以看作一个关于<script type="math/tex">t</script>的<script type="math/tex">k</script>次多项式<script type="math/tex">F(x) = \sum_{i}f_ix^i</script>，则可以化简为<script type="math/tex">j\sum_{i=0}^kf_i\sum_{t = 0}^qt^i</script>。</p><p>后者是个<script type="math/tex">k</script>次前缀和的式子。可以<script type="math/tex">O(k^2)</script>预处理<script type="math/tex">O(k)</script>计算。</p><details><summary>计算过程</summary><p>设<script type="math/tex">f(n,k) = \sum_{i=0}^n i^k</script>。考虑差分，定义<script type="math/tex">f_0(n,k) = f(n,k), f_i(n,k) = f_{i-1}(n,k) - f_{i-1}(n-1,k)</script>（<script type="math/tex">i&gt;0</script>）。差分<script type="math/tex">k+1</script>次，就会变成常数序列。</p><p>那么用<script type="math/tex">f_i(i,k)</script>计算对<script type="math/tex">f(n,k)</script>的贡献即可。容易发现这是个格路计数问题。</p><p>因此可以<script type="math/tex">O(k^2)</script>预处理<script type="math/tex">O(k)</script>计算。</p></details><h3><a id="第二部分" href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p>考虑从<script type="math/tex">x</script>走到<script type="math/tex">y+\mathbf{v}</script>的贡献和。枚举走了<script type="math/tex">t</script>轮行动序列到<script type="math/tex">y</script>（即<script type="math/tex">x+t\mathbf{v} = y</script>）。同时我们要求<script type="math/tex">l_i&lt;x_i</script>，因此贡献和为</p><script type="math/tex;mode=display">n\times \sum_{t\ge 0}(t+1)\sum_{y_1=l_1+1}^{w_1-r'_1}
\sum_{y_2=l_2+1}^{w_2-r'_2}\cdots
\sum_{y_k=l_k+1}^{w_k-r'_k} \prod_{i=1}^k [y_i - t\mathbf{v}_i&gt; l_i]</script><p>化简得到<script type="math/tex">n\sum_{t\ge 0}(t+1) \prod_{i=1}^k(p_i - t\mathbf{v}_i + 1)</script>。</p><details><summary>化简过程</summary><script type="math/tex;mode=display">\begin{aligned}
&\sum_{t\ge 0}(t+1)\sum_{y_1=l_1+1}^{w_1-r'_1}
\sum_{y_2=l_2+1}^{w_2-r'_2}\cdots
\sum_{y_k=l_k+1}^{w_k-r'_k} \prod_{i=1}^k [y_i - t\mathbf{v}_i&gt; l_i] \\
=& \sum_{t\ge 0}(t+1)\sum_{y_1=0}^{p_1}
\sum_{y_2=0}^{p_2}\cdots
\sum_{y_k=0}^{p_k} \prod_{i=1}^k [y_i \ge t\mathbf{v}_i] \\
=& \sum_{t\ge 0}(t+1) \prod_{i=1}^k(p_i - t\mathbf{v}_i + 1)
\end{aligned}</script></details><p>可以用与第一部分类似的方法处理。</p><p>算上枚举<script type="math/tex">j</script>的复杂度，总复杂度<script type="math/tex">O(nk^2)</script>。</p><p><a target="_blank" rel="noopener" href="https://loj.ac/s/1032438">代码</a></p><h2><a id="烟花表演" href="#烟花表演" class="headerlink" title="烟花表演"></a><a target="_blank" rel="noopener" href="https://loj.ac/p/2568">烟花表演</a></h2><blockquote><p>给出一棵<script type="math/tex">n</script>个点边带权的有根树。要求改变边的长度使得所有叶子结点的深度相同。将一条长度为<script type="math/tex">w</script>的边改成<script type="math/tex">w'</script>的代价是<script type="math/tex">|w-w'|</script>（<script type="math/tex">w'\ge 0</script>）。</p><p><script type="math/tex">n\le 6\times 10^5, w_i\le 10^9</script>。</p></blockquote><p><span class="label">凸函数</span> <span class="label">拐点</span> <span class="label">可并堆</span> <span class="label">DP</span></p><p>设<script type="math/tex">f_u(x)</script>表示将结点<script type="math/tex">u</script>子树的叶子到<script type="math/tex">u</script>的距离调整为<script type="math/tex">x</script>的最小代价。用<script type="math/tex">s(u)</script>表示<script type="math/tex">u</script>的儿子结点集合，那么我们可以将转移过程分成两个部分：</p><ul><li>把<script type="math/tex">u</script>连一条长度为<script type="math/tex">w</script>的边到它的父亲。即设<script type="math/tex">g_u(x)</script>表示把<script type="math/tex">u</script>的儿子调整到<script type="math/tex">u</script>的父亲距离为<script type="math/tex">x</script>的最小代价，那么<script type="math/tex">g_u(x) = \min_{0\le i \le x}\{ f_u(i) + |w-x+i| \}</script>。</li><li>将<script type="math/tex">u</script>的儿子的贡献合并：<script type="math/tex">f_u(x) = \sum_{v\in s(v)}g_v(x)</script>。</li></ul><p>为了高效维护这两种操作，我们需要重点分析第一个转移的性质。</p><p>感性理解一下，<script type="math/tex">f_u</script>其实是<script type="math/tex">O(n+m)</script>个绝对值函数的“和”，可以认为<script type="math/tex">f_u</script>具有凸性（下凸壳）。算法的过程会证明这一点，因此我们先认为它是对的。</p><p>同样显然的是，<script type="math/tex">f_u</script>是个直线围成的凸壳，直线的斜率是整数。</p><p>分析<script type="math/tex">g_u</script>的转移。为了方便叙述，省略下标<script type="math/tex">u</script>。</p><p>固定<script type="math/tex">x</script>，则<script type="math/tex">|w-x+i|</script>取到最小值当且仅当<script type="math/tex">i=x-w</script>。另一方面，不妨设<script type="math/tex">f</script>的最小值区间是<script type="math/tex">[L,R]</script>。</p><p>注意到绝对值函数顶点两边的斜率是<script type="math/tex">-1</script>和<script type="math/tex">1</script>，而<script type="math/tex">f</script>函数<script type="math/tex">L</script>左边的斜率<script type="math/tex">\le -1</script>，<script type="math/tex">R</script>右边的斜率<script type="math/tex">\ge 1</script>。换言之我们应当优先满足<script type="math/tex">f</script>的最优性再考虑绝对值函数的最优性。</p><p>对于转移式</p><script type="math/tex;mode=display">g(x) = \min_{0\le i \le x}\{ f(i) + |w-x+i| \}</script><ul><li>当<script type="math/tex">x &lt; L</script>时，<script type="math/tex">f(i)</script>为最小值的条件是<script type="math/tex">i=x</script>。因此有<script type="math/tex">g(x) = f(x) + w</script>。</li><li>当<script type="math/tex">L\le x &lt; L+w</script>时，<script type="math/tex">f(i)</script>为最小值的条件是<script type="math/tex">L\le i &lt; \min(L+w,R+1)</script>。而注意到<script type="math/tex">x-w&lt;L</script>，因此当<script type="math/tex">i=L</script>时<script type="math/tex">f</script>取到最小值，绝对值函数取到极小值，即<script type="math/tex">g(x) = f(L) + w-x+L</script>。</li><li>当<script type="math/tex">L+w \le x\le  R+w</script>时，让<script type="math/tex">i=x-w</script>可以使<script type="math/tex">f</script>和绝对值函数同时取到最小值，则<script type="math/tex">g(x) = f(x-w) = f(L)</script>。</li><li>当<script type="math/tex">R+w &lt; x</script>时，让<script type="math/tex">i=R</script>可以使<script type="math/tex">f</script>取到最小值，此时绝对值函数取到极小值，则<script type="math/tex">g(x) = f(R) + |w-x+R| = f(L) + x-w-R</script>。</li></ul><p>接下来考虑怎么维护<script type="math/tex">f</script>。</p><p>上述过程的实质是平移、加一段斜率为<script type="math/tex">-1</script>的直线、将凸壳的右边替换为斜率为<script type="math/tex">1</script>的直线。</p><p>考虑用可重集维护拐点的横坐标。一个拐点会导致其右边的斜率加<script type="math/tex">1</script>。再维护一下最后一个拐点右边的斜率<script type="math/tex">k</script>，就可以表示整个凸包了。</p><ul><li><p>对于第一种转移，我们只需要找到一个<script type="math/tex">L</script>和<script type="math/tex">R</script>（<script type="math/tex">L</script>不唯一，<script type="math/tex">R</script>唯一），然后将<script type="math/tex">R</script>右边的拐点删掉，将<script type="math/tex">L</script>和<script type="math/tex">R</script>分别变成<script type="math/tex">L+w,R+w</script>即可，然后把<script type="math/tex">k</script>改成<script type="math/tex">1</script>。将一个<script type="math/tex">L</script>变成<script type="math/tex">L+w</script>相当于加一段斜率为<script type="math/tex">-1</script>的直线。</p></li><li><p>对于第二种转移，相当于点值相加，那么合并可重集，<script type="math/tex">k</script>相加即可。</p></li></ul><p>为了维护上述可重集，我们还需要支持：找到<script type="math/tex">L</script>和<script type="math/tex">R</script>。这个并不难。由于一个拐点会导致其右边的斜率加<script type="math/tex">1</script>，而我们知道最后一个拐点右边的斜率，那么我们可以删除横坐标最大的<script type="math/tex">k-1</script>个拐点就可以找到<script type="math/tex">R</script>，然后再删<script type="math/tex">R</script>就可以找到<script type="math/tex">L</script>。</p><p>一个拐点右边的斜率恰好等于<script type="math/tex">u</script>的儿子数，因此复杂度有保证。</p><p>最后考虑如何计算答案。我们知道<script type="math/tex">f(0)</script>等于边长之和，这样就可以计算出<script type="math/tex">f(L)</script>处的点值了。</p><p>不妨用可并堆维护可重集。时间复杂度<script type="math/tex">O(n\log_2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://loj.ac/s/1032928">代码</a></p><h2><a id="硬件包管理器" href="#硬件包管理器" class="headerlink" title="硬件包管理器"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/problem/1476">硬件包管理器</a></h2><blockquote><p>有<script type="math/tex">n</script>个三元组<script type="math/tex">(t_i,a_i,b_i)</script>和<script type="math/tex">m</script>个限制，第<script type="math/tex">j</script>个限制形如<script type="math/tex">(l_j,r_j)</script>，表示要求将区间<script type="math/tex">[l_j,r_j)</script>的三元组的<script type="math/tex">t</script>调整为<script type="math/tex">\ge t_{r_j}</script>。将<script type="math/tex">t_i</script>调整为<script type="math/tex">t'_i</script>的代价是<script type="math/tex">a_i\max(t_i-t'_i,0) + b_i\max(t'_i-t_i,0)</script>。</p><p>求满足所有限制的最小调整代价。</p><p><script type="math/tex">n\le 3\times 10^5, m\le 3\times 10^5</script>。</p></blockquote><p><span class="label">凸函数</span> <span class="label">拐点</span> <span class="label">可并堆</span> <span class="label">DP</span></p><p>限制可以处理成树形结构。接下来就和烟花表演的思路类似了。</p><p>设<script type="math/tex">f_u(x)</script>表示让子树<script type="math/tex">u</script>的<script type="math/tex">t</script>都<script type="math/tex">\ge x</script>的最小代价。有</p><ul><li><script type="math/tex">g_u(x) = \sum_{v\in s(u)} f_v(x)</script>。</li><li><script type="math/tex">f_u(x) = \min( \min_{x\le i\le t_u}g_u(i)+(t_u-i)a_u, \min_{i\ge t_u,i\ge x} g_u(i) + (i-t_u)b_u )</script>。</li></ul><p>第二个转移可以理解为，给<script type="math/tex">g_u</script>加上一个类绝对值函数，然后把斜率小于<script type="math/tex">0</script>的部分改成水平直线。</p><p>相当于加一个横坐标为<script type="math/tex">t_u</script>的拐点。</p><p>这次我们用二元组<script type="math/tex">(x,y)</script>表示拐点的横坐标以及这个拐点对斜率的增量。就可以用可并堆维护了。</p><p>这题的可并堆是小根堆。求答案的时候用<script type="math/tex">f(10^5)</script>减掉差值。</p><p><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/submission/304082">代码</a></p><h2><a id="寿司早餐" href="#寿司早餐" class="headerlink" title="寿司早餐"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/problem/1477">寿司早餐</a></h2><blockquote><p>给出<script type="math/tex">n</script>个<script type="math/tex">d</script>位线性基<script type="math/tex">B_1,\ldots,B_n</script>，问他们的张成空间的并（去重）的第<script type="math/tex">k</script>大。</p><p><script type="math/tex">n\le 12, d\le 50, k\le 10^{18}</script>。</p></blockquote><p><span class="label">线性基</span> <span class="label">线性基合并</span> <span class="label">容斥</span></p><p>数理题。</p><p>记线性基<script type="math/tex">B</script>张成的线性空间为<script type="math/tex">V=\text{span}(B)</script>。</p><p>我们要求的是<script type="math/tex">U = \text{span}(B_1)\cup \cdots \cup \text{span}(B_n)</script>中的第<script type="math/tex">k</script>大。</p><p>可以转化为，枚举<script type="math/tex">i</script>，固定前缀<script type="math/tex">\overline{u_1\ldots u_i}</script>，求<script type="math/tex">U</script>中以<script type="math/tex">\overline{u_1\ldots u_i1}</script>为前缀的向量的个数。</p><p>计数问题可以容斥，则枚举<script type="math/tex">[n]</script>的子集<script type="math/tex">S</script>，求<script type="math/tex">\bigcap_{j\in S}\text{span}(B_j)</script>中以<script type="math/tex">\overline{u_1\ldots u_i1}</script>为前缀的向量的个数。</p><p><strong>引理 1</strong>：两个线性空间的交仍是线性空间。</p><details><summary>证明</summary><p>对于两个线性空间<script type="math/tex">V_1,V_2</script>，如果向量<script type="math/tex">a,b</script>满足<script type="math/tex">a,b\in V_1\cap V_2</script>，则有<script type="math/tex">a\oplus b\in V_1</script>，<script type="math/tex">a\oplus b\in V_2</script>，则<script type="math/tex">a\oplus b \in V_1 \cap V_2</script>。</p></details><p>因此问题转化为如何求两个线性空间交的线性基。</p><p><strong>引理 2</strong>：对于两个线性基<script type="math/tex">B_1,B_2</script>，设<script type="math/tex">W=\{v \in B_2 | v\in \text{span}(B_1)\}</script>，即<script type="math/tex">B_2</script>中能被<script type="math/tex">B_1</script>表示的向量基。若<script type="math/tex">\text{span}(B_1)\cap \text{span}(B_2\setminus W) = \varnothing</script>，即<script type="math/tex">B_1</script>与<script type="math/tex">B_2\setminus W</script>线性无关，则<script type="math/tex">W</script>是<script type="math/tex">\text{span}(B_1)\cap \text{span}(B_2)</script>的一组线性基。</p><p>设<script type="math/tex">B_1 = \{a_1,\ldots,a_x\}</script>，<script type="math/tex">B_2=\{b_1,\ldots,b_y\}</script>。</p><details><summary>证明</summary><p>不妨设<script type="math/tex">W = \{b_1,\ldots,b_z\}</script>（<script type="math/tex">z\le y</script>）。</p><p>对于任意向量<script type="math/tex">v\in \text{span}(B_1)\cap\text{span}(B_2)</script>，<script type="math/tex">v</script>能被<script type="math/tex">a_i</script>和<script type="math/tex">b_i</script>分别表示。</p><p>假设<script type="math/tex">v = \sum A_ia_i = \sum B_ib_i</script>，那么<script type="math/tex">\sum A_ia_i - \sum_{i\le z}B_ib_i = \sum_{z&lt;i\le y}B_ib_i</script>。</p><p>式子的左边是用<script type="math/tex">B_1</script>和<script type="math/tex">W</script>表示的，式子的右边是用<script type="math/tex">B_2\setminus W</script>表示的。</p><p>由于<script type="math/tex">W</script>可以被<script type="math/tex">B_1</script>表示，因此左边可以只用<script type="math/tex">B_1</script>表示。</p><p>因为<script type="math/tex">B_1</script>与<script type="math/tex">B_2\setminus W</script>线性无关，因此等式右边必须为<script type="math/tex">0</script>，否则等式不可能成立。</p><p>注意到这个等式是对任意<script type="math/tex">v\in \text{span}(B_1)\cap\text{span}(B_2)</script>成立的。换言之对任意<script type="math/tex">v\in \text{span}(B_1)\cap\text{span}(B_2)</script>都有等式的右边为<script type="math/tex">0</script>。</p><p>因此<script type="math/tex">B_i = 0</script>（<script type="math/tex">z&lt;i\le y</script>），因此<script type="math/tex">v=\sum_{i\le z}B_ib_i</script>，即<script type="math/tex">v</script>可以被<script type="math/tex">W</script>表示，即<script type="math/tex">v\in\text{span}(W)</script>。</p><p>因此<script type="math/tex">\text{span}(B_1)\cap\text{span}(B_2) = \text{span}(W)</script>。</p></details><p>但问题在于，对于两个线性基<script type="math/tex">B_1,B_2</script>，并非总是存在<script type="math/tex">W=\{v \in B_2 | v\in \text{span}(B_1)\}</script>使得<script type="math/tex">B_1</script>与<script type="math/tex">B_2\setminus W</script>线性无关。因此我们需要构造一个线性基<script type="math/tex">B_2'</script>，使得<script type="math/tex">\text{span}(B_2) = \text{span}(B_2')</script>且对于<script type="math/tex">W'=\{v \in B'_2 | v\in \text{span}(B_1)\}</script>，有<script type="math/tex">B_1</script>与<script type="math/tex">B_2'\setminus W'</script>线性无关。</p><p>设<script type="math/tex">B_2' = \{c_1,\ldots,c_y\}</script>。对于<script type="math/tex">b_i</script>：</p><ul><li>如果它能被<script type="math/tex">a_1\ldots,a_x, b_1\ldots,b_{i-1}</script>线性表出，那么随便取一种表出方案，设<script type="math/tex">b_i = p_1a_1+\cdots + p_xa_x+q_1b_1+\cdots + q_{i-1}b_{i-1}</script>，那么令<script type="math/tex">c_i = p_1a_1+\cdots + p_xa_x</script>。</li><li>否则，令<script type="math/tex">c_i = b_i</script>。</li></ul><details><summary>构造的正确性</summary><p>首先证明<script type="math/tex">B_1</script>与<script type="math/tex">B_2'\setminus W'</script>线性无关。</p><p>这是显然的。因为<script type="math/tex">B_2'\setminus W' = \{c_i | c_i = b_i\}</script>，因此这些基与<script type="math/tex">B_1</script>可以合并成一个线性基。而一个线性基的划分显然是互相线性无关的。</p><p>接下来证明<script type="math/tex">B_2</script>能被<script type="math/tex">B_2'</script>表示（相当于证明<script type="math/tex">B_2'</script>是合法的线性基）。容易发现<script type="math/tex">b_i</script>可以用<script type="math/tex">c_i</script>和<script type="math/tex">b_1, \ldots, b_{i-1}</script>表示。当<script type="math/tex">i=1</script>时始终有<script type="math/tex">b_1 = c_1</script>，使用归纳法可以证明<script type="math/tex">b_i</script>能被<script type="math/tex">c_1,\ldots,c_i</script>表示。</p></details><p>实现上述构造算法的时候，我们维护<script type="math/tex">a_1\ldots,a_x, b_1\ldots,b_{i-1}</script>构成的线性基<script type="math/tex">T</script>，并维护<script type="math/tex">T</script>中的每个向量是<script type="math/tex">a_1\ldots,a_x, b_1\ldots,b_{i-1}</script>中哪些向量的和（一种方案即可），用二进制数表示。</p><p>已知线性基求张成空间中前缀为<script type="math/tex">\overline{u_1\ldots u_i1}</script>的向量个数可以<script type="math/tex">O(d)</script>计算。</p><p>直接枚举<script type="math/tex">[n]</script>的子集容斥的复杂度是<script type="math/tex">O(n2^nd^2)</script>。从去掉最后一个数的基转移可以优化到<script type="math/tex">O(2^nd^2)</script>。预处理出线性基后容斥的复杂度是<script type="math/tex">O(2^nd\log_2k)</script>，因此总复杂度<script type="math/tex">O(2^n(d^2+d\log_2k))</script>。</p><p><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/submission/304107">代码</a></p></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2021年2月11日 第8次修订</li><li class="post-history-item">2021年2月11日 第7次修订</li><li class="post-history-item">2021年2月10日 第6次修订</li><li class="post-history-item">2021年1月22日 第5次修订</li><li class="post-history-item">2021年1月12日 第4次修订</li><li class="post-history-item">2021年1月12日 第3次修订</li><li class="post-history-item">2021年1月11日 第2次修订</li><li class="post-history-item">2020年10月11日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/Probset/Summery-for-practice/">做题总结</a></div><div class="prev-post"><a href="/Probset/21-March-1/">2021 省选三轮跟训日志 1 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>