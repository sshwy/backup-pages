<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>做题总结 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">做题总结</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2021年2月11日星期四下午12点32分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2021年2月11日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 7,429 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> <a class="directory" href="/directory/Probset/">训练题单 </a><span class="icon smallarrow"></span> 当前文章</div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#构造题"><span class="toc-number">1.</span> <span class="toc-text">构造题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Atcoder5093"><span class="toc-number">1.1.</span> <span class="toc-text">Atcoder5093</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtCoder-5167"><span class="toc-number">1.2.</span> <span class="toc-text">AtCoder 5167</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CF-427D"><span class="toc-number">2.1.</span> <span class="toc-text">CF 427D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CF-316G3"><span class="toc-number">2.2.</span> <span class="toc-text">CF 316G3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CF-204E"><span class="toc-number">2.3.</span> <span class="toc-text">CF 204E</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZJOI2015-诸神眷顾的幻想乡"><span class="toc-number">2.4.</span> <span class="toc-text">ZJOI2015 诸神眷顾的幻想乡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-number">3.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ZR-1037C"><span class="toc-number">3.1.</span> <span class="toc-text">ZR 1037C</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CF-438D"><span class="toc-number">3.2.</span> <span class="toc-text">CF 438D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UOJ-228"><span class="toc-number">3.3.</span> <span class="toc-text">UOJ 228</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LOJ-121"><span class="toc-number">3.4.</span> <span class="toc-text">LOJ 121</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BZOJ1568-JSOI2008"><span class="toc-number">3.5.</span> <span class="toc-text">BZOJ1568 JSOI2008</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BZOJ2038"><span class="toc-number">3.6.</span> <span class="toc-text">BZOJ2038</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CF1221F"><span class="toc-number">3.7.</span> <span class="toc-text">CF1221F</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZJOI2019-线段树"><span class="toc-number">3.8.</span> <span class="toc-text">ZJOI2019 线段树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子异和"><span class="toc-number">3.9.</span> <span class="toc-text">子异和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图论"><span class="toc-number">4.</span> <span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AtCoder-5168"><span class="toc-number">4.1.</span> <span class="toc-text">AtCoder 5168</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BZOJ1001-狼抓兔子"><span class="toc-number">4.2.</span> <span class="toc-text">BZOJ1001 狼抓兔子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZR-308"><span class="toc-number">4.3.</span> <span class="toc-text">ZR 308</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CF1243-0-1MST"><span class="toc-number">4.4.</span> <span class="toc-text">CF1243 0-1MST</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计数"><span class="toc-number">5.</span> <span class="toc-text">计数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AtCoder-5169"><span class="toc-number">5.1.</span> <span class="toc-text">AtCoder 5169</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CF1221G"><span class="toc-number">5.2.</span> <span class="toc-text">CF1221G</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LG4980"><span class="toc-number">5.3.</span> <span class="toc-text">LG4980</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BZOJ1002-轮状病毒"><span class="toc-number">5.4.</span> <span class="toc-text">BZOJ1002 轮状病毒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BZOJ3202-SDOI2013-项链"><span class="toc-number">5.5.</span> <span class="toc-text">BZOJ3202 SDOI2013 项链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BZOJ1547-周末晚会"><span class="toc-number">5.6.</span> <span class="toc-text">BZOJ1547 周末晚会</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZR996-空"><span class="toc-number">5.7.</span> <span class="toc-text">ZR996 空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercise"><span class="toc-number">5.8.</span> <span class="toc-text">Exercise</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#博弈"><span class="toc-number">6.</span> <span class="toc-text">博弈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CF1221E"><span class="toc-number">6.1.</span> <span class="toc-text">CF1221E</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#期望"><span class="toc-number">7.</span> <span class="toc-text">期望</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ABC144-F"><span class="toc-number">7.1.</span> <span class="toc-text">ABC144 F</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#离线"><span class="toc-number">8.</span> <span class="toc-text">离线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HNOI2016-网格"><span class="toc-number">8.1.</span> <span class="toc-text">HNOI2016 网格</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心"><span class="toc-number">9.</span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CF893-D"><span class="toc-number">9.1.</span> <span class="toc-text">CF893 D</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数论-数学"><span class="toc-number">10.</span> <span class="toc-text">数论 &#x2F; 数学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ZR1090-A-B-Problem"><span class="toc-number">10.1.</span> <span class="toc-text">ZR1090 A+B Problem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CF1255-E2"><span class="toc-number">10.2.</span> <span class="toc-text">CF1255 E2</span></a></li></ol></li></ol></div><hr></div><div class="post-content"><h2><a id="构造题" href="#构造题" class="headerlink" title="构造题"></a>构造题</h2><h3><a id="Atcoder5093" href="#Atcoder5093" class="headerlink" title="Atcoder5093"></a>Atcoder5093</h3><p><a target="_blank" rel="noopener" href="https://vjudge.net/problem/AtCoder-5093">题面</a></p><p>考虑增量。对于一个大小为 k 的图，我们加一个点进去。那么我们求出原本这个图的哈密尔顿回路的最大值 M，则我们新连的边只要大于 M，就不会和以前的路径冲突。现在我们考虑新连的路径互不冲突。考虑构造一个序列<script type="math/tex">a=\left\langle 1,2,4,7,12,20,29,38,52,73 \right\rangle</script>这个序列满足所有的<script type="math/tex">a_i</script>和<script type="math/tex">a_i+a_j</script>是互不相同的。因此我们第 k+1 个点连向第 i 个点的边权设为<script type="math/tex">(M+1)\times a_i</script>。这样就行了。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/zroi/0912/f.cpp">代码</a></p><h3><a id="AtCoder-5167" href="#AtCoder-5167" class="headerlink" title="AtCoder 5167"></a>AtCoder 5167</h3><p><a target="_blank" rel="noopener" href="https://vjudge.net/contest/326992#problem/D">题面</a></p><p>考虑分治，每次把当前点集分成两个点集，连二分图，然后左右递归做。</p><p>由于左右两边点集不相交，因此两边递归下去连出来的二分图也是不相交的。</p><p>level 就是当前递归的层数。</p><p>标算是一个鬼畜的 lowbit 构造法，不太可扩展。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/zroi/0919/d.cpp">代码</a></p><h2><a id="字符串" href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3><a id="CF-427D" href="#CF-427D" class="headerlink" title="CF 427D"></a>CF 427D</h3><p><a target="_blank" rel="noopener" href="http://codeforces.com/problemset/problem/427/D">题面</a></p><p>一个串建 SAM，另一个串在上面跑就行了。跑的时候要记一下另一个串的当前长度和状态数。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/427d.cpp">代码</a></p><h3><a id="CF-316G3" href="#CF-316G3" class="headerlink" title="CF 316G3"></a>CF 316G3</h3><p><a target="_blank" rel="noopener" href="http://codeforces.com/contest/316/problem/G3">题面</a></p><p>把所有串（包括第一个串）连起来，加一个分隔符（<code class="inline-code">&#123;</code>）建一个 SAM，统计状态数的时候分串统计。然后统计每个状态的贡献就行。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/316g3.cpp">代码</a></p><h3><a id="CF-204E" href="#CF-204E" class="headerlink" title="CF 204E"></a>CF 204E</h3><p><a target="_blank" rel="noopener" href="http://codeforces.com/problemset/problem/204/E">题面</a></p><p>建一个广义 SAM，然后用 Map 统计一下各个串是否经过这个状态以及经过次数，统计的时候和状态数乘一乘就行。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/204e.cpp">代码</a></p><h3><a id="ZJOI2015-诸神眷顾的幻想乡" href="#ZJOI2015-诸神眷顾的幻想乡" class="headerlink" title="ZJOI2015 诸神眷顾的幻想乡"></a>ZJOI2015 诸神眷顾的幻想乡</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P3346">题面</a></p><p>最多只有 20 个叶结点，所以以每个叶结点为根分别建 Trie，然后合并成一个 Trie，然后在 Trie 上 BFS，每次从父节点的 Last 扩展为当前的结点建 SAM。然后统计本质不同状态数就行。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/luogu/3346.cpp">代码</a></p><h2><a id="数据结构" href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3><a id="ZR-1037C" href="#ZR-1037C" class="headerlink" title="ZR 1037C"></a>ZR 1037C</h3><p><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/contest/401/problem/1037">题面</a></p><p>长度相同的一起处理，本质不同的长度是根号级别的。复杂度<script type="math/tex">O(\sqrt{n})</script>。</p><h3><a id="CF-438D" href="#CF-438D" class="headerlink" title="CF 438D"></a>CF 438D</h3><p><a target="_blank" rel="noopener" href="http://codeforces.com/contest/438/problem/D">题面</a></p><p>线段树，均摊</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/438d.cpp">代码</a></p><h3><a id="UOJ-228" href="#UOJ-228" class="headerlink" title="UOJ 228"></a>UOJ 228</h3><p><a target="_blank" rel="noopener" href="http://uoj.ac/problem/228">题面</a></p><p>对于区间<script type="math/tex">\max-\min\le 1</script>的情况开根，有两种情况：</p><ol><li>开根后差仍为 1，相当于一个区间减；</li><li>开根后变成相同的数，相当于区间覆盖；</li></ol><p>对于这两个标记，在区间覆盖的时候清空区间加的标记；在下传的时候先覆盖再加。均摊<script type="math/tex">O(n\log_2n\log_2\log_2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/uoj/228.cpp">代码</a></p><h3><a id="LOJ-121" href="#LOJ-121" class="headerlink" title="LOJ 121"></a>LOJ 121</h3><p>每条边存在的时间是一个区间，那么我们按时间建线段树，然后每个区间被分成 log 个标记。于是我们在线段树上 DFS，使用可撤消并查集维护连通性即可。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/loj/121.cpp">代码</a></p><h3><a id="BZOJ1568-JSOI2008" href="#BZOJ1568-JSOI2008" class="headerlink" title="BZOJ1568 JSOI2008"></a>BZOJ1568 JSOI2008</h3><p>李超线段树，标记永久化一下，即查询的时候查询路径上的标记。<br>复杂度<script type="math/tex">O(n\log_2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/bzoj/1568.cpp">代码</a></p><h3><a id="BZOJ2038" href="#BZOJ2038" class="headerlink" title="BZOJ2038"></a>BZOJ2038</h3><p>典型的莫队。注意 Luogu 的数据可能区间长度为 1。在提交的时候要删调试的文件（吃一发 WA）</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/bzoj/2038.cpp">代码</a></p><h3><a id="CF1221F" href="#CF1221F" class="headerlink" title="CF1221F"></a>CF1221F</h3><p>显然可以把所有点都放到<script type="math/tex">y=x</script>上方，这样转化之后有<script type="math/tex">\forall(x,y),x&lt;y</script>。</p><p>考虑将所有点按照纵坐标从小到大排序。则我们做一个横着向上的扫描线，每次加入一些点后，我们相当于要合理画出一条竖线，使得横线，竖线，<script type="math/tex">y=x</script>围成的三角形内的点权和减掉三角形直角边边长最大。这本质就是线段树上最大右边缘区间和，可以直接维护。在扫描线向上延伸的时候要在对应结点减去前后位置的差，这样就可以顺便减掉边长（可以理解为边长差分）。</p><p>离散化一下，显然正确性不会变。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/1221f.cpp">代码</a></p><h3><a id="ZJOI2019-线段树" href="#ZJOI2019-线段树" class="headerlink" title="ZJOI2019 线段树"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5280">ZJOI2019 线段树</a></h3><blockquote><p>题面较长。</p></blockquote><p>容易想到，转化为概率问题。每次我们的操作有<script type="math/tex">\frac{1}{2}</script>的可能被执行。不妨设<script type="math/tex">f(u)</script>表示线段树的结点<script type="math/tex">u</script>的 tag 值为 1 的概率。那么我们执行一次操作，结点的<script type="math/tex">f(u)</script>会怎么变化？</p><p>我们将一次操作中的结点分类：</p><p><img src="../../images/summary-for-practice-1.png" alt="t"></p><p>黑点代表被完全覆盖，红点表示被部分覆盖，灰点表示它有可能接受父节点的 pushdown。</p><p>若进行一次操作：</p><ol><li>黑点的<script type="math/tex">f(u)</script>是<script type="math/tex">1</script>；</li><li>红点的<script type="math/tex">f(u)</script>是<script type="math/tex">0</script>；</li><li>灰点的<script type="math/tex">f(u)</script>，取决于其祖先的点上是否有 tag。</li></ol><p>因此光定义<script type="math/tex">f(u)</script>并不能很好地处理灰点的情况。我们还定义<script type="math/tex">g(u)</script>表示，<script type="math/tex">u</script>及其祖先中出现 tag 值为 1 的概率。</p><p>对于<script type="math/tex">g(u)</script>，若进行一次操作：</p><ol><li>黑点的<script type="math/tex">g(u)</script>为<script type="math/tex">1</script>（它自己有 tag）；黑点的儿子（子树）的<script type="math/tex">g(u)</script>也是<script type="math/tex">1</script>；</li><li>红点的<script type="math/tex">g(u)</script>为<script type="math/tex">0</script>；</li><li>灰点的<script type="math/tex">f(u)</script>为<script type="math/tex">g(u)</script>，而<script type="math/tex">g(u)</script>则不变。</li></ol><p>因此我们得到了转移的式子：</p><ol><li>黑点：<script type="math/tex">f(u)=\frac{1}{2}(f(u)+1)</script>，<script type="math/tex">g(v)=\frac{1}{2}(g(v)+1)(v\in T_u)</script>；</li><li>红点：<script type="math/tex">f(u)=\frac{1}{2}f(u)</script>，<script type="math/tex">g(u)=\frac{1}{2}g(u)</script>；</li><li>灰点：<script type="math/tex">f(u)=\frac{1}{2}(f(u)+g(u))</script>。</li></ol><p>使用线段树维护即可。</p><p>时间复杂度<script type="math/tex">O(n\log_2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/loj/3043.cpp">代码</a></p><h3><a id="子异和" href="#子异和" class="headerlink" title="子异和"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5127">子异和</a></h3><blockquote><p>设<script type="math/tex">f(S)=\bigoplus_{x\in S}x</script>，设<script type="math/tex">F(S)=\sum_{T\subseteq S} f(T)</script>。</p><p>给出一棵<script type="math/tex">n</script>个点带点权树。要求支持<script type="math/tex">m</script>次操作：</p><ul><li>路径的权值都异或<script type="math/tex">x</script>；</li><li>求路径的权值集合的<script type="math/tex">F</script>值。</li></ul><p><script type="math/tex">n,m\le 2\times 10^5,a_i\le 10^9</script>。</p></blockquote><p><span class="label">位运算</span> <span class="label">按位考虑</span> <span class="label">线段树</span> <span class="label">树链剖分</span></p><p>首先考虑<script type="math/tex">F</script>怎么算。先按位考虑。那么问题转化为 01 集合的<script type="math/tex">F</script>值。设该集合有<script type="math/tex">x</script>个<script type="math/tex">0</script>，<script type="math/tex">y</script>个<script type="math/tex">1</script>。那么可以得到<script type="math/tex">F(S)=2^{x+y-1}[y&gt;0]</script>。于是我们发现这只和集合大小有关。</p><p>考虑树上的问题，那么我们的问题就转化为 01 点权树的操作。然而树链剖分维护的复杂度是<script type="math/tex">O(n\log_2^2n)</script>的，再加上按位考虑就是<script type="math/tex">O(n\log_2^3n)</script>的。</p><p>不妨把所有位合在一起考虑。因为我们只需要查询当前路径的第<script type="math/tex">k</script>位上是否有 1。那么也就是查询路路径 or。要支持路径 or，路径 xor，我们可以维护<script type="math/tex">a_u,b_u,c_u</script>分别表示当前区间的数哪些位都是 1，哪些位都是 0，哪些位是 01 都出现了的。那么在区间异或的时候对<script type="math/tex">a_u,b_u</script>做一些位运算即可。在向上合并信息的时候可以用<script type="math/tex">a,b</script>更新<script type="math/tex">c</script>。</p><p>总时间复杂度<script type="math/tex">O(n\log_2^2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/32966814">代码</a></p><h2><a id="图论" href="#图论" class="headerlink" title="图论"></a>图论</h2><h3><a id="AtCoder-5168" href="#AtCoder-5168" class="headerlink" title="AtCoder 5168"></a>AtCoder 5168</h3><p><a target="_blank" rel="noopener" href="https://jsc2019-qual.contest.atcoder.jp/tasks/jsc2019_qual_e?lang=en">题面</a></p><p>每行，每列建点，那么在 (x,y) 放一个权值为 w 的卡相当于连一条 (x,y,w) 的边。我们选的方案则一定是一个基环树森林。基环树点数等于边数，则每一条边可以不重不漏地选择一个端点，相当于在这一行（列）被选。于是像找 MST 一样贪心找最大权基环树森林就行。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/zroi/0919/e.cpp">代码</a></p><h3><a id="BZOJ1001-狼抓兔子" href="#BZOJ1001-狼抓兔子" class="headerlink" title="BZOJ1001 狼抓兔子"></a>BZOJ1001 狼抓兔子</h3><p>最小割的题，Get 到了一个给无向边建流的 Trick。似乎更好的做法是平面图最小割转对偶图最短路，但我懒所以直接 Dinic 过了。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/bzoj/1001.cpp">代码</a></p><h3><a id="ZR-308" href="#ZR-308" class="headerlink" title="ZR 308"></a>ZR 308</h3><p>动态加点求桥。</p><p>可以离线并查集维护。首先读下来所有边并建出一个桥的生成树（即加入并查集的边构成的树）。然后再扫一遍边集，如果遇到桥就加 1，否则就删除两点路径上的边的桥标记。使用并查集树上的合并技巧即可。</p><p>时间复杂度<script type="math/tex">O(n\log_2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/zroi/308.cpp">代码</a></p><h3><a id="CF1243-0-1MST" href="#CF1243-0-1MST" class="headerlink" title="CF1243 0-1MST"></a>CF1243 0-1MST</h3><p>求的是 0 连通块的个数。每次加入一个点，看这个点可以和当前的哪些连通块合并，于是遍历所有与这个点有关的边，统计到每个连通块的边数，就可以判断是否存在 0 的边。</p><p>时间复杂度<script type="math/tex">O(n\log_2n+m)</script>。<script type="math/tex">O(n\log_2n)</script>是并查集。</p><h2><a id="计数" href="#计数" class="headerlink" title="计数"></a>计数</h2><h3><a id="AtCoder-5169" href="#AtCoder-5169" class="headerlink" title="AtCoder 5169"></a>AtCoder 5169</h3><p><a target="_blank" rel="noopener" href="https://jsc2019-qual.contest.atcoder.jp/tasks/jsc2019_qual_f?lang=en">题面</a></p><p>一个计数题。首先我们要知道，给 n 个人分不超过 r 个球的方案数是<script type="math/tex">\dbinom{n+r}{r}</script>的。相当于给<script type="math/tex">n+1</script>个人分 r 个球，第<script type="math/tex">n+1</script>个人是一个工具人。</p><p>题意要求从大到小排序后<script type="math/tex">a_m=a_{m+1}</script>，则我们转化为求<script type="math/tex">a_m&gt;a_{m+1}</script>的方案数，然后用总方案数减。</p><p>我们枚举<script type="math/tex">x</script>，则转化为求出<script type="math/tex">a_m=x,a_{m+1} \le x-1,\sum_{i=1}^na_i\le S</script>，的方案数。用差分的方法转化为求<script type="math/tex">a_m\ge x,a_{m+1}\le x-1,\sum_{i=1}^na_i\le S</script>的方案数。然后对<script type="math/tex">a_{m+1\sim n}\le x-1</script>容斥一下，这样相当于球的上限是<script type="math/tex">S-mx-ix</script>，i 是枚举的<script type="math/tex">a_k&gt;x</script>的个数。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/zroi/0919/f.cpp">代码</a></p><h3><a id="CF1221G" href="#CF1221G" class="headerlink" title="CF1221G"></a>CF1221G</h3><p>定义<script type="math/tex">f(S)</script>表示边权属于集合<script type="math/tex">S</script>的方案数。这样容斥一下：</p><script type="math/tex;mode=display">Ans=f(0,1,2)-f(0,1)-f(1,2)-f(0,2)+f(0)+f(1)+f(2)-f(\varnothing)</script><p>接下来挨个分析：</p><ol><li>显然，<script type="math/tex">f(0,1,2)=2^n</script>。</li><li><script type="math/tex">f(0,2)</script>相当于每个连通块染一种颜色，则设连通块数量为<script type="math/tex">C</script>，那么<script type="math/tex">f(0,2)=2^C</script>。</li><li><script type="math/tex">f(0)</script>相当于每个点权值为 0，但孤立点则权值任意。设孤立点个数为<script type="math/tex">I</script>，则<script type="math/tex">f(0)=2^I</script>。</li><li><script type="math/tex">f(2)=f(0)</script>。</li><li><script type="math/tex">f(1)</script>即二分图染色。如果存在非二分图连通块则<script type="math/tex">f(1)=0</script>；否则<script type="math/tex">f(1)=2^C</script>。</li><li><script type="math/tex">f(\varnothing)</script>与边数有关，如果边数为 0 则<script type="math/tex">f(\varnothing)=2^n</script>，否则<script type="math/tex">f(\varnothing)=0</script>。</li><li><script type="math/tex">f(1,2)=f(0,1)</script>。</li></ol><p>最后考虑<script type="math/tex">f(0,1)</script>，它相当于是图的独立集个数。则设<script type="math/tex">f(S)</script>表示 G 的导出子图<script type="math/tex">G[S]</script>的独立集数。那么显然可以枚举当前点是否属于独立集来计数。而合法的状态数不多。采用记忆化搜索，事实上最多枚举<script type="math/tex">2^{\frac{n}{2}}</script>次，然后剩下的就根据记忆化的结果直接返回，复杂度是<script type="math/tex">O(2^{\frac{n}{2}})</script>的。</p><p>总复杂度<script type="math/tex">O(2^{\frac{n}{2}})</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/1221g.cpp">代码</a></p><h3><a id="LG4980" href="#LG4980" class="headerlink" title="LG4980"></a>LG4980</h3><p>Polya 模板题</p><script type="math/tex;mode=display">Ans=\frac{1}{n}\sum_{i=1}^nn^{\gcd(n,i)}\\
=\frac{1}{n}\sum_{d|n}n^d\varphi\left(\frac{n}{d}\right)</script><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/luogu/4980.cpp">代码</a></p><h3><a id="BZOJ1002-轮状病毒" href="#BZOJ1002-轮状病毒" class="headerlink" title="BZOJ1002 轮状病毒"></a>BZOJ1002 轮状病毒</h3><p>正解是基尔霍夫矩阵树定理，但递推式很简单，<script type="math/tex">f_i=3f_{i-1}-f_{i-2}+2</script>。</p><p>高精度即可。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/bzoj/1002.cpp">代码</a></p><h3><a id="BZOJ3202-SDOI2013-项链" href="#BZOJ3202-SDOI2013-项链" class="headerlink" title="BZOJ3202 SDOI2013 项链"></a>BZOJ3202 SDOI2013 项链</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.org/blog/PinkRabbit/solution-p3307">题解 1</a></p><p><a target="_blank" rel="noopener" href="https://www.luogu.org/blog/hbyer/solution-p3307">题解 2</a></p><p>总结一下这题的细节与技巧：</p><ol><li>不能费马小定理求逆元，因为模数有时不是质数。</li><li>LL 乘快速幂的时候要先取模，不然可能溢出。</li><li>注意掌握莫比乌斯反演与容斥的小技巧。</li></ol><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/bzoj/3202.cpp">代码</a></p><h3><a id="BZOJ1547-周末晚会" href="#BZOJ1547-周末晚会" class="headerlink" title="BZOJ1547 周末晚会"></a>BZOJ1547 周末晚会</h3><p>通过 Burnside 定理转化为求 01 链的相邻 1 个数不超过 k 的方案数，并且要求首尾的 1 连起来个数不超过 k。</p><p>如果<script type="math/tex">n\le k</script>那么可以随便染。如果<script type="math/tex">n&gt;k,d\le k</script>则环数不超过<script type="math/tex">k</script>，只要不全染 1 就没事。否则考虑 DP。</p><p><script type="math/tex">f[i,j]</script>表示 i 个数末位 k 个为 1 的方案数（不考虑首位和的情况）。最后减掉不合法的方案即可。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/bzoj/1547.cpp">代码</a></p><h3><a id="ZR996-空" href="#ZR996-空" class="headerlink" title="ZR996 空"></a>ZR996 空</h3><p>具体就看题解了。记两个 Trick。</p><p>首先是字符串子序列匹配方案数和具体的字符是没有关系的，因此枚举最后一段的长度可以转化为组合计数问题。</p><p>然后就是组合数化简的技巧：对于<script type="math/tex">f(n,k)=\sum_{i=0}^n\binom{i+k}{k}p^i</script>，可以写成递推的形式：</p><script type="math/tex;mode=display">\begin{aligned}
f(n,k)&=\sum_{i=0}^n\binom{i+k-1}{k-1}p^i+\sum_{i=0}^n\binom{i+k-1}{k}p^i\\
&=f(n,k-1)+\sum_{i=0}^n\binom{i+k-1}{i-1}p^i\\
&=f(n,k-1)+\sum_{i=0}^{n-1}\binom{i+k}{i}p^{i+1}\\
&=f(n,k-1)+p\sum_{i=0}^{n}\binom{i+k}{i}p^i-\binom{n+k}{n}p^{n+1}\\
&=f(n,k-1)+p\cdot f(n,k)-\binom{n+k}{n}p^{n+1}
\end{aligned}</script><p>于是移项得到</p><script type="math/tex;mode=display">f(n,k)=\frac{f(n,k-1)-\binom{n+k}{k}p^{n+1}}{1-p}</script><h3><a id="Exercise" href="#Exercise" class="headerlink" title="Exercise"></a><a target="_blank" rel="noopener" href="https://loj.ac/problem/3284">Exercise</a></h3><blockquote><p>定义一个置换<script type="math/tex">P</script>的幂周期为最小<script type="math/tex">k</script>使得<script type="math/tex">P^k=I</script>。</p><p>求长度为<script type="math/tex">n</script>的所有置换的幂周期乘积<script type="math/tex">\bmod M</script>。</p><p><script type="math/tex">1\le n\le 7500</script>。</p></blockquote><p><span class="label">min-max 容斥</span> <span class="label">DP</span> <span class="label">组合数学</span></p><p>容易发现，幂周期是环长的 LCM。由于求的是乘积，不妨对每个质因子<script type="math/tex">p</script>考虑指数的和。因此我们要求的就是所有幂周期中<script type="math/tex">p</script>的指数的和<script type="math/tex">\bmod (M-1)</script>。</p><p>设<script type="math/tex">E(p,x)</script>表示<script type="math/tex">p</script>在<script type="math/tex">x</script>中的指数。</p><p>假设环长是<script type="math/tex">l_1,l_2,\cdots,l_m</script>。那么<script type="math/tex">p</script>的指数就是<script type="math/tex">\max E(p,l_i)</script>。</p><script type="math/tex;mode=display">\begin{aligned}
\sum_{l}\max_{i=1}^m E(p,l_i)
&=\sum_{l}\sum_{\varnothing\subset S\subseteq [m]} (-1)^{|S|-1} \min_{i\in S}E(p,l_i)\\
&=\sum_{l}\sum_{\varnothing\subset S\subseteq [m]} (-1)^{|S|-1}\sum_{x\ge 1}\prod_{i\in S}[E(p,l_i)\ge x] \\
\end{aligned}</script><p>不妨设</p><script type="math/tex;mode=display">f(x,p)=\sum_{l}\sum_{\varnothing\subset S\subseteq [m]} (-1)^{|S|-1}\prod_{i\in S}[E(p,l_i)\ge x]</script><p>则原式化为<script type="math/tex">\sum_{x\ge 1}f(x,p)</script>。</p><p>考虑如何计算<script type="math/tex">f(x,p)</script>。容易发现，它相当于强制要求子集里的环长都是<script type="math/tex">p^x</script>的倍数。考虑 DP。设<script type="math/tex">s=p^x</script>，设<script type="math/tex">g_i</script>表示<script type="math/tex">is</script>个数的贡献和。那么枚举第一个数所在环的长度，得到</p><script type="math/tex;mode=display">g_i=-\sum_{j= 1}^i(sj-1)!\binom{si-1}{sj-1}g_{i-j}</script><p>前面的负号是容斥系数。那么<script type="math/tex">f(x,p)</script>就相当于<script type="math/tex">n</script>个数中选择<script type="math/tex">si</script>个数（剩下的<script type="math/tex">n-si</script>个数随便排），然后统计这<script type="math/tex">si</script>个数的贡献：</p><script type="math/tex;mode=display">f(x,p)=f'(s)=\sum_{i= 1}^{\lfloor\frac{n}{s}\rfloor} \binom{n}{si}(n-si)!g_i</script><p>那么计算<script type="math/tex">f(x,p)</script>的复杂度就是<script type="math/tex">O(\frac{n^2}{s^2})</script>。则总复杂度就是<script type="math/tex">O(\sum_{i=1}^n\frac{n^2}{i^2})=O(\frac{n^2\pi^2}{6})</script>，能过。</p><p>注意，枚举的时候只枚举<script type="math/tex">p^x</script>，不要枚举非质因子幂的合数。</p><p><a target="_blank" rel="noopener" href="https://loj.ac/submission/792418">代码</a></p><h2><a id="博弈" href="#博弈" class="headerlink" title="博弈"></a>博弈</h2><h3><a id="CF1221E" href="#CF1221E" class="headerlink" title="CF1221E"></a>CF1221E</h3><p>一道不平等博弈的题。由于 a&gt;b，我们考虑 Bob 先手的情况，对于一段连续的<code class="inline-code">.</code>的长度有 4 种情况：</p><ol><li><script type="math/tex">x&lt;b</script>；</li><li><script type="math/tex">b\le x&lt;a</script>；</li><li><script type="math/tex">a\le x&lt;2b</script>；</li><li><script type="math/tex">x\ge 2b</script>。</li></ol><p>如果存在第 2 种情况，那么 Bob 必胜。因为 Alice 能走的 Bob 一定能走，而 Bob 能走的 Alice 不一定能走。</p><p>如果存在第 4 种局面，那么 Bob 可以走一发构造出 2，这样他也赢了。</p><p>第一种局面没用。第三种局面对于 Alice 和 Bob 都是一次性的。</p><p>因此再来考虑 Alice 先手，如果存在 2 那么他就输了；如果存在 2 个及以上的 4 那他也输了。否则可以枚举他走了一步之后的局面，根据局面 3 个数的奇偶性判胜负。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/1221e.cpp">代码</a></p><h2><a id="期望" href="#期望" class="headerlink" title="期望"></a>期望</h2><h3><a id="ABC144-F" href="#ABC144-F" class="headerlink" title="ABC144 F"></a>ABC144 F</h3><p>注意到这是一个拓扑序为 1 到 n 的 DAG，因此我们可以按拓扑序逆序计算每个点到<script type="math/tex">n</script>的期望，记为<script type="math/tex">E(i)</script>。</p><script type="math/tex;mode=display">E(i)=\frac{1}{deg_i}\sum_{(i,j)\in E}E(j)+1</script><p>现在要求我们删掉一条边，则一个直观的想法是我们计算到达点<script type="math/tex">i</script>的概率<script type="math/tex">P(i)</script>：</p><script type="math/tex;mode=display">P(i)=\sum_{(j,i)\in E}\frac{1}{deg_j}P(j)</script><p>假设我们删掉了<script type="math/tex">(i,x)</script>这条边，则<script type="math/tex">i</script>这个点的期望就变成了</p><script type="math/tex;mode=display">E'(i)=\frac{1}{deg_i-1}\sum_{(i,j)\in E,(i,j)\ne (i,x)}E(j)+1</script><p>于是删掉这条边，期望就变成了<script type="math/tex">E(1)-P(i)(E(i)-E'(i))</script>。这样就枚举删边更新答案，做完了。</p><h2><a id="离线" href="#离线" class="headerlink" title="离线"></a>离线</h2><h3><a id="HNOI2016-网格" href="#HNOI2016-网格" class="headerlink" title="HNOI2016 网格"></a>HNOI2016 网格</h3><p>如果所有路径都包括这个点，那么他们的路径交也包括这个点。因此权值线段树上维护路径交，查询的时候在线段树上二分。要先离散化一下变成不同的权值方便删除。</p><p>路径交：边的路径交可以直接取两两 LCA 中最深的两个。点的路径交需要先判是否相交再这么做。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/luogu/3250.cpp">代码</a></p><h2><a id="贪心" href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3><a id="CF893-D" href="#CF893-D" class="headerlink" title="CF893 D"></a>CF893 D</h3><p>一个显然的贪心是，只在<script type="math/tex">a_i=0</script>的时候充钱。这样不会变劣。</p><p>先检查一下最低限度的充钱会不会爆<script type="math/tex">d</script>。如果不会爆<script type="math/tex">d</script>就在每次<script type="math/tex">a_i=0</script>且钱为负数的时候直接充满到<script type="math/tex">d</script>。如果在某个时刻钱数大于<script type="math/tex">d</script>，就说明之前有一次充多了，直接把钱数变成<script type="math/tex">d</script>即可。因为我们检查了最低限度充钱是有解的，因此正确性保证。</p><p>复杂度<script type="math/tex">O(n)</script>。</p><h2><a id="数论-数学" href="#数论-数学" class="headerlink" title="数论 / 数学"></a>数论 / 数学</h2><h3><a id="ZR1090-A-B-Problem" href="#ZR1090-A-B-Problem" class="headerlink" title="ZR1090 A+B Problem"></a>ZR1090 A+B Problem</h3><p>算法一：注意到</p><script type="math/tex;mode=display">f(n)=\sum_{i=0}^na^ib^{n-i}=\frac{a^{n+1}-b^{n+1}}{a-b}</script><p>于是直接计算分子，对<script type="math/tex">(a-b)p</script>取模，然后除掉<script type="math/tex">a-b</script>即可。然而 int128 的精度过不去；</p><p>算法二：注意到<script type="math/tex">f(2x+1)=(a^{x+1}+b^{x+1})f(x), f(2x)=(a^x+b^x)f(x)-a^xb^x</script>。于是类似快速幂地做就行。复杂度<script type="math/tex">O(\log_2n)</script>。</p><h3><a id="CF1255-E2" href="#CF1255-E2" class="headerlink" title="CF1255 E2"></a>CF1255 E2</h3><p>设<script type="math/tex">s_i=\sum_{j=1}^i a_i</script>。那么原操作可以转化为，将<script type="math/tex">s_i</script>加一或减一。这样就是只针对一个数的操作了。</p><p>由于<script type="math/tex">s_i</script>是单增的，因此对于一个固定的<script type="math/tex">k</script>，要把所有<script type="math/tex">s_i</script>变成<script type="math/tex">k</script>的倍数，我们贪心地把<script type="math/tex">s_i</script>变成离它最近的<script type="math/tex">k</script>的倍数即可。容易证明这是合法的。代价就是<script type="math/tex">\sum\min(s_i\bmod k,k-s_i\bmod k)</script>。</p><p>至于<script type="math/tex">k</script>，我们只需要选择<script type="math/tex">s_n</script>的质因子作为<script type="math/tex">k</script>即可。容易证明<script type="math/tex">k</script>的约数一定不比<script type="math/tex">k</script>劣。这样复杂度为<script type="math/tex">O(n\log_2n)</script>。</p></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2021年2月11日 第3次修订</li><li class="post-history-item">2021年2月11日 第2次修订</li><li class="post-history-item">2020年4月24日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/Math/Expectation/Prob/">概率期望习题总结</a></div><div class="prev-post"><a href="/Probset/20-CSP-Training/">WC 赛前训练日志 1 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>