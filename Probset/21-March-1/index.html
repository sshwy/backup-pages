<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>2021 省选三轮跟训日志 1 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">2021 省选三轮跟训日志 1</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2021年3月21日星期日中午12点09分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2021年3月21日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 6,202 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> <a class="directory" href="/directory/Probset/">训练题单 </a><span class="icon smallarrow"></span> 当前文章</div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#矩阵"><span class="toc-number">1.</span> <span class="toc-text">矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网格游走问题"><span class="toc-number">2.</span> <span class="toc-text">网格游走问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树"><span class="toc-number">3.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法一"><span class="toc-number">3.1.</span> <span class="toc-text">算法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法二"><span class="toc-number">3.2.</span> <span class="toc-text">算法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Glow-Little-Pixel-Glow"><span class="toc-number">4.</span> <span class="toc-text">Glow, Little Pixel, Glow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Carny-Magician"><span class="toc-number">5.</span> <span class="toc-text">Carny Magician</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pivoting-Points"><span class="toc-number">6.</span> <span class="toc-text">Pivoting Points</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#尺树寸泓"><span class="toc-number">7.</span> <span class="toc-text">尺树寸泓</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#凫趋雀跃"><span class="toc-number">8.</span> <span class="toc-text">凫趋雀跃</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#保镖"><span class="toc-number">9.</span> <span class="toc-text">保镖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#霍尔定理"><span class="toc-number">9.1.</span> <span class="toc-text">霍尔定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题解"><span class="toc-number">9.2.</span> <span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Two-Buildings"><span class="toc-number">10.</span> <span class="toc-text">Two Buildings</span></a></li></ol></div><hr></div><div class="post-content"><p>所谓跟训日志，就是说我是不打省选第三轮的（因为四川没有第三轮）。</p><h2><a id="矩阵" href="#矩阵" class="headerlink" title="矩阵"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/problem/1778">矩阵</a></h2><blockquote><p>有一个<script type="math/tex">n\times n</script>的矩阵，初始时为全<script type="math/tex">0</script>。每次你可以选一个行的子集<script type="math/tex">R</script>和列的子集<script type="math/tex">C</script>，把所有<script type="math/tex">(r,c)</script>（<script type="math/tex">r\in R, c\in C</script>）变成<script type="math/tex">1</script>。</p><p>要求在不超过<script type="math/tex">26</script>次操作内让<script type="math/tex">(i,j)</script>（<script type="math/tex">j\le i\le j+1</script>）是<script type="math/tex">0</script>，其他全部变成<script type="math/tex">1</script>。</p><p>输出步骤。</p><p><script type="math/tex">n\le 3000</script>。</p></blockquote><p><span class="label">二进制划分</span> <span class="label">分治</span></p><p>这题的部分分可以分治，每次将左下和右上的矩阵干掉，这样就变成了两个互不相关的子问题，可以同步解决。</p><p>先考虑一个相关的问题 A：</p><blockquote><p>让<script type="math/tex">i=j</script>的<script type="math/tex">(i,j)</script>是<script type="math/tex">0</script>，其他都变成<script type="math/tex">1</script>。也就是说我们要选中所有<script type="math/tex">i\ne j</script>的二元组。</p></blockquote><p>考虑按位划分。对于行号和列号（即<script type="math/tex">1,2,\cdots, n</script>）枚举二进制下第<script type="math/tex">i</script>位，将第<script type="math/tex">i</script>位为<script type="math/tex">0</script>的放入集合<script type="math/tex">A</script>，其他的放入集合<script type="math/tex">B</script>。那么我们让<script type="math/tex">R\gets A, C\gets B</script>做一次操作，再让<script type="math/tex">R\gets B, C\gets A</script>做一次操作。这样的操作次数是<script type="math/tex">2\log_2n</script>的。容易证明它可以选中所有<script type="math/tex">i\ne j</script>的二元组<script type="math/tex">(i,j)</script>。</p><p>那么回到原问题。我们能否将原问题转化为上述问题？</p><p>考虑将列（或者行）奇偶分组。这时你会发现原问题被分解为了两个规模是<script type="math/tex">\frac{n}{2}</script>的问题 A。不过这两个不一定能同步做，因此操作次数上界是<script type="math/tex">4\log_2n</script>的。还是太多。</p><p>我们考虑做一个优化，使得只需要<script type="math/tex">R\gets A, C\gets B</script>这一次操作，不需要<script type="math/tex">R\gets B, C\gets A</script>。</p><p>容易发现行号和列号不一定是<script type="math/tex">1,2,\ldots, n</script>，只需要保证互不相同，且对角线上的元素的行号和列号相同即可。</p><p>那么我们找一组数，使得其中的任意两个数<script type="math/tex">a,b</script>满足：</p><ol><li>存在<script type="math/tex">i</script>使得<script type="math/tex">a</script>的二进制第<script type="math/tex">i</script>位为<script type="math/tex">0</script>，<script type="math/tex">b</script>的二进制第<script type="math/tex">i</script>位为<script type="math/tex">1</script>；</li><li>存在<script type="math/tex">j</script>使得<script type="math/tex">a</script>的二进制第<script type="math/tex">i</script>位为<script type="math/tex">1</script>，<script type="math/tex">b</script>的二进制第<script type="math/tex">i</script>位为<script type="math/tex">0</script>。</li></ol><p>这样就意味着，当我们枚举到<script type="math/tex">i</script>时，<script type="math/tex">(a,b)</script>会被选中，当枚举到<script type="math/tex">j</script>时，<script type="math/tex">(b,a)</script>会被选中。因此就不需要<script type="math/tex">R\gets B, C\gets A</script>这一步操作了。</p><p>不妨考虑所有<script type="math/tex">13</script>位，有<script type="math/tex">6</script>个<script type="math/tex">1</script>的二进制数。由于<script type="math/tex">\binom{13}{6} &gt; 1500</script>，可以胜任。将这些数作为行号和列号，可以在<script type="math/tex">2\log_2n</script>次操作内完成任务。</p><p>有一些细节问题：在奇偶分组后，可能要求某一行全部变<script type="math/tex">1</script>。这时不需要新加一次操作，直接在每次操作的时候加上这一行的行号即可。</p><h2><a id="网格游走问题" href="#网格游走问题" class="headerlink" title="网格游走问题"></a>网格游走问题</h2><blockquote><p>要求你从<script type="math/tex">(a_1,b_1)</script>走到<script type="math/tex">(a_2,b_2)</script>，使得不碰到<script type="math/tex">y=0</script>和<script type="math/tex">y=t</script>的直线（<script type="math/tex">0&lt;b_1, b_2&lt;t</script>）。</p><p>从<script type="math/tex">(x,y)</script>出发，你可以走到<script type="math/tex">(x+1, y-1)</script>或者<script type="math/tex">(x+1, y+1)</script>。</p><p>求方案数。</p><p><script type="math/tex">a_1, a_2\le 10^7</script>。</p></blockquote><p><span class="label">容斥</span> <span class="label">组合意义</span> <span class="label">翻折</span></p><p>如果只要求不碰到<script type="math/tex">y=0</script>，那么这就是个经典的翻折问题。而由于本题难以不重不漏的计数，因此考虑容斥。</p><p>从<script type="math/tex">(a_1, b_1)</script>走到<script type="math/tex">(a_2, b_2)</script>的方案数是一个组合数。然后我们要减掉不合法的方案数。</p><p>我们想办法将每个路线赋权，使得合法的路线权值是<script type="math/tex">0</script>，不合法的路线权值是<script type="math/tex">-1</script>。那么我们求出权值和即可得到不合法的方案数。</p><p>对于一个路线<script type="math/tex">P</script>，考虑这样两个累加过程：</p><ol><li>当<script type="math/tex">P</script>第一次经过<script type="math/tex">y=t</script>时减<script type="math/tex">1</script>，接下来当它经过<script type="math/tex">y=0</script>时加<script type="math/tex">1</script>，接下来当它经过<script type="math/tex">y=t</script>时又减<script type="math/tex">1</script>，经过<script type="math/tex">y=0</script>时又加一，以此类推。</li><li>当<script type="math/tex">P</script>第一次经过<script type="math/tex">y=0</script>时减<script type="math/tex">1</script>，接下来当它经过<script type="math/tex">y=t</script>时加<script type="math/tex">1</script>，接下来当它经过<script type="math/tex">y=0</script>时又减<script type="math/tex">1</script>，以此类推。</li></ol><p>你发现这两个过程得到的累加和的和，对于不合法的路径总是<script type="math/tex">-1</script>，对于合法的路径总是<script type="math/tex">0</script>。</p><p>接下来我们就来算两类累加和。由于是对称的，我们只描述第一种累加和的计算过程。</p><p>考虑算所有路线的累加和的和。</p><ul><li>对于第一次经过<script type="math/tex">y=t</script>的情况，我们将<script type="math/tex">(a_2, b_2)</script>关于<script type="math/tex">y=t</script>对称得到<script type="math/tex">(a_2, 2t-b_2)</script>，然后求<script type="math/tex">(a_1, b_1)</script>到<script type="math/tex">(a_2, 2t-b_2)</script>的方案数即可（系数是<script type="math/tex">-1</script>）。</li><li>接下来经过<script type="math/tex">y=0</script>，这时我们将<script type="math/tex">(a_2, 2t-b_2)</script>关于<script type="math/tex">y=0</script>对称得到<script type="math/tex">(a_2, b_2-2t)</script>，然后求<script type="math/tex">(a_1, b_1)</script>到<script type="math/tex">(a_2, b_2-2t)</script>的方案数即可（系数是<script type="math/tex">1</script>）。</li></ul><p>以此类推，第<script type="math/tex">i</script>次翻折的系数是<script type="math/tex">(-1)^i</script>。</p><p>然后就做完了。</p><h2><a id="树" href="#树" class="headerlink" title="树"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/problem/1736">树</a></h2><blockquote><p>完全二叉树：指内部结点的儿子数都为<script type="math/tex">2</script>的二叉树。</p><p>左<script type="math/tex">m</script>链树：有<script type="math/tex">m</script>个叶子点，且所有内部结点的右儿子都是叶子结点的完全二叉树。</p><p>定义两种操作：</p><ol><li>删除某个子树；</li><li>对于边<script type="math/tex">(x,y)</script>（<script type="math/tex">x</script>是<script type="math/tex">y</script>的父亲），将<script type="math/tex">x</script>替换为<script type="math/tex">y</script>（<script type="math/tex">x</script>的其他儿子全部被删除）。</li></ol><p>现在问有多少个<script type="math/tex">n</script>个叶子结点的完全二叉树，使得无法通过若干次操作变成左<script type="math/tex">m</script>链树。</p><p><script type="math/tex">n, m\le 10^7</script>。</p></blockquote><p><span class="label">生成函数</span> <span class="label">组合意义</span></p><p>这道题有两个思路方向，其中只有组合意义是可以走到最后的（目前）。</p><h3><a id="算法一" href="#算法一" class="headerlink" title="算法一"></a>算法一</h3><p>考场上想到的生成函数做法。</p><p>显然我们可以去掉所有的叶子结点。因此问题转化为求<script type="math/tex">n-1</script>个结点，且往左走的最大次数不超过<script type="math/tex">m-2</script>的二叉树的个数。</p><p>设<script type="math/tex">f_{i,j}</script>表示有<script type="math/tex">i</script>个内部结点，且左链（往左走的最大次数加<script type="math/tex">1</script>）长度小于等于<script type="math/tex">j</script>的二叉树是个数。</p><p>设<script type="math/tex">F_j(x) = \sum_{i}f_{i,j}x^i</script>。根据<script type="math/tex">f</script>的DP方程容易得到</p><script type="math/tex;mode=display">F_j = \frac{1}{1-xF_{j-1}}</script><p>其中<script type="math/tex">F_0 = 1</script>。</p><p>然后你算前几个<script type="math/tex">F</script>就会发现分子和分母的多项式的系数有规律。</p><p>这样你可以求出分子和分母的多项式，然后做一个<script type="math/tex">O(n^2)</script>求逆（这题没给<script type="math/tex">O(n\log_2n)</script>部分分）。</p><h3><a id="算法二" href="#算法二" class="headerlink" title="算法二"></a>算法二</h3><p>这是个组合意义的做法。为此我们直接DP。</p><p>设<script type="math/tex">f_{i,j}</script>表示有<script type="math/tex">i</script>个结点且走到当前这个点的左链（走到当前这个点，往左走的最大次数加<script type="math/tex">1</script>）长度小于等于<script type="math/tex">j</script>的完全二叉树是个数。按照 DFS 序DP。</p><p>有<script type="math/tex">f_{i,j} = f_{i-1, j-1} + f_{i-1, j+1}</script>（<script type="math/tex">0&lt;j&lt;m</script>）。</p><p>容易发现这就是上文的网格游走问题。因此容斥即可。</p><p>那么答案是<script type="math/tex">f_{2n-1, 1}</script>，因为根结点的右链末端点是DFS序最大的点。</p><p>时间复杂度<script type="math/tex">O(n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/zroi/contest/837/c.cpp">代码</a></p><h2><a id="Glow-Little-Pixel-Glow" href="#Glow-Little-Pixel-Glow" class="headerlink" title="Glow, Little Pixel, Glow"></a><a target="_blank" rel="noopener" href="https://codeforces.com/group/QkUACVrobk/contest/316985/problem/G">Glow, Little Pixel, Glow</a></h2><blockquote><p>你有一个网格，沿着横竖交叉的网格线会有脉冲经过。有两类脉冲：</p><ul><li>横向的脉冲一定是从左往右移动</li><li>纵向的脉冲一定是从上到下移动</li></ul><p>脉冲可以记为<script type="math/tex">(t, m, a)</script>，分别表示这个脉冲的出发时间、脉冲长度、脉冲所在的行号（列号）：</p><ul><li>出发时间指这个脉冲到达第<script type="math/tex">1</script>列（行）的时间。</li><li>脉冲的移动速度是一个单位网格边长每单位时间。</li><li><script type="math/tex">m</script>可理解为，脉冲是个长度为<script type="math/tex">m-1</script>单位边长的线段，即它同时覆盖了<script type="math/tex">m</script>个格点。</li></ul><p>被脉冲覆盖的格点处于激活状态。</p><p>每个格点上有一个灯泡。如果某个格点的横向和纵向在某个时刻同时被激活，那么这个点上的灯就会亮。</p><p>现在给出<script type="math/tex">n</script>个脉冲，保证每一行最多一个脉冲，每一列最多一个脉冲，问最后被点亮的灯的个数。</p><p><script type="math/tex">n\le 2\times 10^5, t, m, a\le 10^5</script>。</p></blockquote><p><span class="label">建模</span></p><p>这题的条件比较繁琐，细节颇多，难点在于形式化的建模。</p><p>首先我们可以离散化，只考虑存在脉冲的行和列（这里的离散化是指思维过程中离散化，不一定体现在代码上）。</p><p>如果某个灯它不亮，那么要么它所在的行脉冲比列脉冲来得早，要么列脉冲比行脉冲来得早。因此我们可以对这两种情况分别统计，就可以得到不亮的灯数，进而得到点亮的灯数。</p><p>而这两种情况是对称的，只用考虑其中一种情况，然后将行列交换再做一次即可。</p><p>设<script type="math/tex">f_i(x)</script>表示第<script type="math/tex">i</script>行的脉冲第一次到达第<script type="math/tex">x</script>列的时间。假设这一行的脉冲是<script type="math/tex">(t_i, m_i, i)</script>，那么显然<script type="math/tex">f_i(x) = t_i + x - 1</script>。</p><p>设<script type="math/tex">g_x(i)</script>表示第<script type="math/tex">x</script>列的脉冲恰好离开第<script type="math/tex">i</script>行的时间。设这一列的脉冲是<script type="math/tex">(t_x, m_x, x)</script>，那么有<script type="math/tex">g_x(i) = t_x + i + m_x-1</script>。</p><p>那么当且仅当<script type="math/tex">f_i(x)\ge g_x(i)</script>，第<script type="math/tex">i</script>行第<script type="math/tex">x</script>列的灯不亮（只统计列脉冲比行脉冲来得早的情况）。</p><p>于是问题转化为求满足<script type="math/tex">f_i(x)\ge g_x(i)</script>的格点<script type="math/tex">(i, x)</script>的个数。</p><p>简单变换一下不等式得到<script type="math/tex">t_i -i\ge t_x -x + m_x</script>，不等式的左边只和<script type="math/tex">i</script>有关，右边只和<script type="math/tex">x</script>有关。可以<script type="math/tex">O(n\log_2n)</script>计数。</p><p>总时间复杂度<script type="math/tex">O(n\log_2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/sua2021/0/g.cpp">代码</a></p><h2><a id="Carny-Magician" href="#Carny-Magician" class="headerlink" title="Carny Magician"></a><a target="_blank" rel="noopener" href="https://codeforces.com/group/QkUACVrobk/contest/316985/problem/F">Carny Magician</a></h2><blockquote><p>求字典序第<script type="math/tex">k</script>小的含有<script type="math/tex">m</script>个不动点的长度为<script type="math/tex">n</script>的排列。不动点指满足<script type="math/tex">p_i = i</script>的下标<script type="math/tex">i</script>。不存在则输出<script type="math/tex">-1</script>。</p><p><script type="math/tex">m\le n\le 50, k\le 10^{18}</script>。</p></blockquote><p><span class="label">贪心</span> <span class="label">溢出处理</span></p><p>这题是没有取模的。因此如果你的算法涉及了减法（容斥），那么就难以处理溢出的情况。</p><p>因此我们考虑不重不漏的计数。首先外壳是个贪心，将问题转化为：设<script type="math/tex">g(a,b)</script>表示：将<script type="math/tex">a</script>个不同的数排成排列，且其中有<script type="math/tex">b</script>个数无法构成不动点（可以理解为，这<script type="math/tex">b</script>个数的值大于<script type="math/tex">a</script>）的错排方案数。错排指没有不动点的排列。</p><script type="math/tex;mode=display">g(a, b) = \begin{cases}
g(a-1, b-1)b + g(a-1, b)(a-b) & b&gt;0 \\
g(a-1, 1)(a-1) & b=0
\end{cases}</script><p>有了这个我们就可以在贪心的过程中计算方案数了。举个例子，有<script type="math/tex">m</script>个不动点的长度为<script type="math/tex">n</script>的排列总数是<script type="math/tex">\binom{n}{m}g(n, m)</script>。</p><p>然后我们写一个简单的防溢出即可：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span>INF<span class="token punctuation">,</span> x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>x <span class="token operator">||</span> <span class="token operator">!</span>y<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>INF<span class="token operator">/</span>x <span class="token operator">&lt;</span> y<span class="token punctuation">)</span> <span class="token keyword">return</span> INF<span class="token punctuation">;</span>
  <span class="token keyword">return</span> x<span class="token operator">*</span>y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度<script type="math/tex">O(n^3)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/sua2021/0/f.cpp">代码</a></p><h2><a id="Pivoting-Points" href="#Pivoting-Points" class="headerlink" title="Pivoting Points"></a><a target="_blank" rel="noopener" href="https://codeforces.com/group/QkUACVrobk/contest/316985/problem/H">Pivoting Points</a></h2><blockquote><p>二维平面上有<script type="math/tex">n</script>个点<script type="math/tex">p_i(x_i, y_i)</script>，不存在三点共线。你可以选择一个点做为起始点，然后任意画一条只经过这个起始点的直线。</p><p>接下来以该直线过的点<script type="math/tex">u</script>为轴，逆时针旋转直线，每当碰到另一个点<script type="math/tex">v</script>（即两个点同时出现在该直线上）时，把轴点更换为<script type="math/tex">v</script>，并且在<script type="math/tex">v</script>上打个标记，然后继续旋转。</p><p>令这次旋转的价值为，旋转了<script type="math/tex">360^\circ</script>后标记数量最多的点上的标记数量。</p><p>任意选择起点，求最大价值。</p><p><script type="math/tex">n\le 2000</script>。</p></blockquote><p><span class="label">模拟</span></p><p>容易证明，旋转<script type="math/tex">360^\circ</script>后会回到起始点。因此我们设<script type="math/tex">\text{nex}(i, j)</script>表示以<script type="math/tex">i</script>为轴，过<script type="math/tex">p_i</script>和<script type="math/tex">p_j</script>的直线逆时针旋转下一个碰到的点的编号。这个可以<script type="math/tex">O(n^2\log n)</script>预处理。</p><p>然后模拟一下即可。每个环只会被访问一次，因此时间复杂度有保证。</p><p>不过在某些情况下一个环可能只代表<script type="math/tex">180^\circ</script>的旋转，比如<script type="math/tex">n=3</script>时就存在这样的情况。</p><p>一个简单粗暴的方法是记录一下旋转的角度，看加起来是不是约等于<script type="math/tex">2\pi</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/sua2021/0/h.cpp">代码</a></p><h2><a id="尺树寸泓" href="#尺树寸泓" class="headerlink" title="尺树寸泓"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/problem/1741">尺树寸泓</a></h2><blockquote><p>给出一棵<script type="math/tex">n</script>个点的带点权的二叉树，你可以</p><ul><li>把一个点左旋。</li><li>把一个点右旋。</li><li>设一个点的价值是子树点权和。求子树里结点的价值的积。</li></ul><p><script type="math/tex">n\le 2\times 10^5, q\le 2\times 10^5</script>。</p></blockquote><p><span class="label">DFS序</span></p><p>这题的要点是：左旋和右旋都不会影响树的中序遍历。</p><p>而中序遍历中子树对应区间。</p><p>同时分析可得，旋转带来的修改是<script type="math/tex">O(1)</script>的。</p><p>写个树状数组维护即可。</p><p>时间复杂度<script type="math/tex">O(n\log_2n)</script>。</p><h2><a id="凫趋雀跃" href="#凫趋雀跃" class="headerlink" title="凫趋雀跃"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/problem/1742">凫趋雀跃</a></h2><blockquote><p>要求从<script type="math/tex">(0,0)</script>走到<script type="math/tex">(T_x, T_y)</script>，每一步可以走一个<strong>非零</strong>向量<script type="math/tex">(x,y)</script>，其中<script type="math/tex">0\le x\le M_x, 0\le y\le M_y</script>，且其中有<script type="math/tex">k</script>个形如<script type="math/tex">(a_i, a_i)</script>的向量不能选。保证<script type="math/tex">a_i</script>是<script type="math/tex">10</script>的倍数。</p><p>问恰好走<script type="math/tex">R</script>步到达的方案数。</p><p><script type="math/tex">T_x, T_y, M_x, M_y\le 800, R\le 1600, k\le 50</script>。</p></blockquote><p><span class="label">容斥</span></p><p>本题的条件约束复杂，较为繁琐，要点是勇气。只要敢想就可以过。</p><p>如果<script type="math/tex">k=0</script>，并且允许走零向量，那么我们发现可以把向量正交分解，即把横竖分开做，转化为一维的问题。总方案数就是两个一维问题方案数的乘积。转化后的一维问题形如：有<script type="math/tex">n</script>个非负变量，要求总和为<script type="math/tex">m</script>，且每个变量小于<script type="math/tex">M</script>，求方案数。这可以容斥后插板。</p><p>如果不允许走零向量，那就对此套个容斥上去。</p><p>如果<script type="math/tex">k&gt;0</script>，那么就对此再套个容斥上去。形式化地，设<script type="math/tex">g(i, j)</script>表示走了<script type="math/tex">i</script>次不能选的向量，走到了<script type="math/tex">(10j, 10j)</script>这个位置的方案数。然后再配合组合数就可以容斥了。</p><p>仔细算一下复杂度，发现能过。可能需要记忆化以优化。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/zroi/contest/842/c.cpp">代码</a></p><h2><a id="保镖" href="#保镖" class="headerlink" title="保镖"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/problem/1737">保镖</a></h2><blockquote><p>给出一个左部<script type="math/tex">n</script>个点右部<script type="math/tex">m</script>个点的带点权二分图<script type="math/tex">G=(V, E)</script>，求集合<script type="math/tex">S</script>的个数，使得<script type="math/tex">S\subseteq V</script>且存在一个匹配把<script type="math/tex">S</script>中的点都覆盖，且<script type="math/tex">S</script>中的点权和<script type="math/tex">\ge t</script>。</p><p><script type="math/tex">n, m\le 20, t\le 4\times 10^8</script>。</p></blockquote><h3><a id="霍尔定理" href="#霍尔定理" class="headerlink" title="霍尔定理"></a>霍尔定理</h3><p>霍尔定理指出一个二分图存在完美匹配的条件。定义<script type="math/tex">N(u)</script>表示<script type="math/tex">u</script>的邻居集合。那么对于二分图<script type="math/tex">G=(V_l, V_r, E)</script>，不妨设<script type="math/tex">|V_l| \le |V_r|</script>。那么<script type="math/tex">G</script>存在大小为<script type="math/tex">|V_l|</script>的匹配当且仅当</p><script type="math/tex;mode=display">\forall S \subseteq V_l,\; |S| \le |\cup_{u\in S}N(u)|</script><details open><summary>证明</summary><p>如果<script type="math/tex">G</script>存在大小为<script type="math/tex">|V_l|</script>的匹配，那么此条件显然成立。</p><p>如果此条件成立，那么可以通过一个构造性的算法得到大小为<script type="math/tex">|V_l|</script>的匹配：</p><ol><li>初始时令匹配集合<script type="math/tex">M \gets \varnothing</script>。</li><li>若<script type="math/tex">M</script>的左部点集等于<script type="math/tex">V_l</script>就终止算法。</li><li>否则找到一个左部点<script type="math/tex">u\notin M</script>，然后尝试寻找増广路。</li><li>如果找到増广路，就増广。然后返回步骤 2。</li><li>否则，对于任意从<script type="math/tex">u</script>出发，以左部点结束的路径<script type="math/tex">P</script>，设<script type="math/tex">P</script>上的左部点集合为<script type="math/tex">S</script>，那么<script type="math/tex">S</script>必然不满足上述条件（hall violator）。</li></ol><p>简而言之，要点在于：如果找不到増广路，就会出现 hall violator，因此必然有増广路，因此有完美匹配。</p></details><h3><a id="题解" href="#题解" class="headerlink" title="题解"></a>题解</h3><p>如果只选择左部点的子集，那么我们可以使用霍尔定理判断。</p><p>而如果选择了两边的点且满足题目给的条件，那么左右两边选择的点集一定分别满足霍尔定理（必要性）。</p><p>我们尝试证明：左右两边选择的点集分别满足霍尔定理的充分性。</p><p>假设左右两边分别满足霍尔定理。</p><p>那么我们先给左边的点集找一个完美匹配。</p><p>然后依次考虑右边点集里的点：</p><ul><li>如果这个点已经被覆盖，就不管它。</li><li>否则我们就増广。由于右边满足霍尔定理且右边的点集没满，因此一定有増广路。而且増广的过程只会覆盖更多的点。</li></ul><p>这样就证明了充分性。</p><h2><a id="Two-Buildings" href="#Two-Buildings" class="headerlink" title="Two Buildings"></a><a target="_blank" rel="noopener" href="https://codeforces.com/group/QkUACVrobk/contest/317104/problem/L">Two Buildings</a></h2><blockquote><p>给出长度为<script type="math/tex">n</script>的序列<script type="math/tex">h_1, \ldots, h_n</script>，求<script type="math/tex">\max_{1\le i&lt;j\le n}(h_i + h_j)(j-i)</script>。</p><p><script type="math/tex">n\le 10^6</script>。</p></blockquote><p><span class="label">分治</span> <span class="label">决策单调性</span></p><p>考虑分治。那么我们在左边选一个<script type="math/tex">i</script>，右边选一个<script type="math/tex">j</script>。不妨令<script type="math/tex">g_i = -h_i</script>，将问题转化为：左边选一个<script type="math/tex">(i, g_i)</script>，右边选一个<script type="math/tex">(j, h_j)</script>，求<script type="math/tex">(h_j-g_i)(j-i)</script>的最大值——即二维平面上的矩形面积。</p><p>这个问题目前看不到什么性质。不过由于是最优化问题，因此我们考虑添加一些限制来导出我们需要的性质。</p><p>如果存在<script type="math/tex">j_1, j_2</script>使得<script type="math/tex">j_1 &lt; j_2</script>，<script type="math/tex">h_{j_1} &lt; h_{j_2}</script>，那么<script type="math/tex">(j_1, h_{j_1})</script>就是无用的。于是我们可以把右边的点筛选一下，剩下的点满足横坐标单增的同时纵坐标递减。</p><p>左边同理，也可以这么筛一下。</p><p>这时就出现了可供利用的性质：决策单调性。</p><p><img src="../../images/21-March-1.png" alt="image-20210317194241560"></p><p>如图。假设<script type="math/tex">u</script>对应的最优决策是<script type="math/tex">y</script>。那么设浅灰色面积为<script type="math/tex">s_1</script>，深灰色面积为<script type="math/tex">s_2</script>，则有<script type="math/tex">s_1 \le s_2</script>。</p><p>因此对于<script type="math/tex">u</script>右边的<script type="math/tex">v</script>来说，如果<script type="math/tex">v</script>选择<script type="math/tex">y</script>左边的<script type="math/tex">x</script>，那么显然是劣于选择<script type="math/tex">y</script>的。</p><p>这就证明了决策单调性。然后就可以再分治了。</p><p>时间复杂度<script type="math/tex">O(n\log^2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/sua2021/1/l.cpp">代码</a></p></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2021年3月21日 第6次修订</li><li class="post-history-item">2021年3月17日 第5次修订</li><li class="post-history-item">2021年3月13日 第4次修订</li><li class="post-history-item">2021年3月12日 第3次修订</li><li class="post-history-item">2021年3月11日 第2次修订</li><li class="post-history-item">2021年3月10日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/Probset/20-CSP-Training/">WC 赛前训练日志 1</a></div><div class="prev-post"><a href="/Codeforces/part-3/">Codeforces 题目选讲 3 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>