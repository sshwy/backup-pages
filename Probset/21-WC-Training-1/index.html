<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>WC 赛前训练日志 2 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">WC 赛前训练日志 2</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2021年2月11日星期四中午12点26分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2021年2月11日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 6,323 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> <a class="directory" href="/directory/Probset/">训练题单 </a><span class="icon smallarrow"></span> 当前文章</div><div class="post-tags"><span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/WC2021/">WC2021</a></span></div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#染色问题"><span class="toc-number">1.</span> <span class="toc-text">染色问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Journey-of-Geor-Autumn"><span class="toc-number">2.</span> <span class="toc-text">The Journey of Geor Autumn</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sum-of-Log"><span class="toc-number">3.</span> <span class="toc-text">Sum of Log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IOer"><span class="toc-number">4.</span> <span class="toc-text">IOer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flip-and-Reverse"><span class="toc-number">5.</span> <span class="toc-text">Flip and Reverse</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Latin-Square"><span class="toc-number">6.</span> <span class="toc-text">Latin Square</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#珍珠"><span class="toc-number">7.</span> <span class="toc-text">珍珠</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树上游走"><span class="toc-number">8.</span> <span class="toc-text">树上游走</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一部分"><span class="toc-number">8.1.</span> <span class="toc-text">第一部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二部分"><span class="toc-number">8.2.</span> <span class="toc-text">第二部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树的同构"><span class="toc-number">9.</span> <span class="toc-text">树的同构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#移球游戏"><span class="toc-number">10.</span> <span class="toc-text">移球游戏</span></a></li></ol></div><hr></div><div class="post-content"><h2><a id="染色问题" href="#染色问题" class="headerlink" title="染色问题"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/problem/1460">染色问题</a></h2><blockquote><p>给出一个<script type="math/tex">n</script>个点<script type="math/tex">m</script>条边无向图，求<script type="math/tex">k</script>染色方案数（相邻点异色）。</p><p><script type="math/tex">n\le 10^5, m\le n+5</script>，复杂度与<script type="math/tex">k</script>无关。</p></blockquote><p><span class="label">染色</span> <span class="label">缩点</span></p><p>染色数是 NPC 的。注意到<script type="math/tex">m\le n+5</script>的条件。常规思路是理解为一棵树加上若干条非树边，但这并不能方便地处理染色问题。</p><p>问题转化：对于一条边<script type="math/tex">(u,v)</script>，设<script type="math/tex">f(u,v), g(u,v)</script>分别表示<script type="math/tex">u,v</script>同色和异色时边的权值。初始时<script type="math/tex">f(u,v) = 0, g(u,v) = 1</script>。图的权值是边权之积。那么问题转化为求所有染色情况下的图的权值之和。</p><p>对于度数为<script type="math/tex">1</script>点<script type="math/tex">u</script>，假设他连到了<script type="math/tex">v</script>，那么可以直接删掉它，最后答案乘上<script type="math/tex">k-1</script>。实际上，应该是答案乘上<script type="math/tex">(k-1)g(u,v) + f(u,v)</script>。</p><p>对于度数为<script type="math/tex">2</script>的点<script type="math/tex">u</script>，假设它分别连接了<script type="math/tex">x,y</script>，那么删掉<script type="math/tex">u</script>，加一条边<script type="math/tex">(x,y)</script>，有</p><ul><li><script type="math/tex">f(x,y) = g(u,x)g(u,y)(k-1) + f(u,x)f(u,y)</script>。即分<script type="math/tex">u</script>与<script type="math/tex">x,y</script>同色和异色两种情况考虑。</li><li><script type="math/tex">g(x,y) = g(u,x)g(u,y)(k-2) + g(u,x)f(u,y) + f(u,x)g(u,y)</script>。即分三种情况考虑。</li></ul><p>有一个小细节：如果删除<script type="math/tex">u</script>后<script type="math/tex">x,y</script>出现了重边，那么应该把两条边合并，权值则是<script type="math/tex">f</script>和<script type="math/tex">g</script>分别相乘。</p><p>这样图中就只剩下了<script type="math/tex">3</script>度及以上的点。即<script type="math/tex">3n'\le 2m'</script>。又因为<script type="math/tex">n+5\ge m</script>，可以得到<script type="math/tex">n'\le 10, m'\le 15</script>。</p><p>设新图为<script type="math/tex">G=(V,E)</script>，设<script type="math/tex">F(i,S)</script>表示用<script type="math/tex">i</script>种颜色对集合<script type="math/tex">S</script>中的点染色的方案数。则</p><script type="math/tex;mode=display">F(i,S) = \sum_{T\subseteq S}F(i-1,S\setminus T)\prod_{(u\in T,v\notin T)\in E} g(u,v)\prod_{(u\in T, v\in T)\in E} f(u,v)</script><p>从而算出答案。</p><p>时间复杂度<script type="math/tex">O(n+m+n'm'3^{n'})</script>。</p><p><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/submission/304173">代码</a></p><h2><a id="The-Journey-of-Geor-Autumn" href="#The-Journey-of-Geor-Autumn" class="headerlink" title="The Journey of Geor Autumn"></a><a target="_blank" rel="noopener" href="https://codeforces.com/gym/312172/problem/E">The Journey of Geor Autumn</a></h2><blockquote><p>给出<script type="math/tex">n,k</script>，求有多少个<script type="math/tex">n</script>的排列<script type="math/tex">p</script>满足<script type="math/tex">\forall i\in[k+1,n]</script>，<script type="math/tex">p_i &gt; \min_{1\le j\le k}p_{i-j}</script>。</p><p><script type="math/tex">k, n\le 10^7</script>。</p></blockquote><p><span class="label">DP</span></p><p>枚举<script type="math/tex">1</script>在排列中出现的位置。显然它只能出现在<script type="math/tex">p_1,\ldots,p_k</script>中。假设<script type="math/tex">p_x=1</script>。</p><p>那么<script type="math/tex">p_x</script>左边的位置可以随便填。右边的位置则是个递归子问题。设<script type="math/tex">f_n</script>表示长度为<script type="math/tex">n</script>的排列的答案，因此</p><script type="math/tex;mode=display">f_n = \sum_{x=1}^k {(n-1)}^{\underline{x-1}} f_{n-x}</script><p>变换一下可以得到</p><script type="math/tex;mode=display">f_n = (n-1)! \sum_{x=1}^k \frac{f_{n-x}}{(n-x)!}</script><p>那么维护一下<script type="math/tex">\frac{f_i}{i!}</script>的前缀和即可<script type="math/tex">O(n)</script>计算。</p><p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/312172/submission/104242700">代码</a></p><h2><a id="Sum-of-Log" href="#Sum-of-Log" class="headerlink" title="Sum of Log"></a><a target="_blank" rel="noopener" href="https://codeforces.com/gym/312172/problem/C">Sum of Log</a></h2><blockquote><p>给出<script type="math/tex">X,Y</script>，计算<script type="math/tex">\sum_{i=0}^X\sum_{j=[i=0]}^Y[i\&j=0]\lfloor\log_2(i+j)+1\rfloor</script>。<script type="math/tex">X,Y\le 10^9</script>。</p></blockquote><p><span class="label">DP</span> <span class="label">数位</span></p><p>即统计<script type="math/tex">i+j</script>的二进制位数。</p><p>设<script type="math/tex">f(i,S)</script>表示考虑到第<script type="math/tex">i</script>位（从高到低或者从低到高都行）的方案数，<script type="math/tex">g(i,S)</script>表示贡献和。</p><p>状态<script type="math/tex">S</script>包括：<script type="math/tex">X,Y</script>是否到达上界、当前的数字是否为<script type="math/tex">0</script>（是否有最高位的<script type="math/tex">1</script>）。</p><p>时间复杂度<script type="math/tex">O(2^3\log_2X)</script>。</p><p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/312172/submission/104243485">代码</a></p><h2><a id="IOer" href="#IOer" class="headerlink" title="IOer"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/contest/781/problem/1461">IOer</a></h2><blockquote><p>给出<script type="math/tex">u,v,m,n</script>，计算</p><script type="math/tex;mode=display">[x^n]\prod_{i=1}^m\frac{1}{1-(ui+v)x}</script><p><script type="math/tex">m\le 2\times 10^5, n\le 10^{18}</script>。</p></blockquote><p><span class="label">生成函数</span> <span class="label">组合意义</span></p><p>直接分治 NTT 没有用到<script type="math/tex">(ui+v)</script>的特殊形式。</p><p>这个组合意义做法是题解做法，感觉很反思维。</p><p>考虑我们要求的是</p><script type="math/tex;mode=display">\sum_{t_1+\cdots + t_m = n}(u+v)^{t_1}(2u+v)^{t_2}\cdots (mu+v)^{t_m}</script><p>假装我们有理有据地想到：构造一个序列计数问题。</p><p>我们定义一个球具有编号和颜色两种属性：对于编号<script type="math/tex">&lt; m</script>的球，有<script type="math/tex">u</script>种颜色可选。对于编号为<script type="math/tex">m</script>的球，有<script type="math/tex">u+v</script>种颜色可选。两个球不同当且仅当颜色或者编号不同。考虑</p><blockquote><p>求长度为<script type="math/tex">n+m-1</script>的球的序列满足：</p><ol><li>编号在<script type="math/tex">[1,m-1]</script>中的球都有出现；</li><li>设<script type="math/tex">p_i</script>表示编号为<script type="math/tex">i</script>的球第一次出现的位置，那么<script type="math/tex">\forall i&lt;m</script>，有<script type="math/tex">p_{i-1} &lt; p_i</script>。</li></ol><p>的方案数。</p></blockquote><p>枚举序列<script type="math/tex">p_1,\ldots,p_{m-1}</script>，那么<script type="math/tex">p_i</script>位置上的球有<script type="math/tex">u</script>种选法（编号被钦定了）。<script type="math/tex">[1,p_1)</script>只能放编号为<script type="math/tex">m</script>的球，因此有<script type="math/tex">(u+v)^{p_1-1}</script>种选法。<script type="math/tex">(p_1,p_2)</script>能放编号为<script type="math/tex">1</script>或者<script type="math/tex">m</script>的球，因此有<script type="math/tex">(2u+v)^{p_2-p_1-1}</script>种选法。推广得到，总方案数是</p><script type="math/tex;mode=display">u^{m-1}\sum_p (u+v)^{p_1-1}(2u+v)^{p_2-p_1-1}\cdots(mu+v)^{n+m-1-p_{m-1}}</script><p>不妨设<script type="math/tex">p_0=0,p_m = n+m</script>。</p><p>设<script type="math/tex">d_i = p_i-1-p_{i-1}</script>，那么得到</p><script type="math/tex;mode=display">u^{m-1}\sum_d (u+v)^{d_1}(2u+v)^{d_2}\cdots(mu+v)^{d_m}</script><p>那么我们只需要求出序列的方案数即可求出答案。</p><p>不妨去掉第二个条件。由于编号<script type="math/tex">&lt;m</script>的球的可选颜色数都是<script type="math/tex">u</script>，因此可以看作等价。则</p><blockquote><p>长度为<script type="math/tex">n+m-1</script>的球的序列满足：编号在<script type="math/tex">[1,m-1]</script>中的球都有出现</p></blockquote><p>的方案数是</p><script type="math/tex;mode=display">(m-1)!u^{m-1}\sum_d (u+v)^{d_1}(2u+v)^{d_2}\cdots(mu+v)^{d_m}</script><p>这个问题可以容斥：钦定有<script type="math/tex">i</script>个编号的球没出现，得到</p><script type="math/tex;mode=display">\sum_{i=0}^{m-1}(-1)^i\binom{m-1}{i} ((m-i)u+v)^{n+m-1}</script><p>这样我们就得到了问题的答案。</p><h2><a id="Flip-and-Reverse" href="#Flip-and-Reverse" class="headerlink" title="Flip and Reverse"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1458/problem/D">Flip and Reverse</a></h2><blockquote><p>你有一个 01 串<script type="math/tex">s</script>，每次你可以选择<script type="math/tex">s</script>的一个子串<script type="math/tex">s[l,r]</script>满足<script type="math/tex">s[l,r]</script>中 01 出现的次数相等，然后将其反转并交换 01 字符（0 变 1，1 变 0）。求若干次操作最小化<script type="math/tex">s</script>的字典序，并输出这个新的<script type="math/tex">s</script>。</p><p><script type="math/tex">|s| \le 5\times 10^5</script>。</p></blockquote><p><span class="label">折线图</span> <span class="label">贪心</span></p><p>01 序列通常可以理解为：</p><ol><li>括号序列</li><li>折线图</li></ol><p>使用折线图来理解，相当于每次我可以反转一段折线。</p><p>进一步，其实我们不关心折线图的形态，我们只关心每一层的上行和下行的折线数。</p><p>进一步，我们甚至不用区分是上行还是下行。也就是说，记<script type="math/tex">a_i</script>表示<script type="math/tex">i</script>和<script type="math/tex">i+1</script>之间的折线数。那么我们的问题转化成，优先往下走，要求走完所有折线，求路径。</p><p>可以局部贪心。</p><p>朴素策略：在每一步，如果能够往下走就走。</p><p>这个策略有个问题：如果上面存在未走的折线，而下面的折线数是 1（回不来），那么就走不完所有折线了。</p><p>所以特判一下，大于 1 或者上面已经走完了才走下面即可。</p><p>时间复杂度<script type="math/tex">O(|s|)</script>。</p><p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1458/submission/104371627">代码</a></p><h2><a id="Latin-Square" href="#Latin-Square" class="headerlink" title="Latin Square"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1458/problem/C">Latin Square</a></h2><blockquote><p>给出一个<script type="math/tex">n\times n</script>的 Latin Square<script type="math/tex">A</script>：每一行每一列都是<script type="math/tex">n</script>的排列的矩阵。维护以下操作：</p><ul><li>每一行循环左移 / 右移一位。</li><li>每一列循环上移 / 下移一位。</li><li>将每一行的排列取其逆元。</li><li>将每一列的排列取其逆元。</li></ul><p>一个排列<script type="math/tex">p_1,\ldots,p_n</script>的逆元是指排列<script type="math/tex">q</script>使得<script type="math/tex">p_{q_i} = i</script>。</p><p>输出最终的矩阵。操作次数不超过<script type="math/tex">m</script>。</p><p><script type="math/tex">n\le 10^3, m\le 10^5</script>。</p></blockquote><p><span class="label">矩阵</span> <span class="label">Latin Square</span></p><p>考虑排列的逆元：<script type="math/tex">q_{p_i} = i</script>。</p><p>不妨将矩阵映射为三维点：<script type="math/tex">A_{ij} \to (i,j,A_{i,j})</script>。</p><p>那么对行取逆元相当于：<script type="math/tex">(i,j,A_{i,j}) \to (i,A_{i,j},j)</script>。我们这个变换并不是原题目中的变换。严格来说，应该每一行再按照第二维坐标排序才行。但注意，我们维护的是三维空间的点集，不存在顺序的问题。</p><p>同理，对列取逆元相当于<script type="math/tex">(i,j,A_{i,j}) \to (A_{i,j},j,i)</script>。</p><p>也就是说，取逆元等价于坐标不同维度的交换。之后的部分就 trivial 了。</p><p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1458/submission/104372831">代码</a></p><h2><a id="珍珠" href="#珍珠" class="headerlink" title="珍珠"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5401">珍珠</a></h2><blockquote><p>有<script type="math/tex">n</script>个<script type="math/tex">[1,d]</script>范围内的整数均匀随机变量。问满足以下条件的概率：</p><ul><li>可以找出至少<script type="math/tex">m</script>个 pair，每个 pair 包含两个值相同的变量。</li></ul><p><script type="math/tex">n,m\le 10^9, d\le 10^5</script>。</p></blockquote><p><span class="label">CTS2019</span> <span class="label">生成函数</span></p><p>这题有个很迷的地方。先二项式反演再推 gf 可以很轻松，但直接推 gf 就会有一些高深步骤。</p><p>设<script type="math/tex">c_i</script>表示值为<script type="math/tex">i</script>的变量的个数。那么条件等价于<script type="math/tex">\sum_{i} \lfloor\frac{c_i}{2}\rfloor\ge m</script>。</p><p>变换一下得到<script type="math/tex">\sum_{i}c_i\bmod 2\le n- 2m</script>。也就是说出现次数为奇数的变量数<script type="math/tex">\le n-2m</script>。</p><p>于是我们设<script type="math/tex">f_k</script>表示出现次数为奇数的有<script type="math/tex">k</script>个的方案数。方案数除以<script type="math/tex">d^n</script>就是答案。</p><details><summary>直接干</summary><p>这玩意可以直接有</p><script type="math/tex;mode=display">f_k = \binom{d}{k}n![x^n]\left(\frac{e^x-e^{-x}}{2}\right)^k\left(\frac{e^x+e^{-x}}{2}\right)^{d-k}</script><p>然后就会有一些 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/_post/241847">神必操作</a>。这里就不复读了。</p></details><p>复读一个稍微好一点的。</p><p>考虑容斥，我们钦定<script type="math/tex">k</script>个数出现奇数次，其他的不做限制。那么有</p><script type="math/tex;mode=display">\sum_{i\ge k}\binom{i}{k}f_i = \binom{d}{k}n![x^n]\left(\frac{e^x-e^{-x}}{2}\right)^ke^{d-k}</script><details><summary>解释一下</summary><p>序列<script type="math/tex">\{0,1,0,1,\ldots\}</script>即<script type="math/tex">a_i = \frac{1}{2}(1 - (-1)^i)</script>的 EGF 是<script type="math/tex">\frac{e^x-e^{-x}}{2}</script>，这个序列在<script type="math/tex">i</script>是奇数时值为<script type="math/tex">1</script>，否则为<script type="math/tex">0</script>。</p><p><script type="math/tex">(\frac{e^x - e^{-x}}{2})^k</script>的含义是选<script type="math/tex">k</script>个数出现奇数次的方案数。其他数的方案数就是<script type="math/tex">e^{d-k}</script>。</p><p>因为是 EGF，得乘上一个<script type="math/tex">n!</script>表示系数。</p></details><p>不妨设<script type="math/tex">g_k = \sum_{i\ge k}\binom{i}{k} f_i</script>。那么<script type="math/tex">f</script>可以用<script type="math/tex">g</script>容斥（二项式反演）算出。</p><p>这玩意可以这么化简：</p><script type="math/tex;mode=display">\begin{aligned}
g_k &= \binom{d}{k}n![x^n]\left(\frac{e^x-e^{-x}}{2}\right)^ke^{(d-k)x} \\
&= 2^{-k}\binom{d}{k}n![x^n] \sum_{j=0}^k\binom{k}{j}(-1)^{k-j}e^{(2j-2k+d)x} \\
&= 2^{-k}\binom{d}{k}n!k!(-1)^k \sum_{j=0}^k\frac{(-1)^j}{j!} \frac{1}{(k-j)!} [x^n] e^{(2(j-k)+d)x} \\
&= 2^{-k}\binom{d}{k}n!k!(-1)^k \sum_{j=0}^k\frac{(-1)^j}{j!(k-j)!} \frac{(2(j-k)+d)^n}{n!} \\
&= 2^{-k}\binom{d}{k}n!k!(-1)^k \sum_{j=0}^k\frac{(-1)^j}{j!(k-j)!} \frac{(2(j-k)+d)^n}{n!}
\end{aligned}</script><p>化简的方向就是，能提到前面去的就提到前面去。</p><p>把<script type="math/tex">j</script>和<script type="math/tex">k-j</script>相关的部分分开，可以做卷积。卷积的长度是<script type="math/tex">O(d)</script>的，故时间复杂度<script type="math/tex">O(d\log_2d)</script>。</p><h2><a id="树上游走" href="#树上游走" class="headerlink" title="树上游走"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/problem/1706">树上游走</a></h2><blockquote><p>给定一颗<script type="math/tex">n</script>个点的树，每个点有点权<script type="math/tex">v_i</script>，你在点<script type="math/tex">S</script>开始随机游走。</p><p>当你离开一个点第二次的时候这个点就会消失，与其相连的所有边也会消失。</p><p>你每次会等概率地选择一个与当前所在节点有边相连的一个未消失节点并前往那个点。</p><p>如果不存在与当前所在节点有边相连的点，你就会停止随机游走并等于获取当前所在节点权值的分数。</p><p>求你获得分数的期望，对<script type="math/tex">998244353</script>取模。</p><p><script type="math/tex">n\le 10^5, v_i\le 1000</script>。</p></blockquote><p><span class="label">DP</span> <span class="label">期望</span> <span class="label">分类讨论</span></p><p>以<script type="math/tex">S</script>为根。钦定最后走到的结点是<script type="math/tex">u</script>。</p><p>记<script type="math/tex">\deg u</script>表示结点<script type="math/tex">u</script>的度。</p><p>容易发现，与<script type="math/tex">u</script>相邻的结点都必须被删掉。因此<script type="math/tex">\deg u \le 2</script>，否则不可能停在<script type="math/tex">u</script>。</p><p>从<script type="math/tex">S</script>到<script type="math/tex">u</script>的简单路径上的点是必经点。由此我们可以按照结点访问顺序（DFS）刻画出 DP 状态。考虑到改变结点度的因素，设<script type="math/tex">f(u)</script>表示从<script type="math/tex">S</script>出发第一次到达<script type="math/tex">u</script>的概率。</p><script type="math/tex;mode=display">\gdef\fa#1{\text{fa}({ #1 })}
\gdef\son#1{\text{son}({ #1 })}</script><h3><a id="第一部分" href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p>设<script type="math/tex">p=\fa{u}</script>表示<script type="math/tex">u</script>的父节点。那么我们一定先到达<script type="math/tex">p</script>再到达<script type="math/tex">u</script>。从<script type="math/tex">p</script>到<script type="math/tex">u</script>，走<script type="math/tex">(p,u)</script>这条边的概率取决于<script type="math/tex">p</script>的度。为了方便转移，设<script type="math/tex">g(u)</script>表示删掉<script type="math/tex">p</script>并第一次到达<script type="math/tex">u</script>的概率。</p><p>第一种情况：到达<script type="math/tex">p</script>后直接到<script type="math/tex">u</script>：</p><script type="math/tex;mode=display">P_1= \frac{g(p)}{\deg(p) - 1} + \frac{f(p)-g(p)}{\deg(p)}</script><p>第二种情况：到达<script type="math/tex">p</script>后，先走到<script type="math/tex">p</script>的儿子<script type="math/tex">v</script>（<script type="math/tex">v\ne u</script>），再走回来，再去<script type="math/tex">u</script>。这种情况，<script type="math/tex">p</script>必然会被删除。</p><script type="math/tex;mode=display">P_2 = \frac{g(p)}{(\deg(p)-1)^2}\sum_{v\in \son{p},v\ne u}\frac{1}{\deg(v)}
+ \frac{f(p) - g(p)}{\deg(p)^2}\sum_{v\in \son{p},v\ne u}\frac{1}{\deg(v)}</script><p>第三种情况：到达<script type="math/tex">p</script>后，走到<script type="math/tex">p</script>某个儿子<script type="math/tex">v</script>（<script type="math/tex">v\ne u</script>）的子树中的某个结点<script type="math/tex">z</script>（<script type="math/tex">z\in \son{v}, z\ne v</script>），然后走回<script type="math/tex">p</script>。第二次到达<script type="math/tex">p</script>时，<script type="math/tex">\deg(p)</script>会发生变化，因为<script type="math/tex">v</script>会被删除。这种情况下，<script type="math/tex">p</script>也会被删除。</p><p>不妨设<script type="math/tex">v</script>到<script type="math/tex">z</script>简单路径上的点顺次构成序列<script type="math/tex">a_1,\ldots, a_k</script>（<script type="math/tex">a_k = z</script>）。那么可以发现除了<script type="math/tex">a_k</script>，其他结点都会被删。因此<script type="math/tex">a</script>的贡献是</p><script type="math/tex;mode=display">w(a) = \frac{1}{\deg(a_{k-1})^2\deg(a_k)} \prod_{i=1}^{k-2}\frac{1}{(\deg(a_i)-1)\deg(a_i)}</script><p>于是</p><script type="math/tex;mode=display">P_3 = \frac{g(p)}{(\deg(p)-1)(\deg(p)-2)}\sum_{a:a_k = z} w(a)
+ \frac{f(p) - g(p)}{\deg(p)(\deg(p)-1)}\sum_{a:a_k = z} w(a)</script><p>第四种情况：要删除<script type="math/tex">p</script>，还有一个走法：<script type="math/tex">\fa{p} \to p \to \fa{p} \to p \to u</script>。这个走法会同时删除<script type="math/tex">\fa{p}</script>和<script type="math/tex">p</script>：</p><script type="math/tex;mode=display">P_4 = \frac{g(\fa{p})}{(\deg(\fa{p}) -1)^2\deg(p)(\deg(p)-1)} + \frac{f(\fa{p}) - g(\fa{p})}{\deg(\fa{p})^2\deg(p)(\deg(p)-1)}</script><p>因此有</p><script type="math/tex;mode=display">\begin{aligned}
g(u) &= P_2 + P_3 + P_4 \\
f(u) &= P_1 + P_2 + P_3 + P_4
\end{aligned}</script><p>注意：<script type="math/tex">f(S) = 1, g(S) = 0</script>。这很好理解，因为<script type="math/tex">S</script>没有父节点，因此不存在「删掉<script type="math/tex">S</script>的父节点」这样的操作。</p><h3><a id="第二部分" href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p>考虑统计答案。</p><p>首先，要能最终停在<script type="math/tex">u</script>的条件是<script type="math/tex">\deg(u)\le 2</script>。</p><p>我们必须要删掉<script type="math/tex">\fa{u}</script>或者<script type="math/tex">u</script>没有父节点才能保证停在<script type="math/tex">u</script>。</p><p>第一种情况：在第一次到达<script type="math/tex">u</script>时删掉<script type="math/tex">\fa{u}</script>：</p><p>如果<script type="math/tex">u</script>是个叶子结点（此时必然有<script type="math/tex">u\ne S</script>），那么对答案的贡献就是<script type="math/tex">g(u)v_u</script>。</p><p>如果<script type="math/tex">u</script>是个只有一个儿子<script type="math/tex">v</script>的结点，那么我们可以模仿第三种情况的 DP 转移，先删掉<script type="math/tex">\fa{u}</script>走到<script type="math/tex">u</script>，再走到<script type="math/tex">v</script>子树里的结点<script type="math/tex">z</script>（<script type="math/tex">z\ne v</script>）再走回<script type="math/tex">u</script>，以删除<script type="math/tex">v</script>。这部分的贡献是</p><script type="math/tex;mode=display">v_u\left(\frac{g(u)}{\deg(u)-1} + [u=S]\frac{f(u)}{\deg(u)} \right) \sum_{a: a_k = z}w(a)</script><p>第二种情况：在第二次到达<script type="math/tex">u</script>时删掉<script type="math/tex">\fa{u}</script>。</p><p>这种情况适用于<script type="math/tex">u</script>是叶子结点，那么我们第一次到达<script type="math/tex">p</script>后一定会走<script type="math/tex">p\to u\to p\to u</script>的路线。因此贡献为</p><script type="math/tex;mode=display">v_u \left( \frac{g(p)}{(\deg(p)-1)^2} + \frac{f(p) - g(p)}{\deg(p)^2} \right)</script><p><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/submission/305318">代码</a></p><h2><a id="树的同构" href="#树的同构" class="headerlink" title="树的同构"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/contest/801/problem/1707">树的同构</a></h2><blockquote><p>给出一个<script type="math/tex">n</script>个点的树，要求找到两个同构的不相交的连通块，求连通块最大大小。</p><p><script type="math/tex">n\le 51</script>。</p></blockquote><p>枚举一个点<script type="math/tex">x</script>，则<script type="math/tex">x</script>和<script type="math/tex">x</script>父亲的边将这棵树分成两个部分。然后选一个不在<script type="math/tex">x</script>子树里的点<script type="math/tex">y</script>，做为另一个部分的根。这样就可以树形 DP 了。<script type="math/tex">f(i,j)</script>表示<script type="math/tex">i</script>和<script type="math/tex">j</script>的子树的最大同构连通块，且<script type="math/tex">i</script>和<script type="math/tex">j</script>匹配。</p><p>转移是个二分图最大权匹配。用 KM 算法做就行。</p><p>这题的一个难点是算复杂度。</p><p>考虑<script type="math/tex">f(i,j)</script>这个状态被计算的次数，复杂度为</p><script type="math/tex;mode=display">\sum_{i}\sum_j n \text{dist}(i,j) (d_i + d_j)^3 \\</script><p>我也不知道为啥它是<script type="math/tex">O(n^5)</script>。但既然题解这么说了那就是吧。</p><h2><a id="移球游戏" href="#移球游戏" class="headerlink" title="移球游戏"></a><a target="_blank" rel="noopener" href="https://loj.ac/p/3388">移球游戏</a></h2><blockquote><p>有<script type="math/tex">n+1</script>个柱子，每个柱子上有<script type="math/tex">m</script>个位置。第<script type="math/tex">1</script>到<script type="math/tex">n</script>个柱子上放满了球，颜色为<script type="math/tex">i</script>的球有<script type="math/tex">m</script>个，总共<script type="math/tex">n\times m</script>个球。</p><p>每次你可以把一个柱子顶端的球移到另一个柱子顶端，前提是目标柱子有空位。</p><p>要求在<script type="math/tex">8.2\times 10^5</script>步内将每种颜色的球各自集中到一个柱子上。</p><p><script type="math/tex">n\le 50, m\le 400</script>。</p></blockquote><p>首先，这东西可以桶排。</p><p>直接桶排不太行。考虑分治。</p><p>将颜色小于<script type="math/tex">mid</script>的记为<script type="math/tex">0</script>，否则记为<script type="math/tex">1</script>。那么我们每一轮，对于当前区间柱子，干两件事：</p><ul><li>对于每个柱子，把它变成<script type="math/tex">00\cdots011\cdots 1</script>或<script type="math/tex">11\cdots100\cdots 0</script>的形式。</li><li>把每个柱子两两合并，最终变成全<script type="math/tex">0</script>或全<script type="math/tex">1</script>的形式。</li></ul><p>这两个都可以简单操作得到。</p><p>操作一就不说了。对于操作二，我的方法是：对于<script type="math/tex">000111</script>和<script type="math/tex">111000</script>两个柱子的合并可以做到<script type="math/tex">O(3m)</script>，对于两个<script type="math/tex">000111</script>的柱子，把其中一个反转一下就行。</p><p>这样的步数是大概是<script type="math/tex">5n\log_2nm</script>的。</p><p><a target="_blank" rel="noopener" href="https://loj.ac/s/1040896">代码</a></p></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2021年2月11日 第8次修订</li><li class="post-history-item">2021年2月10日 第7次修订</li><li class="post-history-item">2021年1月20日 第6次修订</li><li class="post-history-item">2021年1月19日 第5次修订</li><li class="post-history-item">2021年1月18日 第4次修订</li><li class="post-history-item">2021年1月15日 第3次修订</li><li class="post-history-item">2021年1月15日 第2次修订</li><li class="post-history-item">2021年1月14日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/Gao/part-1/">高爸的杂题练习 1</a></div><div class="prev-post"><a href="/Math/Expectation/Prob/">概率期望习题总结 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>