<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>2021 省选三轮跟训日志 2 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">2021 省选三轮跟训日志 2</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2022年10月31日星期一下午3点35分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2022年10月31日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 6,104 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> <a class="directory" href="/directory/Probset/">训练题单 </a><span class="icon smallarrow"></span> 当前文章</div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#序列"><span class="toc-number">1.</span> <span class="toc-text">序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概率期望二元组"><span class="toc-number">1.1.</span> <span class="toc-text">概率期望二元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题解"><span class="toc-number">1.2.</span> <span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#取石子"><span class="toc-number">2.</span> <span class="toc-text">取石子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Food-Court1"><span class="toc-number">3.</span> <span class="toc-text">Food Court1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Road-Construction2"><span class="toc-number">4.</span> <span class="toc-text">Road Construction2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法一"><span class="toc-number">4.1.</span> <span class="toc-text">算法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法二"><span class="toc-number">4.2.</span> <span class="toc-text">算法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简"><span class="toc-number">5.</span> <span class="toc-text">简</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Literary-Trick"><span class="toc-number">6.</span> <span class="toc-text">Literary Trick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lovely-Painting"><span class="toc-number">7.</span> <span class="toc-text">Lovely Painting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sequence-Counting"><span class="toc-number">8.</span> <span class="toc-text">Sequence Counting</span></a></li></ol></div><hr></div><div class="post-content"><h2><a id="序列" href="#序列" class="headerlink" title="序列"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/problem/1744">序列</a></h2><blockquote><p>有一个序列，初始为空。</p><p>每次往序列末尾等概率随机地添加一个<script type="math/tex">[1,m]</script>中的整数。如果出现两个相邻相同的数，值为<script type="math/tex">x</script>且<script type="math/tex">x&lt;t</script>，那么就会合并为<script type="math/tex">x+1</script>。如果序列长度为<script type="math/tex">n</script>且无法合并，那么操作结束。</p><p>求结束时序列中所有数的和的期望。对<script type="math/tex">10^9+7</script>取模。</p><p><script type="math/tex">n, m \le 1000, m\le t\le 10^9</script>。</p></blockquote><p><span class="label">期望</span> <span class="label">DP</span></p><h3><a id="概率期望二元组" href="#概率期望二元组" class="headerlink" title="概率期望二元组"></a>概率期望二元组</h3><p>对于事件<script type="math/tex">A</script>，设其发生的概率是<script type="math/tex">P(A)</script>，设其期望的贡献为<script type="math/tex">E(A)</script>。那么称<script type="math/tex">(P(A), E(A))</script>为事件<script type="math/tex">A</script>对应的概率期望二元组。</p><p>相对严谨地说，事件<script type="math/tex">A</script>等价于若干个基本事件的集合<script type="math/tex">x_1, \cdots, x_n</script>。每个基本事件发生的概率不一定相同，但是每个基本事件都是不可再拆分的，也是互斥的。</p><p>事件<script type="math/tex">A</script>的发生等价于<script type="math/tex">A</script>中<strong>恰好有一个</strong>基本事件发生。</p><p>因此<script type="math/tex">P(A) = \sum_{x\in A} P(x)</script>，<script type="math/tex">E(A) = \sum_{x\in A}P(x)v(x)</script>。其中<script type="math/tex">v(x)</script>表示基本事件<script type="math/tex">x</script>对随机变量的值的贡献。</p><p>例如<script type="math/tex">x_0 = 4</script>是一个事件，如果<script type="math/tex">x_0</script>在<script type="math/tex">1,2,3,4</script>中等概率随机，那么<script type="math/tex">P(x_0=4) = \frac{1}{4}</script>，<script type="math/tex">v(x_0 = 4) = 4</script>。</p><p>对于两个互斥事件<script type="math/tex">A, B</script>，<script type="math/tex">A</script>和<script type="math/tex">B</script>中有一个发生等价于<script type="math/tex">A\cup B</script>这个事件的发生，记作<script type="math/tex">C=A+B</script>。那么对应的概率期望二元组可定义如下运算：</p><script type="math/tex;mode=display">(p_a, e_a) + (p_b, e_b) = (p_a + p_b, e_a + e_b) = (p_c, e_c)</script><p>对于两个互斥事件<script type="math/tex">A, B</script>，那么<script type="math/tex">A</script>和<script type="math/tex">B</script>同时发生等价于<script type="math/tex">A</script>中恰有一个基本事件<script type="math/tex">x_i</script>和<script type="math/tex">B</script>中恰有一个基本事件<script type="math/tex">y_j</script>同时发生，记作<script type="math/tex">AB</script>。</p><p><script type="math/tex">P(AB) = P(A)P(B)</script>是很好证明的，因此我们主要证明<script type="math/tex">E(AB) = P(A)E(B) + E(A)P(B)</script>。</p><script type="math/tex;mode=display">\begin{aligned}
E(AB) &= \sum_{x\in A}\sum_{y\in B}P(x)P(y)(v(x)+v(y))\\
&= \sum_{x\in A}P(x)v(x)\sum_{y\in B}P(y) + \sum_{x\in A}P(x)\sum_{y\in B}P(y)v(y)\\
&= E(A)P(B) + P(A)E(B)
\end{aligned}</script><p>因此可以对概率期望二元组定义如下运算：</p><script type="math/tex;mode=display">(p_a, e_a)\cdot (p_b, e_b) = (p_ap_b, p_ae_b+e_ap_b) = (p_c, e_c)</script><p>可以证明乘法对加法有分配律。乘法的单位元是<script type="math/tex">(1, 0)</script>，加法的单位元是<script type="math/tex">(0, 0)</script>。</p><h3><a id="题解" href="#题解" class="headerlink" title="题解"></a>题解</h3><p>设<script type="math/tex">x(i, j)</script>表示把长度为<script type="math/tex">i</script>的空序列的第一个位置变成<script type="math/tex">j</script>的概率（不考虑第一个位置的前一个位置上的数是啥）。</p><script type="math/tex;mode=display">x(i, j) = [j\le m]\frac{1}{m} + x(i, j-1)x(i-1, j-1)</script><p>设<script type="math/tex">f(i, j)</script>表示把长度为<script type="math/tex">i</script>的空序列填满，且第一个位置的前一个位置上是<script type="math/tex">j</script>。并且要求在填的过程中<script type="math/tex">j</script>不能被合并的概率。</p><script type="math/tex;mode=display">f(i, j) = \sum_{k + [j\ne t] \le j}x(i, k) f(i-1, k) + \sum_{j&lt;k\le t} f(i-1, k) \sum_{j &lt; p \le min(m, k)} \frac{1}{m} \prod_{p\le q &lt; k} x(i-1, q)</script><p>写的时候用概率期望二元组来实现会很方便。答案是<script type="math/tex">f(n, t)</script>对应的期望。</p><p>注意到我们合成的最大的数是<script type="math/tex">n+m</script>。因此<script type="math/tex">t</script>可以对<script type="math/tex">n+m</script>取 min，因此朴素算法的时间复杂度是<script type="math/tex">O(n(n+m)^2m^2)</script>的。</p><p>使劲前缀和后缀和优化可以做到<script type="math/tex">O(n(n+m))</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/zroi/contest/844/b.cpp">代码</a></p><h2><a id="取石子" href="#取石子" class="headerlink" title="取石子"></a>取石子</h2><blockquote><p>有<script type="math/tex">n</script>堆石子，第<script type="math/tex">i</script>堆石子有<script type="math/tex">x_i</script>个。A 和 B 轮流取，A 先手。规则如下：</p><ul><li>每次可从一堆中取<script type="math/tex">[a,b]</script>数量的石子。</li><li>如果谁取完某一堆，立刻判此人胜。</li></ul><p>求谁获胜。</p></blockquote><p><span class="label">博弈论</span> <span class="label">SG 函数</span></p><p>我们回忆一下 SG 需满足的条件：</p><ul><li>双人回合制：轮流执步。</li><li>公平竞争：两人遵守的游戏规则一样。</li><li>有限：对于任意局面，都可以在有限步数内结束。</li><li>一般游戏条件：不能动的输。</li></ul><p>对于这个游戏而言，第 4 个条件似乎不太满足。因为如果你取完了某一堆，不论对手是否能动，都会判你胜利。</p><p>那么我们能否避免取完某一堆的局面出现？</p><p>如果给出的初始局面里出现了<script type="math/tex">a\le x_i\le b</script>的堆，那么先手必胜。</p><p>否则两人在执步过程中必然不会造出<script type="math/tex">a\le x_i \le b</script>，因为这会导致对方必胜。</p><p>因此我们可以将游戏规则改成：</p><ul><li>每次可从一堆中取<script type="math/tex">[a,b]</script>数量的石子，且取完后该堆石子的数量不能落入<script type="math/tex">[a,b]</script>中。</li></ul><p>原问题的第二个规则就可以不要了。</p><p>我们发现新的游戏满足 SG 条件，同时与老游戏等价。</p><p>因此就可以计算 SG 值找规律了。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/zroi/contest/844/a_sg.cpp">SG 值暴力计算</a></p><h2><a id="Food-Court1" href="#Food-Court1" class="headerlink" title="Food Court1"></a>Food Court<sup><a id="reffn_1" class="headerlink" title="1"></a><a href="#fn_1">1</a></sup></h2><blockquote><p>有<script type="math/tex">n</script>个序列，要求维护<script type="math/tex">q</script>次操作：</p><ul><li><script type="math/tex">\text{Join}(l, r, c, k)</script>：在第<script type="math/tex">l</script>到第<script type="math/tex">r</script>个序列的末位处分别插入<script type="math/tex">k</script>个数字<script type="math/tex">c</script>。</li><li><script type="math/tex">\text{Leave}(l, r, k)</script>：删除第<script type="math/tex">l</script>到第<script type="math/tex">r</script>个序列的开头的<script type="math/tex">k</script>的数字。如果序列长度不足<script type="math/tex">k</script>就把整个序列清空。</li><li><script type="math/tex">\text{Service}(a, b)</script>：询问第<script type="math/tex">a</script>个序列的第<script type="math/tex">b</script>个数字是啥。如果序列长度不足<script type="math/tex">b</script>输出<script type="math/tex">0</script>。</li></ul><p><script type="math/tex">n, q, c \le 2\times 10^5, k\le 10^9, b\le 10^{15}</script>。</p></blockquote><p><span class="label">线段树</span> <span class="label">树状数组</span></p><p>这是一道基本功题。</p><p>考虑只有 Join 和 Service 操作的情况。</p><p>如果要在线处理，那么难以避免信息的分裂。以线段树为例，就需要将操作标记到 log 个区间上，查询的时候得在 log 个集合上二分，复杂度至少有两个 log，常数不小。</p><p>考虑离线处理。这时我们就需要关注操作的执行时间。不过我们发现，序列里的数的位置与操作的执行时间是正相关的——操作执行地越晚，数字的位置相对越靠后。因此我们想要在序列上定位，可以在时间上二分。</p><p>具体地，我们从<script type="math/tex">1</script>到<script type="math/tex">n</script>依次考虑第<script type="math/tex">i</script>个序列与其相关的操作。从第<script type="math/tex">i-1</script>个序列变到第<script type="math/tex">i</script>个序列，需要在某些时刻上加入操作，在某些时刻上减少操作。</p><p>设<script type="math/tex">a_i</script>表示在时刻<script type="math/tex">i</script>被插入的数字个数。设<script type="math/tex">c_i</script>表示在时刻<script type="math/tex">i</script>被插入的数字的值。</p><p>容易发现询问就变成了在<script type="math/tex">a</script>上 lower_bound。修改则变成在<script type="math/tex">a_i</script>上单点修改。这可以用树状数组维护。</p><p>接下来考虑 Leave 操作。</p><p>我们考虑去掉 Leave 操作。也就是说我们想办法求出每个 Service 操作真正询问的位置（相当于加上离开的人数）。这时我们不需要考虑插入的数字具体是啥，只需要考虑插入数字的个数。换言之我们要求维护</p><ul><li>区间加</li><li>区间取 max</li><li>求单点的值</li></ul><p>这可以用线段树维护。注意，这不用吉老师线段树。</p><p>总复杂度<script type="math/tex">O(n\log_2n)</script>。</p><h2><a id="Road-Construction2" href="#Road-Construction2" class="headerlink" title="Road Construction2"></a>Road Construction<sup><a id="reffn_2" class="headerlink" title="2"></a><a href="#fn_2">2</a></sup></h2><blockquote><p>给出<script type="math/tex">n</script>个点<script type="math/tex">(x_i, y_i)</script>，求曼哈顿距离下前<script type="math/tex">k</script>小的点对。输出他们的距离。</p><p><script type="math/tex">n, k\le 2.5\times 10^5</script>。</p></blockquote><p>注：时限<script type="math/tex">10</script>秒。</p><p><span class="label">K-D Tree</span> <span class="label">切比雪夫距离</span> <span class="label">二维数点</span></p><h3><a id="算法一" href="#算法一" class="headerlink" title="算法一"></a>算法一</h3><p>暴力的做法是维护一个堆，枚举点<script type="math/tex">u</script>，再枚举<script type="math/tex">v</script>，然后计算<script type="math/tex">u</script>到<script type="math/tex">v</script>的距离，插入到堆中，并且始终保持堆的大小在<script type="math/tex">k</script>以内。</p><p>考虑用 K-D Tree 优化这个过程。如果堆的大小已经达到<script type="math/tex">k</script>，并且<script type="math/tex">u</script>到<script type="math/tex">v</script>的距离大于堆中的最大元素，那么<script type="math/tex">(u,v)</script>就是无用的。</p><p>2-D Tree 上一个结点代表某个矩形以及这个矩形中按某一维排序的中位点。考虑将枚举<script type="math/tex">v</script>的过程改成在 2-D Tree 上 DFS。如果我们发现当前 DFS 到的矩形的四个角与<script type="math/tex">u</script>的距离的最小值大于堆中的最大元素（且堆的大小为<script type="math/tex">k</script>）那么我们就可以直接回溯了。</p><p>算法复杂度未知。</p><p>能过，而且跑得飞快。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/joi2021/2/b3.cpp">代码</a></p><h3><a id="算法二" href="#算法二" class="headerlink" title="算法二"></a>算法二</h3><p>转成切比雪夫距离。然后二分。问题可以转化为求方形内的点数，可以二维数点。</p><p>复杂度<script type="math/tex">O(n\log^2n)</script>。</p><h2><a id="简" href="#简" class="headerlink" title="简"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/problem/1825">简</a></h2><blockquote><p>给出一个长度为<script type="math/tex">n-1</script>的 01 序列<script type="math/tex">a_1,\ldots, a_{n-1}</script>，问有多少长度为<script type="math/tex">n</script>的排列<script type="math/tex">p_1,\ldots, p_n</script>，使得<script type="math/tex">\forall 1\le i &lt; n</script>，有<script type="math/tex">[a_i = 1] = [p_i = 2p_{i+1} \vee 2p_i = p_{i+1}]</script>。</p><p><script type="math/tex">n\le 40</script>。</p></blockquote><p><span class="label">DP</span> <span class="label">状圧</span></p><p>考虑把<script type="math/tex">1,2,\ldots, n</script>划分为<script type="math/tex">2</script>的倍数的链。那么对于<script type="math/tex">a</script>中长度为<script type="math/tex">k</script>的 1 的连续段，我们得拿出一段长度为<script type="math/tex">k+1</script>的链放上去。计算方案数的过程中有两个条件需要考虑：</p><ol><li><script type="math/tex">a_i=0</script>的两边的数不能是 2 倍关系。</li><li><script type="math/tex">a_i=1</script>的两边得是 2 倍关系。</li></ol><p>老规矩。计数题的思路有两个：不重不漏，或者容斥。本题很难不重不漏地计数，因此考虑容斥。有两种容斥方法都是可行的：</p><ol><li>枚举所有长度为<script type="math/tex">n-1</script>的 01 序列<script type="math/tex">b_1, \ldots, b_{n-1}</script>，计算关于<script type="math/tex">b</script>合法的排列数，容斥系数是<script type="math/tex">(-1)^{\sum_{i = 1}^n [a_i \ne b_i]}</script>。</li><li>枚举所有长度为<script type="math/tex">n-1</script>且当<script type="math/tex">a_i = 1</script>时有<script type="math/tex">b_i = 1</script>的 01 序列<script type="math/tex">b_1, \ldots, b_{n-1}</script>，计算关于<script type="math/tex">b</script>合法的排列数，容斥系数是<script type="math/tex">(-1)^{\sum_{i = 1}^n [a_i \ne b_i]}</script>。</li></ol><p>第一种相当于是把两个条件同时容斥了。第二种相当于把第一个条件容斥了。</p><p>以第二种容斥为例。考虑使用 DP 实现。</p><p>记<script type="math/tex">f(i, j, c_1, c_2, c_3, c_4, c_5, c_6)</script>表示考虑排列的前<script type="math/tex">i</script>个数字，其中最后的<script type="math/tex">j</script>个数字构成<script type="math/tex">2</script>的倍数链，除去前<script type="math/tex">i-j</script>个数字用掉的链，长度为<script type="math/tex">x</script>的链还剩下<script type="math/tex">c_x</script>个，的带上容斥系数的和。</p><p>因为<script type="math/tex">n\le 40</script>，所以状态里只用记长度小于等于<script type="math/tex">6</script>的链数。</p><p>转移时考虑<script type="math/tex">b_i</script>的值：</p><ol><li>若<script type="math/tex">b_i = 1</script>，那么相当于延长最后一段链，转移到<script type="math/tex">f(i+1, j+1, c_1, c_2, c_3, c_4, c_5, c_6)</script>。</li><li>若<script type="math/tex">b_i=0</script>，那么就要把最后一段链结尾，然后从剩下的链中截一段出来填进去。会转移到<script type="math/tex">f(i+1, 1, d_1, d_2, d_3, d_4, d_5, d_6)</script>。这里的<script type="math/tex">d</script>指截一段长度为<script type="math/tex">j</script>的数链出去后新的状态。具体实现见代码的 <code class="inline-code">trans</code> 函数。</li></ol><p>接下来考虑复杂度。</p><p>本题的状态数是很小的，可以再想办法压状态。比如用 BFS 写 DP。但简单计算一下可以发现，在 DP 过程中：</p><ul><li>长度为<script type="math/tex">1</script>的链不超过<script type="math/tex">26</script>个。</li><li>长度为<script type="math/tex">2</script>的链不超过<script type="math/tex">11</script>个。</li><li>长度为<script type="math/tex">3</script>的链不超过<script type="math/tex">5</script>个。</li><li>长度为<script type="math/tex">4</script>的链不超过<script type="math/tex">3</script>个。</li><li>长度为<script type="math/tex">5</script>的链不超过<script type="math/tex">1</script>个。</li><li>长度为<script type="math/tex">6</script>的链不超过<script type="math/tex">1</script>个。</li></ul><p>因此直接开个<script type="math/tex">8</script>维数组就行了。</p><p>时间复杂度<script type="math/tex">O(n\cdot 6\cdot 27\cdot 12\cdot 6\cdot 4\cdot 2\cdot 2)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/zroi/contest/845/a.cpp">代码</a></p><h2><a id="Literary-Trick" href="#Literary-Trick" class="headerlink" title="Literary Trick"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/contest/850/problem/1819">Literary Trick</a></h2><blockquote><p>给出两个字符串<script type="math/tex">S, T</script>，判断他们的编辑距离是否大于<script type="math/tex">k</script>。如果大于<script type="math/tex">k</script>输出<script type="math/tex">-1</script>，否则输出他们的编辑距离。</p><p><script type="math/tex">|S|, |T| \le 5\times 10^5, k\le 5000</script>。</p><p>时限<script type="math/tex">7s</script>。</p></blockquote><p><span class="label">DP</span> <span class="label">SA</span></p><p>有关编辑距离的 DP 方法有这么几种：</p><ul><li>设<script type="math/tex">f(i, j)</script>表示<script type="math/tex">S[1, i]</script>与<script type="math/tex">T[1, j]</script>的最小编辑距离。这个 DP 的时间复杂度为<script type="math/tex">O(|S||T|)</script>。</li><li>设<script type="math/tex">f(i, j)</script>表示<script type="math/tex">S[1, i]</script>与<script type="math/tex">T[1, i-j]</script>的最小编辑距离。这个 DP 的时间复杂度为<script type="math/tex">O(|S|k)</script>。</li><li>设<script type="math/tex">f(i, j)</script>表示最大的<script type="math/tex">a</script>，使得<script type="math/tex">S[1, a]</script>与<script type="math/tex">T[1, a-j]</script>的编辑距离为<script type="math/tex">i</script>。</li></ul><p>本题使用的则是第<script type="math/tex">3</script>种 DP。在转移的过程中需要使用 LCP 优化转移。</p><p>时间复杂度<script type="math/tex">O(n\log_2n + k^2)</script>。</p><p>（但其实 SA 跑得没有暴力 LCP 快）</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/zroi/contest/850/a.cpp">代码</a></p><h2><a id="Lovely-Painting" href="#Lovely-Painting" class="headerlink" title="Lovely Painting"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/problem/1821">Lovely Painting</a></h2><blockquote><p>给出一个<script type="math/tex">n\times m</script>的正整数矩阵<script type="math/tex">M</script>，定义一个四元组<script type="math/tex">(a, b, x, y)</script>是个框当且仅当：</p><ul><li><script type="math/tex">1\le a &lt; x\le n, 1\le b &lt; y\le m</script>。</li><li><script type="math/tex">\forall a\le  i \le x, \; M_{ib} = M_{iy}</script>。</li><li><script type="math/tex">\forall b\le j\le y, \; M_{aj}=M_{xj}</script>。</li></ul><p>也就是说四条边上的数相同的视作一个框。问<script type="math/tex">M</script>中框的个数。</p></blockquote><p><span class="label">分治</span> <span class="label">数点</span></p><p>首先我们设<script type="math/tex">L_{i,j}, R_{i,j}, U_{i,j},D_{i,j}</script>分别表示从<script type="math/tex">(i,j)</script>往左右上下能延伸的最长距离。</p><p>那么对于两个点<script type="math/tex">(a,b)</script>和<script type="math/tex">(x, y)</script>，若<script type="math/tex">x-L_{x, y}\le a &lt; x\le a+R_{a,b}</script>且<script type="math/tex">y-U_{x, y} \le b &lt; y \le b+D_{a, b}</script>，则以<script type="math/tex">(a, b)</script>为左上角，<script type="math/tex">(x, y)</script>为右下角的矩形构成一个框。</p><p>直接四位数点是<script type="math/tex">O(n\log^3n)</script>的。</p><p>考虑分治。对于当前的<script type="math/tex">r\times c</script>的矩形，不妨设<script type="math/tex">r \le c</script>。</p><p>那么我们将其分为左右两部分，计算跨过中线的框的个数。</p><p>对于左边我们记<script type="math/tex">c_1(i, j)</script>表示从中线上第<script type="math/tex">i</script>行（即<script type="math/tex">(i, mid)</script>）出发，到中线上第<script type="math/tex">j</script>行结束的 “C” 型路线的个数。同样的，对右边记<script type="math/tex">c_2(i, j)</script>表示从中线第<script type="math/tex">i</script>行出发到第<script type="math/tex">j</script>行结束的 “反C” 型路线的个数。</p><p>那么跨过中线的框的个数就是<script type="math/tex">c_1\cdot c_2 = \sum_i \sum_j c_1(i, j)\times c_2(i, j)</script>。</p><p>由于两者是对称的，以计算<script type="math/tex">c_1</script>为例。</p><p>对于左边的一个点<script type="math/tex">(a, b)</script>，若<script type="math/tex">b + R_{a, b} \ge mid</script>，那么这个点就有可能成为 “C” 型路线的一部分。这时可能会想到：枚举<script type="math/tex">i</script>，其中<script type="math/tex">a &lt; i \le a+D_{a, b}</script>，然后判断<script type="math/tex">(i, b)</script>是否能延伸到中线，即判断<script type="math/tex">b + R_{i, b} \ge mid</script>是否成立。不过这个思路目前看不到很好的优化。</p><p>不妨换个角度。想办法强制<script type="math/tex">b + R_{i, b} \ge mid</script>成立。也就是说我们按照某种顺序来计算贡献和。</p><p>具体地，考虑 “C” 型路线的上下边界，假设分别是<script type="math/tex">i</script>和<script type="math/tex">j</script>（<script type="math/tex">i &lt; j</script>）。如果<script type="math/tex">L_{i, mid} \le L_{j, mid}</script>，那么不论从第<script type="math/tex">i</script>行的哪一列出发，只要 “C” 型路线的竖线能从第<script type="math/tex">i</script>行延伸到第<script type="math/tex">j</script>行，就一定可以再沿着第<script type="math/tex">j</script>行走到中线。</p><p>所以我们记<script type="math/tex">d_1(i, j)</script>表示：从<script type="math/tex">(i, mid)</script>出发，往左走到任意的某一列，然后往下走走到第<script type="math/tex">j</script>行（<script type="math/tex">i &lt; j</script>）的方案数。</p><p>同时记<script type="math/tex">d_2(i ,j)</script>表示：从<script type="math/tex">(i, mid)</script>出发，往左走到任意的某一列，然后往<strong>上</strong>走走到第<script type="math/tex">j</script>行（<script type="math/tex">i &gt; j</script>）的方案数。</p><p>这两个都可以简单地前缀和处理出来。</p><p>那么有<script type="math/tex">c_1(i, j) = d_1(i, j) [L_{i, mid} \le L_{j, mid}] + d_2(j, i)[L_{i, mid} &gt; L_{j, mid}]</script>。换言之我们将点对<script type="math/tex">(i, j)</script>分两类分别计算方案数。</p><p>考虑时间复杂度。每次分治我们都选择<script type="math/tex">r</script>和<script type="math/tex">c</script>中较小的作为中线。设<script type="math/tex">S = rc</script>，那么中线长度就是<script type="math/tex">O(\sqrt{S})</script>的。根据主定理</p><script type="math/tex;mode=display">T(S) = T(S/2) + O(S + (\sqrt{S})^2) = O(S\log_2S)</script><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/zroi/contest/850/c.cpp">代码</a></p><p><a id="fn_1" class="headerlink" title="1"></a><sup>1</sup>. 来源：JOISC（Japanese Olympiad in Informatics Spring Camp Online Contest） 2021 Day1 T3。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></p><p><a id="fn_2" class="headerlink" title="2"></a><sup>2</sup>. 来源：JOISC（Japanese Olympiad in Informatics Spring Camp Online Contest） 2021 Day2 T2。<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></p><h2><a id="Sequence-Counting" href="#Sequence-Counting" class="headerlink" title="Sequence Counting"></a><a target="_blank" rel="noopener" href="http://www.zhengruioi.com/problem/1822">Sequence Counting</a></h2><p><span class="label">DP</span></p><p>本题的难点在于 DP 状态的设计。对于计数 DP 来说，DP 的状态一般会表示为「满足某种条件的方案数」。而这里的条件既可以限定要统计的对象本身的性质，也可以限定当前的方案空间的性质。</p><p>以本题为例，设<script type="math/tex">f(i, j, k)</script>表示考虑已经填好了<script type="math/tex">a_1, \ldots, a_i</script>，并且前<script type="math/tex">i</script>个数的最大值为<script type="math/tex">j</script>，且钦定<script type="math/tex">a_{i+1},\ldots, a_n</script>的最小值是<script type="math/tex">k</script>的方案数。</p><p>这个状态里的第三维限定的并非前<script type="math/tex">i</script>个数，而是后<script type="math/tex">n-i</script>个数。但实际上后<script type="math/tex">n-i</script>个数是未知的。因此它实际上限定的是方案空间，用通俗的话讲就是：它限定了这个状态能够转移到的状态集合。</p><p>DP 的转移则是枚举<script type="math/tex">a_{i+1}</script>的值，然后转移到对应的位置。</p><p>答案是<script type="math/tex">\sum_j \sum_k [j\ne k] f_{n-1, j, k}</script>。</p><p>朴素的 DP 时间复杂度<script type="math/tex">O(nk^3)</script>，前缀和优化一下可以做到<script type="math/tex">O(nk^2)</script>。</p><p>注意到序列里不同的数最多有<script type="math/tex">n</script>个，因此我们可以想办法算出<script type="math/tex">g_i</script>表示序列中只出现了<script type="math/tex">1, 2, \ldots,i</script>且每个值都出现过的方案数。那么答案就是<script type="math/tex">\sum_i \binom{K}{i} g_i</script>（<script type="math/tex">K</script>是题面中的<script type="math/tex">k</script>）。这个可以容斥计算（也可以理解为是二项式反演）。</p><p>这样时间复杂度就优化为了<script type="math/tex">O(n^3)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/zroi/contest/852/a.cpp">代码</a></p></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2022年10月31日 第8次修订</li><li class="post-history-item">2021年7月3日 第7次修订</li><li class="post-history-item">2021年3月30日 第6次修订</li><li class="post-history-item">2021年3月29日 第5次修订</li><li class="post-history-item">2021年3月27日 第4次修订</li><li class="post-history-item">2021年3月25日 第3次修订</li><li class="post-history-item">2021年3月21日 第2次修订</li><li class="post-history-item">2021年3月21日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/Divide/">分治</a></div><div class="prev-post"><a href="/Monad/">浅谈 Monad </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>