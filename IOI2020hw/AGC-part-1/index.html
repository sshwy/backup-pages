<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>IOI2020 国家集训队作业小结 1 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">IOI2020 国家集训队作业小结 1</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2019年11月27日星期三上午11点09分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2019年11月27日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 4,198 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> <a class="directory" href="/directory/IOI2020hw/">2020 国家集训队作业 </a><span class="icon smallarrow"></span> 当前文章</div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#AGC022-E-Median-Replace"><span class="toc-number">1.</span> <span class="toc-text">AGC022 E Median Replace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AGC022-F-Checkers"><span class="toc-number">2.</span> <span class="toc-text">AGC022 F Checkers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AGC023-F-01-on-Tree"><span class="toc-number">3.</span> <span class="toc-text">AGC023 F 01 on Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AGC023-D-Go-Home"><span class="toc-number">4.</span> <span class="toc-text">AGC023 D Go Home</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AGC024-D-Isomorphism-Freak"><span class="toc-number">5.</span> <span class="toc-text">AGC024 D Isomorphism Freak</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AGC024-E-Sequence-Growing-Hard"><span class="toc-number">6.</span> <span class="toc-text">AGC024 E Sequence Growing Hard</span></a></li></ol></div><hr></div><div class="post-content"><p>主要是 AGC 的题。</p><h2><a id="AGC022-E-Median-Replace" href="#AGC022-E-Median-Replace" class="headerlink" title="AGC022 E Median Replace"></a><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/agc022/tasks/agc022_e">AGC022 E Median Replace</a></h2><blockquote><p>给一个长度为<strong>奇数</strong>的含有 01? 的字符串<script type="math/tex">S</script>，每次可以把一个长度为 3 的子串变成它们的中位数。你可以在? 处填 0 或 1。问有多少种填法，使得填完后我们可以通过若干次操作把整个字符串变成 1。</p><p><script type="math/tex">|S|\le 3\times 10^5</script>。</p></blockquote><p><strong>摘要：将合并的过程理解为是在遍历字符串的时候进行。构建自动机并 DP 计算方案数。</strong></p><p>考虑如何判断一个给定的 01 串是否美丽。我们尝试建立一个自动机：</p><p><img src="../../images/agc022e.png" alt="Automaton"></p><p>我们可以把自动机的状态转移理解为在当前字符串的末位添加一个字符转移到的状态。举个例子，在 01 后接一个 1，我们可以合并 011 为 1 来得到 1 这个状态。当然，有时候我们并不需要合并操作。</p><p>显然，1 和 11 是好的状态。</p><p>考虑在自动机上 DP，<script type="math/tex">f(i,j)</script>表示考虑字符串前 i 个字符，走到状态<script type="math/tex">j</script>的方案数。答案就是<script type="math/tex">f(n,1)+f(n,11)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/atcoder/agc022_e.cpp">代码</a></p><h2><a id="AGC022-F-Checkers" href="#AGC022-F-Checkers" class="headerlink" title="AGC022 F Checkers"></a><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/agc022/tasks/agc022_f">AGC022 F Checkers</a></h2><blockquote><p>题意：有<script type="math/tex">n</script>个棋子在数轴上，第<script type="math/tex">i</script>个棋子的坐标是<script type="math/tex">10^{100i}</script>。每次你可以选择两个棋子，设坐标分别为<script type="math/tex">A,B</script>。你可以以<script type="math/tex">B</script>为中心，将<script type="math/tex">A</script>对称过去，然后删掉<script type="math/tex">B</script>。即<script type="math/tex">A</script>的坐标变成<script type="math/tex">2B-A</script>。一直操作到只剩下一个棋子。问这个棋子有多少种可能的坐标。</p><p><script type="math/tex">n\le 50</script>。</p></blockquote><p><strong>摘要：对称转化为连边，坐标方案数转化为多项式的系数方案数，转化为树的模型。树的形态确定了系数的绝对值，再按层 DP 来同时对树的形态与系数符号的方案计数。</strong></p><p>考虑一个初步转化。如果<script type="math/tex">A</script>对<script type="math/tex">B</script>做对称，相当于删掉<script type="math/tex">A,B</script>，产生一个<script type="math/tex">2B-A</script>的点。我们可以理解为 A 向 B 连一条边（B 是 A 的儿子）。这样一个操作序列可以转化为一棵树。当然，同一棵树可能对应多个不同的操作序列。</p><p>容易发现，最后一个棋子的坐标可以写成<script type="math/tex">n</script>元的多项式。式子里每个元素的系数一定是<script type="math/tex">\pm 2^{dep(i)}</script>的形式，其中<script type="math/tex">dep(i)</script>表示 i 在树上的深度。因此我们只需要考虑每个元素的系数的<strong>符号</strong>对答案的贡献。</p><p>考虑儿子对父亲的贡献：对于树上的一个点<script type="math/tex">u</script>，如果<script type="math/tex">u</script>有奇数个儿子，那么等<script type="math/tex">u</script>合并了它的所有儿子后，<script type="math/tex">u</script>的系数的符号会改变。也就是说如果一个点有奇数个儿子，那么它的系数符号就会受到 1 的贡献。</p><p>考虑兄弟的贡献：如果一个点有偶数个儿子，那么<strong>这些儿子</strong>中有一半会受到 1 的贡献（即乘一个 -1），另一半则不会受到贡献；如果一个点有奇数个儿子，假设为 k，就有<script type="math/tex">\left\lfloor \dfrac{k}{2} \right\rfloor</script>个点会受到 1 的贡献，其他点不会。</p><p>因此一个点的系数符号，可以转化为它的<strong>儿子结点</strong>对它的贡献以及它的<strong>兄弟结点</strong>对它的贡献的方案数。现在问题转化为了在树的模型上进行方案数统计。</p><p>考虑 DP。设<script type="math/tex">f(i,j)</script>表示一共有<script type="math/tex">i</script>个结点的树，且最后一层的结点上<strong>预支</strong><script type="math/tex">j</script>个结点有奇数个儿子的方案数：</p><ol><li>这里的方案数不是树的形态数，而是不同系数构成的序列的方案数；</li><li>最后一层不是指所有叶结点，是深度最深的那些叶结点；</li><li>预支的意思是不一定存在，但是我们假设它有奇数个儿子。</li></ol><p>考虑边界，显然有<script type="math/tex">f(1,0)=f(1,1)=n</script>。第一个点有<script type="math/tex">n</script>种选择。而这个点我们可以预支一个奇数点（奇数点指有奇数个儿子的结点），也可以预支一个偶数点。两者方案数都为 1。</p><p>答案显然为<script type="math/tex">f(n,0)</script>。</p><p>考虑转移。首先我们枚举最后一层的下一层有<script type="math/tex">k</script>个结点，并且这<script type="math/tex">k</script>个点的父亲都在最后一层上。由于最后一层上有<script type="math/tex">j</script>个奇数点，因此<script type="math/tex">k\ge j</script>，并且<script type="math/tex">k,j</script>同奇偶。在这一层上，有<script type="math/tex">\left\lfloor \dfrac{k-j}{2} \right\rfloor</script>个点会受到贡献（乘一个 -1）。即兄弟结点之间的贡献。</p><p>但实际上这<script type="math/tex">k</script>个结点的贡献是啥我们并不知道，因为我们没有考虑这<script type="math/tex">k</script>个点的儿子结点的贡献。因此枚举这<script type="math/tex">k</script>个点中有<script type="math/tex">x</script>个点实际上受到了 1 的贡献（即系数为 -1）。由于我们已知有<script type="math/tex">\left\lfloor \dfrac{k-j}{2} \right\rfloor</script>个点受到 1 的贡献，因此我们需要更改<script type="math/tex">\left| x-\left\lfloor \dfrac{k-j}{2} \right\rfloor \right|</script>个点的贡献状态（如果<script type="math/tex">\left\lfloor \dfrac{k-j}{2} \right\rfloor &lt; x</script>就要让一些点从 1 变成 -1，否则就要让一些点从 -1 变成 1）。因此我们预支这些点有奇数个儿子，这样就可以达到<script type="math/tex">x</script>这个数量了。</p><p>转移的时候要计算一下组合数，相当于从<script type="math/tex">n-i</script>个点中选<script type="math/tex">k</script>个，再从<script type="math/tex">k</script>个中选<script type="math/tex">x</script>个。</p><p>时间复杂度<script type="math/tex">O(n^4)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/atcoder/agc022_f.cpp">代码</a></p><h2><a id="AGC023-F-01-on-Tree" href="#AGC023-F-01-on-Tree" class="headerlink" title="AGC023 F 01 on Tree"></a><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/agc023/tasks/agc023_f">AGC023 F 01 on Tree</a></h2><blockquote><p>题意：一个<script type="math/tex">n</script>个点的有根树，每个点上写了 0 或 1。现在求一个拓扑序使得点权序列的逆序对数最少。</p><p><script type="math/tex">n\le 2\times 10^5</script>。</p></blockquote><p><strong>摘要：树上贪心套路，每次将最优策略点与父节点合并（绑定）。</strong></p><p>假设一个点上有多个 01。设<script type="math/tex">u_0,u_1</script>表示这个结点里<script type="math/tex">0,1</script>的个数。我们考虑贪心地把结点合并到它的父节点上，合并的含义是一旦选择了这个父节点，我们就立刻选这个结点。那么对于结点<script type="math/tex">A</script>的两个儿子结点<script type="math/tex">B,C</script>，我们考虑先合并<script type="math/tex">A,B</script>再合并<script type="math/tex">A,C</script>与先合并<script type="math/tex">A,C</script>再合并<script type="math/tex">A,B</script>的代价差：</p><script type="math/tex;mode=display">A_1B_0+(A_1+B_1)C_0 &lt; A_1C_0+(A_1+C_1)B_0\\
B_1C_0 &lt; C_1B_0\\
\frac{B_0}{B_1} &gt; \frac{C_0}{C_1}</script><p>因此我们每次选择当前结点中<script type="math/tex">\dfrac{u_0}{u_1}</script>最大的结点，把这个点和它的父节点合并即可。</p><p>时间复杂度<script type="math/tex">O(n\log_2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/atcoder/agc023_f.cpp">代码</a></p><h2><a id="AGC023-D-Go-Home" href="#AGC023-D-Go-Home" class="headerlink" title="AGC023 D Go Home"></a><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/agc023/tasks/agc023_d">AGC023 D Go Home</a></h2><blockquote><p>题意：有<script type="math/tex">n</script>个公寓在数轴上，坐标为<script type="math/tex">X_i</script>。每个公寓有<script type="math/tex">P_i</script>个人。有一辆初始时位于坐标<script type="math/tex">S</script>的公交车，一开始所有人都在车上。车上的人都很聪明（带有博弈性质），每个人会投票选择一个方向（左或右），使得自己能尽可能早地到公寓。哪个方向的票数多，车就往哪个方向走一个单位。如果票数相同就走左边。问公交车把所有人都送达公寓的时间。</p><p><script type="math/tex">n\le 10^5,S\le 10^9,X_i&lt;X_{i+1}\le 10^9,X_i\ne S,1\le P_i\le 10^9</script>。坐标都是整数。</p></blockquote><p><strong>摘要：从规模小的问题推广到原问题。</strong></p><p>假设<script type="math/tex">P_1\ge P_n</script>，那么 1 号公寓一定比 n 号公寓先到。因为考虑到你往右走，最多走到 n-1 的位置后，就会开始往 1 走。</p><p>于是聪明的 n 号公寓的人就会想方设法帮 1 号公寓的人投票。因为只有到了 1 号公寓后才会到 n 号公寓，即<script type="math/tex">P_1\gets P_1+P_n</script>，那么我们就可以删掉 n 号公寓。</p><p>如果<script type="math/tex">P_1&lt;P_n</script>同理。这样可以递归求出我们找公寓的顺序。注意边界，当当前所有的公寓都在<script type="math/tex">s</script>的一边的时候，我们就直接顺着走过去即可。</p><p>时间复杂度<script type="math/tex">O(n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/atcoder/agc023_d.cpp">代码</a></p><h2><a id="AGC024-D-Isomorphism-Freak" href="#AGC024-D-Isomorphism-Freak" class="headerlink" title="AGC024 D Isomorphism Freak"></a><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/agc024/tasks/agc024_d">AGC024 D Isomorphism Freak</a></h2><blockquote><p>题意：给一棵无根树。你可以任意给这棵树加点加边，只要保证它是棵树。另外，你需要给这棵树的结点染色，使得对于同色的结点<script type="math/tex">u,v</script>，以<script type="math/tex">u</script>为根的树与以<script type="math/tex">v</script>为根的树<strong>同构</strong>（存在一个置换使得每条边一一对应）。你需要求出最少颜色数，以及在满足前者的条件下最少的叶子数。</p><p><script type="math/tex">n\le 100</script>。</p></blockquote><p><strong>摘要：按层分类，补满来保证同构。枚举根或者一对根（即以边为根），统计最优解。</strong></p><p>我们考虑找一个类似中心的东西。那么我们以这个中心为根，把这棵树补满。这里补满的含义是，每一层结点的度数都相同。补满后我们让每一层的颜色都相同，显然满足题目的条件。这样颜色数就是深度。叶子数就是每一层的单点度数积。（这里的度数指除了父边的度）</p><p>当然，中心也不一定为点，可能是一条边，那么这时就相当于是我们让这两棵树同构，那么同样的方法把两棵树补满即可。叶子数就是每一层的单点度数积再乘 2。</p><p>因此我们没必要求出中心。直接枚举每个点和每个边，统计最小值即可。</p><p>时间复杂度<script type="math/tex">O(n^2)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/atcoder/agc024_d.cpp">代码</a></p><h2><a id="AGC024-E-Sequence-Growing-Hard" href="#AGC024-E-Sequence-Growing-Hard" class="headerlink" title="AGC024 E Sequence Growing Hard"></a><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/agc024/tasks/agc024_e">AGC024 E Sequence Growing Hard</a></h2><blockquote><p>题意：求满足以下条件的<script type="math/tex">n+1</script>元组<script type="math/tex">(A_0,\cdots,A_n)</script>的个数：</p><ol><li><script type="math/tex">A_i</script>是一个长度为<script type="math/tex">i</script>的整数序列，且元素的值在<script type="math/tex">[1,K]</script>内；</li><li><script type="math/tex">A_{i-1}</script>是<script type="math/tex">A_i</script>的子序列；</li><li><script type="math/tex">A_{i-1}</script>的字典序严格小于<script type="math/tex">A_i</script>的字典序。</li></ol><p><script type="math/tex">n,K\le 300</script>。</p></blockquote><p><strong>摘要：<script type="math/tex">A_{i-1}</script>里插入一个数得到<script type="math/tex">A_i</script>，合理枚举插入的位置来防止算重，并转化为带权树的计数问题，通过 DP 计算。</strong></p><p>考虑我们在一个序列里插入一个数，如何让它的字典序变大？假设我们在数字 x 前插入 y，那么有两种情况：</p><ol><li><script type="math/tex">y&gt;x</script>。</li><li><script type="math/tex">x=y</script>。然后在之后第一个不等于<script type="math/tex">x</script>的位置，这个数比<script type="math/tex">x</script>小。</li></ol><p>仔细想想，我们不用考虑第二种情况。因为你可以直接在这个比<script type="math/tex">x</script>小的数前插入<script type="math/tex">y</script>，转化为第一种情况。这样我们也防止了算重的问题。因此我们只考虑第一种情况。</p><p>我们可以把这个<script type="math/tex">n+1</script>元组转化为<script type="math/tex">n+1</script>个二元组<script type="math/tex">(id,val)</script>。第<script type="math/tex">i</script>个二元组表示第<script type="math/tex">i</script>次插入操作，表示我们在第<script type="math/tex">id</script>次操作插入的数前面插入一个<script type="math/tex">val</script>。特殊地，当<script type="math/tex">id=0</script>时表示在序列末尾插入一个<script type="math/tex">val</script>。</p><p>这个操作可以转化为树的构建，即我们把<script type="math/tex">i</script>向<script type="math/tex">id</script>连边。这样就构成了一棵有根树，<script type="math/tex">0</script>为根结点。因此我们的<script type="math/tex">n+1</script>元组最终转化为了一个<script type="math/tex">n+1</script>个结点的有根树。那么我们考虑树的计数。总结一下，这棵树满足以下条件：</p><ol><li>结点总数为<script type="math/tex">n+1</script>。</li><li>每个点有一个二元组<script type="math/tex">(id,val)</script>。</li><li>父节点的<script type="math/tex">id,val</script>比子节点的<script type="math/tex">id,val</script>分别严格小。</li><li>结点<script type="math/tex">val</script>的范围为<script type="math/tex">[0,K]</script>，<script type="math/tex">id</script>的范围为<script type="math/tex">[0,n]</script>且互不相同。</li><li>根结点<script type="math/tex">val=0</script>。（注意在此条件下根结点的<script type="math/tex">id</script>必为 0）</li></ol><p>考虑 DP。设<script type="math/tex">f(i,j)</script>表示有<script type="math/tex">i</script>个结点，根结点的<script type="math/tex">val=j</script>的树的方案数。严格来说是满足以下条件的树方案数：</p><ol><li>结点总数为<script type="math/tex">i</script>。</li><li>每个点有一个二元组<script type="math/tex">(id,val)</script>。</li><li>父节点的<script type="math/tex">id,val</script>分别比子节点的<script type="math/tex">id,val</script>严格小。</li><li>结点<script type="math/tex">val</script>的范围为<script type="math/tex">[0,K]</script>，<script type="math/tex">id</script>的范围为<script type="math/tex">[0,n]</script>且互不相同。</li><li>根结点<script type="math/tex">val=j</script>。</li></ol><p>转移的时候枚举<script type="math/tex">id=1</script>的点（是根结点的儿子）的子树的大小和<script type="math/tex">val</script>值。然后从剩下<script type="math/tex">i-2</script>个<script type="math/tex">id</script>中选择若干个<script type="math/tex">id</script>作为这个子树的<script type="math/tex">id</script>即可：</p><script type="math/tex;mode=display">f(i,j)=\sum_{k=1}^{i-1}\sum_{l=j+1}^K f(k,l)f(i-k,j)\binom{i-2}{k-1}</script><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/atcoder/agc024_e.cpp">代码</a></p></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2019年11月27日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/Data-Structure/Line-Tree/">Line Tree</a></div><div class="prev-post"><a href="/Math/Mobius-prob/">莫比乌斯反演 - 进阶 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>