<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>集合变换学习笔记 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">集合变换学习笔记</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2022年7月8日星期五上午10点33分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2022年7月8日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 6,847 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> <a class="directory" href="/directory/Math/">数学 </a><span class="icon smallarrow"></span> 当前文章</div><div class="post-tags"><span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Notes/">Notes</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Math/">Math</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/FWT/">FWT</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/FMT/">FMT</a></span></div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#快速莫比乌斯变换"><span class="toc-number">1.</span> <span class="toc-text">快速莫比乌斯变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#子集与"><span class="toc-number">1.1.</span> <span class="toc-text">子集与</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子集或"><span class="toc-number">1.2.</span> <span class="toc-text">子集或</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩域情况"><span class="toc-number">1.3.</span> <span class="toc-text">扩域情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分治多项式乘法"><span class="toc-number">2.</span> <span class="toc-text">分治多项式乘法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异或卷积"><span class="toc-number">3.</span> <span class="toc-text">异或卷积</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分治异或卷积"><span class="toc-number">3.1.</span> <span class="toc-text">分治异或卷积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速沃尔什变换"><span class="toc-number">3.2.</span> <span class="toc-text">快速沃尔什变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#通过分治异或卷积理解"><span class="toc-number">3.2.1.</span> <span class="toc-text">通过分治异或卷积理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现"><span class="toc-number">3.2.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#子集卷积"><span class="toc-number">4.</span> <span class="toc-text">子集卷积</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HDU-5823"><span class="toc-number">4.1.</span> <span class="toc-text">HDU 5823</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CF1034-E"><span class="toc-number">4.2.</span> <span class="toc-text">CF1034 E</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HDU-5330"><span class="toc-number">4.3.</span> <span class="toc-text">HDU 5330</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AGC034-F"><span class="toc-number">4.4.</span> <span class="toc-text">AGC034 F</span></a></li></ol></li></ol></div><hr></div><div class="post-content"><p>总结一下有关子集变换的笔记。</p><p>约定：</p><ol><li>接下来我们讨论的序列一般指长度为<script type="math/tex">2^n</script>，下标从<script type="math/tex">0</script>开始的序列。例如<script type="math/tex">a_0, a_1, \ldots, a_{2^n-1}</script>。</li><li>集合幂级数其实可以理解为以集合为下标的序列。本质上就是普通的序列，只不过是用集合的运算表示位运算。本文中的序列可能指集合幂级数，也可能指普通序列，具体见上下文或者使用的记号。</li><li>集合占位多项式可以理解为是一个序列，序列中的每个元素都是一个多项式。</li></ol><h2><a id="快速莫比乌斯变换" href="#快速莫比乌斯变换" class="headerlink" title="快速莫比乌斯变换"></a>快速莫比乌斯变换</h2><h3><a id="子集与" href="#子集与" class="headerlink" title="子集与"></a>子集与</h3><p>考虑形式化的问题：对于两个序列<script type="math/tex">a,b</script>，我们希望求序列<script type="math/tex">c</script>：</p><script type="math/tex;mode=display">c_i=\sum_{j\& k=i} a_j b_k</script><p>用集合幂级数的语言，我们想求的是</p><script type="math/tex;mode=display">c_S=\sum_{S=P\cap Q} a_P b_Q</script><p>其中<script type="math/tex">S</script>是集合。接下来的问题与过程形式都使用集合来展现。</p><p>考虑做一个高维后缀和的变换。对于集合幂级数<script type="math/tex">f</script>定义<script type="math/tex">f'</script>：</p><script type="math/tex;mode=display">f'_S=\sum_{S\subseteq T}f_T</script><p>那么我们对<script type="math/tex">a</script>和<script type="math/tex">b</script>同时做高维后缀和变换得到：</p><script type="math/tex;mode=display">\begin{aligned}
c'_S&=\sum_{S\subseteq T}c_T=\sum_{S\subseteq P\cap Q}a_P b_Q\\
&=\sum_{S\subseteq P}a_P\sum_{S\subseteq Q}b_Q\\
&=a'_Sb'_S
\end{aligned}</script><p>也就是说如果我们能快速计算<script type="math/tex">a</script>和<script type="math/tex">b</script>的高维后缀和，就可以快速得到<script type="math/tex">c</script>的高维后缀和<script type="math/tex">c'</script>。</p><p>在求出了<script type="math/tex">c'</script>后，我们希望还原成<script type="math/tex">c</script>，可以用容斥得到</p><script type="math/tex;mode=display">c(T)=\sum_{T\subseteq S}(-1)^{|T|-|S|}c'(S)</script><p>但其实没必要这么麻烦。我们可以直接倒着写高维后缀和，就可以逆变换回去。</p><p>高维后缀和可以写成</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>j<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
            s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+=</span>s<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>高维后缀差分（逆变换）：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>j<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
            s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-=</span>s<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度<script type="math/tex">O(n2^n)</script>，空间复杂度<script type="math/tex">O(2^n)</script>。</p><h3><a id="子集或" href="#子集或" class="headerlink" title="子集或"></a>子集或</h3><p>对于序列<script type="math/tex">a,b</script>，我们想求</p><script type="math/tex;mode=display">c_S=\sum_{S=P\cup Q}a_Pb_Q</script><p>类似的，我们这次定义一个高维前缀和：</p><script type="math/tex;mode=display">f'_S=\sum_{T\subseteq S}f_S</script><p>则可以推出</p><script type="math/tex;mode=display">\begin{aligned}
c'_S&=\sum_{T\subseteq S}c_T=\sum_{P\cup Q\subseteq S}a_Pb_Q\\
&=\sum_{P\subseteq S}a_P\sum_{Q\subseteq S}b_Q\\
&=a'_Sb'_S
\end{aligned}</script><p>于是类似地使用高维前缀和与高维前缀差分即可。</p><h3><a id="扩域情况" href="#扩域情况" class="headerlink" title="扩域情况"></a>扩域情况</h3><p>对于集合幂级数而言，每一个元素只有选或者不选两种情况。换言之，二进制数的每个位只有<script type="math/tex">0</script>或者<script type="math/tex">1</script>两种值。而对于可重集，即<script type="math/tex">k</script>进制数来说，也是可以定义集合幂级数以及高维前（后）缀变换的。</p><p>以子集与为例，高维后缀和变换可以一般地表示为</p><script type="math/tex;mode=display">c(\min(a_1,b_1),\min(a_2,b_2),\cdots,\min(a_n,b_n))
=\sum a(a_1,a_2,\cdots,a_n)b(b_1,b_2,\cdots,b_n)\\
c'(p_1,p_2,\cdots,p_n)=\sum_{p_i\le q_i}c(q_1,q_2,\cdots,q_n)</script><p>取<script type="math/tex">\min</script>相当于与运算；<script type="math/tex">p_i\le q_i</script>相当于后缀和操作。</p><h2><a id="分治多项式乘法" href="#分治多项式乘法" class="headerlink" title="分治多项式乘法"></a>分治多项式乘法</h2><p>为了理解 FWT 的 xor 变换在干啥，我们先引入分治多项式乘法。</p><p>我们有两个定义在加法乘法环下的<script type="math/tex">n-1</script>次多项式<script type="math/tex">A,B</script>，我们想求<script type="math/tex">A(x)B(x)</script>。设</p><script type="math/tex;mode=display">\begin{aligned}
A(x) &= P_1(x)x^{n/2}+P_2(x)\\
B(x) &= Q_1(x)x^{n/2}+Q_2(x)
\end{aligned}</script><p>假定<script type="math/tex">n</script>是<script type="math/tex">2</script>的幂。则我们有</p><script type="math/tex;mode=display">\begin{aligned}
A(x)B(x) &= (P_1(x)x^{n/2}+P_2(x))(Q_1(x)x^{n/2}+Q_2(x))\\
&= (P_1Q_1)x^n+(P_1Q_2+P_2Q_1)x^{n/2}+P_2Q_2\\
\end{aligned}</script><p>而我们知道</p><script type="math/tex;mode=display">P_1Q_2+P_2Q_1=(P_1+Q_1)(P_2+Q_2)-P_1Q_1-P_2Q_2\\</script><p>因此可以只算<script type="math/tex">P_1Q_1,P_2Q_2,(P_1+Q_1)(P_2+Q_2)</script>的乘法，递归下去。时间复杂度</p><script type="math/tex;mode=display">T(n)=3T(n/2)+O(n)=O(n^{\log_23})\\</script><h2><a id="异或卷积" href="#异或卷积" class="headerlink" title="异或卷积"></a>异或卷积</h2><p>异或卷积问题：对于序列<script type="math/tex">a,b</script>，我们要求</p><script type="math/tex;mode=display">c_i=\sum_{j\oplus k=i}a_jb_k</script><p><script type="math/tex">\oplus</script>表示位异或运算。</p><p>我们首先介绍分治异或卷积算法，然后介绍广泛使用的快速沃尔什变换。了解分治异或卷积算法有利于理解快速沃尔什变换。</p><h3><a id="分治异或卷积" href="#分治异或卷积" class="headerlink" title="分治异或卷积"></a>分治异或卷积</h3><p>由于异或具有结合律、交换律，对加法的分配律，则我们定义一个<strong>指数通过异或运算合并</strong>的多项式来表示该序列：</p><script type="math/tex;mode=display">C(x)=\sum_{i = 0}^{2^n-1} c_ix^i</script><p>可以理解为是“异或生成函数”。类似地我们定义出<script type="math/tex">A(x) = \sum_i a_i x^i</script>以及<script type="math/tex">B(x) = \sum_i b_i x^i</script>，那么有<script type="math/tex">C(x) = A(x) B(x)</script>。这里的乘法定义为</p><script type="math/tex;mode=display">A(x) B(x) = \sum_{i = 0} ^ {2^n-1} \sum_{j = 0} ^ {2^n-1}a_i b_j x^{i\oplus j}</script><p>为了计算上述异或乘法，我们将多项式前后拆成两半。设</p><script type="math/tex;mode=display">\begin{aligned}
A(x) &= P_1x^{2^{n-1} }+ P_2\\
B(x) &= Q_1x^{2^{n-1} }+ Q_2
\end{aligned}</script><p>则使用分治可以得到</p><script type="math/tex;mode=display">\begin{aligned}
C(x) &= A(x) B(x)\\
&= (P_1x^{2^{n-1} }+ P_2) (Q_1x^{2^{n-1} }+ Q_2)\\
&= P_1Q_1 +  (P_2Q_1 + P_1Q_2)x^{2^{n-1} } + P_2Q_2 x^{2^{n-1}  \oplus 2^{n-1} } \\
&= P_1Q_1 +  (P_2Q_1 + P_1Q_2)x^{2^{n-1} } + P_2Q_2 \\
&= (P_1Q_1 + P_2Q_2) +  (P_2Q_1 + P_1Q_2)x^{2^{n-1} } 
\end{aligned}</script><p>这里有个特殊之处：由于下标的异或运算使得<script type="math/tex">P_2 Q_2</script>项的指数被消掉了，因此我们实际上只用递归算两次多项式乘法。我们设</p><script type="math/tex;mode=display">X=(P_1+P_2)(Q_1+Q_2)\\
Y=(P_1-P_2)(Q_1-Q_2)</script><p>于是可以得到</p><script type="math/tex;mode=display">\begin{aligned}
P_1Q_1+P_2Q_2 &= \frac{X+Y}{2} \\
P_2Q_1+P_1Q_2 &= \frac{X-Y}{2}
\end{aligned}</script><p>那么<script type="math/tex">C(x) = \frac{X + Y}{2} + \frac{X - Y}{2}x^{2^{n-1} }</script>。</p><p>时间复杂度就是</p><script type="math/tex;mode=display">T(2^{n-1} )=2T(2^{n-1} )+O(2^n)=O(n2^n)\\</script><p>事实上，与卷积和或卷积也可以使用分治多项式乘法去理解。</p><h3><a id="快速沃尔什变换" href="#快速沃尔什变换" class="headerlink" title="快速沃尔什变换"></a>快速沃尔什变换</h3><p>快速沃尔什变换（Fast Walsh–Hadamard transform，FWT or FWHT）<sup><a id="reffn_1" class="headerlink" title="1"></a><a href="#fn_1">1</a></sup>是用于快速计算一个序列的沃尔什变换的算法。在算法竞赛领域中，大多数时候 FWT 的作用是快速计算异或卷积。</p><p>FWT 的本质是把<script type="math/tex">a</script>变成了</p><script type="math/tex;mode=display">\text{FWT}(a)_i=\sum_j a_j (-1)^{\operatorname{popcount}(i\& j)}</script><p>写成集合幂级数的形式就是</p><script type="math/tex;mode=display">\text{FWT}(a)(S)=\sum_{T}a(T) (-1)^{|S\cap T|}</script><p>不过直接抛出 FWT 的定义并不能帮助我们理解为什么 FWT 可以加速异或卷积的计算。</p><h4><a id="通过分治异或卷积理解" href="#通过分治异或卷积理解" class="headerlink" title="通过分治异或卷积理解"></a>通过分治异或卷积理解</h4><p>为此我们沿用上文中分治异或卷积的描述。</p><p>首先我们要更改分治异或卷积的执行顺序，更准确地说是<strong>拆分</strong>。</p><p>分治异或卷积的优化用一句话概括就是：将计算<script type="math/tex">(P_1x^{2^{n-1} }+ P_2)(Q_1x^{2^{n-1} }+ Q_2)</script>归约到计算<script type="math/tex">(P_1+P_2)(Q_1+Q_2)</script>和<script type="math/tex">(P_1-P_2)(Q_1-Q_2)</script>两个长度减半的异或卷积。</p><p>在实现的时候设<script type="math/tex">\text{Solve}(l, r)</script>表示将<script type="math/tex">\sum_{i = l} ^ r a_i x^i</script>与<script type="math/tex">\sum_{i = l} ^ r b_i x^i</script>做异或卷积。</p><p>我们不妨考虑将<script type="math/tex">A(x) = (P_1x^{2^{n-1} }+ P_2)</script>变成<script type="math/tex">A'(x) = ((P_1 - P_2)x^{2^{n-1} } + (P_1 + P_2))</script>，将<script type="math/tex">B(x) = (Q_1x^{2^{n-1} }+ Q_2)</script>变成<script type="math/tex">B'(x) = ((Q_1 - Q_2)x^{2^{n-1} } + (Q_1 + Q_2))</script>。对于这两个新的多项式：</p><ul><li>首先我们将其前半部分做卷积，后半部分做卷积，即递归调用<script type="math/tex">\text{Solve}(l, mid)</script>和<script type="math/tex">\text{Solve}(mid+1, r)</script>。</li><li>经过上一步我们计算出了<script type="math/tex">X</script>和<script type="math/tex">Y</script>，然后再根据<script type="math/tex">C(x) = \frac{X + Y}{2} + \frac{X - Y}{2}x^{2^{n-1} }</script>，还原出<script type="math/tex">C</script>的系数表示即可。</li></ul><p>考虑第一步和第二步本质上做了什么事情。他们其实执行的计算是差不多的，只不过第二步需要除以<script type="math/tex">2</script>而第一步不需要。且第一步我们需要同时变换<script type="math/tex">A</script>和<script type="math/tex">B</script>，而在第二步里<script type="math/tex">X</script>和<script type="math/tex">Y</script>其实表示的是同一个多项式的高低位。</p><p>因此我们有一个想法：我们将第一步的过程和第二步的过程拆开，再将第一步中对<script type="math/tex">A</script>和<script type="math/tex">B</script>的变换过程拆开！</p><p>换言之我们的操作过程变成：</p><ul><li>先分别递归变换<script type="math/tex">A</script>和<script type="math/tex">B</script>得到<script type="math/tex">\mathcal{T}(A)</script>和<script type="math/tex">\mathcal{T}(B)</script>。</li><li>这时<script type="math/tex">\mathcal{T}(A)</script>和<script type="math/tex">\mathcal{T}(B)</script>里存的分别是<script type="math/tex">2^n</script>个单项式（只有常数项的多项式）。因此我们直接将两者点乘得到<script type="math/tex">\mathcal{T}(C)</script>。</li><li>然后递归地自底向上执行第二步的过程，将<script type="math/tex">\mathcal{T}(C)</script>转化为最后的<script type="math/tex">C</script>。</li></ul><p>由于这三个过程彼此不相关，只要顺序不要乱就行，因此拆开的正确性有保证。</p><p>接下来我们要理解对<script type="math/tex">A</script>的变换是 FWT 变换。</p><p>以<script type="math/tex">A</script>为例，我们分析对<script type="math/tex">A</script>的变换：将<script type="math/tex">A(x) = (P_1x^{2^{n-1} }+ P_2)</script>变成<script type="math/tex">A'(x) = ((P_1 - P_2)x^{2^{n-1} } + (P_1 + P_2))</script>，然后前后两半递归变换。</p><p>设<script type="math/tex">\mathcal{T}(A) = \sum_{i = 0} ^ {2^n-1} t_i x^i</script>，那么我们对于<script type="math/tex">i</script>分析<script type="math/tex">t_i</script>的值是如何得到的。</p><p>以<script type="math/tex">n=3, 2^n=8</script>的情况为例，我们用绿色线表示系数为正，红色线表示系数为负，画出从<script type="math/tex">A</script>变换为<script type="math/tex">\mathcal{T}(A)</script>的示意图：</p><p><img src="../../images/Subset-Transform-1.png" alt="Subset-Transform-1"></p><p>考虑<script type="math/tex">a_j</script>对<script type="math/tex">t_i</script>的贡献。那么我们只需要考虑<script type="math/tex">a_j</script>对<script type="math/tex">t_i</script>贡献的系数是<script type="math/tex">1</script>还是<script type="math/tex">-1</script>即可，这显然由从<script type="math/tex">a_j</script>到<script type="math/tex">t_i</script>路径上的红色箭头数量的奇偶性决定。为此我们枚举考虑<script type="math/tex">i</script>和<script type="math/tex">j</script>二进制下第<script type="math/tex">k</script>位：</p><ul><li>如果两者第<script type="math/tex">k</script>位是相同的，那么走的就是水平方向的，这时是否为红色箭头取决于这一位是否为<script type="math/tex">1</script>；</li><li>如果两者第<script type="math/tex">k</script>位不同，那么<script type="math/tex">j</script>得走斜着的箭头，而斜着的箭头是不存在红色的。</li></ul><p>综上所述，系数即为<script type="math/tex">(-1)^{\text{popcount}(i\&j)}</script>。因此<script type="math/tex">t_i = \sum_{j = 0} ^ {2^n - 1} a_j (-1)^{\text{popcount}(i\&j)}</script>，这恰好就是 FWT 变换的定义。</p><h4><a id="代码实现" href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>FWT 和 IFWT 的递归过程为</p><script type="math/tex;mode=display">\begin{array}{r|l|r|l}
\hline
1 & \textbf{function }\text{FWT}(a,l,r)&
1 & \textbf{function }\text{IFWT}(a,l,r)\\
2 & \qquad m \gets \frac{r-l}{2}&
2 & \qquad \text{IFWT}(a,l,l+m)\\
3 & \qquad \textbf{for }i=l\textbf{ to }l+m-1&
3 & \qquad \text{IFWT}(a,l+m,r)\\
4 & \qquad \qquad x \gets a_i&
4 & \qquad m \gets \frac{r-l}{2}\\
5 & \qquad \qquad y \gets a_{i+m}&
5 & \qquad \textbf{for }i=l\textbf{ to }l+m-1\\
6 & \qquad \qquad a_i \gets x+y&
6 & \qquad \qquad x \gets a_i\\
7 & \qquad \qquad a_{i+m} \gets x-y&
7 & \qquad \qquad y \gets a_{i+m}\\
8 & \qquad \textbf{end for} &
8 & \qquad \qquad a_i \gets \frac{x+y}{2}\\
9 & \qquad \text{FWT}(a,l,l+m)&
9 & \qquad \qquad a_{i+m} \gets \frac{x-y}{2}\\
10 & \qquad \text{FWT}(a,l+m,r)&
10 & \qquad \textbf{end for} \\
11 & \textbf{end function} &
11 & \textbf{end function} \\
  \hline
\end{array}</script><p>异或卷积则是 FWT 后直接做乘法：<script type="math/tex">\operatorname{IFWT}( \operatorname{FWT}(a) \times \operatorname{FWT}(b) )</script>。</p><p>事实上，<script type="math/tex">\operatorname{IFWT}(a) = \operatorname{FWT}(a)\cdot 2^{-n}</script>。因此非递归版本的 IFWT 也可以直接在最后除掉一个<script type="math/tex">2^n</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/mb/fwt.cpp">模板代码</a></p><details open><summary>Trick</summary><p>有一个小 Trick 就是，如果我们修改<script type="math/tex">\operatorname{FWT}(a)(0)</script>，那么等<script type="math/tex">\operatorname{IFWT}</script>变换回去后，所有项都被增加一个常量（这个常量不一定等于我们修改的差量）。原因如上所述，<script type="math/tex">a_0</script>的贡献永远是正的。</p><p>这个性质可以用来解一些要求<script type="math/tex">a_0=0</script>的题，那么我们给<script type="math/tex">\operatorname{FWT}(a)(0)</script>随机一个值，变换回去后把所有项都减掉<script type="math/tex">a_0</script>即可。</p></details><h2><a id="子集卷积" href="#子集卷积" class="headerlink" title="子集卷积"></a>子集卷积</h2><p>我们考虑这样一个问题：求不相交的或卷积：</p><script type="math/tex;mode=display">c_S=\sum_{P\cup Q=S,P\cap Q=\varnothing}a_P b_Q</script><p>这个不好求。我们设一个集合占位多项式：</p><script type="math/tex;mode=display">\begin{aligned}
A_{S}(x) &= \sum_{T\subseteq S} a_Tx^{|T|} = \sum_{i} x^i \sum_{T\subseteq S,|T|=i} a_T \\
B_{S}(x) &= \sum_{T\subseteq S} b_Tx^{|T|} = \sum_{i} x^i \sum_{T\subseteq S,|T|=i} b_T
\end{aligned}</script><p>左右两个定义是等价的。</p><p>令<script type="math/tex">C_S(x) = A_S(x) B_S(x)</script>则可以得到</p><script type="math/tex;mode=display">\begin{aligned}
C_S(x) &= \sum_{P\subseteq S} a_P  x^{|P|} \sum_{Q\subseteq S}b_Q x^{|Q|} \\
&= \sum_{P\subseteq S} \sum_{Q\subseteq S} a_P b_Q x^{|P|+|Q|} \\
&= \sum_{P \cup Q \subseteq S} a_P b_Q x^{|P|+|Q|} \\
\end{aligned}</script><p>把这个逆变换得到</p><script type="math/tex;mode=display">c_S = \sum _{P\cup Q = S}a_P b_Q x^{|P|+|Q|}</script><p>这时你会发现，当<script type="math/tex">|P| + |Q| = |S|</script>时有<script type="math/tex">P\cup Q=S,P\cap Q=\varnothing</script>。因此我们取<script type="math/tex">[x^{|S|}] c_S</script>就是答案。</p><p>时间复杂度为</p><script type="math/tex;mode=display">2O(n2^n)+O(n^22^n)+O(n2^n)=O(n^22^n)</script><p>在实现的时候有一个技巧，就是在暴力卷积的时候要稍微调整循环顺序，不要一列一列访问内存，不然常数极大。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/loj/152.cpp">代码</a></p><h3><a id="HDU-5823" href="#HDU-5823" class="headerlink" title="HDU 5823"></a>HDU 5823</h3><p>首先显然色数是<script type="math/tex">\le n</script>的，因为你每个点染不同颜色一定是成立的。</p><p>而显然每种颜色可以染一个独立集。设<script type="math/tex">f(S)</script>表示点集<script type="math/tex">S</script>是否是一个独立集，<script type="math/tex">g(S,x)</script>表示<script type="math/tex">S</script>点集能否使用<script type="math/tex">x</script>种颜色染。则</p><script type="math/tex;mode=display">g(S,1)=f(S)\\
g(S,i)=\left[\sum_{T\subseteq S}g(T,i-1)f(S\setminus T)\right]\\
g(P\cup Q,i)=\left[\sum_{P\cap Q=\varnothing}g(P,i-1)f(Q)\right]</script><p>但事实上<script type="math/tex">P\cap Q=\varnothing</script>不是必要条件，它不会影响最优解。因此这就是一个子集或卷积，需要做<script type="math/tex">n</script>次，每次卷完要回来转成艾弗森括号运算值。总复杂度<script type="math/tex">O(n^22^n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/hdu/5823.cpp">代码</a></p><h3><a id="CF1034-E" href="#CF1034-E" class="headerlink" title="CF1034 E"></a>CF1034 E</h3><blockquote><p>求<script type="math/tex">c_S=\sum_{P\cup Q=S,P\cap Q=\varnothing}a_Pb_Q\bmod 4</script>。<script type="math/tex">n\le 21</script>。</p></blockquote><p>可以使用上述子集卷积做法，复杂度<script type="math/tex">O(n^22^n)</script>，在这道题中是不能通过的。</p><p>设</p><script type="math/tex;mode=display">\begin{aligned}
A_S(p) &= \sum_{T\subseteq S}a_Tp^{|T|}\\
B_S(p) &= \sum_{T\subseteq S}b_Tp^{|T|}
\end{aligned}</script><p>设<script type="math/tex">F_S(p) = A_S(p)B_S(p)</script>，还原一下有<script type="math/tex">f_S(p) = \sum_{P\cup Q = S}a_P b_Q p^{|P| + |Q|}</script>。</p><p>注意到<script type="math/tex">f_S(p)</script>这个多项式的最低次项的指数是<script type="math/tex">|S|</script>。而我们要的就是所有<script type="math/tex">[p^{|S|}]f_S</script>的和（即<script type="math/tex">|P| + |Q| = |S|</script>）。</p><p>设<script type="math/tex">p=4</script>，这题要求对<script type="math/tex">4</script>取模。</p><p>那么我们可以直接把<script type="math/tex">p=4</script>代入<script type="math/tex">\frac{f_S(p)}{p^{|S|}}</script>这个多项式，因为是对<script type="math/tex">4</script>取模，因此除了常数项之外的其他项的贡献都是<script type="math/tex">0</script>。实现的时候开 LL 暴力右移即可。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/codeforces/1034/e/e.cpp">代码</a></p><h3><a id="HDU-5330" href="#HDU-5330" class="headerlink" title="HDU 5330"></a>HDU 5330</h3><p>这道题虽然名称上是状圧 DP，但在 DP 的过程中是按维度考虑，其实是在做一个高维前缀和的过程。这样就更容易理解它 DP 的含义了。</p><p>具体的 DP 方法可以见注释。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/hdu/5330.cpp">代码</a></p><h3><a id="AGC034-F" href="#AGC034-F" class="headerlink" title="AGC034 F"></a>AGC034 F</h3><p>设<script type="math/tex">E(x)</script>表示从<script type="math/tex">0</script>变到<script type="math/tex">x</script>的期望：</p><script type="math/tex;mode=display">E(x)=1+\sum_{i=0}^{2^n-1}E(i)p_{x\oplus i}\\
=1+\sum_{i=0}^{2^n-1}E(x\oplus i)p_i \\</script><p>且<script type="math/tex">p_x=\dfrac{A_x}{S},E(0)=0</script>。注意到这是一个异或卷积的形式（<script type="math/tex">x\oplus i\oplus i=x</script>），则这个等式可以被表示为</p><script type="math/tex;mode=display">\left\langle E(0),E(1),\cdots,E(2^n-1) \right\rangle \oplus \left\langle p_0,p_1,\cdots,p_{2^n-1} \right\rangle=\left\langle ?,E(1)-1,E(2)-1,\cdots,E(2^n-1)-1 \right\rangle</script><p><script type="math/tex">E(0)=0</script>，不满足和式，因此表示为<script type="math/tex">?</script>状态。</p><p>由于<script type="math/tex">\sum_{i=0}^{2^n-1}p_i=1</script>，而在上述异或卷积中每个<script type="math/tex">E(i)</script>都和所有的<script type="math/tex">p_i,i\in[0,2^n-1]</script>乘起来贡献了一次。因此</p><script type="math/tex;mode=display">E(0)+E(1)+\cdots+E(2^n-1)=?+(E(1)-1)+(E(2)-1)+\cdots +(E(2^n-1)-1)\\
?=E(0)+2^n-1</script><p>于是得到</p><script type="math/tex;mode=display">\left\langle E(0),E(1),\cdots,E(2^n-1) \right\rangle \oplus \left\langle p_0,p_1,\cdots,p_{2^n-1} \right\rangle\\
=\left\langle E(0)+2^n-1,E(1)-1,E(2)-1,\cdots,E(2^n-1)-1 \right\rangle</script><p>我们想办法把所有<script type="math/tex">E(x)</script>消掉：</p><script type="math/tex;mode=display">\left\langle E(0),E(1),\cdots,E(2^n-1) \right\rangle \oplus \left\langle p_0-1,p_1,\cdots,p_{2^n-1} \right\rangle=A=\left\langle 2^n-1,-1,-1,\cdots,-1 \right\rangle</script><p>于是我们 FWT 之后计算<script type="math/tex">\operatorname{FWT}(A)(i)/\operatorname{FWT}(p)(i)</script>，然后再转回来即可。因为最后的答案是强制<script type="math/tex">E(0)=0</script>，所以在做的时候可以直接乘上逆元。最后使用 FWT 本质的 Trick 即可。</p><p>时间复杂度<script type="math/tex">O(2^nn)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/atcoder/agc034_f.cpp">代码</a></p><p><a id="fn_1" class="headerlink" title="1"></a><sup>1</sup>. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fast_Walsh%E2%80%93Hadamard_transform">https://en.wikipedia.org/wiki/Fast_Walsh%E2%80%93Hadamard_transform</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></p></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2022年7月8日 第5次修订</li><li class="post-history-item">2021年4月9日 第4次修订</li><li class="post-history-item">2021年3月25日 第3次修订</li><li class="post-history-item">2021年3月25日 第2次修订</li><li class="post-history-item">2020年3月28日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/19-CSP-Sum/">2019 CSP-S 考挂总结</a></div><div class="prev-post"><a href="/Probset/NOI2020/">NOI2020 补题记录 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>