<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>滚动哈希和卡哈希的数学原理 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">滚动哈希和卡哈希的数学原理</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2020年3月22日星期日晚上8点32分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2020年3月22日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 3,860 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> <a class="directory" href="/directory/Math/">数学 </a><span class="icon smallarrow"></span> 当前文章</div><div class="post-tags"><span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Notes/">Notes</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Math/">Math</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Hash/">Hash</a></span></div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#设计难卡的滚动哈希"><span class="toc-number">1.</span> <span class="toc-text">设计难卡的滚动哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#滚动哈希"><span class="toc-number">1.1.</span> <span class="toc-text">滚动哈希</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#随机基数"><span class="toc-number">1.2.</span> <span class="toc-text">随机基数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#随机模数"><span class="toc-number">1.3.</span> <span class="toc-text">随机模数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何随机"><span class="toc-number">1.4.</span> <span class="toc-text">如何随机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多重哈希"><span class="toc-number">1.5.</span> <span class="toc-text">多重哈希</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更大的模数"><span class="toc-number">1.6.</span> <span class="toc-text">更大的模数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#卡哈希"><span class="toc-number">2.</span> <span class="toc-text">卡哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何卡哈希"><span class="toc-number">2.1.</span> <span class="toc-text">如何卡哈希</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单哈希"><span class="toc-number">2.2.</span> <span class="toc-text">单哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Thue–Morse-序列攻击：ULL-自然溢出"><span class="toc-number">2.2.1.</span> <span class="toc-text">Thue–Morse 序列攻击：ULL 自然溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生日攻击：32-位模数，固定模数和基数"><span class="toc-number">2.2.2.</span> <span class="toc-text">生日攻击：32 位模数，固定模数和基数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#树攻击：更大模数，固定模数和基数"><span class="toc-number">2.2.3.</span> <span class="toc-text">树攻击：更大模数，固定模数和基数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#卡回文串"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">卡回文串</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多重树攻击"><span class="toc-number">2.2.4.</span> <span class="toc-text">多重树攻击</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多重哈希-1"><span class="toc-number">2.3.</span> <span class="toc-text">多重哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#逐个击破"><span class="toc-number">2.3.1.</span> <span class="toc-text">逐个击破</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中国剩余定理（CRT）"><span class="toc-number">2.3.2.</span> <span class="toc-text">中国剩余定理（CRT）</span></a></li></ol></li></ol></li></ol></div><hr></div><div class="post-content"><p>translate from <em><a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/60442">The Mathematics Behind Rolling Hashes and Anti-hash Tests</a></em></p><h2><a id="设计难卡的滚动哈希" href="#设计难卡的滚动哈希" class="headerlink" title="设计难卡的滚动哈希"></a>设计难卡的滚动哈希</h2><h3><a id="滚动哈希" href="#滚动哈希" class="headerlink" title="滚动哈希"></a>滚动哈希</h3><p>我们使用二元组<script type="math/tex">(p,a)</script>来描述滚动哈希。其中<script type="math/tex">p</script>是<strong>模数（modulo）</strong>，<script type="math/tex">a</script>是<strong>基数（base）</strong>。</p><p>对于长度为<script type="math/tex">n</script>的字符串<script type="math/tex">s</script>，它的滚动哈希函数为</p><script type="math/tex;mode=display">h(S)=\sum_{i=1}^{n}a^{n-i}s_i \mod p</script><p>对于等长的两个字符串<script type="math/tex">S,T</script>，若<script type="math/tex">S\ne T</script>且<script type="math/tex">h(S)=h(T)</script>，则称这是<strong>等长冲突（equal-length collision）</strong>。</p><h3><a id="随机基数" href="#随机基数" class="headerlink" title="随机基数"></a>随机基数</h3><p>考虑我们固定一个<strong>质数</strong>模数<script type="math/tex">p</script>，在<script type="math/tex">[1,p)</script>中随机一个整数作为基数<script type="math/tex">a</script>来做滚动哈希。</p><p>对于两个长度为<script type="math/tex">n</script>的串<script type="math/tex">S,T(S\ne T)</script>，考虑计算他们等长冲突的概率：</p><script type="math/tex;mode=display">\begin{aligned}
&h(S)=h(T) \\
\Leftrightarrow &\sum_{i=1}^na^{n-i}S_i=\sum_{i=1}^na^{n-i}T_i \mod p\\
\Leftrightarrow & P(a)=\sum_{i=1}^na^{n-i}(S_i-T_i)=0\mod p
\end{aligned}</script><p>在这里<script type="math/tex">P(a)</script>是一个关于<script type="math/tex">a</script>的<script type="math/tex">n-1</script>度的多项式。那么<script type="math/tex">h(S)=h(T)</script>的概率就是<script type="math/tex">P(a)=0\pmod p</script>的概率，即<script type="math/tex">a</script>是<script type="math/tex">P</script>的根的概率。</p><p>由于<script type="math/tex">p</script>是质数，因此这构成一个域。在域中，任何<script type="math/tex">\le n-1</script>度的多项式最多有<script type="math/tex">n-1</script>个根。因此</p><script type="math/tex;mode=display">\Pr[h(S)=h(T)]=\Pr[P(a)=0]\le \frac{n-1}{p}</script><p>对于<script type="math/tex">n=10^5,p=10^9+7</script>，这个概率是<script type="math/tex">10^{-4}</script>级别的。</p><p><script type="math/tex">\frac{n-1}{p}</script>的范围其实比较紧的。如果<script type="math/tex">(n-1)\mid (p-1)</script>。考虑<script type="math/tex">S=\text{ba...aa},T=\text{aa...ab}</script>，则<script type="math/tex">P(a)=A^{n-1}-1\pmod p</script>。根据一些群论知识，这个方程有<script type="math/tex">n-1</script>个根。</p><h3><a id="随机模数" href="#随机模数" class="headerlink" title="随机模数"></a>随机模数</h3><p>考虑固定基数<script type="math/tex">a(|\Sigma|\le a &lt;N)</script>，然后在<script type="math/tex">[N,2N-1]</script>的范围内随机选择一个整数作为模数<script type="math/tex">p</script>。</p><p>同样地，对于两个长度为<script type="math/tex">n</script>的串<script type="math/tex">S,T(S\ne T)</script>，考虑计算他们等长冲突的概率：</p><script type="math/tex;mode=display">\begin{aligned}
h(S)=h(T)
\Leftrightarrow X=\sum_{i=1}^na^{n-i}(S_i-T_i)=0\mod p
\end{aligned}</script><p>则可以通过一些数学知识得到</p><script type="math/tex;mode=display">\Pr[h(S)=h(T)]=\Pr[p\mid X]\le \sim\frac{n\ln(a)}{N}</script><p>对于<script type="math/tex">n=10^5,a=26,N=10^9</script>，这个概率是<script type="math/tex">3\times 10^{-4}</script>级别的。</p><h3><a id="如何随机" href="#如何随机" class="headerlink" title="如何随机"></a>如何随机</h3><p>以下三种可以考虑：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//by Sshwy</span>
<span class="token comment">//#define DEBUGGER</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;chrono></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    cout<span class="token operator">&lt;&lt;</span>chrono<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">duration_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>chrono<span class="token double-colon punctuation">::</span>nanoseconds<span class="token operator">></span></span></span><span class="token punctuation">(</span>chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>chrono<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">duration_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>chrono<span class="token double-colon punctuation">::</span>nanoseconds<span class="token operator">></span></span></span><span class="token punctuation">(</span>chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token function">__builtin_ia32_rdtsc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3><a id="多重哈希" href="#多重哈希" class="headerlink" title="多重哈希"></a>多重哈希</h3><p>我们可以使用多重的随机滚动哈希。如果<script type="math/tex">k</script>重哈希的冲突概率分别是<script type="math/tex">\alpha_1,\alpha_2,\cdots,\alpha_k</script>，则你哈希碰撞的概率就是<script type="math/tex">\prod_{i=1}^k \alpha_i</script>。</p><h3><a id="更大的模数" href="#更大的模数" class="headerlink" title="更大的模数"></a>更大的模数</h3><p>你哈希的模数越大，冲突的概率就越小。但是更大的模数在计算过程中会很吃力。使用<code class="inline-code">__int128</code>会降低计算速度。不过有一个质数例外，那就是梅森质数<script type="math/tex">p=2^{61}-1</script>，我们可以通过位运算来计算<script type="math/tex">a\times b\mod p</script>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">uint64_t</span> mod <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1ull</span><span class="token operator">&lt;&lt;</span><span class="token number">61</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">uint64_t</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token keyword">uint64_t</span> a<span class="token punctuation">,</span> <span class="token keyword">uint64_t</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">uint64_t</span> l1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">)</span>a<span class="token punctuation">,</span> h1 <span class="token operator">=</span> a<span class="token operator">>></span><span class="token number">32</span><span class="token punctuation">,</span> l2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">)</span>b<span class="token punctuation">,</span> h2 <span class="token operator">=</span> b<span class="token operator">>></span><span class="token number">32</span><span class="token punctuation">;</span>
	<span class="token keyword">uint64_t</span> l <span class="token operator">=</span> l1<span class="token operator">*</span>l2<span class="token punctuation">,</span> m <span class="token operator">=</span> l1<span class="token operator">*</span>h2 <span class="token operator">+</span> l2<span class="token operator">*</span>h1<span class="token punctuation">,</span> h <span class="token operator">=</span> h1<span class="token operator">*</span>h2<span class="token punctuation">;</span>
	<span class="token keyword">uint64_t</span> ret <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">&amp;</span>mod<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>l<span class="token operator">>></span><span class="token number">61</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>m <span class="token operator">>></span> <span class="token number">29</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>m <span class="token operator">&lt;&lt;</span> <span class="token number">35</span> <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token punctuation">(</span>ret <span class="token operator">&amp;</span> mod<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ret<span class="token operator">>></span><span class="token number">61</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token punctuation">(</span>ret <span class="token operator">&amp;</span> mod<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ret<span class="token operator">>></span><span class="token number">61</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ret<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><a id="卡哈希" href="#卡哈希" class="headerlink" title="卡哈希"></a>卡哈希</h2><p>接下来就是关于如何卡哈希的教程了。</p><h3><a id="如何卡哈希" href="#如何卡哈希" class="headerlink" title="如何卡哈希"></a>如何卡哈希</h3><p>在介绍具体的方法之前，先思考一下，面对一道哈希问题，如果去卡它？</p><p>本质上，分为两个步骤：</p><ol><li>对于该哈希方式找一个等长冲突；</li><li>利用这个等长冲突来造数据卡他。</li></ol><h3><a id="单哈希" href="#单哈希" class="headerlink" title="单哈希"></a>单哈希</h3><h4><a id="Thue–Morse-序列攻击：ULL-自然溢出" href="#Thue–Morse-序列攻击：ULL-自然溢出" class="headerlink" title="Thue–Morse 序列攻击：ULL 自然溢出"></a>Thue–Morse 序列攻击：ULL 自然溢出</h4><p>考虑<script type="math/tex">p=2^{64}</script>，<script type="math/tex">a</script>任意的情况。我们可以使用 Thue–Morse 序列来卡。它的生成方式如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> Q <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> Q<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string <span class="token function">S</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">T</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'A'</span> <span class="token operator">+</span> <span class="token function">__builtin_popcount</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    T<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'B'</span> <span class="token operator">-</span> <span class="token function">__builtin_popcount</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时<script type="math/tex">S,T</script>就发生了等长冲突（不论<script type="math/tex">a</script>的值）。具体参见 <a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/4898">这篇文章</a>。</p><h4><a id="生日攻击：32-位模数，固定模数和基数" href="#生日攻击：32-位模数，固定模数和基数" class="headerlink" title="生日攻击：32 位模数，固定模数和基数"></a>生日攻击：32 位模数，固定模数和基数</h4><p>考虑使用<strong>生日攻击</strong>。固定长度<script type="math/tex">l</script>，令<script type="math/tex">k=1+\sqrt{(2\ln 2)p}</script>。并且<strong>等概率随机（uniformly at random）</strong>生成<script type="math/tex">k</script>个长度为<script type="math/tex">l</script>的字符串。</p><p>如果<script type="math/tex">l</script>的值不是特别小，则这<script type="math/tex">k</script>个串的哈希值可以近似看作等概率随机分布，使用生日悖论，则这<script type="math/tex">k</script>个数全部两两不同的概率是</p><script type="math/tex;mode=display">\prod_{i=0}^{k-1}\left(1-\frac{i}{p} \right)&lt;\prod_{i=0}^{k-1}e^{-\frac{i}{p}}&lt;e^{-\ln 2}=\frac{1}{2}</script><p>因此我们重复这个过程，可以在<script type="math/tex">O(\sqrt{p})</script>的时间内找到等长冲突。</p><p>生日攻击不依赖于哈希函数（异或哈希也可以）。但它不能卡回文串。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/mb/birth_attack.cpp">代码</a></p><h4><a id="树攻击：更大模数，固定模数和基数" href="#树攻击：更大模数，固定模数和基数" class="headerlink" title="树攻击：更大模数，固定模数和基数"></a>树攻击：更大模数，固定模数和基数</h4><p>对于更大的模数，生日攻击将会变得很慢。</p><p>考虑<strong>树攻击（tree-attack）</strong>。</p><p>对于两个长度为<script type="math/tex">n</script>的的字符串<script type="math/tex">S,T</script>，我们知道</p><script type="math/tex;mode=display">h(S)=h(T)\Leftrightarrow \sum_{i=1}^n(a^{n-i}\bmod p)(S_i-T_i)=0\mod p</script><p>不妨设<script type="math/tex">A_i=S_i-T_i</script>。显然<script type="math/tex">-|\Sigma|\le A_i\le |\Sigma|</script>。树攻击会尝试寻找一个<script type="math/tex">A_i\in\{-1,0,1\}</script>的序列使得</p><script type="math/tex;mode=display">\sum_{i=1}^n(a^{n-i}\bmod p)A_i=0</script><p>考虑维护<script type="math/tex">k</script>个集合<script type="math/tex">C_1,\cdots,C_k</script>。定义<script type="math/tex">S(C)=\sum_{i\in C}(a^{n-i}\bmod p)A_i</script>。</p><p>如果我们合并两个集合<script type="math/tex">C_1,C_2</script>为<script type="math/tex">C_3</script>，则我们可以：</p><ol><li>直接合并，则<script type="math/tex">S(C_3)=S(C_2)+S(C_1)</script>；</li><li>把<script type="math/tex">\forall i\in C_1,A_i</script>都乘<script type="math/tex">-1</script>再合并，则<script type="math/tex">S(C_3)=S(C_2)-S(C_1)</script>；</li><li>类似 2，可以令<script type="math/tex">S(C_3)=S(C_1)-S(C_2)</script>；</li><li>把<script type="math/tex">\forall i\in C_1,A_i</script>都变成<script type="math/tex">0</script>，则<script type="math/tex">S(C_3)=S(C_2)</script>；</li><li>类似 4，可以令<script type="math/tex">S(C_3)=S(C_1)</script>。</li></ol><p>一开始我们有<script type="math/tex">n</script>个集合，设每个集合的<script type="math/tex">A_i</script>都是<script type="math/tex">1</script>。不妨设<script type="math/tex">n=2^k</script>。则我们每个阶段，都把集合按<script type="math/tex">S(C)</script>排序，然后使用 2 或者 3 方法来合并相邻两个集合（要保证合并完后<script type="math/tex">S(C)</script>非负）。一轮完成后，集合数量减半。如果出现了一个<script type="math/tex">S(C)=0</script>的集合，那么我们把其他集合的<script type="math/tex">A_i</script>都置为<script type="math/tex">0</script>即可。这样会最多做<script type="math/tex">k</script>轮。如果没有找到，那么就对更大的<script type="math/tex">k</script>继续这个过程。</p><p>如果一开始<script type="math/tex">n</script>个集合的<script type="math/tex">S(C)</script>是等概率随机分布于<script type="math/tex">[0,p-1]</script>，则<script type="math/tex">k</script>期望为<script type="math/tex">\sqrt{2\lg p}+1</script>时可以找到。那么我们就可以<script type="math/tex">\Theta(n)</script>地构造长度为<script type="math/tex">n=2^{\sqrt{2\lg p}+1}</script>的等长冲突的串了。</p><p>注意，树攻击是依赖于哈希函数的，即你的哈希函数必须是多项式函数。</p><h5><a id="卡回文串" href="#卡回文串" class="headerlink" title="卡回文串"></a>卡回文串</h5><p>树攻击可以卡回文串。以偶回文串为例，具体地说，我们要构造一个<strong>长度为偶数</strong>的串<script type="math/tex">S</script>，使得<script type="math/tex">S\ne S^R,h(S)=h(S^R)</script>。<script type="math/tex">S^R</script>表示反串。</p><p>那么这等价于</p><script type="math/tex;mode=display">\begin{aligned}
&h(S)=h(S^R)\\
\Leftrightarrow& \sum_{i=1}^n(a^{n-i}\bmod p)(S_i-S_{n+1-i})=0\mod p\\
\Leftrightarrow& \sum_{i=1}^{\frac{n}{2}}((a^{n-i}-a^{i-1})\bmod p)(S_i-S_{n+1-i})=0
\end{aligned}</script><p>因此我们设<script type="math/tex">A_i=S_i-S_{n+1-i}</script>，得到</p><script type="math/tex;mode=display">\sum_{i=1}^{\frac{n}{2}}((a^{n-i}-a^{i-1})\bmod p)A_i=0</script><p>那么我们对这个做一次正常的树攻击，就可以构造出一组<script type="math/tex">S_i-S_{n+1-i}</script>的值。</p><p>那么用字符<script type="math/tex">\text{a}</script>和<script type="math/tex">\text{b}</script>来构造串<script type="math/tex">S</script>即可。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/mb/tree_attack.cpp">代码</a></p><h4><a id="多重树攻击" href="#多重树攻击" class="headerlink" title="多重树攻击"></a>多重树攻击</h4><p>尽管树攻击速度很快，生成的字符串可能会过长（对于<script type="math/tex">p=2^{61}-1</script>，通常<script type="math/tex">n=2048</script>）。实际上我们可以花更多的计算时间来生成一个尽量短的等长冲突。对于每个集合，我们可以维护<script type="math/tex">m</script>个最小的可能的和（单树攻击是<script type="math/tex">m=1</script>的情况）。合并两个集合可以使用堆在<script type="math/tex">O(m\log_2m)</script>的时间内完成。</p><p>一通鬼畜分析后，我们得到<script type="math/tex">k=\sqrt{2\frac{\lg p}{\lg m}}+\log_2(m)</script>。</p><p>这个东西 Dls 也没写过，所以不知道好不好使。</p><h3><a id="多重哈希-1" href="#多重哈希-1" class="headerlink" title="多重哈希"></a>多重哈希</h3><p>卡多重哈希的方式有两种。</p><h4><a id="逐个击破" href="#逐个击破" class="headerlink" title="逐个击破"></a>逐个击破</h4><p>以双哈希为例，考虑<script type="math/tex">(a_1,p_1),(a_2,p_2)</script>双哈希。首先我们使用生日攻击或者树攻击找到<script type="math/tex">(a_1,p_1)</script>的一个等长冲突<script type="math/tex">S,T</script>。然后我们以<script type="math/tex">\{S,T\}</script>作为字符集对<script type="math/tex">(a_2^{|S|},p_2)</script>求出等长冲突（以<script type="math/tex">\{S,T\}</script>作为字符集的意思是，我们用<script type="math/tex">S</script>和<script type="math/tex">T</script>拼接出一个更大的串）。这样就可以把两个哈希都冲突掉。</p><p>使用这个方法，时间复杂度是每次攻击的复杂度之和。但生成的串长会随着哈希的重数而指数级增长。</p><p>不过这个方法不用考虑模数的大小。</p><h4><a id="中国剩余定理（CRT）" href="#中国剩余定理（CRT）" class="headerlink" title="中国剩余定理（CRT）"></a>中国剩余定理（CRT）</h4><p>对于树攻击，我们可以使用中国剩余定理来卡哈希。本质上，我们要求</p><script type="math/tex;mode=display">\begin{cases}
\sum_{i=1}^n({a_1}^{n-i}\bmod {p_1})A_i=0\\
\sum_{i=1}^n({a_2}^{n-i}\bmod {p_2})A_i=0
\end{cases}</script><p>设<script type="math/tex">x_i=a_1^{n-i},y_i=a_2^{n-i}</script>。然后我们使用 CRT 求出一个<script type="math/tex">z_i(0\le z_i &lt;[p_1,p_2])</script>，使得</p><script type="math/tex;mode=display">\begin{cases}
z_i=x_i \mod p_1\\
z_i=y_i \mod p_2
\end{cases}</script><p>那么我们就只需要</p><script type="math/tex;mode=display">\sum_{i=1}^n(z_i\bmod [p_1,p_2])A_i=0</script><p>即可。 那么我们对此做一次树攻击即可。</p><p>这个方法的要求模数的 LCM 不能太大。不过它的优点是，双哈希的回文串它也能卡。</p></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2020年3月22日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/Probset/NOIo-day1/">NOI Online 提高组 Day1</a></div><div class="prev-post"><a href="/Codeforces/part-2/">Codeforces 题目选讲 2 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>