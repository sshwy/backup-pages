<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>计数习题总结 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">计数习题总结</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2023年3月9日星期四下午5点55分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2023年3月9日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 5,144 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> <a class="directory" href="/directory/Math/">数学 </a><span class="icon smallarrow"></span> 当前文章</div><div class="post-tags"><span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Math/">Math</a></span></div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SetAndSet"><span class="toc-number">1.</span> <span class="toc-text">SetAndSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Endless-Spin"><span class="toc-number">2.</span> <span class="toc-text">Endless Spin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CTS2019-随机立方体"><span class="toc-number">3.</span> <span class="toc-text">CTS2019 随机立方体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Square-Constraints"><span class="toc-number">4.</span> <span class="toc-text">Square Constraints</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Two-Histograms"><span class="toc-number">5.</span> <span class="toc-text">Two Histograms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HamiltonianPaths"><span class="toc-number">6.</span> <span class="toc-text">HamiltonianPaths</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZJOI2016-小星星"><span class="toc-number">7.</span> <span class="toc-text">ZJOI2016 小星星</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fireflies"><span class="toc-number">8.</span> <span class="toc-text">Fireflies</span></a></li></ol></div><hr></div><div class="post-content"><h2><a id="SetAndSet" href="#SetAndSet" class="headerlink" title="SetAndSet"></a><a target="_blank" rel="noopener" href="https://vjudge.net/problem/TopCoder-12004">SetAndSet</a></h2><blockquote><p>给出一个长度为<script type="math/tex">n</script>的非负整数序列<script type="math/tex">a</script>，要求将<script type="math/tex">a</script>中的元素染红或染蓝，使得：</p><ol><li>至少有一个红色元素；</li><li>至少有一个蓝色元素；</li><li>红色元素的按位与等于蓝色元素的按位与。</li></ol><p>问有多少种合法的染色方案。</p><p><script type="math/tex">n\le 50,a_i&lt;2^{20}</script>。</p></blockquote><p><span class="label">容斥</span></p><p>考虑二进制下第<script type="math/tex">x</script>位。如果所有数的第<script type="math/tex">x</script>位都是 1，那么就可以不管这一位。否则，这一位为<script type="math/tex">0</script>的数不能全部分在一个集合。</p><p>考虑容斥，容斥哪些位的<script type="math/tex">0</script>分在同一集合。那么转化为无限制减去全部分在同一集合，用并查集统计有多少个连通块，容斥贡献就是<script type="math/tex">2^{cnt}-2</script>，减 2 是因为要非空。</p><p>使用 DFS 写容斥可以少一个<script type="math/tex">20</script>，时间复杂度<script type="math/tex">O(2^{20}n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/topcoder/12004.cpp">代码</a></p><h2><a id="Endless-Spin" href="#Endless-Spin" class="headerlink" title="Endless Spin"></a><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=4624">Endless Spin</a></h2><blockquote><p>给出<script type="math/tex">n</script>个球排成一排。初始时每个球都是白的。每次从<script type="math/tex">\frac{n(n+1)}{2}</script>个区间中等概率选择一个区间，把里面的求染黑。问期望多少次可以把所有球染黑。</p><p><script type="math/tex">n\le 50</script>。</p></blockquote><p><span class="label">期望</span> <span class="label">容斥 DP</span></p><p>设随机变量<script type="math/tex">x_i</script>表示第<script type="math/tex">i</script>个球被染黑的时间，且<script type="math/tex">S=\{x_1,\cdots,x_n\}</script>。那么答案可以表示为</p><script type="math/tex;mode=display">E(\max S)=\sum_{T\subseteq S}E(\min T)(-1)^{|T|-1}\\</script><p>对于集合<script type="math/tex">T</script>，我们需要求出，选到至少一个球的期望时间。期望是概率的倒数，转化为选到至少一个球的概率。那么假设对于集合<script type="math/tex">T</script>的元素，有<script type="math/tex">A</script>个区间可以让我们至少选到一个元素，那么概率就为<script type="math/tex">\Pr(T)=\frac{2A}{n(n+1)}</script>，因此期望为<script type="math/tex">\frac{1}{\Pr(T)}</script>。</p><p>那么如果我们求出</p><script type="math/tex;mode=display">F(k)\sum_{T\in S,|T|=k}\frac{1}{\Pr(T)}</script><p>答案就为</p><script type="math/tex;mode=display">\sum_{k=1}^{|S|}F(k)(-1)^{k}</script><p>考虑“至少选到一个”不好求，我们转化为，求一个都选不到。设<script type="math/tex">f(i,j,k)</script>表示考虑前<script type="math/tex">i</script>个点，有恰好<script type="math/tex">j</script>个区间，最后一个被选的点到第<script type="math/tex">i</script>个点的距离为<script type="math/tex">k</script>，使得这<script type="math/tex">j</script>个区间选不到白点的方案数（可以理解为这个概率的出现次数），再记一个<script type="math/tex">bit</script>表示这个部分的容斥系数：</p><script type="math/tex;mode=display">f(i,j,k,bit) \to f(i+1,j,0,\neg bit)\\
f(i,j,k,bit) \to f(i+1,j+k+1,k+1,bit)</script><p>那么答案为</p><script type="math/tex;mode=display">\sum_{A=0}^{\frac{1}{2}n(n+1)-1}\sum_{k=0}^n\frac{1}{1-\frac{2A}{n(n+1)}}\cdot f(n,A,k,bit)(-1)^{bit}</script><p>高精度用 python 打表即可。</p><p>时间复杂度<script type="math/tex">O(n^4)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/hdu/4624.cpp">代码</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/hdu/4624.py">代码 python</a></p><h2><a id="CTS2019-随机立方体" href="#CTS2019-随机立方体" class="headerlink" title="CTS2019 随机立方体"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5400">CTS2019 随机立方体</a></h2><blockquote><p>有一个<script type="math/tex">n\times m\times l</script>的立方体，立方体中每个格子上都有一个数，如果某个格子上的数比三维坐标<strong>至少有一维</strong>相同的其他格子（三个方向的格子的集合）里的数都要大的话，我们就称它是极大的。</p><p>现在将<script type="math/tex">1,2,\cdots,nml</script>随机填入到<script type="math/tex">n\times m\times l</script>个格子中，使得每个数恰出现一次，求恰有<script type="math/tex">k</script>个极大的数的概率，对<script type="math/tex">998244353</script>取模。</p><p><script type="math/tex">n,m,l\le 5\times 10^6,k\le 100</script>。</p></blockquote><p><span class="label">二项式反演</span> <span class="label">概率</span> <span class="label">组合数</span> <span class="label">线性求逆元</span></p><p>设<script type="math/tex">g(k)</script>表示恰有<script type="math/tex">k</script>个的概率。那么设<script type="math/tex">f(k)</script>表示至少有<script type="math/tex">k</script>个的概率。那么每个<script type="math/tex">g(i)</script>就被<script type="math/tex">f(k)</script>计算了<script type="math/tex">\dbinom{i}{k}</script>次，根据二项式反演，得到</p><script type="math/tex;mode=display">\begin{aligned}
f(k)&=\sum_{i=k}^n\binom{i}{k}g(i)\\
g(k)&=\sum_{i=k}^n\binom{i}{k}f(i)(-1)^{i-k}
\end{aligned}</script><p>考虑求<script type="math/tex">f(k)</script>。显然我们可以钦定<script type="math/tex">k</script>个最大值，那么不妨设这<script type="math/tex">k</script>个最大值的位置分别在<script type="math/tex">(i,i,i),i\in[1,k]</script>的地方。并且我们要求<script type="math/tex">a_{i,i,i}\le a_{i+1,i+1,i+1},i\in[1,k)</script>。然后这<script type="math/tex">k</script>个数是各自的 3 个方向上切面的最大值。容易发现，这形成了一个树形结构（可以看二维的情况模拟得到），那么我们的问题等价于，给一棵树的每个结点分配一个标号，使得每个点是子树最大值的概率。答案即为每个子树的大小之和。由于这棵树的形态特殊，因此实际上可以得到概率为</p><script type="math/tex;mode=display">\prod_{i=1}^k\frac{1}{nml-(n-i)(m-i)(l-i)}</script><p>然后考虑这<script type="math/tex">k</script>个最大值的位置（刚才我们是钦定的位置，没有讨论过），那么第一个有<script type="math/tex">nml</script>种选择，第二个有<script type="math/tex">(n-1)(m-1)(l-1)</script>种选择，以此类推。则总方案数为<script type="math/tex">n^{\underline{k}}m^{\underline{k}}l^{\underline{k}}</script>。因此得到</p><script type="math/tex;mode=display">f(k)=n^{\underline{k}}m^{\underline{k}}l^{\underline{k}}\prod_{i=1}^k\frac{1}{nml-(n-i)(m-i)(l-i)}</script><p>显然<script type="math/tex">f</script>是可以递推的：</p><script type="math/tex;mode=display">\begin{aligned}
f(i)&=f(i-1)(n-i+1)(m-i+1)(l-i+1)a_i\\
a_i&=\frac{1}{nml-(n-i)(m-i)(l-i)}
\end{aligned}</script><p>那么我们线性求<script type="math/tex">a_i</script>的逆元即可（注意，线性求逆元在<script type="math/tex">a_i</script>含有 0 的时候有 bug，但是本题中不会出现这种情况），时间复杂度<script type="math/tex">O(n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/luogu/5400.cpp">代码</a></p><h2><a id="Square-Constraints" href="#Square-Constraints" class="headerlink" title="Square Constraints"></a><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/agc036/tasks/agc036_f">Square Constraints</a></h2><p>设</p><script type="math/tex;mode=display">\begin{aligned}
f(i)&=\left\lfloor \sqrt{n^2-i^2-1} \right\rfloor+1\\
g(i)&=\min\left(\left\lfloor \sqrt{4n^2-i^2} \right\rfloor+1,2n\right)
\end{aligned}</script><p>原题目的限制可以表示为</p><script type="math/tex;mode=display">\forall i\in[0,2n),f(i)\le P_i&lt; g(i)</script><p>考虑容斥下界。那么我们就枚举这<script type="math/tex">2n</script>个数中有<script type="math/tex">k</script>个数<script type="math/tex">&lt; f(i)</script>。假设我们确定了<script type="math/tex">k</script>个数<script type="math/tex">x_1,\cdots,x_k(x_i\in[0,n))</script>，这个<script type="math/tex">k</script>个数的限制是<script type="math/tex">P_{x_i}&lt;f(x_i)</script>，所有数的限制是<script type="math/tex">P_i&lt;g(i)</script>（注意到<script type="math/tex">f(i)\le g(i)</script>，<script type="math/tex">g</script>是包含了<script type="math/tex">f</script>的），求这样的方案数。那么我们把每个数的限制从小到大排序，形成一个长度为<script type="math/tex">2n</script>的数组<script type="math/tex">h</script>，那么答案为</p><script type="math/tex;mode=display">\prod_{i=0}^{2n-1}(h_i-i)</script><p>但是这<script type="math/tex">k</script>个数是不确定的。我们考虑把<script type="math/tex">f(i),i\in[0,n)</script>和<script type="math/tex">g(i),i\in[0,2n)</script>放在一起升序排序得到序列<script type="math/tex">A</script>，并且我们把<script type="math/tex">f(i)</script>标记为<code class="inline-code">a</code>，把<script type="math/tex">g(i),i\in[0,n)</script>标记为<code class="inline-code">b</code>，把<script type="math/tex">g(i),i\in[n,2n)</script>标记为<code class="inline-code">c</code>。那么<script type="math/tex">A</script>的标记数组<script type="math/tex">B</script>一定长成<code class="inline-code">aaccac...bbbbb</code>的形式，即<code class="inline-code">a</code>、<code class="inline-code">c</code>全在前面，<code class="inline-code">b</code>在后面的形式。</p><p>相当于我们从这<script type="math/tex">3n</script>个数中选择<script type="math/tex">2n</script>个出来，满足对于<script type="math/tex">i\in[n,2n)</script>的部分我们选择<script type="math/tex">g(i)</script>（即所有的<code class="inline-code">c</code>必选），然后我们选择<script type="math/tex">k</script>个<script type="math/tex">f(x_i)</script>（相当于选择<script type="math/tex">k</script>个<code class="inline-code">a</code>），然后剩下的选<script type="math/tex">g(i)</script>（相当于选择<code class="inline-code">b</code>）。</p><p>由于<script type="math/tex">f(i),g(i)</script>都是非递增的，因此相当于你选了第<script type="math/tex">i</script>个<code class="inline-code">a</code>就不能选第<script type="math/tex">i</script>个<code class="inline-code">b</code>。因此我们就转化为了求出，选<script type="math/tex">k</script>个数的限制为<script type="math/tex">&lt;f(i)</script>的容斥贡献和。这个可以 DP 做，设<script type="math/tex">F(i,j)</script>表示在考虑前<script type="math/tex">i</script>个数以及对应的前若干个<code class="inline-code">b</code>，我们选<script type="math/tex">j</script>个<code class="inline-code">a</code>的容斥贡献和。设<script type="math/tex">b_i</script>表示当<script type="math/tex">B_i=a</script>时它对应的<code class="inline-code">b</code>的位置，方便转移。那么贡献和就是<script type="math/tex">F(2n,k)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/atcoder/agc036_f.cpp">代码</a></p><h2><a id="Two-Histograms" href="#Two-Histograms" class="headerlink" title="Two Histograms"></a><a target="_blank" rel="noopener" href="https://agc035.contest.atcoder.jp/tasks/agc035_f">Two Histograms</a></h2><p>对于一个方案，如果存在<script type="math/tex">k_i,l_j</script>使得<script type="math/tex">k_i=j-1,l_j=i</script>，那么我们就把它变成<script type="math/tex">k_i=j,l_j=i-1</script>。如果不存在，就是一个“合法”的方案。</p><p>我们只需要统计出所有“合法”的方案就是答案。证明见官题。</p><p>考虑容斥，则答案为</p><script type="math/tex;mode=display">\sum_{i=0}^n\binom{n}{i}\binom{m}{i}i!(m+1)^{n-i}(n+1)^{m-i}(-1)^i</script><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/atcoder/agc035_f.cpp">代码</a></p><h2><a id="HamiltonianPaths" href="#HamiltonianPaths" class="headerlink" title="HamiltonianPaths"></a><a target="_blank" rel="noopener" href="https://vjudge.net/problem/TopCoder-14250">HamiltonianPaths</a></h2><blockquote><p>有一个<script type="math/tex">k</script>个点的无向简单图，你把它复制<script type="math/tex">n-1</script>次变成一个<script type="math/tex">nk</script>个点的图，然后求补图的哈密尔顿路径（有向）的数目。</p><p><script type="math/tex">k\le 14,n\le 5\times 10^4</script>。</p></blockquote><p>设原图上的边为不合法的边，我们要求不能经过不合法的边。考虑容斥，问题转化为，钦定经过<script type="math/tex">k</script>条不合法的边，其他点无限制，问哈密尔顿路径的数目，这样的容斥贡献是<script type="math/tex">(-1)^k</script>。</p><p>我们先不考虑复制的操作，考虑在原图及其补图上求出经过<script type="math/tex">k</script>条不合法的边的哈密尔顿的路径数的容斥贡献和。</p><p>更具体地，设<script type="math/tex">f(S,x)</script>表示在原图上，点集<script type="math/tex">S</script>以<script type="math/tex">x</script>结尾的哈密尔顿路径数，乘上容斥系数，这个可以 DP 求出：</p><script type="math/tex;mode=display">f(S\cup \{y\},y)=\sum_{(x,y)\in E}(-1)f(S,x)</script><p>那么设<script type="math/tex">F(S)</script>表示在原图上点集<script type="math/tex">S</script>的哈密尔顿路径数，即<script type="math/tex">F(S)=\sum_{x\in S}f(S,x)</script>。</p><p>于是，我们设<script type="math/tex">g(S,x)</script>表示在原图上点集<script type="math/tex">S</script>被分成<script type="math/tex">x</script>条路径的方案数（单点算一条路径），显然可以枚举第一个点 / 最后一个点所在的子集<script type="math/tex">T</script>，用<script type="math/tex">F(T)</script>转移：</p><script type="math/tex;mode=display">g(S,x)=\sum_{T}F(T)g(S\setminus T,x-1)</script><p>那么，我们就求出了把原图划分为<script type="math/tex">x</script>条<strong>不合法</strong>的路径的方案数的容斥贡献和<script type="math/tex">G(x)=g(U,x)</script>。考虑复制了<script type="math/tex">n-1</script>遍，能否求出新图的<script type="math/tex">G</script>？</p><p>答案是可以。注意到复制<script type="math/tex">n-1</script>遍的<script type="math/tex">G</script>即为<script type="math/tex">G^n(x)</script>，因此做<script type="math/tex">n</script>次 FFT 即可（用快速幂）。</p><p>求出了这个<script type="math/tex">G^n(x)</script>，那么答案就为<script type="math/tex">\sum G^n(i)i!</script>，表示你把这<script type="math/tex">i</script>条不合法路径用<script type="math/tex">i-1</script>条合法的边（合法的边就是补图上的边）连起来，连成一个哈密尔顿通路的方案数，显然这<script type="math/tex">i</script>条路径的顺序可以任意安排，因此有<script type="math/tex">i!</script>种方案。至于容斥系数在一开始的时候就计算过了，因此不用乘<script type="math/tex">(-1)^k</script>。</p><p>时间复杂度<script type="math/tex">O(nk\log_2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/topcoder/14250.cpp">代码</a></p><h2><a id="ZJOI2016-小星星" href="#ZJOI2016-小星星" class="headerlink" title="ZJOI2016 小星星"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3349">ZJOI2016 小星星</a></h2><p>我们把双射放缩为一个函数<script type="math/tex">p(i)\in[1,n]</script>，那么我们希望<script type="math/tex">p(1),\cdots,p(n)</script>中，<script type="math/tex">1,\cdots,n</script>都出现过。</p><p>考虑容斥，我们枚举哪些值没有出现（即我们允许多个点对应一个点）。没有出现，我们就直接在图上删掉这个点。于是考虑 DP，设<script type="math/tex">f(u,v)</script>表示考虑<script type="math/tex">u</script>的子树，且<script type="math/tex">u</script>和原图上的<script type="math/tex">v</script>对应，问有多少种对应方案。转移时枚举每个儿子的对应方案：</p><script type="math/tex;mode=display">f(u,v)=\prod_{x\in Son(u)}\sum_{(v,y)\in E}f(x,y)</script><p>DP 的复杂度是<script type="math/tex">O(n^3)</script>的，加上枚举的复杂度，总复杂度<script type="math/tex">O(n^32^n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/luogu/3349.cpp">代码</a></p><h2><a id="Fireflies" href="#Fireflies" class="headerlink" title="Fireflies"></a><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=6355">Fireflies</a></h2><p>设</p><script type="math/tex;mode=display">M=\left\lfloor\frac{1}{2}\sum_{i=1}^n(p_i+1)\right\rfloor</script><p>问题可以通过一堆定理转化为，求<script type="math/tex">\sum_{i=1}^nx_i=M</script>且<script type="math/tex">1\le x_i\le p_i</script>的解的方案数。</p><p>考虑容斥，转化为枚举<script type="math/tex">S\in[n]</script>集合内的元素不满足限制，则可以得到</p><script type="math/tex;mode=display">\sum_{S\in[n]}(-1)^{|S|}\max\left(0,\binom{M-1-\sum_{x\in S}p_x}{n-1}\right)\\
=\sum_{S\in[n]}(-1)^{|S|}\binom{\max(0,M-1-\sum_{x\in S}p_x)}{n-1}</script><p>直接做的复杂度为<script type="math/tex">2^n</script>，不能接受。考虑 meet-in-middle。</p><p>根据范德蒙德卷积</p><script type="math/tex;mode=display">\binom{a+b}{n}=\sum_{i=0}^n\binom{a}{i}\binom{b}{n-i}</script><p>那么我们把<script type="math/tex">U</script>拆成两个集合<script type="math/tex">A,B</script>，可以得到</p><script type="math/tex;mode=display">\binom{M-1-\sum_{x\in S}p_x}{n-1}=
\sum_{i=0}^{n-1}\binom{M-1-\sum_{x\in S\cap A}p_x}{n-1-i}
\binom{-\sum_{x\in S\cap B}p_x}{i}</script><p>因此，设<script type="math/tex">S\in2^A,T\in 2^B</script>，那么上式可以等价地表示为</p><script type="math/tex;mode=display">\binom{M-1-\sum_{x\in S\cup T}p_x}{n-1}=
\sum_{i=0}^{n-1}\binom{M-1-\sum_{x\in S}p_x}{n-1-i}
\binom{-\sum_{x\in T}p_x}{i}</script><p>那么原式即为</p><script type="math/tex;mode=display">\sum_{S\in 2^A,T\in 2^B}(-1)^{|S\cup T|}
\sum_{i=0}^{n-1}\binom{M-1-\sum_{x\in S}p_x}{n-1-i}
\binom{-\sum_{x\in T}p_x}{i}\\
=\sum_{S\in 2^A,T\in 2^B}
\sum_{i=0}^{n-1}(-1)^{|S|}\binom{M-1-\sum_{x\in S}p_x}{n-1-i}
(-1)^{|T|}\binom{-\sum_{x\in T}p_x}{i}</script><p>设出函数来简化问题</p><script type="math/tex;mode=display">\begin{aligned}
f(S,i)&=(-1)^{|S|}\binom{M-1-\sum_{x\in S}p_x}{n-1-i} & (S\in 2^A)\\
g(T,i)&=(-1)^{|T|}\binom{-\sum_{x\in T}p_x}{i}        & (T\in 2^B)
\end{aligned}</script><p>注意<script type="math/tex">f(\varnothing,n-1)=g(\varnothing,0)=1</script>。那么原式进一步简化为</p><script type="math/tex;mode=display">\sum_{S\in 2^A,T\in 2^B}\sum_{i=0}^{n-1}f(S,i)g(S,i)
=\sum_{i=0}^{n-1}\sum_{S\in 2^A}f(S,i)\sum_{T\in 2^B}g(S,i)</script><p>那么我们在求和的过程中，只需要保证<script type="math/tex">M-1-\sum_{x\in S}p_x-\sum_{x\in T}p_x\ge 0</script>即可。这个可以排序后双指针实现，再加上前缀和优化，就可以<script type="math/tex">O(2^{n/2}n)</script>合并答案。<script type="math/tex">f</script>，<script type="math/tex">g</script>可以各自递推求出：</p><script type="math/tex;mode=display">\begin{aligned}
f(S,i)&=f(S,i+1)\frac{M-1-\sum_{x\in S}p_x-(n-2-i)}{n-1-i}\\
g(T,i)&=g(T,i-1)\frac{-\sum_{x\in T}p_x-(i-1)}{i}
\end{aligned}</script><p>注意，使用下降幂计算组合数，上部是可以为负数的：</p><script type="math/tex;mode=display">\binom{n}{m}=\frac{n^{\underline{m}}}{m!}</script><p>注意，范德蒙德卷积是可以做负数的。</p><p>总复杂度<script type="math/tex">O(2^{n/2}n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/hdu/6355.cpp">代码</a></p></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2023年3月9日 第3次修订</li><li class="post-history-item">2021年2月11日 第2次修订</li><li class="post-history-item">2020年6月3日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/Randomized/Count-min-Sketch/">「随机算法专题」Count-min Sketch 入门</a></div><div class="prev-post"><a href="/Randomized/Distance/">「随机算法专题」距离与相似度的度量 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>