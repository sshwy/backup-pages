<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="keywords" content=""><meta name="description" content="Sshwy 的个人博客"><meta name="generator" content="Hexo 6.3.0"><title>生成函数回炉重造 - Sshwy&#39;s Notes</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/ssimple.css?20250423.css"><link rel="stylesheet" href="/iconfont/iconfont.css?20250423.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){window.renderKatex()})</script></head><body><header><div class="header" style="width:100%"><div class="header-inner" style="position:fixed;z-index:20;top:0;left:0"><div class="header-content" style="max-width:1200px;margin:auto"><div class="blog-title"><span class="iconfont icon-menu1" id="menu-button"></span> <a href="/" class="logo header-title">Sshwy&#39;s Notes</a><div class="mobile-search"><input type="text"> <span class="iconfont icon-search mobile-search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div><div class="navbar" id="menu-list"><ul class="menu"><li class="menu-item"><a href="/archives/" class="menu-item-link"><span class="menu-item-icon iconfont icon-work"></span> Archives</a></li><li class="menu-item"><a href="/directory/" class="menu-item-link"><span class="menu-item-icon iconfont icon-folder-close"></span> Directory</a></li><li class="menu-item"><a href="/about/" class="menu-item-link"><span class="menu-item-icon iconfont icon-user"></span> About</a></li><li class="menu-item"><a href="/static/beibishi2023" class="menu-item-link"><span class="menu-item-icon iconfont icon-favorite"></span> NOI 背笔试</a></li></ul></div><div class="search"><input type="text"> <span class="iconfont icon-search search-icon"></span> <span class="iconfont icon-baseline-close-px search-close-icon"></span></div></div></div><div class="search-shadow"></div><div class="search-box"><div class="search-container"><div class="search-container-inner"><div class="search-data-status"><span>Fetching search data...</span></div><div class="search-count"></div><div class="search-result"></div></div></div></div></div></header><main class="main"><article class="post"><div class="post-title"><h1 class="page-title">生成函数回炉重造</h1></div><div class="post-meta"><div class="post-info"><span class="post-info-item post-time" title="2021年3月30日星期二下午4点31分 (CST+08:00)"><span class="info-icon iconfont icon-time"></span>更新于 2021年3月30日 </span><span class="icon infosep"></span><span class="post-info-item post-wordcount"> <span class="info-icon iconfont icon-text"></span>约 7,832 字</span></div><div class="post-directory"><span class="iconfont icon-folder-close"></span> <a class="directory" href="/directory">Home</a> <a class="directory" href="/directory/"></a> <span class="icon smallarrow"></span> <a class="directory" href="/directory/Math/">数学 </a><span class="icon smallarrow"></span> <a class="directory" href="/directory/Math/Polynomial/">多项式与生成函数 </a><span class="icon smallarrow"></span> 当前文章</div><div class="post-tags"><span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Notes/">Notes</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Math/">Math</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/EGF/">EGF</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Generating-Function/">Generating-Function</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/OGF/">OGF</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Polynomial/">Polynomial</a></span> <span class="tag"><span class="meta-icon iconfont icon-tag"></span><a class="tag" href="/tags/Combinatorial/">Combinatorial</a></span></div><hr></div><div class="toc"><h2 class="toc-title"><span class="iconfont icon-explain" style="font-size:1em;padding-right:5px"></span>文章目录</h2><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#EGF-与-OGF"><span class="toc-number">1.</span> <span class="toc-text">EGF 与 OGF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PKUWC2018-猎人杀"><span class="toc-number">2.</span> <span class="toc-text">PKUWC2018 猎人杀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生成函数部分"><span class="toc-number">2.1.</span> <span class="toc-text">生成函数部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多项式部分"><span class="toc-number">2.2.</span> <span class="toc-text">多项式部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UNR3-百鸽笼"><span class="toc-number">3.</span> <span class="toc-text">UNR3 百鸽笼</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生成函数部分-1"><span class="toc-number">3.1.</span> <span class="toc-text">生成函数部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多项式部分-1"><span class="toc-number">3.2.</span> <span class="toc-text">多项式部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UR19-通用测评号"><span class="toc-number">4.</span> <span class="toc-text">UR19 通用测评号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生成函数部分-2"><span class="toc-number">4.1.</span> <span class="toc-text">生成函数部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多项式部分-2"><span class="toc-number">4.2.</span> <span class="toc-text">多项式部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EGF-转-OGF"><span class="toc-number">5.</span> <span class="toc-text">EGF 转 OGF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZJOI2019-开关"><span class="toc-number">6.</span> <span class="toc-text">ZJOI2019 开关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生成函数部分-3"><span class="toc-number">6.1.</span> <span class="toc-text">生成函数部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多项式部分-3"><span class="toc-number">6.2.</span> <span class="toc-text">多项式部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#喂鸽子"><span class="toc-number">7.</span> <span class="toc-text">喂鸽子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生成函数部分-4"><span class="toc-number">7.1.</span> <span class="toc-text">生成函数部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多项式部分-4"><span class="toc-number">7.2.</span> <span class="toc-text">多项式部分</span></a></li></ol></li></ol></div><hr></div><div class="post-content"><p>本文目前是笔记的形式，可能观点比较散。</p><p>初衷是把生成函数的部分复习一下。</p><p>首先要理解一件事：<strong>生成函数是理解问题的方式</strong>，而多项式则是计算的方法。因此即使经常有“生成函数与多项式”之类的博客标题，但不能把生成函数和多项式混为一谈。</p><p>事实上，在把问题转化为生成函数后，剩下的式子转化与代码实现都属于多项式的范畴。</p><p>强烈建议在做生成函数题的时候，推完式子时，先手算一下样例看对不对，对了再写代码。</p><p>另外，本文的所有例题均带有 <span class="label">生成函数</span> <span class="label">多项式</span> <span class="label">EGF</span> 标签。</p><h2><a id="EGF-与-OGF" href="#EGF-与-OGF" class="headerlink" title="EGF 与 OGF"></a>EGF 与 OGF</h2><p>OGF 的定义：<script type="math/tex">F(x)=\sum a_ix^i</script>，表示序列<script type="math/tex">a_i</script>的生成函数。</p><p>EGF 的定义：<script type="math/tex">\hat{F}(x)=\sum a_i\frac{x^i}{i!}</script>，表示序列<script type="math/tex">a_i</script>的指数生成函数。</p><p>再次强调，生成函数只是理解问题的方式。因此你可能发现，EGF 的实现和 OGF 的实现是差不多的——只不过多乘一个阶乘而已。你甚至可以认为，EGF 是<script type="math/tex">\frac{a_i}{i!}</script>的 OGF。这是理解方式的转变。然而实际上，生成函数也就只是<strong>一种理解问题的技巧</strong>。</p><p>OGF 和 EGF 的加法，都是对应项系数相加。</p><p>OGF 的乘法：<script type="math/tex">a_ix^i\times b_jx^j=a_ib_jx^{i+j}</script>。表达的是卷积的运算。</p><p>EGF 的乘法：<script type="math/tex">a_i\frac{x_i}{i!}\times b_j\frac{x^j}{j!}=a_ib_j\binom{i+j}{i}\frac{x^{i+j}}{(i+j)!}</script>。表达的是带组合系数的卷积运算。</p><p>OGF 的多个函数的乘法，表达的是类似多个背包合并的运算。而 EGF 的多个函数的乘法，表达的是类似多个序列合并（同一个序列里的相对顺序不计贡献）的运算（多重组合数）。两者的区别是，背包中的物品是不考虑顺序的，而序列则是要考虑顺序的。</p><p>因此在理解问题的时候，可以先转化为序列问题或者背包问题，再用生成函数来理解。</p><h2><a id="PKUWC2018-猎人杀" href="#PKUWC2018-猎人杀" class="headerlink" title="PKUWC2018 猎人杀"></a><a target="_blank" rel="noopener" href="https://loj.ac/problem/2541">PKUWC2018 猎人杀</a></h2><blockquote><p>有<script type="math/tex">n</script>猎人。每个猎人只有一个固定的技能：死亡后必须开一枪，且被射中的人也会死亡。</p><p>假设当前活着的人有<script type="math/tex">[i_1,\cdots,i_m]</script>，那么有<script type="math/tex">\frac{w_{i_k}}{\sum_{j=1}^m w_{i_j}}</script>的概率向猎人<script type="math/tex">i_k</script>开枪。</p><p>第一枪由你打，目标选择方法和猎人一样。由于开枪导致的连锁反应，所有猎人最终都会死亡。求<script type="math/tex">1</script>号猎人最后一个死的概率。</p><p><script type="math/tex">w_i&gt;0,1\le \sum w_i\le 10^5</script>。</p></blockquote><p><span class="label">分治</span> <span class="label">NTT</span></p><h3><a id="生成函数部分" href="#生成函数部分" class="headerlink" title="生成函数部分"></a>生成函数部分</h3><p>按照原题意，每杀一个人，概率空间会发生变化。这样就没法做了。</p><p>如果我们允许向死人开枪呢？</p><p>向死人开枪，相当于浪费一回合。但这无关紧要。因为我们要求的答案和回合数无关。我们只关心一号猎人最后一个死的概率。</p><p>这样的话概率空间就一样了。那么我们的问题就可以转化为一个序列问题：</p><blockquote><p>每次有<script type="math/tex">p_i=\frac{w_i}{\sum_{j=1}^n w_j}</script>的概率在序列的末位加入<script type="math/tex">i</script>。求：</p><ul><li>最后一个数是<script type="math/tex">1</script>，且<script type="math/tex">1</script>只出现了这一次，</li><li><script type="math/tex">2,\cdots,n</script>都在序列中出现过</li></ul><p>的序列出现的概率。</p></blockquote><p>（这个序列的长度是不固定的，可能无限长）</p><p>如果我们按照一个一个在序列末尾加数的方式理解问题，那么要求<script type="math/tex">2,\cdots,n</script>都在序列中出现过就比较难处理。因此我们考虑另一个理解方式——<script type="math/tex">n</script>个序列的合并。</p><blockquote><p>假设你有<script type="math/tex">n</script>个序列，第<script type="math/tex">i</script>个序列是<script type="math/tex">c_i</script>个<script type="math/tex">i</script>（<script type="math/tex">c_i&gt;0</script>）。特殊地，<script type="math/tex">c_1=1</script>。你要把他们合并成一个序列，使得<script type="math/tex">1</script>出现在最后一个位置，求方案数？</p></blockquote><p>容易发现这个问题和上面的问题是等价的。我们知道概率乘方案数等于这些方案的概率。因此我们求出每个序列的出现概率——即，选出<script type="math/tex">c_i</script>个<script type="math/tex">i</script>的概率，那么乘起来再乘上方案数，就是这些方案的概率。而方案数就是一个简单的多重组合数。</p><p>这是从序列合并的角度理解，那么接下来我们将其转化为生成函数的理解。</p><p>对于<script type="math/tex">2\le j\le n</script>，由于我们可以选择任意个数的<script type="math/tex">i</script>，因此他们的生成函数应该是无穷级数的 EGF。不妨设</p><script type="math/tex;mode=display">\hat{f_j}(x)=\sum_{i\ge 1}\frac{(p_jx)^i}{i!}</script><p>含义是，选择<script type="math/tex">i</script>个<script type="math/tex">j</script>的概率是<script type="math/tex">p_j^i</script>，由于我们至少选一个，因此<script type="math/tex">i\ge 1</script>。</p><p>对于<script type="math/tex">i=1</script>，我们只要求<script type="math/tex">1</script>出现一次且在末尾，因此它不会影响方案数，只需要乘一次<script type="math/tex">p_1</script>的概率即可。因此我们可以不用求它的生成函数。也可以理解为，<script type="math/tex">i=1</script>的生成函数是一个常数<script type="math/tex">p_1</script>。</p><p>那么序列的生成函数（EGF）就是</p><script type="math/tex;mode=display">\hat{F}(x)=p_1\prod_{j=2}^n\hat{f_j}(x)</script><p>其中<script type="math/tex">[x^i]\hat{F}(x)</script>表示长度为<script type="math/tex">i</script>的序列出现的概率。那么我们要求的就是<script type="math/tex">\hat{F}(x)</script>的<strong>EGF 系数</strong>的和。</p><p>注意，对于 EGF<script type="math/tex">\hat{F}(x)=\sum a_i\frac{x^i}{i!}=\sum b_ix^i</script>，我们说的<strong>EGF 系数</strong>是指<script type="math/tex">a_i</script>，即<script type="math/tex">b_i\cdot i!</script>，系数才是指<script type="math/tex">b_i</script>。</p><h3><a id="多项式部分" href="#多项式部分" class="headerlink" title="多项式部分"></a>多项式部分</h3><p>接下来就是多项式转化的部分了。</p><p>首先<script type="math/tex">\hat{f_j}=e^{p_jx}-1</script>，因此</p><script type="math/tex;mode=display">\hat{F}(x)=p_1 \prod_{j=2}^n(e^{p_jx}-1)</script><p>首先我们知道，<script type="math/tex">e^{px}</script>的 EGF 系数和就是等比数列求和，可以化为封闭形式<script type="math/tex">\frac{1}{1-p}</script>。可惜<script type="math/tex">e^{px}</script>与<script type="math/tex">e^{qx}</script>的乘积的 EGF 系数和并不是<script type="math/tex">\frac{1}{1-p}\cdot \frac{1}{1-q}</script>，因此我们只能想办法求出对与每个<script type="math/tex">t</script>，<script type="math/tex">e^{tx}</script>的系数值（出现次数）。因此接下来的问题就是一个类似背包的计算。然而这不能直接容斥<script type="math/tex">\frac{1}{1-\sum p}</script>。注意到<script type="math/tex">\sum p_i\le 10^5</script>，因此不妨设<script type="math/tex">g_i</script>表示<script type="math/tex">\frac{1}{1-i}</script>出现的次数（带容斥系数），容易发现<script type="math/tex">g_i</script>的 OGF 是</p><script type="math/tex;mode=display">\prod_{j=2}^n(x^{p_j}-1)</script><p>那么直接使用分治 + 多项式乘法计算即可。</p><p>可以先把<script type="math/tex">p_j</script>当作<script type="math/tex">w_j</script>来算，最后再全部除以<script type="math/tex">\prod w_i</script>即可。</p><p>时间复杂度<script type="math/tex">O(n\log_2^2n)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/loj/2541.cpp">代码</a></p><h2><a id="UNR3-百鸽笼" href="#UNR3-百鸽笼" class="headerlink" title="UNR3 百鸽笼"></a><a target="_blank" rel="noopener" href="http://uoj.ac/problem/390">UNR3 百鸽笼</a></h2><blockquote><p>有<script type="math/tex">n</script>个数<script type="math/tex">a_i</script>。设<script type="math/tex">\sum_{i=1}^na_i=m</script>。</p><p>接下来进行<script type="math/tex">m-1</script>次操作：每次在<script type="math/tex">&gt;0</script>的数中等概率随机选择一个数<script type="math/tex">a_x</script>，然后把<script type="math/tex">a_x</script>减 1。</p><p>最后一定会剩下一个<script type="math/tex">1</script>。现在问对于<script type="math/tex">1\le i\le n</script>，在操作后<script type="math/tex">a_i=1</script>的概率。</p><p><script type="math/tex">1\le a_i\le 30,n\le 30</script>。</p></blockquote><p><span class="label">插板法</span> <span class="label">无穷级数转封闭形式</span></p><h3><a id="生成函数部分-1" href="#生成函数部分-1" class="headerlink" title="生成函数部分"></a>生成函数部分</h3><p>不妨考虑<script type="math/tex">i=1</script>时<script type="math/tex">a_i=1</script>的概率。</p><p>不妨加一次操作。因为选择最后一个空的笼子的概率是<script type="math/tex">1</script>。</p><p>仍然考虑使用生成函数的方式理解。首先，根据类似的思路，我们可以把操作变成，每次在所有数中等概率选择。这样的话序列的长度就可能是无限长的，它需要满足的条件是：</p><ul><li>对于<script type="math/tex">2\le i\le n</script>，<script type="math/tex">i</script>的出现次数<script type="math/tex">\ge a_i</script>。</li><li><script type="math/tex">1</script>在序列中出现了恰好<script type="math/tex">a_1</script>次，且最后一个数是<script type="math/tex">1</script>。</li></ul><p>这里可能会有一个小疑问：为什么是出现<script type="math/tex">a_1</script>次而不是<script type="math/tex">a_1-1</script>次？其实如果是出现<script type="math/tex">a_1-1</script>次的话，那么就没有最后一个数是<script type="math/tex">1</script>的限制。我们相当于删掉了第<script type="math/tex">1</script>列里的一个格子，那么这和原问题就是不等价的。</p><p>仍然是考虑每个数的生成函数。对于<script type="math/tex">2\le j\le n</script>：</p><script type="math/tex;mode=display">\hat{f_j}(x)=\sum_{i\ge a_j}\frac{(\frac{1}{n}x)^i}{i!}</script><p>特殊地，对于<script type="math/tex">i=1</script>，我们考虑除了最后一个<script type="math/tex">1</script>之外的<script type="math/tex">1</script>：</p><script type="math/tex;mode=display">\hat{f_1}(x)= \frac{(\frac{1}{n}x)^{a_1-1}}{(a_1-1)!}</script><p>那么整个序列的生成函数就是</p><script type="math/tex;mode=display">\hat{F}(x)=\frac{1}{n}\prod_{i=1}^n\hat{f_i}(x)</script><p>我们要求的仍是系数和。</p><h3><a id="多项式部分-1" href="#多项式部分-1" class="headerlink" title="多项式部分"></a>多项式部分</h3><p>首先，对于<script type="math/tex">2\le j\le n</script>：</p><script type="math/tex;mode=display">\hat{f_j}(x)=\sum_{i\ge a_j}\frac{(\frac{1}{n}x)^i}{i!}=e^{\frac{1}{n}x}-\sum_{i=0}^{a_j-1}\frac{(\frac{1}{n}x)^i}{i!}</script><p>为了方便表示，设<script type="math/tex">\hat{S}(j)=\sum_{i=0}^j\frac{(\frac{1}{n}x)^i}{i!}</script>，那么就可以得到<script type="math/tex">\hat{f_j}(x)=e^{\frac{1}{n}x}-\hat{S}(a_j-1)</script>。因此整个序列的生成函数可以化为</p><script type="math/tex;mode=display">\hat{F}(x)=\frac{1}{n} \frac{(\frac{1}{n}x)^{a_1-1}}{(a_1-1)!}
\prod_{j=2}^n(e^{\frac{1}{n}x}-\hat{S}(a_j-1))</script><p>如果我们把除了<script type="math/tex">e</script>之外的部分展开，那么可以得到形如<script type="math/tex">\sum_{m,t} e^{\frac{m}{n}x}c_{m,t}\frac{x^t}{t!}</script>的一个多项式（二维数组）。要计算它的 EGF 系数和，我们可以对每一项<script type="math/tex">e^{\frac{m}{n}x}c_{m,t}\frac{x^t}{t!}</script>分别计算 EGF 系数和再相加。那么对这个单项式展开<script type="math/tex">e</script>会得到</p><script type="math/tex;mode=display">c_{m,t}\sum_{i\ge 0}\left(\frac{m}{n}\right)^i\binom{i+t}{i}\frac{x^{i+t}}{(i+t)!}</script><p>它的 EGF 系数和就是</p><script type="math/tex;mode=display">c_{m,t}\sum_{i\ge 0}\left(\frac{m}{n}\right)^i\binom{i+t}{i}</script><p>这里要补充一个知识。我们知道等比数列的封闭形式是<script type="math/tex">\sum_{i\ge0} x^i=\frac{1}{1-x}</script>。那么考虑<script type="math/tex">\frac{1}{(1-x)^t}</script>。它的展开形式是<script type="math/tex">(\sum_{i\ge 0}x^i)^t</script>，第<script type="math/tex">[x^i]</script>项的系数实际上是把<script type="math/tex">i</script>分成<script type="math/tex">t</script>个非负变量的方案数，也就是插板法<script type="math/tex">\binom{i+t-1}{i}</script>。因此<script type="math/tex">\frac{1}{(1-x)^t}=\sum_{i\ge 0}x^i\binom{i+t-1}{i}</script>。</p><p>应用这个补充的知识，我们可以得到上式的封闭形式为<script type="math/tex">c_{m,t}\frac{1}{(1-\frac{m}{n})^{t+1}}=c_{m,t}\left(\frac{n}{n-m}\right)^{t+1}</script>。注意，UOJ 的官方题解中得到的系数是带了一个<script type="math/tex">t!</script>的，因为它算的是 OGF 系数，不是 EGF 系数。还是那句话，两者只是理解方式的不同，代码实现是相似的。</p><p>得出封闭形式那么就容易计算了。</p><p>最后，考虑到我们要计算每个<script type="math/tex">i</script>的概率，那么我们可以先把所有的<script type="math/tex">(e^{\frac{1}{n}x}-\hat{S}(a_j-1))</script>乘起来。然后每次除掉<script type="math/tex">i</script>对应的 EGF，再求答案即可。</p><p>时间复杂度<script type="math/tex">O(n^6)</script>（<script type="math/tex">a_i</script>和<script type="math/tex">n</script>同阶）。</p><p>事实上，生成函数做法和容斥的做法，代码几乎一样。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/uoj/390.cpp">代码</a></p><p>附 UNR#3 的题解链接：</p><p><a target="_blank" rel="noopener" href="http://wuhongxun.blog.uoj.ac/blog/3670">UNR #3 day1</a></p><p><a target="_blank" rel="noopener" href="http://wuhongxun.blog.uoj.ac/blog/3679">UNR #3 day2</a></p><h2><a id="UR19-通用测评号" href="#UR19-通用测评号" class="headerlink" title="UR19 通用测评号"></a><a target="_blank" rel="noopener" href="http://uoj.ac/problem/514">UR19 通用测评号</a></h2><blockquote><p>有<script type="math/tex">n</script>个变量<script type="math/tex">x_i</script>，初值为<script type="math/tex">0</script>。给出两个数<script type="math/tex">a,b</script>（<script type="math/tex">a&gt;b</script>）。每次会在<script type="math/tex">&lt;a</script>的变量中等概率随机选一个加<script type="math/tex">1</script>，直到所有变量都<script type="math/tex">\ge b</script>。问操作完后<script type="math/tex">=a</script>的变量的个数的期望。</p><p><script type="math/tex">1\le n\le 250,1\le b&lt;a\le 250</script>。</p></blockquote><p><span class="label">递推</span> <span class="label">微分方程</span></p><h3><a id="生成函数部分-2" href="#生成函数部分-2" class="headerlink" title="生成函数部分"></a>生成函数部分</h3><p><script type="math/tex">n</script>个变量之间是等价的。因此我们可以计算操作完之后<script type="math/tex">x_1=a</script>的概率，然后乘<script type="math/tex">n</script>就是答案。</p><p>仍然考虑把<script type="math/tex">&lt;a</script>的条件去掉。每次在所有变量中选一个加<script type="math/tex">1</script>，直到所有变量<script type="math/tex">\ge b</script>。那么我们要求的就是<script type="math/tex">x_1\ge a</script>的概率，不过我们还要求<script type="math/tex">x_2,\cdots,x_n</script>中至少出现一个<script type="math/tex">b</script>（因为你最后一次操作一定是把某个变量从<script type="math/tex">b-1</script>变成<script type="math/tex">b</script>），而如果有多个<script type="math/tex">b</script>的话，你最后一次操作在什么位置，也要计入方案中。这就比较难计数。</p><p>不妨考虑另一种理解方式。仍然要把<script type="math/tex">&lt;a</script>的条件去掉。但我们可以理解为：让<script type="math/tex">x_1=a</script>的这次操作会产生<script type="math/tex">1</script>的贡献。其他时候都没有贡献。问贡献的期望。</p><p>在什么时候会产生贡献？首先你要选出<script type="math/tex">a</script>个<script type="math/tex">x_1</script>，且当前选的这一次（操作序列的最后一个变量）是<script type="math/tex">x_1</script>。其次<script type="math/tex">x_2,\cdots,x_n</script>中至少有一个变量<script type="math/tex">&lt;b</script>。这样理解的好处是，我们不用考虑最后一次操作的方案数（因为操作仍没有结束），只用考虑生成这类序列的方案数。那么就可以使用生成函数了。</p><p>那么<script type="math/tex">x_1</script>的 EGF 是<script type="math/tex">\frac{1}{n}\frac{(\frac{1}{n}x)^{a-1}}{(a-1)!}</script>。对于<script type="math/tex">x_j</script>（<script type="math/tex">2\le j\le n</script>）的 EGF，我们可以把至少一个变量<script type="math/tex">&lt;b</script>容斥为 1 减去所有变量<script type="math/tex">\ge b</script>的概率。那么<script type="math/tex">x_j\ge b</script>的概率的 EGF 是<script type="math/tex">\hat{f}(x)=\sum_{i\ge b}\frac{(\frac{1}{n}x)^i}{i!}</script>。因此我们得到了整个序列的生成函数：</p><script type="math/tex;mode=display">\hat{F}(x)=\frac{1}{n}\frac{(\frac{1}{n}x)^{a-1}}{(a-1)!}\left(
\left(e^{\frac{1}{n}x}\right)^{n-1}-\hat{f}(x)^{n-1}\right)</script><h3><a id="多项式部分-2" href="#多项式部分-2" class="headerlink" title="多项式部分"></a>多项式部分</h3><p>考虑转化：</p><script type="math/tex;mode=display">\hat{F}(x)=\frac{1}{n}\frac{(\frac{1}{n}x)^{a-1}}{(a-1)!}\left(
e^{\frac{n-1}{n}x}-
\left(e^{\frac{1}{n}x}-\sum_{i=0}^{b-1}\frac{(\frac{1}{n}x)^i}{i!}\right)^{n-1}
\right)</script><p>我们要计算的仍是<script type="math/tex">\hat{F}(x)</script>的 EGF 系数和。仍然考虑求出类似<script type="math/tex">\sum e^{\frac{m}{n}x}c_{m,t}\frac{x^t}{t!}</script>的形式。</p><p>为了方便表示，设<script type="math/tex">v=\frac{1}{n}x,u=e^{v}</script>。我们先求出关于<script type="math/tex">v</script>的生成函数，就可以快速转化为关于<script type="math/tex">x</script>的生成函数。</p><p>那么换元之后，我们得到</p><script type="math/tex;mode=display">\hat{F}(v)=\frac{1}{n}\frac{v^{a-1}}{(a-1)!}\left(
u^{n-1}-\left(u-\sum_{i=0}^{b-1}\frac{v^i}{i!}\right)^{n-1}\right)</script><p>不妨设<script type="math/tex">\hat{S}=\sum_{i=0}^{b-1}\frac{v^i}{i!}</script>，然后把后面的式子二项式展开：</p><script type="math/tex;mode=display">\begin{aligned}
\hat{F}(v)

&=\frac{1}{n}\frac{v^{a-1}}{(a-1)!}\left(u^{n-1}-
\sum_{j=0}^{n-1}\binom{n-1}{j}(-1)^j\hat{S}^ju^{n-1-j}
\right)\\

&=-\frac{1}{n}\frac{v^{a-1}}{(a-1)!}
\sum_{j=1}^{n-1}\binom{n-1}{j}(-1)^j\hat{S}^ju^{n-1-j}
\end{aligned}</script><p>到这里我们已经可以直接计算了。我们可以<script type="math/tex">O(n^2b\log_2(nb))</script>计算<script type="math/tex">\hat{S}^1,\cdots,\hat{S}^{n-1}</script>。然后把他们加起来就能得到<script type="math/tex">c_{m,t}</script>了。但我们仍然可以继续优化。</p><p>首先，可以发现<script type="math/tex">\hat{S}'=\hat{S}-\frac{v^{b-1}}{(b-1)!}</script>。因此</p><script type="math/tex;mode=display">\begin{aligned}
(\hat{S}^j)'
&=j\hat{S}'\hat{S}^{j-1} \\
&=j\left( \hat{S}-\frac{v^{b-1}}{(b-1)!}\right)\hat{S}^{j-1} \\
&=j\left(\hat{S}^j-\frac{v^{b-1}}{(b-1)!}\hat{S}^{j-1}\right) \\
\end{aligned}</script><p>不妨设<script type="math/tex">\hat{S}^j=\sum p_i\frac{v^i}{i!}</script>，<script type="math/tex">\frac{v^{b-1}}{(b-1)!}\hat{S}^{j-1}=\sum q_i\frac{v^i}{i!}</script>。那么上式就可以表示为</p><script type="math/tex;mode=display">p_{i+1}\frac{v^{i}}{i!}=j\left(p_i\frac{v^i}{i!}-q_{i}\frac{v^i}{i!}\right)</script><p>即<script type="math/tex">p_{i+1}=j(p_i-q_i)</script>。</p><p>转 OGF 系数就是<script type="math/tex">p'_{i+1}(i+1)!=j(p'_ii!-q'_ii!)</script>，即<script type="math/tex">p'_{i+1}=\frac{j(p'_i-q'_i)}{i+1}</script>。</p><p>这样就可以递推求<script type="math/tex">\hat{S}^j</script>了，时间复杂度<script type="math/tex">O(n^2b)</script>。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/uoj/514.cpp">代码</a></p><h2><a id="EGF-转-OGF" href="#EGF-转-OGF" class="headerlink" title="EGF 转 OGF"></a>EGF 转 OGF</h2><p>考虑<script type="math/tex">\hat{F}(x)=\sum_{i\ge 0}a_i\frac{x^i}{i!}</script>，我们要将其转为<script type="math/tex">F(x)=\sum_{i\ge 0}a_i</script>。</p><p>对于长度有限的生成函数，我们可以直接乘阶乘。</p><p>对于一些无穷级数，则需要做代数变换。例如<script type="math/tex">\hat{F}(x)=e^{ax}</script>。它的展开形式为<script type="math/tex">\hat{F}(x)=\sum_{i\ge 0}\frac{(ax)^i}{i!}</script>。我们要将它转为<script type="math/tex">F(x)=\sum_{i\ge 0}(ax)^i=\frac{1}{1-ax}</script>，因此我们说<script type="math/tex">e^{ax}</script>的<strong>EGF 转 OGF</strong>为<script type="math/tex">\frac{1}{1-ax}</script>。</p><p>接下来的部分题目会用到这一技巧。</p><p>还是那句话。这只是一种理解方式的转变。上文的 EGF 系数和，也可以使用 EGF 转 OGF 理解为，<script type="math/tex">\hat{F}</script>转为<script type="math/tex">F</script>后求<script type="math/tex">F(1)</script>。</p><h2><a id="ZJOI2019-开关" href="#ZJOI2019-开关" class="headerlink" title="ZJOI2019 开关"></a><a target="_blank" rel="noopener" href="https://loj.ac/problem/3045">ZJOI2019 开关</a></h2><blockquote><p>你有<script type="math/tex">n</script>个开关，初始时全为 0。每次你会以<script type="math/tex">\frac{p_i}{\sum_{j=1}^n p_j}</script>的概率按动第<script type="math/tex">i</script>个开关。给出一个状态<script type="math/tex">s</script>（01 串），问期望按多少次才能<strong>第一次</strong>按到这个状态。</p><p><script type="math/tex">n\le 100,\sum p_i\le 5\times 10^4</script>。</p></blockquote><p><span class="label">EGF 转 OGF</span> <span class="label">导数</span> <span class="label">概率生成函数</span> <span class="label">期望</span></p><h3><a id="生成函数部分-3" href="#生成函数部分-3" class="headerlink" title="生成函数部分"></a>生成函数部分</h3><p>为了避免歧义，我们用<script type="math/tex">a_i</script>来表示题目中的<script type="math/tex">\frac{p_i}{\sum_{j=1}^n p_j}</script>。相信在做过之前的若干题目后，大家对 EGF 都有了一定的理解。因此接下来的描述就不会像之前那么详细了。</p><p>我们要求的是第一次按出<script type="math/tex">s</script>的期望次数，这里有一个经典的套路。我们求出按<script type="math/tex">i</script>次后第一次到达<script type="math/tex">s</script>的概率，记为<script type="math/tex">h_i</script>。那么它的 OGF 就是<script type="math/tex">H(x)=\sum_{i\ge 0}h_i x^i</script>。则期望就是<script type="math/tex">\sum_{i\ge 0}h_i\cdot i=H'(1)</script>。</p><p>那么如何求出<script type="math/tex">H</script>？“第一次到达<script type="math/tex">s</script>”这个条件比较烦。考虑构造生成函数方程：到达<script type="math/tex">s</script>的概率 = 第一次到达<script type="math/tex">s</script>后，经过若干次操作（可能是 0 次）又到达<script type="math/tex">s</script>的概率。</p><p>到达<script type="math/tex">s</script>的概率可以用 EGF 表示。要到达<script type="math/tex">s</script>，则某些开关要按奇数次，有些要按偶数次。那么这两种的 EGF 分别是<script type="math/tex">\frac{e^x-e^{-x}}{2}</script>和<script type="math/tex">\frac{e^x+e^{-x}}{2}</script>。因此容易得到</p><script type="math/tex;mode=display">\hat{F}(x)=\prod_{i=1}^n \frac{e^{a_ix}+(-1)^{s_i}e^{-a_ix}}{2}</script><p>第一次到达<script type="math/tex">s</script>后又到达<script type="math/tex">s</script>，相当于我先到达<script type="math/tex">s</script>。然后经过若干次操作后回到<script type="math/tex">s</script>。因此我们再考虑求出一个 EGF 表示，回到原状态的概率（即，所有开关都按偶数次）：</p><script type="math/tex;mode=display">\hat{G}(x)=\prod_{i=1}^n\frac{e^{a_ix}+e^{-a_ix}}{2}</script><p>那么我们 EGF 转 OGF，设<script type="math/tex">\hat{F}</script>和<script type="math/tex">\hat{G}</script>的 OGF 分别为<script type="math/tex">F,G</script>。那么我们可以得到<script type="math/tex">HG=F</script>。即<script type="math/tex">H=\frac{F}{G}</script>。</p><h3><a id="多项式部分-3" href="#多项式部分-3" class="headerlink" title="多项式部分"></a>多项式部分</h3><p>根据简单的函数求导法则可以得知<script type="math/tex">H'=\frac{F'G-FG'}{G^2}</script>。那么<script type="math/tex">H'(1)=\frac{F'(1)G(1)-F(1)G'(1)}{G^2(1)}</script>。于是我们想办法计算<script type="math/tex">F,F',G,G'</script>的系数和即可。</p><p>我们仍从 EGF 入手。以<script type="math/tex">F,F'</script>为例。</p><p>首先，<script type="math/tex">\hat{F}(x)</script>可以表示为<script type="math/tex">\sum_{j}f_je^{\frac{j}{m}x}</script>的形式（注意，这里是没有<script type="math/tex">\frac{x^i}{i!}</script>的），其中<script type="math/tex">m=\sum_{i=1}^n p_i</script>。那么使用 EGF 转 OGF 就可以得到</p><script type="math/tex;mode=display">F(x)=\sum_j f_j \cdot \frac{m}{m-jx}</script><p>那么它的系数和就是<script type="math/tex">F(1)</script>。不过有一个小问题，如果<script type="math/tex">j=m</script>，那么<script type="math/tex">m -mx</script>做分母的项当<script type="math/tex">x=1</script>时就没有意义了。</p><p>这也好办。我们有两种思路：</p><ol><li>在<script type="math/tex">H=\frac{F}{G}</script>的分子分母同乘<script type="math/tex">(1-x)</script>；</li><li>在<script type="math/tex">H'=\frac{F'G-FG'}{G^2}</script>的分子分母同乘<script type="math/tex">(1-x)^2</script>（把<script type="math/tex">F,F',G,G'</script>都乘一个<script type="math/tex">(1-x)</script>）。</li></ol><p>第二种思路不大可行。因为</p><script type="math/tex;mode=display">F'(x) =\sum_j f_j \cdot
\frac{m^2}{\left(m-jx\right)^2}
\cdot \frac{j}{m}</script><p>只乘一个<script type="math/tex">(1-x)</script>不足以解决问题。因此我们考虑第一种思路。</p><p>设<script type="math/tex">\dot F(x)=F(x)(1-x)</script>，<script type="math/tex">\dot G(x)=G(x)(1-x)</script>。那么首先<script type="math/tex">\dot F(x)=F(x)=\sum_j f_j \cdot \frac{m(1-x)}{m-jx}</script>，且<script type="math/tex">\dot F(1)=f_m</script>。然后使用简单的求导法则得到</p><script type="math/tex;mode=display">\dot F'(x)=\sum_j f_j \frac{m(j-m)}{(m-jx)^2}</script><p>那么<script type="math/tex">\dot F'(1)=\sum_{j\ne m}f_j\frac{m}{j-m}</script>。</p><p><script type="math/tex">\dot G</script>和<script type="math/tex">\dot G'</script>同理。</p><p>综上所述，我们只需要求出<script type="math/tex">\hat{F}</script>的<script type="math/tex">\sum_{j}f_je^{\frac{j}{m}x}</script>形式即可，这个可以<script type="math/tex">O(nm)</script>背包计算。<script type="math/tex">\hat{G}</script>同理。时间复杂度<script type="math/tex">O(nm)</script>。当然可以分治 +NTT 优化。</p><p>事实上，在实现的时候，连最开头的<script type="math/tex">\frac{1}{2}</script>那个部分都可以不用除了（分子分母同乘<script type="math/tex">2^n</script>）。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/loj/3045.cpp">代码</a></p><h2><a id="喂鸽子" href="#喂鸽子" class="headerlink" title="喂鸽子"></a><a target="_blank" rel="noopener" href="http://uoj.ac/problem/449">喂鸽子</a></h2><blockquote><p>有<script type="math/tex">n</script>个变量<script type="math/tex">x_i</script>，初值为<script type="math/tex">0</script>。每次等概率随机选择一个变量加 1，直到所有变量都<script type="math/tex">\ge k</script>。问期望的操作次数。</p><p><script type="math/tex">n\le 50,k\le 1000</script>。</p></blockquote><p><span class="label">EGF 转 OGF</span></p><p>由于这题和通用评测号相似，因此也不会详细讲述。</p><h3><a id="生成函数部分-4" href="#生成函数部分-4" class="headerlink" title="生成函数部分"></a>生成函数部分</h3><p>不妨钦定<script type="math/tex">1</script>是最后一个变成<script type="math/tex">k</script>的，最后把答案乘<script type="math/tex">n</script>即可。那么可以得到关于操作次数（减 1）的概率的 EGF：</p><script type="math/tex;mode=display">\hat{F}(x)=\frac{1}{n}\frac{(\frac{1}{n}x)^{k-1}}{(k-1)!}\prod_{j=2}^n\left(\sum_{i\ge k}\frac{(\frac{1}{n}x)^i}{i!} \right)</script><p>设<script type="math/tex">F</script>是<script type="math/tex">\hat{F}</script>EGF 转 OGF 后的生成函数。</p><p>那么关于操作次数的概率的 OGF 是<script type="math/tex">\dot F=F(x)\cdot x</script>。因此我们要求的就是<script type="math/tex">\dot F'(1)</script>。</p><h3><a id="多项式部分-4" href="#多项式部分-4" class="headerlink" title="多项式部分"></a>多项式部分</h3><p>众所周知<script type="math/tex">\dot F'(x)=F'(x)\cdot x+F(x)</script>。因此<script type="math/tex">\dot F'(1)=F'(1)+F(1)</script>。</p><p>接下来考虑变换 EGF。首先</p><script type="math/tex;mode=display">\hat{F}(x)=\frac{1}{n}\frac{(\frac{1}{n}x)^{k-1}}{(k-1)!}
\left(e^{\frac{1}{n}x}-\sum_{i=0}^{k-1}\frac{(\frac{1}{n}x)^i}{i!} \right)^{n-1}</script><p>不妨设<script type="math/tex">\hat{S}=\sum_{i=0}^{k-1}\frac{(\frac{1}{n}x)^i}{i!}</script>，那么</p><script type="math/tex;mode=display">\begin{aligned}
\hat{F}(x)

&=\frac{1}{n}\frac{(\frac{1}{n}x)^{k-1}}{(k-1)!}
\left(e^{\frac{1}{n}x}-\hat{S} \right)^{n-1}\\

&=\frac{1}{n}\frac{(\frac{1}{n}x)^{k-1}}{(k-1)!}
\sum_{j=0}^{n-1}\binom{n-1}{j}(-1)^j\hat{S}^je^{\frac{n-1-j}{n}x}
\end{aligned}</script><p>可以利用相同的方式<script type="math/tex">O(n^2k)</script>递推求出<script type="math/tex">\hat{S}^j</script>。然后我们可以把<script type="math/tex">\hat{F}(x)</script>表示为<script type="math/tex">\sum e^{\frac{m}{n}x}c_{m,t}\frac{x^t}{t!}</script>的形式（<script type="math/tex">0\le m&lt;n</script>）。我们要求<script type="math/tex">F(x)</script>，那么我们把每一项<script type="math/tex">e^{\frac{m}{n}x}c_{m,t}\frac{x^t}{t!}</script>分别 EGF 转 OGF，然后相加即可。</p><p>把<script type="math/tex">e^{\frac{m}{n}x}c_{m,t}\frac{x^t}{t!}</script>展开得到<script type="math/tex">c_{m,t}\sum_{i\ge 0}\binom{i+t}{i}(\frac{m}{n})^i\frac{x^{i+t}}{(i+t)!}</script>。</p><p>EGF 转 OGF 得到<script type="math/tex">c_{m,t}\sum_{i\ge 0}\binom{i+t}{i}(\frac{m}{n})^ix^{i+t}</script>，转化为封闭形式是<script type="math/tex">c_{m,t}x^t(\frac{n}{n-mx})^{t+1}</script>。</p><p>因此<script type="math/tex">F(x)=\sum c_{m,t}x^t(\frac{n}{n-mx})^{t+1}</script>。则通过简单的导数法则再加一些代数变换得知</p><script type="math/tex;mode=display">F'(x)=\sum c_{m,t}n^{t+1}
\frac{ntx^{t-1}+mx^t}{(n-mx)^{t+2}}</script><p>由于<script type="math/tex">m&lt;n</script>，所以不会出现分母为<script type="math/tex">0</script>的情况。直接计算<script type="math/tex">F'(1)</script>和<script type="math/tex">F(1)</script>即可。</p><p><a target="_blank" rel="noopener" href="https://gitee.com/sshwy/code/raw/master/uoj/449.cpp">代码</a></p></div><hr><h3><span class="iconfont icon-history" style="padding-right:5px;font-size:1em"></span>修订记录</h3><div class="post-history-list"><ol reversed><li class="post-history-item">2021年3月30日 第4次修订</li><li class="post-history-item">2021年2月11日 第3次修订</li><li class="post-history-item">2021年2月4日 第2次修订</li><li class="post-history-item">2020年4月27日 创建文章</li></ol></div><div class="post-footer"><hr><div class="next-post"><span class="iconfont icon-arrow-left-circle"></span> <a href="/Data-Structure/Long-Path-Decomposition/">长链剖分学习笔记</a></div><div class="prev-post"><a href="/LCSE-rev-prog/">记一次 L 社 GalGame 汉化经历 </a><span class="iconfont icon-arrow-right-circle"></span></div></div></article></main></body><div class="side-button"><div id="comment-button" class="button" title="Valine Comment"><span class="iconfont icon-comment"></span></div><div id="darkmode-button" class="button" title="Switch between day and night"><span class="iconfont icon-moonbyueliang"></span></div><div id="top" class="button" title="Back to top"><span class="iconfont icon-arrowup"></span></div></div><footer id="footer" style="margin:3em 0 2em 0;text-align:center;line-height:1.4em"><span class="post-wordcount iconfont icon-text"></span> 全站约 404,069 字<div class="license" style="padding:0 10px"><span>本站所有文章遵循许可协议 <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></span></div><div class="credit"><span>Themed <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.9.11</a> | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span></div><div class="friends"><span class="friend-link-span">友情链接 </span><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://carol-xrl.github.io/"><span class="friend-link-span">Carol </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/GavinZheng"><span class="friend-link-span">GavinZheng </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xryjr233"><span class="friend-link-span">xryjr233 </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dysyn1314"><span class="friend-link-span" title="为什么我的头常常变绿？因为…… "><span style="font-weight:700"><span class="codeforces p">dy</span><span class="codeforces m">syn</span><span class="codeforces p">1314</span></span> </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://blog.aor.sd.cn"><span class="friend-link-span">RainAir </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcyfrog"><span class="friend-link-span">lcyfrog </span></a><span class="icon friendsep"></span> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maoyiting"><span class="friend-link-span">/hanx/se</span></a></div><div class="copyright"><span>Copyright &copy; 2019-present - Sshwy</span></div></footer><script src="/js/ssimple.js?20250423.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script></html>